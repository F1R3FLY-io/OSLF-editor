(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config, children) {
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i]);
          i = {};
          var key = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set) {
          var array = [];
          set.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root3, element) {
          root3.context === emptyContextObject && (updateContainerImpl(root3.current, 2, element, root3, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root3, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root3.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return type.displayName || "Context";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i = type.length - 1; 0 <= i; i--)
                  if ("string" === typeof type[i].name) return type[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "", previous = null;
            do {
              info += describeFiber(workInProgress2, previous);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info;
                    a: {
                      var name = entry.name, env = entry.env, location = entry.debugLocation;
                      if (null != location) {
                        var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                        if (-1 !== lastLine.indexOf(name)) {
                          var JSCompiler_inline_result = "\n" + lastLine;
                          break a;
                        }
                      }
                      JSCompiler_inline_result = describeBuiltInComponentFrame(
                        name + (env ? " [" + env + "]" : "")
                      );
                    }
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              previous = workInProgress2;
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (workInProgress2 && debugStack) {
                  var formattedStack = formatOwnerStack(debugStack);
                  "" !== formattedStack && (info += "\n" + formattedStack);
                }
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %o.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root3.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
          root3 = root3.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root3, renderLanes2) {
          return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root3, updateLane) {
          root3.pendingLanes |= updateLane;
          268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
        }
        function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root3.pendingLanes;
          root3.pendingLanes = remainingLanes;
          root3.suspendedLanes = 0;
          root3.pingedLanes = 0;
          root3.warmLanes = 0;
          root3.expiredLanes &= remainingLanes;
          root3.entangledLanes &= remainingLanes;
          root3.errorRecoveryDisabledLanes &= remainingLanes;
          root3.shellSuspendCounter = 0;
          var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
          root3.pendingLanes |= spawnedLane;
          root3.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root3.entangledLanes |= spawnedLane;
          root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
        }
        function markRootEntangled(root3, entangledLanes) {
          var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
          for (root3 = root3.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root3[index] & entangledLanes && (root3[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root3, renderLanes2) {
          var renderLane = renderLanes2 & -renderLanes2;
          renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root3, fiber, lanes) {
          if (isDevToolsPresent)
            for (root3 = root3.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root3[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root3, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap, memoizedUpdaters = root3.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root3 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root3;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root3) {
          var resources = root3[internalRootNodeResourcesKey];
          resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? "checked" : "value";
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              "" + node[valueField]
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
              track(element);
              return;
            }
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = true;
                setDefaultSelected && (node[i].defaultSelected = true);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
          track(element);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 31:
              return "Activity";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i.length; node++)
            serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function noop$1() {
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root3, offset) {
          var node = getLeafNode(root3);
          root3 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root3 + node.textContent.length;
              if (root3 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root3 };
              root3 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function getArrayKind(array) {
          for (var kind = EMPTY_ARRAY, i = 0; i < array.length; i++) {
            var value = array[i];
            if ("object" === typeof value && null !== value)
              if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
                if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                  return COMPLEX_ARRAY;
                kind = ENTRIES_ARRAY;
              } else return COMPLEX_ARRAY;
            else {
              if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
                return COMPLEX_ARRAY;
              kind = PRIMITIVE_ARRAY;
            }
          }
          return kind;
        }
        function addObjectToProperties(object, properties, indent, prefix2) {
          for (var key in object)
            hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
        }
        function addValueToProperties(propertyName, value, properties, indent, prefix2) {
          switch (typeof value) {
            case "object":
              if (null === value) {
                value = "null";
                break;
              } else {
                if (value.$$typeof === REACT_ELEMENT_TYPE) {
                  var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                  value = value.props;
                  var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                  if (null == key && 0 === propsLength) {
                    value = "<" + typeName2 + " />";
                    break;
                  }
                  if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                    value = "<" + typeName2 + " \u2026 />";
                    break;
                  }
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    "<" + typeName2
                  ]);
                  null !== key && addValueToProperties(
                    "key",
                    key,
                    properties,
                    indent + 1,
                    prefix2
                  );
                  propertyName = false;
                  for (var propKey in value)
                    "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  properties.push([
                    "",
                    propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                  ]);
                  return;
                }
                typeName2 = Object.prototype.toString.call(value);
                typeName2 = typeName2.slice(8, typeName2.length - 1);
                if ("Array" === typeName2) {
                  if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                    value = JSON.stringify(value);
                    break;
                  } else if (propKey === ENTRIES_ARRAY) {
                    properties.push([
                      prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                      ""
                    ]);
                    for (propertyName = 0; propertyName < value.length; propertyName++)
                      typeName2 = value[propertyName], addValueToProperties(
                        typeName2[0],
                        typeName2[1],
                        properties,
                        indent + 1,
                        prefix2
                      );
                    return;
                  }
                }
                if ("Promise" === typeName2) {
                  if ("fulfilled" === value.status) {
                    if (typeName2 = properties.length, addValueToProperties(
                      propertyName,
                      value.value,
                      properties,
                      indent,
                      prefix2
                    ), properties.length > typeName2) {
                      properties = properties[typeName2];
                      properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                      return;
                    }
                  } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.reason,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2)) {
                    properties = properties[typeName2];
                    properties[1] = "Rejected Promise<" + properties[1] + ">";
                    return;
                  }
                  properties.push([
                    "\xA0\xA0".repeat(indent) + propertyName,
                    "Promise"
                  ]);
                  return;
                }
                "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
                ]);
                3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
                return;
              }
            case "function":
              value = "" === value.name ? "() => {}" : value.name + "() {}";
              break;
            case "string":
              value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
              break;
            case "undefined":
              value = "undefined";
              break;
            case "boolean":
              value = value ? "true" : "false";
              break;
            default:
              value = String(value);
          }
          properties.push([
            prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
            value
          ]);
        }
        function addObjectDiffToProperties(prev, next, properties, indent) {
          var isDeeplyEqual = true;
          for (key in prev)
            key in next || (properties.push([
              REMOVED + "\xA0\xA0".repeat(indent) + key,
              "\u2026"
            ]), isDeeplyEqual = false);
          for (var _key in next)
            if (_key in prev) {
              var key = prev[_key];
              var nextValue = next[_key];
              if (key !== nextValue) {
                if (0 === indent && "children" === _key)
                  isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                    [REMOVED + isDeeplyEqual, "\u2026"],
                    [ADDED + isDeeplyEqual, "\u2026"]
                  );
                else {
                  if (!(3 <= indent)) {
                    if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                      if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                        if (key.type === nextValue.type && key.key === nextValue.key) {
                          key = getComponentNameFromType(nextValue.type) || "\u2026";
                          isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                          key = "<" + key + " \u2026 />";
                          properties.push(
                            [REMOVED + isDeeplyEqual, key],
                            [ADDED + isDeeplyEqual, key]
                          );
                          isDeeplyEqual = false;
                          continue;
                        }
                      } else {
                        var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                        if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                          prevKind = [
                            UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                            "[object Array]" === nextKind ? "Array" : ""
                          ];
                          properties.push(prevKind);
                          nextKind = properties.length;
                          addObjectDiffToProperties(
                            key,
                            nextValue,
                            properties,
                            indent + 1
                          ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                          continue;
                        }
                      }
                    else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                      key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                      properties.push([
                        UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                        key + " Referentially unequal function closure. Consider memoization."
                      ]);
                      continue;
                    }
                  }
                  addValueToProperties(_key, key, properties, indent, REMOVED);
                  addValueToProperties(_key, nextValue, properties, indent, ADDED);
                }
                isDeeplyEqual = false;
              }
            } else
              properties.push([
                ADDED + "\xA0\xA0".repeat(indent) + _key,
                "\u2026"
              ]), isDeeplyEqual = false;
          return isDeeplyEqual;
        }
        function setCurrentTrackFromLanes(lanes) {
          currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
        }
        function logComponentTrigger(fiber, startTime, endTime, trigger) {
          supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
            performance.measure.bind(
              performance,
              trigger,
              reusableComponentOptions
            )
          ) : performance.measure(trigger, reusableComponentOptions));
        }
        function logComponentReappeared(fiber, startTime, endTime) {
          logComponentTrigger(fiber, startTime, endTime, "Reconnect");
        }
        function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name && supportsUserTiming) {
            var alternate = fiber.alternate, selfTime = fiber.actualDuration;
            if (null === alternate || alternate.child !== fiber.child)
              for (var child = fiber.child; null !== child; child = child.sibling)
                selfTime -= child.actualDuration;
            wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
            var props = fiber.memoizedProps;
            selfTime = fiber._debugTask;
            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
              performance.measure.bind(
                performance,
                "\u200B" + name,
                reusableComponentOptions
              )
            ) : performance.measure(
              "\u200B" + name,
              reusableComponentOptions
            ))) : null != selfTime ? selfTime.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            );
          }
        }
        function logComponentErrored(fiber, startTime, endTime, errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              for (var debugTask = null, properties = [], i = 0; i < errors.length; i++) {
                var capturedValue = errors[i];
                null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
                capturedValue = capturedValue.value;
                properties.push([
                  "Error",
                  "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
              null == debugTask && (debugTask = fiber._debugTask);
              fiber = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                    properties
                  }
                }
              };
              debugTask ? debugTask.run(
                performance.measure.bind(performance, "\u200B" + name, fiber)
              ) : performance.measure("\u200B" + name, fiber);
            }
          }
        }
        function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
          if (null !== errors) {
            if (supportsUserTiming) {
              var name = getComponentNameFromFiber(fiber);
              if (null !== name) {
                selfTime = [];
                for (var i = 0; i < errors.length; i++) {
                  var error = errors[i].value;
                  selfTime.push([
                    "Error",
                    "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                  ]);
                }
                null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
                startTime = {
                  start: startTime,
                  end: endTime,
                  detail: {
                    devtools: {
                      color: "error",
                      track: COMPONENTS_TRACK,
                      tooltipText: "A lifecycle or effect errored",
                      properties: selfTime
                    }
                  }
                };
                (fiber = fiber._debugTask) ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200B" + name,
                    startTime
                  )
                ) : performance.measure("\u200B" + name, startTime);
              }
            }
          } else
            name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                errors
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            ));
        }
        function logRenderPhase(startTime, endTime, lanes, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
            lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
            debugTask ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            ) : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
          }
        }
        function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            lanes = [];
            for (var i = 0; i < recoverableErrors.length; i++) {
              var error = recoverableErrors[i].value;
              lanes.push([
                "Recoverable Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "primary-dark",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                  properties: lanes
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            ) : performance.measure("Recovered", startTime);
          }
        }
        function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            )
          ) : console.timeStamp(
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          ));
        }
        function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            )
          ) : console.timeStamp(
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          ));
        }
        function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            for (var properties = [], i = 0; i < errors.length; i++) {
              var error = errors[i].value;
              properties.push([
                "Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            ) : performance.measure("Errored", startTime);
          }
        }
        function logAnimatingPhase(startTime, endTime, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          do {
            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
            _fiber = _fiber.type;
            var candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = _fiber;
                break;
              case 11:
                candidateType = _fiber.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            _fiber = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
            _fiber && (fiber._debugNeedsRemount = true);
            if (_fiber || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || _fiber || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            if (null === sibling) break;
            fiber = sibling;
          } while (1);
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(18, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnIfHydrating() {
          isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          );
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              );
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber, true);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function startUpdateTimerByLane(lane, method, fiber) {
          if (0 !== (lane & 127))
            0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
          else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
            lane = resolveEventTimeStamp();
            method = resolveEventType();
            if (lane !== transitionEventRepeatTime || method !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = lane;
            transitionEventType = method;
          }
        }
        function startHostActionTimer(fiber) {
          if (0 > blockingUpdateTime) {
            blockingUpdateTime = now();
            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
            blockingEventTime = newEventTime;
            blockingEventType = newEventType;
          }
          if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
            fiber = resolveEventTimeStamp();
            newEventTime = resolveEventType();
            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = fiber;
            transitionEventType = newEventTime;
          }
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function resetComponentEffectTimers() {
          componentEffectEndTime = componentEffectStartTime = -1.1;
        }
        function pushComponentEffectStart() {
          var prevEffectStart = componentEffectStartTime;
          componentEffectStartTime = -1.1;
          return prevEffectStart;
        }
        function popComponentEffectStart(prevEffectStart) {
          0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
        }
        function pushComponentEffectDuration() {
          var prevEffectDuration = componentEffectDuration;
          componentEffectDuration = -0;
          return prevEffectDuration;
        }
        function popComponentEffectDuration(prevEffectDuration) {
          0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
        }
        function pushComponentEffectErrors() {
          var prevErrors = componentEffectErrors;
          componentEffectErrors = null;
          return prevErrors;
        }
        function pushComponentEffectDidSpawnUpdate() {
          var prev = componentEffectSpawnedUpdate;
          componentEffectSpawnedUpdate = false;
          return prev;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var endTime = now(), elapsedTime = endTime - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
            componentEffectDuration += elapsedTime;
            componentEffectEndTime = endTime;
          }
        }
        function recordEffectError(errorInfo) {
          null === componentEffectErrors && (componentEffectErrors = []);
          componentEffectErrors.push(errorInfo);
          null === commitErrors && (commitErrors = []);
          commitErrors.push(errorInfo);
        }
        function startEffectTimer() {
          profilerStartTime = now();
          0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$1, noop$1), thenable = index);
          if (void 0 === thenable._debugInfo) {
            thenableState2 = performance.now();
            trackedThenables = thenable.displayName;
            var ioInfo = {
              name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
              start: thenableState2,
              end: thenableState2,
              value: thenable
            };
            thenable._debugInfo = [{ awaited: ioInfo }];
            "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
              ioInfo.end = performance.now();
            }, thenable.then(thenableState2, thenableState2));
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            return callLazyInitInDEV(lazyType);
          } catch (x) {
            if (null !== x && "object" === typeof x && "function" === typeof x.then)
              throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
            throw x;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function getCurrentDebugTask() {
          var debugInfo = currentDebugInfo;
          if (null != debugInfo) {
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if (null != debugInfo[i].name) {
                var debugTask = debugInfo[i].debugTask;
                if (null != debugTask) return debugTask;
              }
          }
          return null;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
        }
        function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root3, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(suspenseHandlerStackCursor, fiber, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create, deps) {
          tag = { tag, create, deps, inst, next: null };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            { destroy: void 0 },
            create,
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, deps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
          else {
            var events = componentUpdateQueue.events;
            null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
          }
        }
        function mountEvent(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref, nextImpl: callback });
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              ReactSharedInternals.asyncTransitions++;
              returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startHostActionTimer(formFiber);
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "_";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root3 = enqueueUpdate(provider, refreshUpdate, lane);
                null !== root3 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root3, provider, lane), entangleTransitions(root3, provider, lane));
                fiber = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root3 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                refreshUpdate.payload = { cache: fiber };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root3, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root3, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root3.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root3, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root3.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root3, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root3, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root3,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root3,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root3, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root3, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root3.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root3, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root3
                ), enqueueCapturedUpdate(sourceFiber, root3), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root3,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
          var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextProps = workInProgress2.child = current2.child;
                for (nextChildren = 0; null !== nextProps; )
                  nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
                nextProps = nextChildren & ~prevState;
              } else nextProps = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                prevState,
                renderLanes2,
                nextProps
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2,
                nextProps
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function bailoutOffscreenComponent(current2, workInProgress2) {
          null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          return workInProgress2.sibling;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          workInProgress2.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress2, nextProps) {
          var hiddenProp = nextProps.hidden;
          void 0 !== hiddenProp && console.error(
            `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
            true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
            hiddenProp ? 'mode="hidden"' : 'mode="visible"'
          );
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress2.mode
          );
          nextProps.ref = workInProgress2.ref;
          workInProgress2.child = nextProps;
          nextProps.return = workInProgress2;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountActivityChildren(
            workInProgress2,
            workInProgress2.pendingProps
          );
          current2.flags |= 2;
          popSuspenseHandler(workInProgress2);
          workInProgress2.memoizedState = null;
          return current2;
        }
        function updateActivityComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
          workInProgress2.flags &= -129;
          if (null === current2) {
            if (isHydrating) {
              if ("hidden" === nextProps.mode)
                return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
              pushDehydratedActivitySuspenseHandler(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              workInProgress2.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress2, nextProps);
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var activityInstance = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            if (didSuspend)
              if (workInProgress2.flags & 256)
                workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              else if (null !== workInProgress2.memoizedState)
                workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
              else
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
              nextProps = workInProgressRoot;
              if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
                nextProps,
                renderLanes2
              ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
                throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
              renderDidSuspendDelayIfPossible();
              workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                activityInstance.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
            return workInProgress2;
          }
          prevState = current2.child;
          nextProps = { mode: nextProps.mode, children: nextProps.children };
          0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          current2 = createWorkInProgress(prevState, nextProps);
          current2.ref = workInProgress2.ref;
          workInProgress2.child = current2;
          current2.return = workInProgress2;
          return current2;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2724;
          var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_message_2723 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
              return null;
            }
            var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
            JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
            if (JSCompiler_object_inline_message_2723) {
              reuseSuspenseHandlerOnStack(workInProgress2);
              var mode = workInProgress2.mode;
              nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "hidden", children: nextPrimaryChildren },
                mode
              );
              JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2725,
                mode,
                renderLanes2,
                null
              );
              nextPrimaryChildren.return = workInProgress2;
              JSCompiler_object_inline_stack_2725.return = workInProgress2;
              nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
              workInProgress2.child = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = workInProgress2.child;
              JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              );
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              );
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              nextPrimaryChildren
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
            if (null !== JSCompiler_object_inline_componentStack_2726) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2725.children
                  },
                  mode
                ), nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  mode,
                  renderLanes2,
                  null
                ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                  null,
                  JSCompiler_object_inline_stack_2725
                ));
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
                JSCompiler_object_inline_componentStack_2726
              )) {
                JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2724) {
                  nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                  var message = JSCompiler_object_inline_digest_2724.msg;
                  mode = JSCompiler_object_inline_digest_2724.stck;
                  var componentStack = JSCompiler_object_inline_digest_2724.cstck;
                }
                JSCompiler_object_inline_message_2723 = message;
                JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
                JSCompiler_object_inline_stack_2725 = mode;
                JSCompiler_object_inline_componentStack_2726 = componentStack;
                nextPrimaryChildren = JSCompiler_object_inline_message_2723;
                mode = JSCompiler_object_inline_componentStack_2726;
                nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
                nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
                JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
                JSCompiler_object_inline_stack_2725 = {
                  value: nextPrimaryChildren,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2724
                };
                "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                  nextPrimaryChildren,
                  JSCompiler_object_inline_stack_2725
                );
                queueHydrationError(JSCompiler_object_inline_stack_2725);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
                JSCompiler_object_inline_digest_2724 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2724,
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), SelectiveHydrationException;
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2725.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
          }
          if (JSCompiler_object_inline_message_2723)
            return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
              componentStack,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2725.children
              }
            ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
              JSCompiler_object_inline_componentStack_2726,
              nextPrimaryChildren
            ) : (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              mode,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
              baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
              cachePool: mode
            }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
              current2.child,
              JSCompiler_object_inline_stack_2725
            );
          null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2725.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode,
            treeForkCount: treeForkCount2
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
          (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
          push(suspenseStackCursor, suspenseContext, workInProgress2);
          suspenseContext = null == revealOrder ? "null" : revealOrder;
          if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
            if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
              console.error(
                'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
              );
            else if ("backwards" === revealOrder)
              console.error(
                'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
              );
            else if ("string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                case "independent":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          suspenseContext = null == tailMode ? "null" : tailMode;
          if (!didWarnAboutTailOptions[suspenseContext])
            if (null == tailMode) {
              if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
                didWarnAboutTailOptions[suspenseContext] = true, console.error(
                  'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
                );
            } else
              "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
            if (isArrayImpl(newChildren))
              for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
                if (!validateSuspenseListNestedChild(
                  newChildren[suspenseContext],
                  suspenseContext
                ))
                  break a;
              }
            else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
              if (suspenseContext = suspenseContext.call(newChildren))
                for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
          if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode,
                newChildren
              );
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode,
                newChildren
              );
              break;
            case "together":
              initSuspenseListRenderState(
                workInProgress2,
                false,
                null,
                null,
                void 0,
                newChildren
              );
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== workInProgress2.memoizedState)
                return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
              return workInProgress2.lanes = 0, updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                renderLanes2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    renderLanes2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = renderLanes2; renderLanes2; )
                      renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
                renderLanes2,
                returnFiber.tag,
                current2.ancestorInfo.implicitRootScope
              ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
                current2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return updateActivityComponent(current2, workInProgress2, renderLanes2);
            case 22:
              return updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
          if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
            type = false;
          if (type) {
            if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
              if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
              else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
              else
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          } else workInProgress2.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                null,
                newProps,
                renderLanes2
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                current2,
                newProps,
                renderLanes2
              ));
              return null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var _currentHostContext = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
                else {
                  nextResource = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(type, _currentHostContext.ancestorInfo);
                  _currentHostContext = _currentHostContext.context;
                  nextResource = getOwnerDocumentFromRootContainer(nextResource);
                  switch (_currentHostContext) {
                    case HostContextNamespaceSvg:
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case HostContextNamespaceMath:
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    default:
                      switch (type) {
                        case "svg":
                          nextResource = nextResource.createElementNS(
                            SVG_NAMESPACE,
                            type
                          );
                          break;
                        case "math":
                          nextResource = nextResource.createElementNS(
                            MATH_NAMESPACE,
                            type
                          );
                          break;
                        case "script":
                          nextResource = nextResource.createElement("div");
                          nextResource.innerHTML = "<script><\/script>";
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild
                          );
                          break;
                        case "select":
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                            is: newProps.is
                          }) : nextResource.createElement("select");
                          newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                            is: newProps.is
                          }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            type
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            type
                          )));
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress2;
                  nextResource[internalPropsKey] = newProps;
                  a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                    if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                      nextResource.appendChild(_currentHostContext.stateNode);
                    else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                      _currentHostContext.child.return = _currentHostContext;
                      _currentHostContext = _currentHostContext.child;
                      continue;
                    }
                    if (_currentHostContext === workInProgress2) break a;
                    for (; null === _currentHostContext.sibling; ) {
                      if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                        break a;
                      _currentHostContext = _currentHostContext.return;
                    }
                    _currentHostContext.sibling.return = _currentHostContext.return;
                    _currentHostContext = _currentHostContext.sibling;
                  }
                  workInProgress2.stateNode = nextResource;
                  a: switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                  newProps && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                workInProgress2.type,
                null === current2 ? null : current2.memoizedProps,
                workInProgress2.pendingProps,
                renderLanes2
              );
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  type = !didSuspendOrErrorDEV;
                  newProps = null;
                  nextResource = hydrationParentFiber;
                  if (null !== nextResource)
                    switch (nextResource.tag) {
                      case 3:
                        type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                        break;
                      case 27:
                      case 5:
                        newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2, true);
                } else
                  type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 31:
              renderLanes2 = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState) {
                newProps = popHydrationState(workInProgress2);
                if (null !== renderLanes2) {
                  if (null === current2) {
                    if (!newProps)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    current2 = workInProgress2.memoizedState;
                    current2 = null !== current2 ? current2.dehydrated : null;
                    if (!current2)
                      throw Error(
                        "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    current2[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  current2 = false;
                } else
                  renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
                if (!current2) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
                if (0 !== (workInProgress2.flags & 128))
                  throw Error(
                    "Client rendering an Activity suspended it again. This is a bug in React."
                  );
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                type = newProps;
                nextResource = popHydrationState(workInProgress2);
                if (null !== type && null !== type.dehydrated) {
                  if (null === current2) {
                    if (!nextResource)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    nextResource = workInProgress2.memoizedState;
                    nextResource = null !== nextResource ? nextResource.dehydrated : null;
                    if (!nextResource)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    nextResource[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  type = false;
                } else
                  type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
                if (!type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              newProps = workInProgress2.memoizedState;
              if (null === newProps) return bubbleProperties(workInProgress2), null;
              type = 0 !== (workInProgress2.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      nextResource = findFirstSuspended(current2);
                      if (null !== nextResource) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(newProps, false);
                        current2 = nextResource.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!type)
                  if (current2 = findFirstSuspended(nextResource), null !== current2) {
                    if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
              }
              if (null !== newProps.tail)
                return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 31:
              if (null !== workInProgress2.memoizedState) {
                popSuspenseHandler(workInProgress2);
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 31:
              null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHydratingParent(current2, finishedWork) {
          return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
        }
        function commitBeforeMutationEffects(root3, firstChild) {
          root3 = root3.containerInfo;
          eventsEnabled = _enabled;
          root3 = getActiveElementDeep(root3);
          if (hasSelectionCapabilities(root3)) {
            if ("selectionStart" in root3)
              var JSCompiler_temp = {
                start: root3.selectionStart,
                end: root3.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root3) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root3,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
              root3.return = firstChild, nextEffect = root3;
            else
              for (; null !== nextEffect; ) {
                root3 = firstChild = nextEffect;
                JSCompiler_temp = root3.alternate;
                anchorOffset = root3.flags;
                switch (root3.tag) {
                  case 0:
                    if (0 !== (anchorOffset & 4) && (root3 = root3.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                      for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                        anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root3, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root3 = root3.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root3);
                      else if (1 === JSCompiler_temp)
                        switch (root3.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root3);
                            break;
                          default:
                            root3.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root3 = firstChild.sibling;
                if (null !== root3) {
                  root3.return = firstChild.return;
                  nextEffect = root3;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (null === current2) {
                if (flags & 4) commitHostMount(finishedWork);
                else if (flags & 64) {
                  finishedRoot = finishedWork.type;
                  current2 = finishedWork.memoizedProps;
                  prevProps = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedInstance,
                      prevProps,
                      finishedRoot,
                      current2,
                      finishedWork
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error
                    );
                  }
                }
              }
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, flags))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            deletedFiber,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedActivityInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root3 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                deletedFiber,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
              root3 = deletedFiber;
              returnFiber = root3.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root3.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root3) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
                var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
                flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
              }
              break;
            case 26:
              existingHiddenCallbacks = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4) {
                var currentResource = null !== current2 ? current2.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                        b: switch (flags) {
                          case "title":
                            currentResource = existingHiddenCallbacks.getElementsByTagName(
                              "title"
                            )[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                              currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                                currentResource,
                                existingHiddenCallbacks.querySelector(
                                  "head > title"
                                )
                              );
                            setInitialProperties(currentResource, flags, current2);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              existingHiddenCallbacks
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              existingHiddenCallbacks
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      existingHiddenCallbacks,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    resetTextContent,
                    existingHiddenCallbacks
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                existingHiddenCallbacks,
                null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    existingHiddenCallbacks,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              existingHiddenCallbacks = pushNestedEffectDurations();
              tagCaches = null;
              currentResource = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root3.containerInfo);
              recursivelyTraverseMutationEffects(root3, finishedWork);
              currentHoistableRoot = currentResource;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root3.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root3.effectDuration += popNestedEffectDurations(
                existingHiddenCallbacks
              );
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              existingHiddenCallbacks = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root3 = finishedWork.stateNode, root3._visibility = existingHiddenCallbacks ? root3._visibility & ~OffscreenVisible : root3._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                )), current2 = null, root3 = finishedWork; ; ) {
                  if (5 === root3.tag || 26 === root3.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root3;
                      try {
                        currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          currentResource
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root3.tag) {
                    if (null === current2) {
                      wasHidden = root3;
                      try {
                        maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          maybeNodes,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root3.tag) {
                    if (null === current2) {
                      wasHidden = root3;
                      try {
                        i = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideDehydratedBoundary,
                          i
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideDehydratedBoundary,
                          wasHidden.stateNode
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                    root3.child.return = root3;
                    root3 = root3.child;
                    continue;
                  }
                  if (root3 === finishedWork) break a;
                  for (; null === root3.sibling; ) {
                    if (null === root3.return || root3.return === finishedWork)
                      break a;
                    current2 === root3 && (current2 = null);
                    root3 = root3.return;
                  }
                  current2 === root3 && (current2 = null);
                  root3.sibling.return = root3.return;
                  root3 = root3.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root3, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions, endTime) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var nextSibling = parentFiber.sibling;
              commitPassiveMountOnFiber(
                root3,
                parentFiber,
                committedLanes,
                committedTransitions,
                null !== nextSibling ? nextSibling.actualStartTime : endTime
              );
              parentFiber = nextSibling;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                []
              ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              ));
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
              inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = wasInHydratedSubtree;
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(
                prevProfilerEffectDuration
              );
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
              break;
            case 31:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true) : inHydratedSubtree = false;
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 13:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 23:
              break;
            case 22:
              wasInHydratedSubtree = finishedWork.stateNode;
              prevProfilerEffectDuration = finishedWork.alternate;
              null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
                endTime
              ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                prevProfilerEffectDuration,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          if ((finishedWork.mode & ProfileMode) !== NoMode) {
            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
              committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
          }
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
          includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree,
            committedLanes
          );
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (var child = parentFiber.child; null !== child; ) {
              parentFiber = child.sibling;
              var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
              (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
                child,
                child.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              var flags = child.flags;
              switch (child.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
              }
              alreadyWarnedForDeepEquality = prevDeepEquality;
              child = parentFiber;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState
              ), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                suspendedState,
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 12:
              prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 22:
              prevProfilerEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              current2,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            );
            popComponentEffectStart(prevEffectStart);
            popComponentEffectDuration(prevEffectDuration);
            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
            componentEffectErrors = prevEffectErrors;
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                prevEffectStart = current2.sibling;
                prevEffectDuration = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== prevEffectStart) {
                  prevEffectStart.return = prevEffectDuration;
                  nextEffect = prevEffectStart;
                  break a;
                }
                nextEffect = prevEffectDuration;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root3, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root3 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            prepareFreshStack(root3, 0), markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root3, lane);
          if ((executionContext & RenderContext) !== NoContext && root3 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root3 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root3) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root3), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root3,
                    root3
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root3, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root3 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root3);
        }
        function performWorkOnRoot(root3, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
            var yieldedFiber = workInProgress, yieldEndTime = now$1();
            switch (yieldReason) {
              case SuspendedOnImmediate:
              case SuspendedOnData:
                var startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              case SuspendedOnAction:
                startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              default:
                supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
                ));
            }
          }
          startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root3.expiredLanes) || checkIfRootIsPrerendering(root3, lanes)) ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes, true);
          var renderWasConcurrent = forceSync;
          do {
            if (startTime === RootInProgress) {
              workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root3, lanes, 0, false);
              lanes = workInProgressSuspendedReason;
              yieldStartTime = now();
              yieldReason = lanes;
              break;
            } else {
              yieldedFiber = now$1();
              yieldEndTime = root3.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
                setCurrentTrackFromLanes(lanes);
                yieldEndTime = renderStartTime;
                startTime = yieldedFiber;
                !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  )
                ) : console.timeStamp(
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                ));
                finalizeRender(lanes, yieldedFiber);
                startTime = renderRootSync(root3, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (startTime === RootErrored) {
                renderWasConcurrent = lanes;
                if (root3.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root3.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  setCurrentTrackFromLanes(lanes);
                  logErroredRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  lanes = errorRetryLanes;
                  a: {
                    yieldedFiber = root3;
                    startTime = renderWasConcurrent;
                    renderWasConcurrent = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                    errorRetryLanes = renderRootSync(
                      yieldedFiber,
                      errorRetryLanes,
                      false
                    );
                    if (errorRetryLanes !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                        workInProgressRootInterleavedUpdatedLanes |= startTime;
                        startTime = RootSuspendedWithDelay;
                        break a;
                      }
                      yieldedFiber = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = renderWasConcurrent;
                      null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        yieldedFiber
                      ));
                    }
                    startTime = errorRetryLanes;
                  }
                  renderWasConcurrent = false;
                  if (startTime !== RootErrored) continue;
                  else yieldedFiber = now$1();
                }
              }
              if (startTime === RootFatalErrored) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                prepareFreshStack(root3, 0);
                markRootSuspended(root3, lanes, 0, true);
                break;
              }
              a: {
                forceSync = root3;
                switch (startTime) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    setCurrentTrackFromLanes(lanes);
                    logSuspendedRenderPhase(
                      renderStartTime,
                      yieldedFiber,
                      lanes,
                      workInProgressUpdateTask
                    );
                    finalizeRender(lanes, yieldedFiber);
                    yieldEndTime = lanes;
                    0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    forceSync,
                    yieldEndTime,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    startTime,
                    null,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(forceSync, 0, true)) break a;
                    pendingEffectsLanes = lanes;
                    forceSync.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        forceSync,
                        yieldEndTime,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        startTime,
                        "Throttled",
                        renderStartTime,
                        yieldedFiber
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root3);
        }
        function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root3.timeoutHandle = noTimeout;
          var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: true,
              waitingForViewTransition: false,
              unsuspend: noop$1
            }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
              pendingEffectsLanes = lanes;
              root3.cancelPendingCommit = subtreeFlags(
                commitRoot.bind(
                  null,
                  root3,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedState,
                  suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root3,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root3,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedState,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root3.suspendedLanes |= suspendedLanes;
          root3.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root3.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function finalizeRender(lanes, finalizationTime) {
          0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
          0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
          0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
          0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
        }
        function prepareFreshStack(root3, lanes) {
          supportsUserTiming && (console.timeStamp(
            "Blocking Track",
            3e-3,
            3e-3,
            "Blocking",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Transition Track",
            3e-3,
            3e-3,
            "Transition",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Suspense Track",
            3e-3,
            3e-3,
            "Suspense",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Idle Track",
            3e-3,
            3e-3,
            "Idle",
            LANES_TRACK_GROUP,
            "primary-light"
          ));
          var previousRenderStartTime = renderStartTime;
          renderStartTime = now();
          if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
            setCurrentTrackFromLanes(workInProgressRootRenderLanes);
            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
              logSuspendedRenderPhase(
                previousRenderStartTime,
                renderStartTime,
                lanes,
                workInProgressUpdateTask
              );
            else {
              var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
              if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
                var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
                debugTask ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                ) : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
              }
            }
            finalizeRender(workInProgressRootRenderLanes, renderStartTime);
          }
          previousRenderStartTime = workInProgressUpdateTask;
          workInProgressUpdateTask = null;
          if (0 !== (lanes & 127)) {
            workInProgressUpdateTask = blockingUpdateTask;
            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
            0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
            previousRenderStartTime = debugTask;
            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
            debugTask = renderStartTime;
            endTime = blockingUpdateTask;
            color = blockingUpdateMethodName;
            label = blockingUpdateComponentName;
            if (supportsUserTiming) {
              currentTrack = "Blocking";
              0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
              0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
              if (null !== eventType && previousRenderStartTime > eventTime) {
                var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
                endTime ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                ) : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
              }
              debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
                start: previousRenderStartTime,
                end: debugTask,
                detail: {
                  devtools: {
                    properties: isPingedUpdate,
                    track: currentTrack,
                    trackGroup: LANES_TRACK_GROUP,
                    color: eventTime
                  }
                }
              }, endTime ? endTime.run(
                performance.measure.bind(
                  performance,
                  isSpawnedUpdate,
                  previousRenderStartTime
                )
              ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
            }
            blockingUpdateTime = -1.1;
            blockingUpdateType = 0;
            blockingUpdateComponentName = blockingUpdateMethodName = null;
            blockingSuspendedTime = -1.1;
            blockingEventRepeatTime = blockingEventTime;
            blockingEventTime = -1.1;
            blockingClampTime = now();
          }
          0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
            transitionSuspendedTime,
            color,
            lanes,
            workInProgressUpdateTask
          )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              eventType ? "Consecutive" : "Event: " + eventTime,
              isPingedUpdate,
              debugTask,
              currentTrack,
              LANES_TRACK_GROUP,
              color$jscomp$0
            )
          ) : console.timeStamp(
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              "Action",
              debugTask,
              previousRenderStartTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "primary-dark"
            )
          ) : console.timeStamp(
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: color,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: "primary-light"
              }
            }
          }, endTime ? endTime.run(
            performance.measure.bind(
              performance,
              debugTask,
              previousRenderStartTime
            )
          ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
          0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
          0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
          previousRenderStartTime = root3.timeoutHandle;
          previousRenderStartTime !== noTimeout && (root3.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
          previousRenderStartTime = root3.cancelPendingCommit;
          null !== previousRenderStartTime && (root3.cancelPendingCommit = null, previousRenderStartTime());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root3;
          workInProgress = previousRenderStartTime = createWorkInProgress(
            root3.current,
            null
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          endTime = root3.entangledLanes;
          if (0 !== endTime)
            for (root3 = root3.entanglements, endTime &= lanes; 0 < endTime; )
              debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root3[debugTask], endTime &= ~color;
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          root3 = getCurrentTime();
          1e3 < root3 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root3);
          ReactStrictModeWarnings.discardPendingWarnings();
          return previousRenderStartTime;
        }
        function handleThrow(root3, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function markRenderDerivedCause(fiber) {
          null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root3, lanes);
          }
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root3, thrownValue$8);
            }
          while (1);
          lanes && root3.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root3, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root3,
              lanes
            );
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root3 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root3);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root3, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return RootInProgress;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root3,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root3,
                createCapturedValueAtFiber(thrownValue, root3.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root3 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root3 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root3);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root3.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          setCurrentTrackFromLanes(lanes);
          exitStatus === RootErrored ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          ) : null !== recoverableErrors ? logRecoveredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            recoverableErrors,
            null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
            workInProgressUpdateTask
          ) : logRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          );
          if (null !== finishedWork) {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root3.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root3,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root3;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            pendingEffectsRenderEndTime = completedRenderEndTime;
            pendingSuspendedCommitReason = suspendedCommitReason;
            pendingDelayedCommitReason = IMMEDIATE_COMMIT;
            pendingSuspendedViewTransitionReason = null;
            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            })) : (root3.callbackNode = null, root3.callbackPriority = 0);
            commitErrors = null;
            commitStartTime = now();
            null !== suspendedCommitReason && logSuspendedCommitPhase(
              completedRenderEndTime,
              commitStartTime,
              suspendedCommitReason,
              workInProgressUpdateTask
            );
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root3, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root3;
                resetComponentEffectTimers();
                commitMutationEffectsOnFiber(finishedWork, root3);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root3.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
            if (null !== suspendedViewTransitionReason) {
              commitStartTime = now();
              var startTime = commitEndTime, endTime = commitStartTime;
              !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            suspendedViewTransitionReason = pendingEffectsRoot;
            startTime = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var _previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var _prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                  suspendedViewTransitionReason,
                  startTime.alternate,
                  startTime
                ), inProgressRoot = inProgressLanes = null;
              } finally {
                executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            suspendedViewTransitionReason = pendingEffectsRenderEndTime;
            startTime = pendingSuspendedCommitReason;
            commitEndTime = now();
            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
            startTime = commitEndTime;
            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            rootHasLayoutEffect = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              false,
              rootHasLayoutEffect
            ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
              console.timeStamp.bind(
                console,
                endTime ? "Commit Interrupted View Transition" : "Commit",
                suspendedViewTransitionReason,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                endTime ? "error" : "secondary-dark"
              )
            ) : console.timeStamp(
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            ));
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
              var startViewTransitionStartTime = commitEndTime;
              commitEndTime = now();
              var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
              !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? "error" : "secondary-light"
                )
              ) : console.timeStamp(
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? " error" : "secondary-light"
              ));
              pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
            }
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            startViewTransitionStartTime = pendingEffectsRoot;
            var finishedWork = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            abortedViewTransition = pendingRecoverableErrors;
            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
            remainingLanes = lanesToEventPriority(endTime);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (remainingLanes) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== abortedViewTransition) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
                for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                  var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(startViewTransitionStartTime);
            remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root3, remainingLanes) {
          0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            priority = pendingEffectsRoot;
            var lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            setCurrentTrackFromLanes(lanes);
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            var passiveEffectStartTime = 0;
            commitErrors = null;
            passiveEffectStartTime = now$1();
            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
              logAnimatingPhase(
                commitEndTime,
                passiveEffectStartTime,
                animatingTask
              );
            else {
              var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
              !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            startTime = executionContext;
            executionContext |= CommitContext;
            var finishedWork = priority.current;
            resetComponentEffectTimers();
            commitPassiveUnmountOnFiber(finishedWork);
            var finishedWork$jscomp$0 = priority.current;
            finishedWork = pendingEffectsRenderEndTime;
            resetComponentEffectTimers();
            commitPassiveMountOnFiber(
              priority,
              finishedWork$jscomp$0,
              lanes,
              transitions,
              finishedWork
            );
            commitDoubleInvokeEffectsInDEV(priority);
            executionContext = startTime;
            var passiveEffectsEndTime = now$1();
            finishedWork$jscomp$0 = passiveEffectStartTime;
            finishedWork = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              true,
              finishedWork
            ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
              console.timeStamp.bind(
                console,
                "Remaining Effects",
                finishedWork$jscomp$0,
                passiveEffectsEndTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            ) : console.timeStamp(
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
            finalizeRender(lanes, passiveEffectsEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, priority);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            var stateNode = priority.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root3, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          recordEffectError(sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  recordEffectError(sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root3, wakeable, lanes) {
          var pingCache = root3.pingCache;
          if (null === pingCache) {
            pingCache = root3.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root3, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root3, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root3, wakeable, pingedLanes) {
          var pingCache = root3.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          root3.warmLanes &= ~pingedLanes;
          0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root3);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root3 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root3,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root3,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root3, fiber) {
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root3, fiber.alternate, fiber, false), reconnectPassiveEffects(root3, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root3) {
          var doubleInvokeEffects = true;
          root3.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root3,
            root3.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root3, lanes) {
          isDevToolsPresent && root3.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root3, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root3) {
          root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root3 = firstScheduledRoot; null !== root3; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root3.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root3,
                      root3 === workInProgressRoot ? nextLanes : 0,
                      null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root3, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                root3 = root3.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          schedulerEvent = window.event;
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
          for (var currentTime = now$1(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
            var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
            if (0 === nextLanes)
              root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root3 = next;
          }
          pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
          for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root3,
            root3 === currentTime ? suspendedLanes : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          pingedLanes = root3.callbackNode;
          if (0 === suspendedLanes || root3 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root3.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root3.callbackPriority = currentTime;
            root3.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root3.callbackPriority = 2;
          root3.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          schedulerEvent = window.event;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root3.callbackNode = null, root3.callbackPriority = 0, null;
          var originalCallbackNode = root3.callbackNode;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root3,
            root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root3,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root3, now$1());
          return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
        }
        function performSyncWorkOnRoot(root3, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root3, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                          lastHostComponent++;
                        _instance2 = 0;
                        for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                          _instance2++;
                        for (; 0 < lastHostComponent - _instance2; )
                          reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                        for (; 0 < _instance2 - lastHostComponent; )
                          instance = inCapturePhase(instance), _instance2--;
                        for (; lastHostComponent--; ) {
                          if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return true;
            default:
              return false;
          }
        }
        function estimateBandwidth() {
          if ("function" === typeof performance.getEntriesByType) {
            for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
              var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
              if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i += 1; i < resourceEntries.length; i++) {
                  var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
                }
                --i;
                bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function resolveEventType() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.type : null;
        }
        function resolveEventTimeStamp() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.timeStamp : -1.1;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitHydratedInstance() {
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function warnForReactChildrenConflict(container) {
          if (!container.__reactWarnedAboutChildrenConflict) {
            var props = container[internalPropsKey] || null;
            if (null !== props) {
              var fiber = getInstanceFromNode(container);
              null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })));
            }
          }
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
                depth++;
              else if (node === PREAMBLE_CONTRIBUTION_HTML)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement
                );
              else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA)
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function hideDehydratedBoundary(suspenseInstance) {
          hideOrUnhideDehydratedBoundary(suspenseInstance, true);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideDehydratedBoundary(dehydratedInstance) {
          hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data === SUSPENSE_QUEUED_START_DATA)
            instance._reactRetry = callback;
          else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
                return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else
                data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedActivityInstance(activityInstance) {
          retryIfBlockedOn(activityInstance);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root3) {
          for (var nodes = root3.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function() {
                state.waitingForImages = false;
                if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root3, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root3);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root3, precedences);
              for (var nodes = root3.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          tag |= ProfileMode;
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane(fiber);
            lane = getBumpedLaneForHydrationByLane(lane);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root3 = fiber;
                          root3.pendingLanes |= 2;
                          for (root3.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root3.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept && "react-transition" === event.info && event.intercept({
              handler: function() {
                return new Promise(function(resolve) {
                  return pendingResolve = resolve;
                });
              },
              focusReset: "manual",
              scroll: "manual"
            });
          }
          function handleNavigateComplete() {
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
                state: currentEntry.getState(),
                info: "react-transition",
                history: "replace"
              });
            }
          }
          if ("object" === typeof navigation) {
            var isCancelled = false, pendingResolve = null;
            navigation.addEventListener("navigate", handleNavigate);
            navigation.addEventListener("navigatesuccess", handleNavigateComplete);
            navigation.addEventListener("navigateerror", handleNavigateComplete);
            setTimeout(startFakeNavigation, 100);
            return function() {
              isCancelled = true;
              navigation.removeEventListener("navigate", handleNavigate);
              navigation.removeEventListener(
                "navigatesuccess",
                handleNavigateComplete
              );
              navigation.removeEventListener(
                "navigateerror",
                handleNavigateComplete
              );
              null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root2 = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
          color: "primary",
          properties: null,
          tooltipText: "",
          track: COMPONENTS_TRACK
        }, reusableComponentOptions = {
          start: -0,
          end: -0,
          detail: { devtools: reusableComponentDevToolDetails }
        }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
          return null;
        }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          globalMostRecentTransitionTime = now$1();
          if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
            if (0 > transitionStartTime && 0 > transitionUpdateTime) {
              transitionStartTime = now();
              var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
              if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
                transitionEventRepeatTime = -1.1;
              transitionEventTime = newEventTime;
              transitionEventType = newEventType;
            }
            entangleAsyncAction(transition, returnValue);
          }
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          }
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          cacheSignal: function() {
            return readContext(CacheContext).controller.signal;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        };
        scheduleRetry = function(fiber) {
          var lane = claimNextRetryLane(), root3 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root3 = this._internalRoot;
          if (null === root3) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root3.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root3, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!(function() {
          var internals = {
            bundleType: 1,
            version: "19.2.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.2.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.scheduleRetry = scheduleRetry;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          return injectInternals(internals);
        })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js
  var require_react_jsx_dev_runtime_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
              return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
          React,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            isStaticChildren,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-dev-runtime.js
  var require_jsx_dev_runtime = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-dev-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_dev_runtime_development();
      }
    }
  });

  // index.tsx
  var import_client = __toESM(require_client());
  var import_react = __toESM(require_react());

  // ../editor/dist/index.js
  (() => {
    var RI = Object.create;
    var Cd = Object.defineProperty;
    var SI = Object.getOwnPropertyDescriptor;
    var OI = Object.getOwnPropertyNames;
    var wI = Object.getPrototypeOf, LI = Object.prototype.hasOwnProperty;
    var D_ = (r, c) => () => (c || r((c = { exports: {} }).exports, c), c.exports), NI = (r, c) => {
      for (var u in c) Cd(r, u, { get: c[u], enumerable: true });
    }, AI = (r, c, u, p) => {
      if (c && typeof c == "object" || typeof c == "function") for (let T of OI(c)) !LI.call(r, T) && T !== u && Cd(r, T, { get: () => c[T], enumerable: !(p = SI(c, T)) || p.enumerable });
      return r;
    };
    var P_ = (r, c, u) => (u = r != null ? RI(wI(r)) : {}, AI(c || !r || !r.__esModule ? Cd(u, "default", { value: r, enumerable: true }) : u, r));
    var x_ = D_((vd, B_) => {
      (function(r, c) {
        typeof define == "function" && define.amd ? define([], c) : typeof vd == "object" ? B_.exports = c() : r.Blockly = c();
      })(vd, function() {
        var r = {}, c, u, p, T, G, Y, ht, Er, Ce, Jl, dt, Oe, Ws, es, ql, w, ze, x, zs, Qe, ts, Xs, Xe, wt, Ys, br, Eo, Zl, os, Bd, xd, Fd, Hd, Ud, Ql, fr, Gd, Vd, Wd, Ks, zd, Xd, Yd, Kd, jd, Jd, qd, Zd, we, R, Qd, Ir, ec, yr, Cr, J, e$, js, tc, S, oc, b, I, vr, P, kr, V, bo, Rr, fo, Io, ss, t$, Js, Sr, Wt, qs, $t, zt, is, sc, ic, De, Zs, rs, o$, Xt, Qs, Or, Yt, ei, s$, wr, i$, ti, Pe, pt, rc, oi, r$, nc, gt, Kt, lc, cc, ac, uc, si, Lr, hc, dc, ii, ns, n$, ls, l$, Nr, c$, ri, Ar, a$, Mr, u$, Dr, $c, pc, Pr, Br, xr, ni, h$, yo, li, Fr, d$, $$, p$, mt, ae, cs, gc, _t, jt, g$, mc, Hr, _c, m$, Tc, ci, _$, Ur, T$, Gr, E$, b$, f$, Co, Ec, Vr, me, Wr, bc, zr, Xr, I$, fc, Ic, y$, Yr, vo, Kr, C$, yc, Cc, v$, k$, ko, R$, ai, as, us, Be, S$, O$, w$, L$, N$, A$, M$, vc, Jt, hs, kc, D$, P$, B$, x$, F$, H$, U$, G$, V$, Rc, W$, qt, jr, z$, ds, Jr, Sc, Oc, qr, Zr, wc, X$, Lc, Nc, Ac, Mc, Dc, Pc, Bc, Y$, ui, xc, Qr, en, Tt, Fc, Hc, hi, Uc, Gc, K$, tn, Vc, j$, J$, q$, Z$, Q$, $s, Wc, zc, di, Xc, ep, tp, Yc, Kc, Lt, jc, Jc, op, sp, ip, rp, qc, np, Zc, lp, Ro, $i, on, sn, So, Qc, rn, ea, ie, cp, ps, gs, ap, ta, nn, ms, oa, Oo, pi, sa, ia, up, hp, dp, ra, $p, na, _s, pp, gp, mp, _p, gi, la, ca, mi, _i, Tp, Ti, aa, Ei, Ep, bp, Zt, ua, Et, fp, Ip, ha, yp, wo, da, Cp, vp, kp, Rp, Sp, $a, Op, wp, ln, Lp, Np, pa, bt, Ap, Mp, Ts, Dp, ga, cn, Pp, Bp, xp, ma, an, _a, un, Fp, Hp, Up, Gp, k, Le, _e, ee, ft, Es, O, re, Vp, Wp, zp, hn, Ta, dn, Ea, ba, fa, Ia, bs, ya, Xp, Yp, Lo, Ca, Kp, $n, xe, va, No, Ye, ka, jp, Ao, Ra, Nt, bi, fi, Sa, Jp, Oa, qp, pn, wa, La, Na, Zp, Aa, Qp, Ii, Ma, Da, yi, eg, Pa, Ci, vi, ki, gn, Ba, tg, xa, og, mn, _n, sg, Tn, ig, Fa, rg, Qt, Ha, fs, Ua, Ga, En, Va, Wa, za, Xa, Ya, Ka, ja, Ja, qa, ng, lg, Za, cg, ag, ug, hg, dg, $g, Qa, eu, tu, ou, su, iu, ru, bn, Ri, nu, pg, lu, cu, au, uu, hu, du, $u, pu, gu, mu, gg, mg, _u, Tu, Eu, bu, _g, Tg, m;
        c = function(e, t, o, s) {
          if (!(e instanceof E) && typeof e != "string" || `${e}`.trim() === "") throw Error('Invalid type "' + e + '". The type must be a non-empty string or a Blockly.registry.Type.');
          if (e = `${e}`.toLowerCase(), typeof t != "string" || t.trim() === "") throw Error('Invalid name "' + t + '". The name must be a non-empty string.');
          let i = t.toLowerCase();
          if (!o) throw Error("Can not register a null value");
          let n = eo[e], l = fn[e];
          if (n || (n = eo[e] = /* @__PURE__ */ Object.create(null), l = fn[e] = /* @__PURE__ */ Object.create(null)), u(e, o), !s && n[i] && n[i] !== o) throw Error('Name "' + i + '" with type "' + e + '" already registered.');
          n[i] = o, l[i] = t;
        }, u = function(e, t) {
          switch (e) {
            case String(E.FIELD):
              if (typeof t.fromJson != "function") throw Error('Type "' + e + '" must have a fromJson function');
          }
        }, p = function(e, t) {
          e = `${e}`.toLowerCase(), t = t.toLowerCase();
          let o = eo[e];
          o && o[t] ? (delete eo[e][t], delete fn[e][t]) : console.warn("Unable to unregister [" + t + "][" + e + "] from the registry.");
        }, T = function(e, t, o) {
          e = `${e}`.toLowerCase(), t = t.toLowerCase();
          let s = eo[e];
          if (!s || !s[t]) {
            if (t = "Unable to find [" + t + "][" + e + "] in the registry.", o) throw Error(t + " You must require or register a " + e + " plugin.");
            return console.warn(t), null;
          }
          return s[t];
        }, G = function(e, t) {
          return e = `${e}`.toLowerCase(), t = t.toLowerCase(), (e = eo[e]) ? !!e[t] : false;
        }, Y = function(e, t, o) {
          return T(e, t, o);
        }, ht = function(e, t, o) {
          return T(e, t, o);
        }, Er = function(e, t, o) {
          e = `${e}`.toLowerCase();
          var s = eo[e];
          if (!s) {
            if (s = `Unable to find [${e}] in the registry.`, o) throw Error(`${s} You must require or register a ${e} plugin.`);
            return console.warn(s), null;
          }
          if (!t) return s;
          e = fn[e], o = /* @__PURE__ */ Object.create(null);
          for (let i of Object.keys(s)) o[e[i]] = s[i];
          return o;
        }, Ce = function(e, t, o) {
          return t = t.plugins[String(e)] || Fe, typeof t == "function" ? t : Y(e, t, o);
        }, Jl = function(e, t) {
          dt(), yn = setTimeout(function() {
            t && t.handleRightClick(e);
          }, Z_);
        }, dt = function() {
          yn && (clearTimeout(yn), yn = 0);
        }, Oe = function() {
          In = null;
        }, Ws = function(e) {
          return !e.type.startsWith("pointer") || e instanceof PointerEvent && ql(e);
        }, es = function(e) {
          return `${e.pointerId}`;
        }, ql = function(e) {
          let t = es(e);
          return In ? In === t : e.type === "pointerdown" ? (In = t, true) : false;
        }, w = function(e, t, o, s, i) {
          function n(a) {
            (i || Ws(a)) && (o ? s.call(o, a) : s(a));
          }
          let l = [];
          if (t in Mo) for (let a = 0; a < Mo[t].length; a++) {
            let _ = Mo[t][a];
            e.addEventListener(_, n, false), l.push([e, _, n]);
          }
          else e.addEventListener(t, n, false), l.push([e, t, n]);
          return l;
        }, ze = function(e, t, o, s) {
          function i(l) {
            o ? s.call(o, l) : s(l);
          }
          let n = [];
          if (t in Mo) for (let l = 0; l < Mo[t].length; l++) {
            let a = Mo[t][l];
            e.addEventListener(a, i, false), n.push([e, a, i]);
          }
          else e.addEventListener(t, i, false), n.push([e, t, i]);
          return n;
        }, x = function(e) {
          let t = e[e.length - 1][2];
          for (; e.length; ) {
            let [o, s, i] = e.pop();
            o.removeEventListener(s, i, false);
          }
          return t;
        }, zs = function(e) {
          if (e.target instanceof HTMLElement) {
            if (e.target.isContentEditable || e.target.getAttribute("data-is-text-input") === "true") return true;
            if (e.target instanceof HTMLInputElement) return e = e.target, e.type === "text" || e.type === "number" || e.type === "email" || e.type === "password" || e.type === "search" || e.type === "tel" || e.type === "url";
            if (e.target instanceof HTMLTextAreaElement) return true;
          }
          return false;
        }, Qe = function(e) {
          return e.ctrlKey && Cu ? true : e.button === 2;
        }, ts = function(e, t, o) {
          let s = t.createSVGPoint();
          return s.x = e.clientX, s.y = e.clientY, o || (o = t.getScreenCTM().inverse()), s.matrixTransform(o);
        }, Xs = function(e) {
          switch (e.deltaMode) {
            default:
              return { x: e.deltaX, y: e.deltaY };
            case 1:
              return { x: e.deltaX * wg, y: e.deltaY * wg };
            case 2:
              return { x: e.deltaX * Lg, y: e.deltaY * Lg };
          }
        }, Xe = function() {
          return "blockly-" + (oT++).toString(36);
        }, wt = function() {
          return ku.genUid();
        }, Ys = function(e) {
          return e.type === d.BLOCK_CREATE;
        }, br = function(e) {
          return e.type === d.BLOCK_DELETE;
        }, Eo = function(e) {
          return e.type === d.BLOCK_CHANGE;
        }, Zl = function(e) {
          return e.type === d.BLOCK_FIELD_INTERMEDIATE_CHANGE;
        }, os = function(e) {
          return e.type === d.BLOCK_MOVE;
        }, Bd = function(e) {
          return e.type === d.VAR_CREATE;
        }, xd = function(e) {
          return e.type === d.VAR_DELETE;
        }, Fd = function(e) {
          return e.type === d.VAR_RENAME;
        }, Hd = function(e) {
          return e.type === d.BLOCK_DRAG;
        }, Ud = function(e) {
          return e.type === d.SELECTED;
        }, Ql = function(e) {
          return e.type === d.CLICK;
        }, fr = function(e) {
          return e.type === d.BUBBLE_OPEN;
        }, Gd = function(e) {
          return e.type === d.TRASHCAN_OPEN;
        }, Vd = function(e) {
          return e.type === d.TOOLBOX_ITEM_SELECT;
        }, Wd = function(e) {
          return e.type === d.THEME_CHANGE;
        }, Ks = function(e) {
          return e.type === d.VIEWPORT_CHANGE;
        }, zd = function(e) {
          return e.type === d.COMMENT_CREATE;
        }, Xd = function(e) {
          return e.type === d.COMMENT_DELETE;
        }, Yd = function(e) {
          return e.type === d.COMMENT_CHANGE;
        }, Kd = function(e) {
          return e.type === d.COMMENT_MOVE;
        }, jd = function(e) {
          return e.type === d.COMMENT_RESIZE;
        }, Jd = function(e) {
          return e.type === d.COMMENT_DRAG;
        }, qd = function(e) {
          return e.type === d.COMMENT_COLLAPSE;
        }, Zd = function(e) {
          return e.type === d.FINISHED_LOADING;
        }, r.setRecordUndo$$module$build$src$core$events$utils = function(e) {
          Si = e;
        }, we = function() {
          return Si;
        }, R = function(e) {
          wu.fireInternal(e);
        }, Qd = function(e) {
          if (J()) {
            if (!Dt.length) try {
              requestAnimationFrame(() => {
                setTimeout(Ir, 0);
              });
            } catch {
              setTimeout(Ir, 0);
            }
            ec(e);
          }
        }, Ir = function() {
          let e = yr(Dt);
          Dt.length = 0;
          for (let t of e) {
            if (!t.workspaceId) continue;
            let o;
            (o = zt(t.workspaceId)) == null || o.fireChangeListener(t);
          }
        }, ec = function(e) {
          if (Eo(e) && e.element === "mutation") {
            let t;
            for (t = Dt.length; t > 0; t--) {
              let o = Dt[t - 1];
              if (o.group !== e.group || o.workspaceId !== e.workspaceId || !os(o) || o.newParentId !== e.blockId) break;
            }
            Dt.splice(t, 0, e);
          } else Dt.push(e);
        }, yr = function(e) {
          let t = [];
          for (let o of e) if (e = t[t.length - 1], !o.isNull()) if (e && e.workspaceId === o.workspaceId && e.group === o.group) if (os(o) && os(e) && o.blockId === e.blockId) {
            if (e.newParentId = o.newParentId, e.newInputName = o.newInputName, e.newCoordinate = o.newCoordinate, e.reason || o.reason) {
              let s, i;
              e.reason = Array.from(new Set(((s = e.reason) != null ? s : []).concat((i = o.reason) != null ? i : [])));
            }
          } else Eo(o) && Eo(e) && o.blockId === e.blockId && o.element === e.element && o.name === e.name ? e.newValue = o.newValue : Ks(o) && Ks(e) ? (e.viewTop = o.viewTop, e.viewLeft = o.viewLeft, e.scale = o.scale, e.oldScale = o.oldScale) : Ql(o) && fr(e) || t.push(o);
          else t.push(o);
          return e = t.filter((o) => !o.isNull());
        }, Cr = function() {
          for (let e = 0, t; t = Dt[e]; e++) t.recordUndo = false;
        }, r.disable$$module$build$src$core$events$utils = function() {
          Su++;
        }, r.enable$$module$build$src$core$events$utils = function() {
          Su--;
        }, J = function() {
          return Su === 0;
        }, r.getGroup$$module$build$src$core$events$utils = function() {
          return Ag;
        }, r.setGroup$$module$build$src$core$events$utils = function(e) {
          wu.setGroupInternal(e);
        }, e$ = function(e) {
          Ag = typeof e == "boolean" ? e ? wt() : "" : e;
        }, js = function(e) {
          let t = [];
          e = e.getDescendants(false);
          for (let o = 0, s; s = e[o]; o++) t[o] = s.id;
          return t;
        }, tc = function(e, t) {
          let o = S(e.type);
          if (!o) throw Error("Unknown event type.");
          return o.fromJson(e, t);
        }, S = function(e) {
          let t = Y(E.EVENT, e);
          if (!t) throw Error(`Event type ${e} not found in registry.`);
          return t;
        }, oc = function(e) {
          if ((os(e) || Ys(e)) && e.workspaceId) {
            var t = zt(e.workspaceId);
            if (!e.blockId) throw Error("Encountered a blockEvent without a proper blockId");
            if (e = t.getBlockById(e.blockId)) {
              let o = Si;
              try {
                Si = false;
                let s = e.getParent();
                if (s && !s.hasDisabledReason(Ou)) {
                  let i = e.getDescendants(false);
                  for (let n = 0, l; l = i[n]; n++) l.setDisabledReason(false, Ou);
                } else if ((e.outputConnection || e.previousConnection) && !t.isDragging()) do
                  e.setDisabledReason(true, Ou), e = e.getNextBlock();
                while (e);
              } finally {
                Si = o;
              }
            }
          }
        }, b = function(e, t, o) {
          e = document.createElementNS(Oi, `${e}`);
          for (let s in t) e.setAttribute(s, `${t[s]}`);
          return o && o.appendChild(e), e;
        }, I = function(e, t) {
          return t = t.split(" "), t.every((o) => e.classList.contains(o)) ? false : (e.classList.add(...t), true);
        }, vr = function(e, t) {
          e.classList.remove(...t.split(" "));
        }, P = function(e, t) {
          return t = t.split(" "), t.every((o) => !e.classList.contains(o)) ? false : (e.classList.remove(...t), true);
        }, kr = function(e, t) {
          return e.classList.contains(t);
        }, V = function(e) {
          return e && e.parentNode ? e.parentNode.removeChild(e) : null;
        }, bo = function(e, t) {
          let o = t.nextSibling;
          if (t = t.parentNode, !t) throw Error("Reference node has no parent.");
          o ? t.insertBefore(e, o) : t.appendChild(e);
        }, Rr = function(e, t) {
          e.style.transform = t, e.style["-webkit-transform"] = t;
        }, fo = function() {
          Lu++, et || (et = /* @__PURE__ */ Object.create(null));
        }, Io = function() {
          Lu--, Lu || (et = null);
        }, ss = function(e) {
          let t = e.textContent + `
` + e.className.baseVal;
          var o;
          return et && (o = et[t]) || (o = window.getComputedStyle(e), o = Js(e, o.fontSize, o.fontWeight, o.fontFamily), et && (et[t] = o)), o;
        }, t$ = function(e, t, o, s) {
          return Js(e, t + "pt", o, s);
        }, Js = function(e, t, o, s) {
          let i = e.textContent;
          e = i + `
` + e.className.baseVal;
          var n;
          return et && (n = et[e]) || (wi || (n = document.createElement("canvas"), n.className = "blocklyComputeCanvas", document.body.appendChild(n), wi = n.getContext("2d")), i && wi ? (wi.font = o + " " + t + " " + s, n = wi.measureText(i).width) : n = 0, et && (et[e] = n)), n;
        }, Sr = function(e, t, o, s) {
          let i = document.createElement("span");
          i.style.font = o + " " + t + " " + s, i.textContent = e, e = document.createElement("div"), e.style.width = "1px", e.style.height = "0", t = document.createElement("div"), t.style.display = "flex", t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.appendChild(i), t.appendChild(e), document.body.appendChild(t), o = { height: 0, baseline: 0 };
          try {
            t.style.alignItems = "baseline", o.baseline = e.offsetTop - i.offsetTop, t.style.alignItems = "flex-end", o.height = e.offsetTop - i.offsetTop;
          } finally {
            document.body.removeChild(t);
          }
          return o;
        }, r.getFocusManager$$module$build$src$core$focus_manager = function() {
          return Ee.getFocusManager();
        }, Wt = function(e) {
          return e && typeof e.getFocusableElement == "function" && typeof e.getFocusableTree == "function" && typeof e.onNodeFocus == "function" && typeof e.onNodeBlur == "function" && typeof e.canBeFocused == "function";
        }, qs = function(e) {
          return Wt(e) && typeof e.id == "string" && typeof e.workspace == "object" && typeof e.select == "function" && typeof e.unselect == "function";
        }, $t = function(e, t) {
          for (let o in t) t[o] !== null && Array.isArray(t[o]) ? e[o] = $t(e[o] || [], t[o]) : e[o] = t[o] !== null && typeof t[o] == "object" ? $t(e[o] || /* @__PURE__ */ Object.create(null), t[o]) : t[o];
          return e;
        }, zt = function(e) {
          return Li[e] || null;
        }, is = function() {
          let e = [];
          for (let t in Li) e.push(Li[t]);
          return e;
        }, sc = function(e) {
          Li[e.id] = e;
        }, ic = function(e) {
          delete Li[e.id];
        }, De = function() {
          return Pg;
        }, Zs = function(e) {
          Pg = e;
        }, rs = function() {
          let e = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode();
          return e && qs(e) ? e : null;
        }, o$ = function(e) {
          r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e);
        }, Xt = function(e) {
          let t = rs(), o, s, i, n, l = new (S(d.SELECTED))((o = t?.id) != null ? o : null, (s = e?.id) != null ? s : null, (n = (i = e?.workspace.id) != null ? i : t?.workspace.id) != null ? n : "");
          R(l);
        }, Qs = function() {
          return Bg;
        }, Or = function(e) {
          Bg = e;
        }, Yt = function(e) {
          for (; e.options.parentWorkspace; ) e = e.options.parentWorkspace;
          let t = e.getParentSvg(), o = e.getCachedParentSvgSize();
          var s = t.parentElement;
          if (s instanceof HTMLElement) {
            var i = s.offsetWidth;
            s = s.offsetHeight, o.width !== i && (t.setAttribute("width", i + "px"), e.setCachedParentSvgSize(i, null)), o.height !== s && (t.setAttribute("height", s + "px"), e.setCachedParentSvgSize(null, s)), e.resize();
          }
        }, ei = function(e, t) {
          let o = /* @__PURE__ */ Object.create(null), s = e.getDescendants(true);
          t && (e = e.getNextBlock()) && (e = s.indexOf(e), s.splice(e, s.length - e));
          for (let i = 0, n; n = s[i]; i++) o[n.type] ? o[n.type]++ : o[n.type] = 1;
          return o;
        }, s$ = function(e) {
          return function() {
            this.jsonInit(e);
          };
        }, wr = function(e) {
          xg.defineBlocksWithJsonArrayInternal(e);
        }, i$ = function(e) {
          r.defineBlocks$$module$build$src$core$common(r.createBlockDefinitionsFromJsonArray$$module$build$src$core$common(e));
        }, r.createBlockDefinitionsFromJsonArray$$module$build$src$core$common = function(e) {
          let t = {};
          for (let o = 0; o < e.length; o++) {
            let s = e[o];
            if (!s) {
              console.warn(`Block definition #${o} in JSON array is ${s}. Skipping`);
              continue;
            }
            let i = s.type;
            i ? t[i] = { init: s$(s) } : console.warn(`Block definition #${o} in JSON array is missing a type attribute. Skipping.`);
          }
          return t;
        }, r.defineBlocks$$module$build$src$core$common = function(e) {
          for (let t of Object.keys(e)) {
            let o = e[t];
            t in K && console.warn(`Block definition "${t}" overwrites previous definition.`), K[t] = o;
          }
        }, ti = function(e) {
          let t = De(), o = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedTree();
          for (let s of is()) if (o === s) {
            t = s;
            break;
          }
          !zs(e) && t && (!t.rendered || t.isFlyout || t.isVisible()) && W.registry.onKeyDown(t, e);
        }, Pe = function(e, t) {
          return t = e.indexOf(t), t === -1 ? false : (e.splice(t, 1), true);
        }, pt = function(e) {
          if (Nu) throw Error("CSS already injected");
          Au += `
` + e;
        }, rc = function(e, t) {
          Nu || (Nu = true, e && (e = t.replace(/[\\/]$/, ""), t = Au.replace(/<<<PATH>>>/g, e), Au = "", e = document.createElement("style"), e.id = "blockly-common-style", t = document.createTextNode(t), e.appendChild(t), document.head.insertBefore(e, document.head.firstChild)));
        }, oi = function(e) {
          return Gg.getSizeInternal(e);
        }, r$ = function(e) {
          if (gt(e, "display") !== "none") return nc(e);
          let t = e.style, o = t.display, s = t.visibility, i = t.position;
          t.visibility = "hidden", t.position = "absolute", t.display = "inline";
          let n = e.offsetWidth;
          return e = e.offsetHeight, t.display = o, t.position = i, t.visibility = s, new N(n, e);
        }, nc = function(e) {
          return new N(e.offsetWidth, e.offsetHeight);
        }, gt = function(e, t) {
          return e = window.getComputedStyle(e), e[t] || e.getPropertyValue(t);
        }, Kt = function(e) {
          let t = new f(0, 0);
          e = e.getBoundingClientRect();
          var o = document.documentElement;
          return o = new f(window.pageXOffset || o.scrollLeft, window.pageYOffset || o.scrollTop), t.x = e.left + o.x, t.y = e.top + o.y, t;
        }, lc = function() {
          let e = document.body, t = document.documentElement;
          return new f(e.scrollLeft || t.scrollLeft, e.scrollTop || t.scrollTop);
        }, cc = function(e) {
          let t = parseFloat(gt(e, "borderLeftWidth")), o = parseFloat(gt(e, "borderRightWidth")), s = parseFloat(gt(e, "borderTopWidth"));
          return e = parseFloat(gt(e, "borderBottomWidth")), new L(s, e, t, o);
        }, ac = function(e, t, o) {
          e = uc(e, t, o), t.scrollLeft = e.x, t.scrollTop = e.y;
        }, uc = function(e, t, o) {
          var s = Kt(e), i = Kt(t), n = cc(t);
          let l = s.x - i.x - n.left;
          return s = s.y - i.y - n.top, i = nc(e), e = t.clientWidth - i.width, i = t.clientHeight - i.height, n = t.scrollLeft, t = t.scrollTop, o ? (n += l - e / 2, t += s - i / 2) : (n += Math.min(l, Math.max(l - e, 0)), t += Math.min(s, Math.max(s - i, 0))), new f(n, t);
        }, si = function(e) {
          let t = new f(0, 0);
          var o = e.x && e.getAttribute("x");
          let s = e.y && e.getAttribute("y");
          return o && (t.x = parseInt(o)), s && (t.y = parseInt(s)), (o = (o = e.getAttribute("transform")) && o.match(Vg)) && (t.x += Number(o[1]), o[3] && (t.y += Number(o[3]))), (e = e.getAttribute("style")) && e.includes("translate") && (e = e.match(Wg)) && (t.x += Number(e[1]), e[3] && (t.y += Number(e[3]))), t;
        }, Lr = function(e) {
          let t = 0, o = 0;
          for (; e; ) {
            let s = si(e);
            if (t += s.x, o += s.y, (" " + (e.getAttribute("class") || "") + " ").includes(" injectionDiv ")) break;
            e = e.parentNode;
          }
          return new f(t, o);
        }, hc = function() {
          let e = lc();
          return new L(e.y, document.documentElement.clientHeight + e.y, e.x, document.documentElement.clientWidth + e.x);
        }, dc = function() {
          let e = document.documentElement, t = window;
          return new f(t.pageXOffset || e.scrollLeft, t.pageYOffset || e.scrollTop);
        }, ii = function(e, t) {
          var o = t.x;
          t = t.y;
          let s = e.getInjectionDiv().getBoundingClientRect();
          return o = new f(o - s.left, t - s.top), t = e.getOriginOffsetInPixels(), f.difference(o, t).scale(1 / e.scale);
        }, ns = function(e, t) {
          var o = t.scale(e.scale);
          t = o.x, o = o.y;
          let s = e.getInjectionDiv().getBoundingClientRect();
          return e = e.getOriginOffsetInPixels(), new f(t + s.left + e.x, o + s.top + e.y);
        }, n$ = function(e) {
          ({ document: wn = wn, DOMParser: Ai = Ai, XMLSerializer: Mi = Mi } = e), On = new Ai(), Du = new Mi();
        }, r.createElement$$module$build$src$core$utils$xml = function(e) {
          return wn.createElementNS(zg, e);
        }, r.createTextNode$$module$build$src$core$utils$xml = function(e) {
          return wn.createTextNode(e);
        }, r.textToDom$$module$build$src$core$utils$xml = function(e) {
          let t = On.parseFromString(e, "text/xml");
          if (t && t.documentElement && !t.getElementsByTagName("parsererror").length) return t.documentElement;
          if ((t = On.parseFromString(e, "text/html")) && t.body.firstChild && t.body.firstChild.nodeName.toLowerCase() === "xml") return t.body.firstChild;
          throw Error(`DOMParser was unable to parse: ${e}`);
        }, ls = function(e) {
          return l$(Du.serializeToString(e));
        }, l$ = function(e) {
          return e.replace(_T, (t) => `&#${t.charCodeAt(0)};`);
        }, Nr = function(e) {
          return e ? ((e instanceof Element || typeof e == "string") && (e = pc(e), e = u$(e)), c$(e), e) : null;
        }, c$ = function(e) {
          let t = e.kind;
          if (e = e.contents, t && t !== Xg && t !== Pu) throw Error("Invalid toolbox kind " + t + ". Please supply either " + Xg + " or " + Pu);
          if (!e) throw Error("Toolbox must have a contents attribute.");
        }, ri = function(e) {
          return e ? e.contents ? e.contents : Array.isArray(e) && e.length > 0 && !e[0].nodeType ? e : Dr(e) : [];
        }, Ar = function(e) {
          return Yg.hasCategoriesInternal(e);
        }, a$ = function(e) {
          if (!e) return false;
          let t = e.kind;
          return t ? t === Pu : !!e.contents.filter((o) => o.kind.toUpperCase() === "CATEGORY").length;
        }, Mr = function(e) {
          return e && e.contents ? !!e.contents.filter(function(t) {
            return t.kind.toUpperCase() === "CATEGORY";
          }).length : false;
        }, u$ = function(e) {
          let t = { contents: Dr(e) };
          return e instanceof Node && $c(e, t), t;
        }, Dr = function(e) {
          let t = [], o = e.childNodes;
          o || (o = e);
          for (let s = 0, i; i = o[s]; s++) {
            if (!i.tagName) continue;
            e = {};
            let n = i.tagName.toUpperCase();
            e.kind = n, n === "BLOCK" ? e.blockxml = i : i.childNodes && i.childNodes.length > 0 && (e.contents = Dr(i)), $c(i, e), t.push(e);
          }
          return t;
        }, $c = function(e, t) {
          for (let o = 0; o < e.attributes.length; o++) {
            let s = e.attributes[o];
            s.nodeName.includes("css-") ? (t.cssconfig = t.cssconfig || {}, t.cssconfig[s.nodeName.replace("css-", "")] = s.value) : t[s.nodeName] = s.value;
          }
        }, pc = function(e) {
          let t = null;
          if (e) if (typeof e == "string") {
            if (t = r.textToDom$$module$build$src$core$utils$xml(e), t.nodeName.toLowerCase() !== "xml") throw TypeError("Toolbox should be an <xml> document.");
          } else e instanceof Element && (t = e);
          return t;
        }, Pr = function(e, t, o, s, i, n) {
          let l = n.scrollbar && n.scrollbar.canScrollVertically();
          return e.horizontal === ys.LEFT ? (o = i.absoluteMetrics.left + o, l && n.RTL && (o += te.scrollbarThickness)) : (o = i.absoluteMetrics.left + i.viewMetrics.width - t.width - o, l && !n.RTL && (o -= te.scrollbarThickness)), e.vertical === xt.TOP ? e = i.absoluteMetrics.top + s : (e = i.absoluteMetrics.top + i.viewMetrics.height - t.height - s, n.scrollbar && n.scrollbar.canScrollHorizontally() && (e -= te.scrollbarThickness)), new L(e, e + t.height, o, o + t.width);
        }, Br = function(e, t) {
          return { horizontal: t.toolboxMetrics.position === A.LEFT || e.horizontalLayout && !e.RTL ? ys.RIGHT : ys.LEFT, vertical: t.toolboxMetrics.position === A.BOTTOM ? xt.TOP : xt.BOTTOM };
        }, xr = function(e, t, o, s) {
          let i = e.left, n = e.right - e.left, l = e.bottom - e.top;
          for (let a = 0; a < s.length; a++) {
            let _ = s[a];
            e.intersects(_) && (e = o === so.UP ? _.top - l - t : _.bottom + t, e = new L(e, e + l, i, i + n), a = -1);
          }
          return e;
        }, ni = function(e, t) {
          c(E.SERIALIZER, e, t);
        }, h$ = function(e) {
          p(E.SERIALIZER, e);
        }, yo = function(e, { addCoordinates: t = false, saveIds: o = true } = {}) {
          let s = e.workspace, i = /* @__PURE__ */ Object.create(null);
          return i.height = e.getSize().height, i.width = e.getSize().width, o && (i.id = e.id), t && (t = e.getRelativeToSurfaceXY(), i.x = s.RTL ? s.getWidth() - t.x : t.x, i.y = t.y), e.getText() && (i.text = e.getText()), e.isCollapsed() && (i.collapsed = true), e.isOwnEditable() || (i.editable = false), e.isOwnMovable() || (i.movable = false), e.isOwnDeletable() || (i.deletable = false), i;
        }, li = function(e, t, { recordUndo: o = false } = {}) {
          let s = we();
          if (r.setRecordUndo$$module$build$src$core$events$utils(o), o = t.newComment(e.id), e.text !== void 0 && o.setText(e.text), e.x !== void 0 || e.y !== void 0) {
            let n = o.getRelativeToSurfaceXY(), l, a = (l = e.x) != null ? l : n.x;
            a = t.RTL ? t.getWidth() - a : a;
            var i;
            t = (i = e.y) != null ? i : n.y, o.moveTo(new f(a, t));
          }
          if (e.width !== void 0 || e.height) {
            i = o.getSize();
            let n, l;
            o.setSize(new N((n = e.width) != null ? n : i.width, (l = e.height) != null ? l : i.height));
          }
          return e.collapsed !== void 0 && o.setCollapsed(e.collapsed), e.editable !== void 0 && o.setEditable(e.editable), e.movable !== void 0 && o.setMovable(e.movable), e.deletable !== void 0 && o.setDeletable(e.deletable), r.setRecordUndo$$module$build$src$core$events$utils(s), o;
        }, Fr = function(e, t) {
          c(E.PASTER, e, t);
        }, d$ = function(e) {
          p(E.PASTER, e);
        }, $$ = function(e) {
          let t = e.workspace, o = e.getRelativeToSurfaceXY(), s = new f(0, 0), i = t.getTopComments(false).filter((n) => n.id !== e.id).map((n) => n.getRelativeToSurfaceXY());
          for (; p$(f.sum(o, s), i); ) s.translate(t.RTL ? -30 : 30, 30);
          e.moveTo(f.sum(o, s));
        }, p$ = function(e, t) {
          return t.some((o) => Math.abs(o.x - e.x) <= 1 && Math.abs(o.y - e.y) <= 1);
        }, mt = function(e, t) {
          e.setAttribute(yT, t);
        }, ae = function(e, t, o) {
          Array.isArray(o) && (o = o.join(" ")), e.setAttribute(IT + t, `${o}`);
        }, cs = function(e) {
          return e && typeof e.saveState == "function" && typeof e.loadState == "function";
        }, gc = function(e) {
          return mc(e), g$() ? (Hr(), Promise.resolve()) : (vs || (vs = new Promise((t) => {
            Wu = t, Qg = window.requestAnimationFrame(() => {
              Hr(), t();
            });
          })), vs);
        }, _t = function() {
          return vs || Promise.resolve();
        }, jt = function(e) {
          e || window.cancelAnimationFrame(Qg), Hr(e), !e && Wu && Wu();
        }, g$ = function() {
          return kg;
        }, mc = function(e) {
          Gu.add(e), Vu.set(e, r.getGroup$$module$build$src$core$events$utils());
          let t = e.getParent();
          t ? mc(t) : An.add(e);
        }, Hr = function(e) {
          let t = e ? /* @__PURE__ */ new Set([e]) : new Set([...An].map((n) => n.workspace)), o = [...An].filter(m$).filter((n) => t.has(n.workspace));
          for (var s of o) Tc(s);
          for (let n of t) n.resizeContents();
          for (var i of o) s = i.getRelativeToSurfaceXY(), i.updateComponentLocations(s);
          for (let n of o) i = r.getGroup$$module$build$src$core$events$utils(), (s = Vu.get(n)) && r.setGroup$$module$build$src$core$events$utils(s), n.bumpNeighbours(), r.setGroup$$module$build$src$core$events$utils(i);
          for (let n of o) _c(n);
          e || (vs = null);
        }, _c = function(e) {
          An.delete(e), Gu.delete(e), Vu.delete(e);
          for (let t of e.getChildren(false)) _c(t);
        }, m$ = function(e) {
          return !e.isDisposed() && !e.getParent();
        }, Tc = function(e) {
          if (Gu.has(e) && e.initialized) {
            for (let t of e.getChildren(false)) Tc(t);
            e.renderEfficiently();
          }
        }, ci = function(e, t) {
          im(e, t);
        }, _$ = function(e = sm) {
          im = e;
        }, Ur = function(e, t) {
          nm(e, t);
        }, T$ = function(e = rm) {
          nm = e;
        }, Gr = function(e, t, o) {
          cm(e, t, o);
        }, E$ = function(e = lm) {
          cm = e;
        }, b$ = function(e, t) {
          um(e, t);
        }, f$ = function(e = am) {
          um = e;
        }, Co = function(e) {
          return e && typeof e.getProcedureDef == "function";
        }, Ec = function(e) {
          return e && typeof e.getProcedureCall == "function" && typeof e.renameProcedure == "function";
        }, Vr = function(e) {
          return e.getVariableModel !== void 0;
        }, me = function(e, t, o, s) {
          e = e + " was deprecated in " + t + " and will be deleted in " + o + ".", s && (e += `
Use ` + s + " instead."), dm.has(e) || (dm.add(e), console.warn(e));
        }, r.allUsedVarModels$$module$build$src$core$variables = function(e) {
          e = e.getAllBlocks(false);
          let t = /* @__PURE__ */ new Set();
          for (let o = 0; o < e.length; o++) {
            let s = e[o].getVarModels();
            if (s) for (let i = 0; i < s.length; i++) {
              let n = s[i];
              n.getId() && t.add(n);
            }
          }
          return Array.from(t.values());
        }, r.allDeveloperVariables$$module$build$src$core$variables = function(e) {
          e = e.getAllBlocks(false);
          let t = /* @__PURE__ */ new Set();
          for (let s = 0, i; i = e[s]; s++) {
            var o = i.getDeveloperVariables;
            if (o) {
              o = o();
              for (let n = 0; n < o.length; n++) t.add(o[n]);
            }
          }
          return Array.from(t.values());
        }, Wr = function(e) {
          return bc(e, false);
        }, bc = function(e, t = true) {
          return K.variables_set || K.variables_get || console.warn("There are no variable blocks, but there is a variable category."), t ? (me("The XML return value of Blockly.Variables.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), I$(e)) : (e.registerButtonCallback("CREATE_VARIABLE", function(o) {
            vo(o.getTargetWorkspace());
          }), [{ kind: "button", text: "%{BKY_NEW_VARIABLE}", callbackkey: "CREATE_VARIABLE" }, ...Xr(e, e.getVariableMap().getVariablesOfType(""), true)]);
        }, zr = function(e) {
          return { VAR: { name: e.getName(), type: e.getType() } };
        }, Xr = function(e, t, o, s = "variables_get", i = "variables_set") {
          o && (o = K.math_change), e = [];
          let n = t.slice(-1)[0];
          return n && (K[i] && e.push({ kind: "block", type: i, gap: o ? 8 : 24, fields: zr(n) }), o && e.push({ kind: "block", type: "math_change", gap: K[s] ? 20 : 8, fields: zr(n), inputs: { DELTA: { shadow: { type: "math_number", fields: { NUM: 1 } } } } })), K[s] && e.push(...t.sort(as).map((l) => ({ kind: "block", type: s, gap: 8, fields: zr(l) }))), e;
        }, I$ = function(e) {
          let t = [], o = document.createElement("button");
          return o.setAttribute("text", "%{BKY_NEW_VARIABLE}"), o.setAttribute("callbackKey", "CREATE_VARIABLE"), e.registerButtonCallback("CREATE_VARIABLE", function(s) {
            vo(s.getTargetWorkspace());
          }), t.push(o), e = fc(e), t = t.concat(e);
        }, fc = function(e) {
          e = e.getVariableMap().getVariablesOfType("");
          let t = [];
          if (e.length > 0) {
            var o = e[e.length - 1];
            if (K.variables_set) {
              var s = r.createElement$$module$build$src$core$utils$xml("block");
              s.setAttribute("type", "variables_set"), s.setAttribute("gap", K.math_change ? "8" : "24"), s.appendChild(ko(o)), t.push(s);
            }
            if (K.math_change && (s = r.createElement$$module$build$src$core$utils$xml("block"), s.setAttribute("type", "math_change"), s.setAttribute("gap", K.variables_get ? "20" : "8"), s.appendChild(ko(o)), o = r.textToDom$$module$build$src$core$utils$xml('<value name="DELTA"><shadow type="math_number"><field name="NUM">1</field></shadow></value>'), s.appendChild(o), t.push(s)), K.variables_get) {
              e.sort(as);
              for (let i = 0, n; n = e[i]; i++) o = r.createElement$$module$build$src$core$utils$xml("block"), o.setAttribute("type", "variables_get"), o.setAttribute("gap", "8"), o.appendChild(ko(n)), t.push(o);
            }
          }
          return t;
        }, Ic = function(e) {
          return pm.generateUniqueNameInternal(e);
        }, y$ = function(e) {
          return Yr(Xu.charAt(0), e.getVariableMap().getAllVariables().map((t) => t.getName()));
        }, Yr = function(e, t) {
          if (!t.length) return e;
          let o = Xu, s = "", i = o.indexOf(e);
          for (; ; ) {
            let n = false;
            for (let l = 0; l < t.length; l++) if (t[l].toLowerCase() === e) {
              n = true;
              break;
            }
            if (!n) break;
            i++, i === o.length && (i = 0, s = `${Number(s) + 1}`), e = o.charAt(i) + s;
          }
          return e;
        }, vo = function(e, t, o) {
          function s(n) {
            Kr(r.Msg$$module$build$src$core$msg.NEW_VARIABLE_TITLE, n, function(l) {
              if (l) {
                var a = yc(l, e);
                if (a) {
                  if (a.getType() === i) var _ = r.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS.replace("%1", a.getName());
                  else _ = r.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE, _ = _.replace("%1", a.getName()).replace("%2", a.getType());
                  ci(_, function() {
                    s(l);
                  });
                } else e.getVariableMap().createVariable(l, i), t && t(l);
              } else t && t(null);
            });
          }
          let i = o || "";
          s("");
        }, r.renameVariable$$module$build$src$core$variables = function(e, t, o) {
          function s(i) {
            let n = r.Msg$$module$build$src$core$msg.RENAME_VARIABLE_TITLE.replace("%1", t.getName());
            Kr(n, i, function(l) {
              if (l) {
                var a = C$(l, t.getType(), e), _ = Cc(t.getName(), l, e);
                if (a || _) {
                  var v = "";
                  a ? v = r.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace("%1", a.getName()).replace("%2", a.getType()) : _ && (v = r.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER.replace("%1", l).replace("%2", _)), ci(v, function() {
                    s(l);
                  });
                } else e.getVariableMap().renameVariable(t, l), o && o(l);
              } else o && o(null);
            });
          }
          s("");
        }, Kr = function(e, t, o) {
          Gr(e, t, function(s) {
            s && (s = s.replace(/[\s\xa0]+/g, " ").trim(), s === r.Msg$$module$build$src$core$msg.RENAME_VARIABLE || s === r.Msg$$module$build$src$core$msg.NEW_VARIABLE) && (s = null), o(s);
          });
        }, C$ = function(e, t, o) {
          o = o.getVariableMap().getAllVariables(), e = e.toLowerCase();
          for (let s = 0, i; i = o[s]; s++) if (i.getName().toLowerCase() === e && i.getType() !== t) return i;
          return null;
        }, yc = function(e, t) {
          t = t.getVariableMap().getAllVariables(), e = e.toLowerCase();
          for (let o = 0, s; s = t[o]; o++) if (s.getName().toLowerCase() === e) return s;
          return null;
        }, Cc = function(e, t, o) {
          return o.getProcedureMap().getProcedures().length ? v$(e, t, o) : k$(e, t, o);
        }, v$ = function(e, t, o) {
          e = e.toLowerCase(), t = t.toLowerCase(), o = o.getProcedureMap().getProcedures();
          for (let i of o) {
            var s = i.getParameters().filter(Vr).map((n) => n.getVariableModel().getName());
            if (s && (o = s.some((n) => n.toLowerCase() === e), s = s.some((n) => n.toLowerCase() === t), o && s)) return i.getName();
          }
          return null;
        }, k$ = function(e, t, o) {
          e = e.toLowerCase(), t = t.toLowerCase(), o = o.getAllBlocks(false);
          for (let i of o) {
            if (!Co(i)) continue;
            o = i.getProcedureDef();
            var s = o[1];
            let n = s.some((l) => l.toLowerCase() === e);
            if (s = s.some((l) => l.toLowerCase() === t), n && s) return o[0];
          }
          return null;
        }, ko = function(e) {
          let t = r.createElement$$module$build$src$core$utils$xml("field");
          return t.setAttribute("name", "VAR"), t.setAttribute("id", e.getId()), t.setAttribute("variabletype", e.getType()), e = r.createTextNode$$module$build$src$core$utils$xml(e.getName()), t.appendChild(e), t;
        }, r.getOrCreateVariablePackage$$module$build$src$core$variables = function(e, t, o, s) {
          let i = r.getVariable$$module$build$src$core$variables(e, t, o, s);
          return i || (i = R$(e, t, o, s)), i;
        }, r.getVariable$$module$build$src$core$variables = function(e, t, o, s) {
          let i = e.getPotentialVariableMap(), n = null;
          if (t && (n = e.getVariableById(t), !n && i && (n = i.getVariableById(t)), n)) return n;
          if (o) {
            if (s === void 0) throw Error("Tried to look up a variable by name without a type");
            n = e.getVariable(o, s), !n && i && (n = i.getVariable(o, s));
          }
          return n;
        }, R$ = function(e, t, o, s) {
          let i = e.getVariableMap(), n = e.getPotentialVariableMap();
          return o || (o = Ic(e.isFlyout ? e.targetWorkspace : e)), n ? n.createVariable(o, s, t ?? void 0) : i.createVariable(o, s, t);
        }, ai = function(e, t) {
          e = e.getAllVariables();
          let o = [];
          if (t.length !== e.length) for (let s = 0; s < e.length; s++) {
            let i = e[s];
            t.includes(i) || o.push(i);
          }
          return o;
        }, as = function(e, t) {
          return e.getName().localeCompare(t.getName(), void 0, { sensitivity: "base" });
        }, us = function(e, t) {
          let o = [];
          e = e.getAllBlocks(false);
          for (let s = 0; s < e.length; s++) {
            let i = e[s].getVarModels();
            if (i) for (let n = 0; n < i.length; n++) i[n].getId() === t && o.push(e[s]);
          }
          return o;
        }, r.deleteVariable$$module$build$src$core$variables = function(e, t, o) {
          var s = t.getName();
          let i = us(e, t.getId());
          for (let n = i.length - 1; n >= 0; n--) {
            let l = i[n];
            if (l.type === "procedures_defnoreturn" || l.type === "procedures_defreturn") {
              o = String(l.getFieldValue("NAME")), s = r.Msg$$module$build$src$core$msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace("%1", s).replace("%2", o), ci(s);
              return;
            }
            l === o && i.splice(n, 1);
          }
          o && i.length || i.length > 1 ? (s = r.Msg$$module$build$src$core$msg.DELETE_VARIABLE_CONFIRMATION.replace("%1", String(i.length + (o && !o.workspace.isFlyout ? 1 : 0))).replace("%2", s), Ur(s, (n) => {
            n && t && e.getVariableMap().deleteVariable(t);
          })) : e.getVariableMap().deleteVariable(t);
        }, Be = function(e, { addCoordinates: t = false, addInputBlocks: o = true, addNextBlocks: s = true, doFullSerialization: i = true, saveIds: n = true } = {}) {
          if (e.isInsertionMarker()) return null;
          let l = { type: e.type, id: n ? e.id : void 0 };
          return t && O$(e, l), S$(e, l), w$(e, l, i), L$(e, l, i), N$(e, l, i), o && A$(e, l, i, n), s && M$(e, l, i, n), l;
        }, S$ = function(e, t) {
          e.isCollapsed() && (t.collapsed = true), e.isEnabled() || (t.disabledReasons = Array.from(e.getDisabledReasons())), e.isOwnDeletable() || (t.deletable = false), e.isOwnMovable() || (t.movable = false), e.isOwnEditable() || (t.editable = false), e.inputsInline !== void 0 && e.inputsInline !== e.inputsInlineDefault && (t.inline = e.inputsInline), e.data && (t.data = e.data);
        }, O$ = function(e, t) {
          let o = e.workspace;
          e = e.getRelativeToSurfaceXY(), t.x = Math.round(o.RTL ? o.getWidth() - e.x : e.x), t.y = Math.round(e.y);
        }, w$ = function(e, t, o) {
          e.saveExtraState ? (e = e.saveExtraState(o), e !== null && (t.extraState = e)) : e.mutationToDom && (e = e.mutationToDom(), e !== null && (t.extraState = Et(e).replace(' xmlns="https://developers.google.com/blockly/xml"', "")));
        }, L$ = function(e, t, o) {
          let s = /* @__PURE__ */ Object.create(null);
          for (let i of e.getIcons()) cs(i) && (e = i.saveState(o)) && (s[i.getType().toString()] = e);
          Object.keys(s).length && (t.icons = s);
        }, N$ = function(e, t, o) {
          let s = /* @__PURE__ */ Object.create(null);
          for (let i of e.getFields()) i.isSerializable() && (s[i.name] = i.saveState(o));
          Object.keys(s).length && (t.fields = s);
        }, A$ = function(e, t, o, s) {
          let i = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < e.inputList.length; n++) {
            let l = e.inputList[n];
            if (!l.connection) continue;
            let a = vc(l.connection, o, s);
            a && (i[l.name] = a);
          }
          Object.keys(i).length && (t.inputs = i);
        }, M$ = function(e, t, o, s) {
          e.nextConnection && (e = vc(e.nextConnection, o, s)) && (t.next = e);
        }, vc = function(e, t, o) {
          let s = e.getShadowState(true);
          if (e = e.targetBlock(), !s && !e) return null;
          let i = /* @__PURE__ */ Object.create(null);
          return s && (i.shadow = s), e && !e.isShadow() && (i.block = Be(e, { doFullSerialization: t, saveIds: o })), i;
        }, Jt = function(e, t, { recordUndo: o = false } = {}) {
          return e = hs(e, t, { recordUndo: o }), t.rendered && jt(), e;
        }, hs = function(e, t, { parentConnection: o, isShadow: s = false, recordUndo: i = false } = {}) {
          let n = we();
          r.setRecordUndo$$module$build$src$core$events$utils(i), (i = r.getGroup$$module$build$src$core$events$utils()) || r.setGroup$$module$build$src$core$events$utils(true), r.disable$$module$build$src$core$events$utils();
          let l = t.getAllVariables(), a;
          try {
            a = kc(e, t, { parentConnection: o, isShadow: s });
          } finally {
            r.enable$$module$build$src$core$events$utils();
          }
          if (D$(t, l), J() && R(new (S(d.BLOCK_CREATE))(a)), r.setGroup$$module$build$src$core$events$utils(i), r.setRecordUndo$$module$build$src$core$events$utils(n), t.rendered) {
            let _ = a;
            setTimeout(() => {
              _.disposed || _.setConnectionTracking(true);
            }, 1);
          }
          return a;
        }, kc = function(e, t, { parentConnection: o, isShadow: s = false } = {}) {
          if (!e.type) throw new gm(e);
          let i = t.newBlock(e.type, e.id);
          return i.setShadow(s), P$(i, e), B$(i, e), x$(i, e), F$(o, i, e), H$(i, e), U$(i, e), G$(i, e), V$(i, e), W$(i, t.rendered), i;
        }, D$ = function(e, t) {
          if (J()) for (e = ai(e, t), t = 0; t < e.length; t++) {
            let o = e[t];
            R(new (S(d.VAR_CREATE))(o));
          }
        }, P$ = function(e, t) {
          let o = t.x === void 0 ? 0 : t.x;
          t = t.y === void 0 ? 0 : t.y;
          let s = e.workspace;
          o = s.RTL ? s.getWidth() - o : o, e.moveBy(o, t);
        }, B$ = function(e, t) {
          if (t.collapsed && e.setCollapsed(true), t.deletable === false && e.setDeletable(false), t.movable === false && e.setMovable(false), t.editable === false && e.setEditable(false), t.enabled === false && e.setDisabledReason(true, Ke), Array.isArray(t.disabledReasons)) for (let o of t.disabledReasons) e.setDisabledReason(true, o);
          t.inline !== void 0 && e.setInputsInline(t.inline), t.data !== void 0 && (e.data = t.data);
        }, x$ = function(e, t) {
          t.extraState && (e.loadExtraState ? e.loadExtraState(t.extraState) : e.domToMutation && e.domToMutation(r.textToDom$$module$build$src$core$utils$xml(t.extraState)));
        }, F$ = function(e, t, o) {
          if (e) {
            if (e.getSourceBlock().isShadow() && !t.isShadow()) throw new _m(o);
            if (e.type === r.inputTypes$$module$build$src$core$inputs$input_types.VALUE) {
              var s = t.outputConnection;
              if (!s) throw new Hi("output", t, o);
            } else if (s = t.previousConnection, !s) throw new Hi("previous", t, o);
            if (!e.connect(s)) {
              let i = t.workspace.connectionChecker;
              throw new mm(i.getErrorMessage(i.canConnectWithReason(s, e, false), s, e), e.type === r.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? "output connection" : "previous connection", t, o);
            }
          }
        }, H$ = function(e, t) {
          if (t.icons) {
            var o = Object.keys(t.icons);
            for (let i of o) {
              o = t.icons[i];
              var s = e.getIcon(i);
              if (!s) {
                if (s = Y(E.ICON, i, false), !s) throw new Tm(i, e, t);
                s = new s(e), e.addIcon(s);
              }
              cs(s) && s.loadState(o);
            }
          }
        }, U$ = function(e, t) {
          if (t.fields) {
            var o = Object.keys(t.fields);
            for (let s = 0; s < o.length; s++) {
              let i = o[s], n = t.fields[i], l = e.getField(i);
              l ? l.loadState(n) : console.warn(`Ignoring non-existant field ${i} in block ${e.type}`);
            }
          }
        }, G$ = function(e, t) {
          if (t.inputs) {
            var o = Object.keys(t.inputs);
            for (let s = 0; s < o.length; s++) {
              let i = o[s], n = e.getInput(i);
              if (!n || !n.connection) throw new Hi(i, e, t);
              Rc(n.connection, t.inputs[i]);
            }
          }
        }, V$ = function(e, t) {
          if (t.next) {
            if (!e.nextConnection) throw new Hi("next", e, t);
            Rc(e.nextConnection, t.next);
          }
        }, Rc = function(e, t) {
          t.shadow && e.setShadowState(t.shadow), t.block && kc(t.block, e.getSourceBlock().workspace, { parentConnection: e });
        }, W$ = function(e, t) {
          if (t) {
            e.setConnectionTracking(false), e.initSvg(), e.queueRender();
            for (let o of e.getIcons()) o.onLocationChange(e.getRelativeToSurfaceXY());
          } else e.initModel();
        }, qt = function(e) {
          return typeof e.bubbleIsVisible == "function" && typeof e.setBubbleVisible == "function" && typeof e.getBubble == "function";
        }, jr = function(e) {
          return e * Math.PI / 180;
        }, z$ = function(e) {
          return e * 180 / Math.PI;
        }, ds = function(e, t, o) {
          if (o < e) {
            let s = o;
            o = e, e = s;
          }
          return Math.max(e, Math.min(t, o));
        }, Jr = function() {
          document.querySelector(".blocklyDropDownDiv") || (oe = document.createElement("div"), oe.className = "blocklyDropDownDiv", oe.tabIndex = -1, (Qs() || document.body).appendChild(oe), Vi = document.createElement("div"), Vi.className = "blocklyDropDownContent", oe.appendChild(Vi), Fn = w(Vi, "keydown", null, ti), Go = document.createElement("div"), Go.className = "blocklyDropDownArrow", oe.appendChild(Go), oe.style.opacity = "0", oe.style.transition = "transform " + Bn + "s, opacity " + Bn + "s");
        }, Sc = function(e) {
          Ju = e;
        }, Oc = function() {
          return lo;
        }, qr = function() {
          return Vi;
        }, Zr = function() {
          Fn && (x(Fn), Fn = null), oe.remove(), Jr();
        }, wc = function(e, t) {
          oe.style.backgroundColor = e, oe.style.borderColor = t;
        }, X$ = function(e, t, o, s, i = true) {
          return Mc(Nc(t), e, i, o, s);
        }, Lc = function(e, t, o, s = true) {
          return ym = true, Mc(Ac(e), e, s, t, o);
        }, Nc = function(e) {
          var t = e.getSvgRoot();
          let o = e.workspace.scale, s = e.height * o;
          return e = e.width * o, t = Kt(t), new L(t.y, t.y + s, t.x, t.x + e);
        }, Ac = function(e) {
          return e = e.getScaledBBox(), new L(e.top, e.bottom, e.left, e.right);
        }, Mc = function(e, t, o, s, i) {
          let n = e.left + (e.right - e.left) / 2, l = e.bottom;
          e = e.top, i && (e += i), i = t.getSourceBlock();
          let a = i.workspace;
          for (; a.options.parentWorkspace; ) a = a.options.parentWorkspace;
          return Sc(a.getParentSvg().parentNode), Dc(t, i.RTL, n, l, n, e, o, s);
        }, Dc = function(e, t, o, s, i, n, l, a) {
          return lo = e, Uo = a || null, oe.style.direction = t ? "rtl" : "ltr", e = De(), fm = e.getRenderer().getClassName(), Im = e.getTheme().getClassName(), I(oe, fm), I(oe, Im), o = Fc(o, s, i, n), l && (xn = r.getFocusManager$$module$build$src$core$focus_manager().takeEphemeralFocus(oe)), o;
        }, Pc = function(e, t, o, s) {
          return e = ui(e, o.left, o.right, s.width), { initialX: e.divX, initialY: t, finalX: e.divX, finalY: t + Ku, arrowX: e.arrowX, arrowY: -(Gi / 2 + Yu), arrowAtTop: true, arrowVisible: true };
        }, Bc = function(e, t, o, s) {
          return e = ui(e, o.left, o.right, s.width), { initialX: e.divX, initialY: t - s.height, finalX: e.divX, finalY: t - s.height - Ku, arrowX: e.arrowX, arrowY: s.height - Yu * 2 - Gi / 2, arrowAtTop: false, arrowVisible: true };
        }, Y$ = function(e, t, o) {
          return e = ui(e, t.left, t.right, o.width), { initialX: e.divX, initialY: 0, finalX: e.divX, finalY: 0, arrowAtTop: null, arrowX: null, arrowY: null, arrowVisible: false };
        }, ui = function(e, t, o, s) {
          return t = ds(t, e - s / 2, o - s), e = e - Gi / 2 - t, o = bm, e = ds(o, e, s - o - Gi), { arrowX: e, divX: t };
        }, xc = function() {
          return !!lo;
        }, Qr = function(e, t) {
          return lo === e ? (t ? Tt() : en(), true) : false;
        }, en = function() {
          oe.style.transform = "translate(0, 0)", oe.style.opacity = "0", ju = setTimeout(function() {
            Tt();
          }, Bn * 1e3), Uo && (Uo(), Uo = null);
        }, Tt = function() {
          xc() && (ju && clearTimeout(ju), Uo && (Uo(), Uo = null), Zr(), lo = null, De().markFocused(), xn && (xn(), xn = null));
        }, Fc = function(e, t, o, s) {
          e = Hn.getPositionMetrics(e, t, o, s), e.arrowVisible ? (t = e.arrowX, o = e.arrowY, s = e.arrowAtTop ? 45 : 225, Go.style.display = "", Go.style.transform = `translate(${t}px, ${o}px) rotate(${s}deg)`, Go.setAttribute("class", "blocklyDropDownArrow")) : Go.style.display = "none", t = Math.floor(e.initialX), o = Math.floor(e.initialY), s = Math.floor(e.finalX);
          let i = Math.floor(e.finalY);
          return oe.style.left = t + "px", oe.style.top = o + "px", oe.style.display = "block", oe.style.opacity = "1", oe.style.transform = "translate(" + (s - t) + "px," + (i - o) + "px)", !!e.arrowAtTop;
        }, Hc = function() {
          if (lo) {
            var e = lo.getSourceBlock();
            e = ym ? Ac(lo) : Nc(e);
            let t = e.left + (e.right - e.left) / 2;
            Fc(t, e.bottom, t, e.top);
          } else en();
        }, hi = function(e) {
          return e.length ? e.reduce(function(t, o) {
            return t.length < o.length ? t : o;
          }).length : 0;
        }, Uc = function(e, t) {
          if (!e.length) return 0;
          if (e.length === 1) return e[0].length;
          let o = 0;
          t = t || hi(e);
          let s;
          for (s = 0; s < t; s++) {
            for (var i = e[0][s], n = 1; n < e.length; n++) if (i !== e[n][s]) return o;
            i === " " && (o = s + 1);
          }
          for (i = 1; i < e.length; i++) if ((n = e[i][s]) && n !== " ") return o;
          return t;
        }, Gc = function(e, t) {
          if (!e.length) return 0;
          if (e.length === 1) return e[0].length;
          let o = 0;
          t = t || hi(e);
          let s;
          for (s = 0; s < t; s++) {
            for (var i = e[0].substr(-s - 1, 1), n = 1; n < e.length; n++) if (i !== e[n].substr(-s - 1, 1)) return o;
            i === " " && (o = s + 1);
          }
          for (i = 1; i < e.length; i++) if ((n = e[i].charAt(e[i].length - s - 1)) && n !== " ") return o;
          return t;
        }, r.wrap$$module$build$src$core$utils$string = function(e, t) {
          e = e.split(`
`);
          for (let o = 0; o < e.length; o++) e[o] = K$(e[o], t);
          return e.join(`
`);
        }, K$ = function(e, t) {
          if (e.length <= t) return e;
          let o = e.trim().split(/\s+/);
          for (var s = 0; s < o.length; s++) o[s].length > t && (t = o[s].length);
          var i = -1 / 0;
          let n, l = 1;
          do {
            s = i, n = e, e = [], i = o.length / l;
            let a = 1;
            for (let _ = 0; _ < o.length - 1; _++) a < (_ + 1.5) / i ? (a++, e[_] = true) : e[_] = false;
            e = Vc(o, e, t), i = tn(o, e, t), e = j$(o, e), l++;
          } while (i > s);
          return n;
        }, tn = function(e, t, o) {
          let s = [0], i = [];
          for (var n = 0; n < e.length; n++) s[s.length - 1] += e[n].length, t[n] === true ? (s.push(0), i.push(e[n].charAt(e[n].length - 1))) : t[n] === false && s[s.length - 1]++;
          for (e = Math.max(...s), t = 0, n = 0; n < s.length; n++) t -= Math.pow(Math.abs(o - s[n]), 1.5) * 2, t -= Math.pow(e - s[n], 1.5), ".?!".includes(i[n]) ? t += o / 3 : ",;)]}".includes(i[n]) && (t += o / 4);
          return s.length > 1 && s[s.length - 1] <= s[s.length - 2] && (t += 0.5), t;
        }, Vc = function(e, t, o) {
          let s = tn(e, t, o), i;
          for (let n = 0; n < t.length - 1; n++) {
            if (t[n] === t[n + 1]) continue;
            let l = [].concat(t);
            l[n] = !l[n], l[n + 1] = !l[n + 1];
            let a = tn(e, l, o);
            a > s && (s = a, i = l);
          }
          return i ? Vc(e, i, o) : t;
        }, j$ = function(e, t) {
          let o = [];
          for (let s = 0; s < e.length; s++) o.push(e[s]), t[s] !== void 0 && o.push(t[s] ? `
` : " ");
          return o.join("");
        }, r.isNumber$$module$build$src$core$utils$string = function(e) {
          return /^\s*-?\d+(\.\d+)?\s*$/.test(e);
        }, J$ = function(e) {
          Un = e;
        }, q$ = function() {
          return Un;
        }, Z$ = function() {
          return Wi;
        }, Q$ = function() {
          return he;
        }, $s = function(e) {
          if (e = Wc(e)) {
            for (e = e.tooltip; typeof e == "function"; ) e = e();
            if (typeof e != "string") throw Error("Tooltip function must return a string.");
            return e;
          }
          return "";
        }, Wc = function(e) {
          for (; e && e.tooltip; ) {
            if (typeof e.tooltip == "string" || typeof e.tooltip == "function") return e;
            e = e.tooltip;
          }
          return null;
        }, zc = function() {
          document.querySelector(".blocklyTooltipDiv") || (he = document.createElement("div"), he.className = "blocklyTooltipDiv", (Qs() || document.body).appendChild(he));
        }, di = function(e) {
          e.mouseOverWrapper_ = ze(e, "pointerover", null, ep), e.mouseOutWrapper_ = ze(e, "pointerout", null, tp), e.addEventListener("pointermove", Yc, false);
        }, Xc = function(e) {
          e && (x(e.mouseOverWrapper_), x(e.mouseOutWrapper_), e.removeEventListener("pointermove", Yc));
        }, ep = function(e) {
          Ss || (e = Wc(e.currentTarget), je !== e && (Lt(), zi = null, je = e), clearTimeout(vm));
        }, tp = function(e) {
          Ss || (vm = setTimeout(function() {
            zi = je = null, Lt();
          }, 1), clearTimeout(Vo), Vo = 0);
        }, Yc = function(e) {
          if (je && je.tooltip && !Ss) if (Wi) {
            let t = qu - e.pageX;
            e = Zu - e.pageY, Math.sqrt(t * t + e * e) > km && Lt();
          } else zi !== je && (clearTimeout(Vo), qu = e.pageX, Zu = e.pageY, Vo = setTimeout(rp, Rm));
        }, Kc = function() {
          zi = je = null, Lt();
        }, Lt = function() {
          Wi && (Wi = false, he && (he.style.display = "none")), Vo && (clearTimeout(Vo), Vo = 0);
        }, jc = function() {
          Lt(), Ss = true;
        }, Jc = function() {
          Ss = false;
        }, op = function() {
          he && je && (typeof Un == "function" ? Un(he, je) : sp());
        }, sp = function() {
          var e = $s(je);
          e = r.wrap$$module$build$src$core$utils$string(e, Cm), e = e.split(`
`);
          for (let t = 0; t < e.length; t++) {
            let o = document.createElement("div");
            o.appendChild(document.createTextNode(e[t])), he.appendChild(o);
          }
        }, ip = function(e) {
          let t = document.documentElement.clientWidth, o = document.documentElement.clientHeight, s = qu;
          s = e ? s - (Qu + he.offsetWidth) : s + Qu;
          let i = Zu + eh;
          return i + he.offsetHeight > o + window.scrollY && (i -= he.offsetHeight + 2 * eh), e ? s = Math.max(Gn - window.scrollX, s) : s + he.offsetWidth > t + window.scrollX - 2 * Gn && (s = t - he.offsetWidth - 2 * Gn), { x: s, y: i };
        }, rp = function() {
          if (!Ss && (zi = je, he)) {
            he.textContent = "", op();
            var e = je.RTL;
            he.style.direction = e ? "rtl" : "ltr", he.style.display = "block", Wi = true;
            var { x: t, y: o } = ip(e);
            he.style.left = t + "px", he.style.top = o + "px";
          }
        }, qc = function() {
          return th;
        }, np = function(e) {
          th = e;
        }, Zc = function() {
          return oh;
        }, lp = function(e) {
          oh = e;
        }, Ro = function(e) {
          e = `${e}`.toLowerCase().trim();
          var t = Sm[e];
          if (t || (t = e.substring(0, 2) === "0x" ? "#" + e.substring(2) : e, t = t[0] === "#" ? t : "#" + t, /^#[0-9a-f]{6}$/.test(t))) return t;
          if (/^#[0-9a-f]{3}$/.test(t)) return ["#", t[1], t[1], t[2], t[2], t[3], t[3]].join("");
          var o = e.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
          return o && (e = Number(o[1]), t = Number(o[2]), o = Number(o[3]), e >= 0 && e < 256 && t >= 0 && t < 256 && o >= 0 && o < 256) ? $i(e, t, o) : null;
        }, $i = function(e, t, o) {
          return t = e << 16 | t << 8 | o, e < 16 ? "#" + (16777216 | t).toString(16).substr(1) : "#" + t.toString(16);
        }, on = function(e) {
          return e = Ro(e), e ? (e = parseInt(e.substr(1), 16), [e >> 16, e >> 8 & 255, e & 255]) : [0, 0, 0];
        }, sn = function(e, t, o) {
          let s = 0, i = 0, n = 0;
          if (t === 0) n = i = s = o;
          else {
            let l = Math.floor(e / 60), a = e / 60 - l;
            e = o * (1 - t);
            let _ = o * (1 - t * a);
            switch (t = o * (1 - t * (1 - a)), l) {
              case 1:
                s = _, i = o, n = e;
                break;
              case 2:
                s = e, i = o, n = t;
                break;
              case 3:
                s = e, i = _, n = o;
                break;
              case 4:
                s = t, i = e, n = o;
                break;
              case 5:
                s = o, i = e, n = _;
                break;
              case 6:
              case 0:
                s = o, i = t, n = e;
            }
          }
          return $i(Math.floor(s), Math.floor(i), Math.floor(n));
        }, So = function(e, t, o) {
          return e = Ro(e), !e || (t = Ro(t), !t) ? null : (e = on(e), t = on(t), $i(Math.round(t[0] + o * (e[0] - t[0])), Math.round(t[1] + o * (e[1] - t[1])), Math.round(t[2] + o * (e[2] - t[2]))));
        }, Qc = function(e) {
          return sn(e, th, oh * 255);
        }, rn = function(e, t, o) {
          let s = [];
          var i = e.split("");
          i.push("");
          var n = 0;
          e = [];
          let l = null;
          for (let v = 0; v < i.length; v++) {
            var a = i[v];
            if (n === 0) if (a === "%") (n = e.join("")) && s.push(n), e.length = 0, n = 1;
            else if (o && a === `
`) {
              let Q = e.join("");
              Q && s.push(Q), e.length = 0, s.push(a);
            } else e.push(a);
            else if (n === 1) a === "%" ? (e.push(a), n = 0) : t && "0" <= a && a <= "9" ? (n = 2, l = a, (a = e.join("")) && s.push(a), e.length = 0) : a === "{" ? n = 3 : (e.push("%", a), n = 0);
            else if (n === 2) if ("0" <= a && a <= "9") l += a;
            else {
              var _ = void 0;
              s.push(parseInt((_ = l) != null ? _ : "", 10)), v--, n = 0;
            }
            else n === 3 && (a === "" ? (e.splice(0, 0, "%{"), v--, n = 0) : a !== "}" ? e.push(a) : (n = e.join(""), /[A-Z]\w*/i.test(n) ? (a = n.toUpperCase(), (a = a.startsWith("BKY_") ? a.substring(4) : null) && a in r.Msg$$module$build$src$core$msg ? (n = r.Msg$$module$build$src$core$msg[a], typeof n == "string" ? Array.prototype.push.apply(s, rn(n, t, o)) : t ? s.push(`${n}`) : s.push(n)) : s.push("%{" + n + "}")) : s.push("%{" + n + "}"), n = e.length = 0));
          }
          for ((t = e.join("")) && s.push(t), _ = [], e.length = 0, i = 0; i < s.length; i++) typeof s[i] != "string" || o && s[i] === `
` ? ((t = e.join("")) && _.push(t), e.length = 0, _.push(s[i])) : e.push(s[i]);
          return (t = e.join("")) && _.push(t), e.length = 0, _;
        }, ea = function(e) {
          return rn(e, true, true);
        }, ie = function(e) {
          return typeof e != "string" ? e : (e = rn(e, false, false), e.length ? String(e[0]) : "");
        }, cp = function(e) {
          let t = true, o = r.Msg$$module$build$src$core$msg, s = e.match(/%{BKY_[A-Z]\w*}/gi);
          if (s) for (let i = 0; i < s.length; i++) {
            let n = s[i].toUpperCase();
            o[n.slice(6, -1)] === void 0 && (console.warn("No message string for " + s[i] + " in " + e), t = false);
          }
          return t;
        }, ps = function(e) {
          let t = typeof e == "string" ? ie(e) : e;
          var o = Number(t);
          if (!isNaN(o) && 0 <= o && o <= 360) return { hue: o, hex: sn(o, qc(), Zc() * 255) };
          if (o = Ro(t)) return { hue: null, hex: o };
          throw o = 'Invalid colour: "' + t + '"', e !== t && (o += ' (from "' + e + '")'), Error(o);
        }, gs = function() {
          return Ve;
        }, ap = function(e) {
          if (Ve = e, e === null) {
            let t;
            (t = document.querySelector("." + sh)) == null || t.remove();
          }
        }, ta = function() {
          let e = Qs() || document.body, t = document.querySelector("div." + sh);
          t ? Ve = t : (Ve = document.createElement("div"), Ve.className = sh, Ve.tabIndex = -1), w(Ve, "keydown", null, ti), e.appendChild(Ve);
        }, nn = function(e, t, o, s, i = true) {
          if (ms(), Os = e, Vn = o, o = Ve) {
            if (o.style.direction = t ? "rtl" : "ltr", o.style.display = "block", !s && e instanceof F) {
              let a;
              s = (a = e.getSourceBlock()) == null ? void 0 : a.workspace;
            }
            var n;
            wm = (n = s) != null ? n : null;
            var l;
            e = (l = s) != null ? l : De(), ws = e.getRenderer().getClassName(), Ls = e.getTheme().getClassName(), ws && I(o, ws), Ls && I(o, Ls), i && (Wn = r.getFocusManager$$module$build$src$core$focus_manager().takeEphemeralFocus(o));
          }
        }, ms = function() {
          if (oa()) {
            Os = null;
            var e = Ve;
            e && (e.style.display = "none", e.style.left = "", e.style.top = "", Vn && (Vn(), Vn = null), e.textContent = "", ws && (P(e, ws), ws = ""), Ls && (P(e, Ls), Ls = ""), De().markFocused(), Wn && (Wn(), Wn = null));
          }
        }, oa = function() {
          return !!Os;
        }, Oo = function(e) {
          Os === e && ms();
        }, pi = function(e) {
          let t = wm === null, o = e;
          for (; !t && o; ) {
            if (o === e) {
              t = true;
              break;
            }
            o = e.options.parentWorkspace;
          }
          t && ms();
        }, sa = function(e, t, o) {
          Ve.style.left = e + "px", Ve.style.top = t + "px", Ve.style.height = o + "px";
        }, ia = function(e, t, o, s) {
          let i = hp(e, t, o);
          e = up(e, t, o, s), i < 0 ? sa(e, 0, o.height + i) : sa(e, i, o.height);
        }, up = function(e, t, o, s) {
          return s ? Math.min(Math.max(t.right - o.width, e.left), e.right - o.width) : Math.max(Math.min(t.left, e.right - o.width), e.left);
        }, hp = function(e, t, o) {
          return t.bottom + o.height >= e.bottom ? t.top - o.height : t.bottom;
        }, dp = function(e) {
          return !(e == null || !e.repositionForWindowResize);
        }, ra = function() {
          dp(Os) && Os.repositionForWindowResize() || ms();
        }, $p = function() {
          return zn;
        }, na = function(e) {
          zn = e;
        }, _s = function(e, t, o, s, i) {
          if (nn(Lm, o, la, s), t.length) {
            i || (e instanceof PointerEvent ? i = new f(e.clientX, e.clientY) : (console.warn("Context menu opened with keyboard but no location given"), i = new f(0, 0)));
            var n = pp(t, o, e, i);
            Xn = n, gp(n, o, i), setTimeout(function() {
              n.focus();
            }, 1), zn = null;
          } else gi();
        }, pp = function(e, t, o, s) {
          let i = new Nn();
          i.setRole(Ue.MENU);
          for (let n = 0; n < e.length; n++) {
            let l = e[n];
            if (l.separator) {
              i.addChild(new Uu());
              continue;
            }
            let a = new Bi(l.text);
            a.setRightToLeft(t), a.setRole(Ue.MENUITEM), i.addChild(a), a.setEnabled(l.enabled), l.enabled && a.onAction(function(_, v) {
              gi(), requestAnimationFrame(() => {
                setTimeout(() => {
                  l.callback(l.scope, o, v, s);
                }, 0);
              });
            }, {});
          }
          return i;
        }, gp = function(e, t, o) {
          let s = hc();
          o = new L(o.y + s.top, o.y + s.top, o.x + s.left, o.x + s.left), mp(e);
          let i = e.getSize();
          t && (o.left += i.width, o.right += i.width, s.left += i.width, s.right += i.width), ia(s, o, i, t), e.focus();
        }, mp = function(e) {
          var t = gs();
          if (!t) throw Error("Attempting to create a context menu when widget div is null");
          t = e.render(t), I(t, "blocklyContextMenu"), w(t, "contextmenu", null, _p), e.focus();
        }, _p = function(e) {
          e.preventDefault(), e.stopPropagation();
        }, gi = function() {
          Oo(Lm), zn = null;
        }, la = function() {
          Xn && (Xn.dispose(), Xn = null);
        }, r.callbackFactory$$module$build$src$core$contextmenu = function(e, t) {
          return () => {
            r.disable$$module$build$src$core$events$utils();
            let o;
            try {
              o = t instanceof Element ? wo(t, e.workspace) : hs(t, e.workspace);
              let s = e.getRelativeToSurfaceXY();
              s.x = e.RTL ? s.x - r.config$$module$build$src$core$config.snapRadius : s.x + r.config$$module$build$src$core$config.snapRadius, s.y += r.config$$module$build$src$core$config.snapRadius * 2, o.moveBy(s.x, s.y);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
            return J() && !o.isShadow() && R(new (S(d.BLOCK_CREATE))(o)), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(o), o;
          };
        }, ca = function(e, t) {
          return t = ts(t, e.getParentSvg(), e.getInverseScreenCTM()), t.x /= e.scale, t.y /= e.scale, t;
        }, mi = function(e, t, o) {
          t = ca(e, t), Am.set(e, f.difference(o, t));
        }, _i = function(e, t) {
          if (t = ca(e, t), e = Am.get(e), !e) throw Error("Drag not initialized");
          return f.sum(e, t);
        }, Tp = function(e, t = false) {
          let o = r.createElement$$module$build$src$core$utils$xml("xml");
          var s = aa(r.allUsedVarModels$$module$build$src$core$variables(e));
          s.hasChildNodes() && o.appendChild(s);
          for (let i of e.getTopComments()) o.appendChild(Ti(i, t));
          for (e = e.getTopBlocks(true), s = 0; s < e.length; s++) o.appendChild(Ei(e[s], t));
          return o;
        }, Ti = function(e, t = false) {
          let o = r.createElement$$module$build$src$core$utils$xml("comment");
          t || o.setAttribute("id", e.id), t = e.workspace;
          let s = e.getRelativeToSurfaceXY().clone();
          return s.x = t.RTL ? t.getWidth() - s.x : s.x, o.setAttribute("x", `${s.x}`), o.setAttribute("y", `${s.y}`), o.setAttribute("w", `${e.getSize().width}`), o.setAttribute("h", `${e.getSize().height}`), e.getText() && (o.textContent = e.getText()), e.isCollapsed() && o.setAttribute("collapsed", "true"), e.isOwnEditable() || o.setAttribute("editable", "false"), e.isOwnMovable() || o.setAttribute("movable", "false"), e.isOwnDeletable() || o.setAttribute("deletable", "false"), o;
        }, aa = function(e) {
          let t = r.createElement$$module$build$src$core$utils$xml("variables");
          for (let o = 0; o < e.length; o++) {
            let s = e[o], i = r.createElement$$module$build$src$core$utils$xml("variable");
            i.appendChild(r.createTextNode$$module$build$src$core$utils$xml(s.getName())), s.getType() && i.setAttribute("type", s.getType()), i.id = s.getId(), t.appendChild(i);
          }
          return t;
        }, Ei = function(e, t) {
          if (e.isInsertionMarker() && (e = e.getChildren(false)[0], !e)) return new DocumentFragment();
          let o = 0;
          if (e.workspace.RTL && (o = e.workspace.getWidth()), t = Zt(e, t), pa(t)) {
            let s = e.getRelativeToSurfaceXY();
            t.setAttribute("x", String(Math.round(e.workspace.RTL ? o - s.x : s.x))), t.setAttribute("y", String(Math.round(s.y)));
          }
          return t;
        }, Ep = function(e) {
          if (e.isSerializable()) {
            let t = r.createElement$$module$build$src$core$utils$xml("field");
            return t.setAttribute("name", e.name || ""), e.toXml(t);
          }
          return null;
        }, bp = function(e, t) {
          for (let o of e.getFields()) (e = Ep(o)) && t.appendChild(e);
        }, Zt = function(e, t) {
          if (e.isInsertionMarker()) return (t = e.getChildren(false)[0]) ? Zt(t) : new DocumentFragment();
          let o = r.createElement$$module$build$src$core$utils$xml(e.isShadow() ? "shadow" : "block");
          if (o.setAttribute("type", e.type), t || (o.id = e.id), e.mutationToDom) {
            var s = e.mutationToDom();
            s && (s.hasChildNodes() || s.hasAttributes()) && o.appendChild(s);
          }
          if (bp(e, o), s = e.getCommentText()) {
            var i = e.getIcon(ue.COMMENT), n = i.getBubbleSize(), l = i.bubbleIsVisible();
            i = i.getBubbleLocation();
            var a = r.createElement$$module$build$src$core$utils$xml("comment");
            a.appendChild(r.createTextNode$$module$build$src$core$utils$xml(s)), a.setAttribute("pinned", `${l}`), a.setAttribute("h", `${n.height}`), a.setAttribute("w", `${n.width}`), i && (a.setAttribute("x", `${e.workspace.RTL ? e.workspace.getWidth() - (i.x + n.width) : i.x}`), a.setAttribute("y", `${i.y}`)), o.appendChild(a);
          }
          for (e.data && (s = r.createElement$$module$build$src$core$utils$xml("data"), s.appendChild(r.createTextNode$$module$build$src$core$utils$xml(e.data)), o.appendChild(s)), s = 0; s < e.inputList.length; s++) {
            n = e.inputList[s];
            var _ = void 0;
            l = true, n.type !== r.inputTypes$$module$build$src$core$inputs$input_types.DUMMY && n.type !== r.inputTypes$$module$build$src$core$inputs$input_types.END_ROW && (i = n.connection.targetBlock(), n.type === r.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? _ = r.createElement$$module$build$src$core$utils$xml("value") : n.type === r.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT && (_ = r.createElement$$module$build$src$core$utils$xml("statement")), a = n.connection.getShadowDom(), !a || i && i.isShadow() || _.appendChild(ua(a, t)), i && (i = Zt(i, t), i.nodeType === Pt.ELEMENT_NODE && (_.appendChild(i), l = false)), _.setAttribute("name", n.name), l || o.appendChild(_));
          }
          e.inputsInline !== void 0 && e.inputsInline !== e.inputsInlineDefault && o.setAttribute("inline", String(e.inputsInline)), e.isCollapsed() && o.setAttribute("collapsed", "true"), e.isEnabled() || o.setAttribute("disabled-reasons", Array.from(e.getDisabledReasons()).map(encodeURIComponent).join(",")), e.isOwnDeletable() || o.setAttribute("deletable", "false"), e.isOwnMovable() || o.setAttribute("movable", "false"), e.isOwnEditable() || o.setAttribute("editable", "false"), _ = e.getNextBlock();
          let v;
          return _ && (s = Zt(_, t), s.nodeType === Pt.ELEMENT_NODE && (v = r.createElement$$module$build$src$core$utils$xml("next"), v.appendChild(s), o.appendChild(v))), e = e.nextConnection && e.nextConnection.getShadowDom(), !e || _ && _.isShadow() || v.appendChild(ua(e, t)), o;
        }, ua = function(e, t) {
          let o = e = e.cloneNode(true), s;
          for (; o; ) if (t && o.nodeName === "shadow" && o.removeAttribute("id"), o.firstChild) o = o.firstChild;
          else {
            for (; o && !o.nextSibling; ) {
              s = o, o = o.parentNode;
              let i;
              s.nodeType === Pt.TEXT_NODE && s.data.trim() === "" && ((i = o) == null ? void 0 : i.firstChild) !== s && V(s);
            }
            o && (s = o, o = o.nextSibling, s.nodeType === Pt.TEXT_NODE && s.data.trim() === "" && V(s));
          }
          return e;
        }, Et = function(e) {
          return ls(e).replace(/<(\w+)([^<]*)\/>/g, "<$1$2></$1>");
        }, fp = function(e) {
          e = Et(e).split("<");
          let t = "";
          for (let o = 1; o < e.length; o++) {
            let s = e[o];
            s[0] === "/" && (t = t.substring(2)), e[o] = t + "<" + s, s[0] !== "/" && s.slice(-2) !== "/>" && (t += "  ");
          }
          return e = e.join(`
`), e = e.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>"), e.replace(/^\n/, "");
        }, Ip = function(e, t) {
          return t.setResizesEnabled(false), t.clear(), e = r.domToWorkspace$$module$build$src$core$xml(e, t), t.setResizesEnabled(true), e;
        }, r.domToWorkspace$$module$build$src$core$xml = function(e, t) {
          let o = 0;
          t.RTL && (o = t.getWidth());
          let s = [];
          fo();
          let i = r.getGroup$$module$build$src$core$events$utils();
          i || r.setGroup$$module$build$src$core$events$utils(true), t.setResizesEnabled && t.setResizesEnabled(false);
          let n = true;
          try {
            for (let l = 0, a; a = e.childNodes[l]; l++) {
              let _ = a.nodeName.toLowerCase(), v = a;
              if (_ === "block" || _ === "shadow" && !we()) {
                let Q = wo(v, t);
                s.push(Q.id);
                let X, ye = parseInt((X = v.getAttribute("x")) != null ? X : "10", 10), Gt, Ot = parseInt((Gt = v.getAttribute("y")) != null ? Gt : "10", 10);
                isNaN(ye) || isNaN(Ot) || Q.moveBy(t.RTL ? o - ye : ye, Ot, ["create"]), n = false;
              } else {
                if (_ === "shadow") throw TypeError("Shadow block cannot be a top-level block.");
                if (_ === "comment") ha(v, t);
                else if (_ === "variables") {
                  if (n) da(v, t);
                  else throw Error("'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.");
                  n = false;
                }
              }
            }
          } finally {
            r.setGroup$$module$build$src$core$events$utils(i), t.setResizesEnabled && t.setResizesEnabled(true), t.rendered && jt(), Io();
          }
          return R(new (S(d.FINISHED_LOADING))(t)), s;
        }, ha = function(e, t) {
          var o;
          let s = (o = e.getAttribute("id")) != null ? o : void 0;
          o = t.rendered ? new It(t, s) : new ji(t, s);
          var i;
          o.setText((i = e.textContent) != null ? i : "");
          var n;
          i = parseInt((n = e.getAttribute("x")) != null ? n : "", 10);
          let l;
          n = parseInt((l = e.getAttribute("y")) != null ? l : "", 10), isNaN(i) || isNaN(n) || (i = t.RTL ? t.getWidth() - i : i, o.moveTo(new f(i, n)));
          var a;
          t = parseInt((a = e.getAttribute("w")) != null ? a : "", 10);
          let _;
          return a = parseInt((_ = e.getAttribute("h")) != null ? _ : "", 10), isNaN(t) || isNaN(a) || o.setSize(new N(t, a)), e.getAttribute("collapsed") === "true" && o.setCollapsed(true), e.getAttribute("editable") === "false" && o.setEditable(false), e.getAttribute("movable") === "false" && o.setMovable(false), e.getAttribute("deletable") === "false" && o.setDeletable(false), o;
        }, yp = function(e, t) {
          if (!t.getBlocksBoundingBox) return r.domToWorkspace$$module$build$src$core$xml(e, t);
          var o = t.getBlocksBoundingBox();
          if (e = r.domToWorkspace$$module$build$src$core$xml(e, t), o && o.top !== o.bottom) {
            var s = o.bottom;
            o = t.RTL ? o.right : o.left;
            var i = 1 / 0;
            let n = -1 / 0, l = 1 / 0;
            for (let a = 0; a < e.length; a++) {
              let _ = t.getBlockById(e[a]).getRelativeToSurfaceXY();
              _.y < l && (l = _.y), _.x < i && (i = _.x), _.x > n && (n = _.x);
            }
            for (s = s - l + 10, o = t.RTL ? o - n : o - i, i = 0; i < e.length; i++) t.getBlockById(e[i]).moveBy(o, s, ["create"]);
          }
          return e;
        }, r.domToBlock$$module$build$src$core$xml = function(e, t) {
          return e = wo(e, t), t.rendered && jt(), e;
        }, wo = function(e, t) {
          r.disable$$module$build$src$core$events$utils();
          var o = t.getAllVariables();
          let s;
          try {
            if (s = ln(e, t), t.rendered) {
              let i = s, n = s.getDescendants(false);
              i.setConnectionTracking(false);
              for (let l = n.length - 1; l >= 0; l--) n[l].initSvg();
              for (let l = n.length - 1; l >= 0; l--) n[l].queueRender();
              setTimeout(function() {
                i.disposed || i.setConnectionTracking(true);
              }, 1), t.resizeContents();
            } else {
              let i = s.getDescendants(false);
              for (let n = i.length - 1; n >= 0; n--) i[n].initModel();
            }
          } finally {
            r.enable$$module$build$src$core$events$utils();
          }
          if (J()) {
            for (e = ai(t, o), t = 0; t < e.length; t++) o = e[t], R(new (S(d.VAR_CREATE))(o));
            R(new (S(d.BLOCK_CREATE))(s));
          }
          return s;
        }, da = function(e, t) {
          for (let s = 0; s < e.children.length; s++) {
            var o = e.children[s];
            let i = o.getAttribute("type"), n = o.getAttribute("id");
            if (o = o.textContent, !o) break;
            let l;
            t.getVariableMap().createVariable(o, (l = i) != null ? l : void 0, n);
          }
        }, Cp = function(e) {
          let t = { mutation: [], comment: [], data: [], field: [], input: [], next: [] };
          for (let o = 0; o < e.children.length; o++) {
            let s = e.children[o];
            if (s.nodeType !== Pt.TEXT_NODE) switch (s.nodeName.toLowerCase()) {
              case "mutation":
                t.mutation.push(s);
                break;
              case "comment":
                t.comment.push(s);
                break;
              case "data":
                t.data.push(s);
                break;
              case "title":
              case "field":
                t.field.push(s);
                break;
              case "value":
              case "statement":
                t.input.push(s);
                break;
              case "next":
                t.next.push(s);
                break;
              default:
                console.warn("Ignoring unknown tag: " + s.nodeName);
            }
          }
          return t;
        }, vp = function(e, t) {
          let o = false;
          for (let s = 0; s < e.length; s++) {
            let i = e[s];
            t.domToMutation && (t.domToMutation(i), t.initSvg && (o = true));
          }
          return o;
        }, kp = function(e, t) {
          for (let o = 0; o < e.length; o++) {
            let s = e[o], i = s.textContent, n = s.getAttribute("pinned") === "true", l, a = parseInt((l = s.getAttribute("w")) != null ? l : "50", 10), _, v = parseInt((_ = s.getAttribute("h")) != null ? _ : "50", 10), Q, X = parseInt((Q = s.getAttribute("x")) != null ? Q : "", 10), ye, Gt = parseInt((ye = s.getAttribute("y")) != null ? ye : "", 10);
            t.setCommentText(i);
            let Ot = t.getIcon(ue.COMMENT);
            isNaN(a) || isNaN(v) || Ot.setBubbleSize(new N(a, v)), Ot.setBubbleVisible(n), setTimeout(() => {
              isNaN(X) || isNaN(Gt) || (X = t.workspace.RTL ? t.workspace.getWidth() - (X + a) : X, Ot.setBubbleLocation(new f(X, Gt))), Ot.setBubbleVisible(n);
            }, 1);
          }
        }, Rp = function(e, t) {
          for (let o = 0; o < e.length; o++) t.data = e[o].textContent;
        }, Sp = function(e, t) {
          for (let o = 0; o < e.length; o++) {
            let s = e[o], i = s.getAttribute("name");
            i ? Lp(t, i, s) : console.warn(`Ignoring unnamed field in block ${t.type}`);
          }
        }, $a = function(e) {
          let t = null, o = null;
          for (let s = 0; s < e.childNodes.length; s++) {
            let i = e.childNodes[s];
            pa(i) && (i.nodeName.toLowerCase() === "block" ? t = i : i.nodeName.toLowerCase() === "shadow" && (o = i));
          }
          return { childBlockElement: t, childShadowElement: o };
        }, Op = function(e, t, o, s) {
          for (let n = 0; n < e.length; n++) {
            var i = e[n];
            let l = i.getAttribute("name"), a = l ? o.getInput(l) : null;
            if (!a) {
              console.warn("Ignoring non-existent input " + l + " in block " + s);
              break;
            }
            if (i = $a(i), i.childBlockElement) {
              if (!a.connection) throw TypeError("Input connection does not exist.");
              ln(i.childBlockElement, t, a.connection, false);
            }
            if (i.childShadowElement) {
              let _;
              (_ = a.connection) == null || _.setShadowDom(i.childShadowElement);
            }
          }
        }, wp = function(e, t, o) {
          for (let s = 0; s < e.length; s++) {
            let i = $a(e[s]);
            if (i.childBlockElement) {
              if (!o.nextConnection) throw TypeError("Next statement does not exist.");
              if (o.nextConnection.isConnected()) throw TypeError("Next statement is already connected.");
              ln(i.childBlockElement, t, o.nextConnection, true);
            }
            i.childShadowElement && o.nextConnection && o.nextConnection.setShadowDom(i.childShadowElement);
          }
        }, ln = function(e, t, o, s) {
          var i;
          let n = e.getAttribute("type");
          if (!n) throw TypeError("Block type unspecified: " + e.outerHTML);
          var l = (i = e.getAttribute("id")) != null ? i : void 0;
          i = t.newBlock(n, l), l = Cp(e);
          let a = vp(l.mutation, i);
          if (kp(l.comment, i), Rp(l.data, i), o) if (s) if (i.previousConnection) o.connect(i.previousConnection);
          else throw TypeError("Next block does not have previous statement.");
          else if (i.outputConnection) o.connect(i.outputConnection);
          else if (i.previousConnection) o.connect(i.previousConnection);
          else throw TypeError("Child block does not have output or previous statement.");
          if (Sp(l.field, i), Op(l.input, t, i, n), wp(l.next, t, i), a && i.initSvg(), (t = e.getAttribute("inline")) && i.setInputsInline(t === "true"), (t = e.getAttribute("disabled")) && i.setDisabledReason(t === "true" || t === "disabled", Ke), t = e.getAttribute("disabled-reasons"), t !== null) for (var _ of t.split(",")) i.setDisabledReason(true, decodeURIComponent(_));
          if ((_ = e.getAttribute("deletable")) && i.setDeletable(_ === "true"), (_ = e.getAttribute("movable")) && i.setMovable(_ === "true"), (_ = e.getAttribute("editable")) && i.setEditable(_ === "true"), (_ = e.getAttribute("collapsed")) && i.setCollapsed(_ === "true"), e.nodeName.toLowerCase() === "shadow") {
            for (e = i.getChildren(false), _ = 0; _ < e.length; _++) if (!e[_].isShadow()) throw TypeError("Shadow block not allowed non-shadow child.");
            i.setShadow(true);
          }
          return i;
        }, Lp = function(e, t, o) {
          let s = e.getField(t);
          s ? s.fromXml(o) : console.warn("Ignoring non-existent field " + t + " in block " + e.type);
        }, Np = function(e) {
          for (let t = 0; t < e.childNodes.length; t++) {
            let o = e.childNodes[t];
            if (o.nodeName.toLowerCase() === "next") {
              e.removeChild(o);
              break;
            }
          }
        }, pa = function(e) {
          return e.nodeType === Pt.ELEMENT_NODE;
        }, bt = function(e, t) {
          c(E.FIELD, e, t, true);
        }, Ap = function(e) {
          p(E.FIELD, e);
        }, r.fromJson$$module$build$src$core$field_registry = function(e) {
          return Dm.fromJsonInternal(e);
        }, Mp = function(e) {
          let t = ht(E.FIELD, e.type);
          return t ? t.fromJson(e) : (console.warn("Blockly could not create a field of type " + e.type + ". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached."), null);
        }, Ts = function(e) {
          return e && typeof e == "object" && "src" in e && typeof e.src == "string" && "alt" in e && typeof e.alt == "string" && "width" in e && typeof e.width == "number" && "height" in e && typeof e.height == "number";
        }, r.register$$module$build$src$core$extensions = function(e, t) {
          if (typeof e != "string" || e.trim() === "") throw Error('Error: Invalid extension name "' + e + '"');
          if (Ms[e]) throw Error('Error: Extension "' + e + '" is already registered.');
          if (typeof t != "function") throw Error('Error: Extension "' + e + '" must be a function');
          Ms[e] = t;
        }, r.registerMixin$$module$build$src$core$extensions = function(e, t) {
          if (!t || typeof t != "object") throw Error('Error: Mixin "' + e + '" must be a object');
          r.register$$module$build$src$core$extensions(e, function() {
            this.mixin(t);
          });
        }, r.registerMutator$$module$build$src$core$extensions = function(e, t, o, s) {
          let i = 'Error when registering mutator "' + e + '": ';
          _a(i, t);
          let n = ma(t, i);
          if (o && typeof o != "function") throw Error(i + 'Extension "' + e + '" is not a function');
          r.register$$module$build$src$core$extensions(e, function() {
            n && this.setMutator(new r.MutatorIcon$$module$build$src$core$icons$mutator_icon(s || [], this)), this.mixin(t), o && o.apply(this);
          });
        }, Dp = function(e) {
          ga(e) ? delete Ms[e] : console.warn('No extension mapping for name "' + e + '" found to unregister');
        }, ga = function(e) {
          return !!Ms[e];
        }, cn = function(e, t, o) {
          let s = Ms[e];
          if (typeof s != "function") throw Error('Error: Extension "' + e + '" not found.');
          let i;
          if (o ? Pp(e, t) : i = un(t), s.apply(t), o) _a('Error after applying mutator "' + e + '": ', t);
          else if (!Fp(i, t)) throw Error('Error when applying extension "' + e + '": mutation properties changed when applying a non-mutator extension.');
        }, Pp = function(e, t) {
          if (un(t).length) throw Error('Error: tried to apply mutation "' + e + '" to a block that already has mutator functions.  Block id: ' + t.id);
        }, Bp = function(e, t) {
          return an(e.mutationToDom, e.domToMutation, t + " mutationToDom/domToMutation");
        }, xp = function(e, t) {
          return an(e.saveExtraState, e.loadExtraState, t + " saveExtraState/loadExtraState");
        }, ma = function(e, t) {
          return an(e.compose, e.decompose, t + " compose/decompose");
        }, an = function(e, t, o) {
          if (e && t) {
            if (typeof e != "function" || typeof t != "function") throw Error(o + " must be a function");
            return true;
          }
          if (!e && !t) return false;
          throw Error(o + "Must have both or neither functions");
        }, _a = function(e, t) {
          let o = Bp(t, e), s = xp(t, e);
          if (!o && !s) throw Error(e + "Mutations must contain either XML hooks, or JSON hooks, or both");
          ma(t, e);
        }, un = function(e) {
          let t = [];
          return e.domToMutation !== void 0 && t.push(e.domToMutation), e.mutationToDom !== void 0 && t.push(e.mutationToDom), e.saveExtraState !== void 0 && t.push(e.saveExtraState), e.loadExtraState !== void 0 && t.push(e.loadExtraState), e.compose !== void 0 && t.push(e.compose), e.decompose !== void 0 && t.push(e.decompose), t;
        }, Fp = function(e, t) {
          if (t = un(t), t.length !== e.length) return false;
          for (let o = 0; o < t.length; o++) if (e[o] !== t[o]) return false;
          return true;
        }, Hp = function(e) {
          if (typeof document != "object") throw Error("runAfterPageLoad() requires browser document.");
          if (document.readyState === "complete") e();
          else {
            let t = setInterval(function() {
              document.readyState === "complete" && (clearInterval(t), e());
            }, 10);
          }
        }, r.buildTooltipForDropdown$$module$build$src$core$extensions = function(e, t) {
          let o = [];
          return function() {
            o.includes(this.type) || (Up(this, e, t), o.push(this.type)), this.setTooltip(function() {
              let s = String(this.getFieldValue(e));
              return ie(t[s]);
            }.bind(this));
          };
        }, Up = function(e, t, o) {
          var s = e.getField(t);
          if (s instanceof be && !s.isOptionListDynamic()) {
            s = s.getOptions();
            for (let i of s) i !== be.SEPARATOR && ([, s] = i, o[s] === void 0 && console.warn(`No tooltip mapping for value ${s} of field ${t} of block type ${e.type}.`));
          }
        }, r.buildTooltipWithFieldText$$module$build$src$core$extensions = function(e, t) {
          return function() {
            this.setTooltip(function() {
              let o = this.getField(t);
              return ie(e).replace("%1", o ? o.getText() : "");
            }.bind(this));
          };
        }, Gp = function() {
          let e = this.tooltip;
          this.setTooltip(function() {
            let t = this.getParent();
            return t && t.getInputsInline() && t.tooltip || e;
          }.bind(this));
        }, k = function(e, t) {
          return " " + e + "," + t + " ";
        }, Le = function(e, t) {
          return " " + e + t.join("");
        }, _e = function(e, t) {
          return " M " + e + "," + t + " ";
        }, ee = function(e, t) {
          return " m " + e + "," + t + " ";
        }, ft = function(e, t) {
          return " l " + e + "," + t + " ";
        }, Es = function(e) {
          return " l" + e.join("");
        }, O = function(e, t) {
          return " " + e + " " + t + " ";
        }, re = function(e, t, o, s) {
          return e + " " + o + " " + o + " " + t + s;
        }, Vp = function(e, t) {
          if (!e || !t) throw Error("Cannot connect null connections.");
          e.targetConnection = t, t.targetConnection = e;
        }, Wp = function(e, t) {
          let o = null;
          t = t.outputConnection;
          let s = t?.getConnectionChecker();
          for (let i = 0, n; n = e.inputList[i]; i++) {
            let l = n.connection, a;
            if (l && ((a = s) != null && a.canConnect(t, l, false))) {
              if (o) return null;
              o = l;
            }
          }
          return o;
        }, zp = function(e, t) {
          let o;
          for (; o = Wp(e, t); ) if (e = o.targetBlock(), !e || e.isShadow()) return o;
          return null;
        }, hn = function(e) {
          return Wt(e) && typeof e.getType == "function" && typeof e.initView == "function" && typeof e.dispose == "function" && typeof e.getWeight == "function" && typeof e.getSize == "function" && typeof e.applyColour == "function" && typeof e.hideForInsertionMarker == "function" && typeof e.updateEditable == "function" && typeof e.updateCollapsed == "function" && typeof e.isShownWhenCollapsed == "function" && typeof e.setOffsetInBlock == "function" && typeof e.onLocationChange == "function" && typeof e.onClick == "function";
        }, Ta = function(e) {
          return hn(e) && qt(e) && cs(e) && typeof e.setText == "function" && typeof e.getText == "function" && typeof e.setBubbleSize == "function" && typeof e.getBubbleSize == "function" && typeof e.setBubbleLocation == "function" && typeof e.getBubbleLocation == "function" && e.getType() === ue.COMMENT;
        }, dn = function(e) {
          if (!(e.getDescendants(false).length > 100)) {
            var t = e.workspace, o = e.getSvgRoot();
            t.getAudioManager().play("delete");
            var s = e.getRelativeToSurfaceXY(), i = o.cloneNode(true);
            i.setAttribute("transform", "translate(" + s.x + "," + s.y + ")");
            var n;
            (n = t.getLayerManager()) == null || n.appendToAnimationLayer({ getSvgRoot: () => i }), Ea(i, { x: s.x, y: s.y, width: e.width, height: e.height }, t.RTL, /* @__PURE__ */ new Date());
          }
        }, Ea = function(e, t, o, s) {
          let i = ((/* @__PURE__ */ new Date()).getTime() - s.getTime()) / 150;
          i > 1 ? V(e) : (e.setAttribute("transform", "translate(" + (t.x + (o ? -1 : 1) * t.width / 2 * i) + "," + (t.y + t.height / 2 * i) + ") scale(" + (1 - i) + ")"), setTimeout(Ea, 10, e, t, o, s));
        }, ba = function(e) {
          var t = e.workspace;
          let o = t.scale;
          if (t.getAudioManager().play("click"), !(o < 1)) {
            var s = t.getSvgXY(e.getSvgRoot());
            e.outputConnection ? (s.x += (e.RTL ? 3 : -3) * o, s.y += 13 * o) : e.previousConnection && (s.x += (e.RTL ? -23 : 23) * o, s.y += 3 * o);
            var i = b($.CIRCLE, { cx: s.x, cy: s.y, r: 0, fill: "none", stroke: "#888", "stroke-width": 10 }, t.getParentSvg());
            e = b($.ANIMATE, { id: "animationCircle", begin: "indefinite", attributeName: "r", dur: "150ms", from: 0, to: 25 * o }, i), t = b($.ANIMATE, { id: "animationOpacity", begin: "indefinite", attributeName: "opacity", dur: "150ms", from: 1, to: 0 }, i), e.beginElement(), t.beginElement(), setTimeout(() => void V(i), 150);
          }
        }, fa = function(e) {
          if (bs(), e.workspace.getAudioManager().play("disconnect"), !(e.workspace.scale < 1)) {
            var t = e.getHeightWidth().height;
            t = Math.atan(10 / t) / Math.PI * 180, e.RTL || (t *= -1), er = e, Ia(e, t, /* @__PURE__ */ new Date(), 0);
          }
        }, Ia = function(e, t, o, s) {
          let i = [0.66, 1, 0.66, 0, -0.66, -1, -0.66, 0], n = "";
          o.getTime() + 200 > (/* @__PURE__ */ new Date()).getTime() && (n = `skewX(${Math.round(i[s % i.length] * t)})`, rl = setTimeout(Ia, 15, e, t, o, s + 1)), e.getSvgRoot().setAttribute("transform", `${e.getTranslation()} ${n}`);
        }, bs = function() {
          er && (rl && (clearTimeout(rl), rl = null), er.getSvgRoot().setAttribute("transform", er.getTranslation()), er = null);
        }, ya = function(e, t) {
          e.workspace.RTL && (t.x = e.workspace.getWidth() - t.x);
          let o = e.workspace, s = r.config$$module$build$src$core$config.snapRadius, i = f.difference(t, e.getRelativeToSurfaceXY()), n = new f(0, 0), l = o.getAllBlocks(false).filter((a) => a.id != e.id).map((a) => a.getRelativeToSurfaceXY());
          for (; Xp(f.sum(t, n), l) || Yp(e, f.sum(i, n), s); ) o.RTL ? n.translate(-s, s * 2) : n.translate(s, s * 2);
          e.moveTo(f.sum(t, n));
        }, Xp = function(e, t) {
          return t.some((o) => Math.abs(o.x - e.x) <= 1 && Math.abs(o.y - e.y) <= 1);
        }, Yp = function(e, t, o) {
          return e.getConnections_(false).some((s) => !!s.closest(o, t).connection);
        }, Lo = function(e, t, o) {
          let s = o.getBoundingRectangle(), i = s.right - s.left, n = ds(t.top, s.top, t.top + t.height - (s.bottom - s.top)) - s.top, l = t.left;
          return t = t.left + t.width - i, e.RTL ? l = Math.min(t, l) : t = Math.max(l, t), (e = ds(l, s.left, t) - s.left) || n ? (o.moveBy(e, n, ["inbounds"]), true) : false;
        }, Ca = function(e) {
          return (t) => {
            var o = e.getMetricsManager();
            if (o.hasFixedEdges() && !e.isDragging()) {
              var s;
              if (vu.includes((s = t.type) != null ? s : "")) {
                s = o.getScrollMetrics(true);
                let i = Kp(e, t);
                i && (o = r.getGroup$$module$build$src$core$events$utils() || false, r.setGroup$$module$build$src$core$events$utils(t.group), Lo(e, s, i) && !t.group && console.warn("Moved object in bounds but there was no event group. This may break undo."), r.setGroup$$module$build$src$core$events$utils(o));
              } else Ks(t) && t.scale && t.oldScale && t.scale > t.oldScale && $n(e);
            }
          };
        }, Kp = function(e, t) {
          let o = null;
          switch (t.type) {
            case d.BLOCK_CREATE:
            case d.BLOCK_MOVE:
              (o = e.getBlockById(t.blockId)) && (o = o.getRootBlock());
              break;
            case d.COMMENT_CREATE:
            case d.COMMENT_MOVE:
            case d.COMMENT_RESIZE:
              o = e.getCommentById(t.commentId);
          }
          return o;
        }, $n = function(e) {
          var t = e.getMetricsManager();
          if (t.hasFixedEdges() && !e.isDragging()) {
            t = t.getScrollMetrics(true);
            var o = e.getTopBoundedElements();
            for (let s = 0, i; i = o[s]; s++) Lo(e, t, i);
          }
        }, xe = function(e) {
          return e && typeof e.isDeletable == "function" && typeof e.dispose == "function" && typeof e.setDeleteStyle == "function";
        }, va = function(e, t) {
          let o = e.getIcons();
          for (let s of e.inputList) {
            if (!s.isVisible()) continue;
            o.push(...s.fieldRow);
            let i;
            if ((i = s.connection) != null && i.targetBlock()) if (e = s.connection.targetBlock(), s.connection.type !== C.NEXT_STATEMENT || t) o.push(e);
            else {
              let n;
              (e = (n = e.lastConnectionInStack(false)) == null ? void 0 : n.getSourceBlock()) && o.push(e);
            }
            else {
              let n;
              ((n = s.connection) == null ? void 0 : n.type) === C.INPUT_VALUE && o.push(s.connection);
            }
          }
          return o;
        }, No = function(e, t) {
          let o = e.workspace.getTopBoundedElements(true).filter((i) => Wt(i));
          e = o.indexOf(e instanceof z ? e.getRootBlock() : e) + t;
          let s = null;
          if (e >= 0 && e < o.length ? s = o[e] : e < 0 ? s = o[o.length - 1] : e >= o.length && (s = o[0]), t < 0 && s instanceof z) {
            let i, n;
            return (n = (i = s.lastConnectionInStack(false)) == null ? void 0 : i.getSourceBlock()) != null ? n : s;
          }
          return s;
        }, Ye = function(e, t) {
          var o;
          let s, i = e instanceof z ? (s = (o = e.outputConnection) == null ? void 0 : o.targetBlock()) != null ? s : e.getSurroundParent() : e.getSourceBlock();
          return !(i instanceof z) || (o = va(i, t > 0), e = o.indexOf(e), e === -1) ? null : (t = e + t, t >= 0 && t < o.length ? o[t] : null);
        }, ka = function(e, t) {
          c(E.ICON, e.toString(), t);
        }, jp = function(e) {
          p(E.ICON, e);
        }, Ao = function(e) {
          return e && typeof e.getRelativeToSurfaceXY == "function" && typeof e.isMovable == "function" && typeof e.startDrag == "function" && typeof e.drag == "function" && typeof e.endDrag == "function" && typeof e.revertDrag == "function";
        }, Ra = function(e) {
          return e && typeof e.autoHide == "function";
        }, Nt = function(e) {
          return typeof e.getProcedureModel == "function" && typeof e.doProcedureUpdate == "function" && typeof e.isProcedureDef == "function";
        }, bi = function(e) {
          return e && typeof e.startPublishing == "function" && typeof e.stopPublishing == "function";
        }, fi = function(e) {
          let t = e.getProcedureMap().getProcedures().filter((s) => !s.getReturnTypes()).map((s) => [s.getName(), s.getParameters().map((i) => i.getName()), false]);
          e.getBlocksByType("procedures_defnoreturn", false).forEach((s) => {
            !Nt(s) && Co(s) && t.push(s.getProcedureDef());
          });
          let o = e.getProcedureMap().getProcedures().filter((s) => !!s.getReturnTypes()).map((s) => [s.getName(), s.getParameters().map((i) => i.getName()), true]);
          return e.getBlocksByType("procedures_defreturn", false).forEach((s) => {
            !Nt(s) && Co(s) && o.push(s.getProcedureDef());
          }), t.sort(Sa), o.sort(Sa), [t, o];
        }, Sa = function(e, t) {
          return e[0].localeCompare(t[0], void 0, { sensitivity: "base" });
        }, r.findLegalName$$module$build$src$core$procedures = function(e, t) {
          if (t.isInFlyout) return e;
          for (e = e || r.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed"; !Jp(e, t.workspace, t); ) {
            let o = e.match(/^(.*?)(\d+)$/);
            e = o ? o[1] + (parseInt(o[2]) + 1) : e + "2";
          }
          return e;
        }, Jp = function(e, t, o) {
          return !Oa(e, t, o);
        }, Oa = function(e, t, o) {
          for (let s of t.getAllBlocks(false)) if (s !== o && Co(s) && r.Names$$module$build$src$core$names.equals(s.getProcedureDef()[0], e)) return true;
          o = o && Nt(o) ? o?.getProcedureModel() : void 0;
          for (let s of t.getProcedureMap().getProcedures()) if (s !== o && r.Names$$module$build$src$core$names.equals(s.getName(), e)) return true;
          return false;
        }, r.rename$$module$build$src$core$procedures = function(e) {
          var t = this.getSourceBlock();
          if (!t) throw new se();
          e = e.trim();
          let o = r.findLegalName$$module$build$src$core$procedures(e, t);
          Nt(t) && !t.isInsertionMarker() && t.getProcedureModel().setName(o);
          let s = this.getValue();
          if (s !== e && s !== o) for (e = t.workspace.getAllBlocks(false), t = 0; t < e.length; t++) {
            let i = e[t];
            i.renameProcedure && i.renameProcedure(s, o);
          }
          return o;
        }, qp = function(e) {
          function t(n, l) {
            for (let _ = 0; _ < n.length; _++) {
              var a = n[_][0];
              let v = n[_][1], Q = r.createElement$$module$build$src$core$utils$xml("block");
              Q.setAttribute("type", l), Q.setAttribute("gap", "16");
              let X = r.createElement$$module$build$src$core$utils$xml("mutation");
              for (X.setAttribute("name", a), Q.appendChild(X), a = 0; a < v.length; a++) {
                let ye = r.createElement$$module$build$src$core$utils$xml("arg");
                ye.setAttribute("name", v[a]), X.appendChild(ye);
              }
              o.push(Q);
            }
          }
          let o = [];
          if (K.procedures_defnoreturn) {
            var s = r.createElement$$module$build$src$core$utils$xml("block");
            s.setAttribute("type", "procedures_defnoreturn"), s.setAttribute("gap", "16");
            var i = r.createElement$$module$build$src$core$utils$xml("field");
            i.setAttribute("name", "NAME"), i.appendChild(r.createTextNode$$module$build$src$core$utils$xml(r.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_PROCEDURE)), s.appendChild(i), o.push(s);
          }
          return K.procedures_defreturn && (s = r.createElement$$module$build$src$core$utils$xml("block"), s.setAttribute("type", "procedures_defreturn"), s.setAttribute("gap", "16"), i = r.createElement$$module$build$src$core$utils$xml("field"), i.setAttribute("name", "NAME"), i.appendChild(r.createTextNode$$module$build$src$core$utils$xml(r.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_PROCEDURE)), s.appendChild(i), o.push(s)), K.procedures_ifreturn && (s = r.createElement$$module$build$src$core$utils$xml("block"), s.setAttribute("type", "procedures_ifreturn"), s.setAttribute("gap", "16"), o.push(s)), o.length && o[o.length - 1].setAttribute("gap", "24"), e = fi(e), t(e[0], "procedures_callnoreturn"), t(e[1], "procedures_callreturn"), o;
        }, pn = function(e) {
          return wa(e, false);
        }, wa = function(e, t = true) {
          function o(i, n) {
            for (let [l, a] of i) s.push({ kind: "block", type: n, gap: 16, extraState: { name: l, params: a } });
          }
          if (t) return me("The XML return value of Blockly.Procedures.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), qp(e);
          let s = [];
          return K.procedures_defnoreturn && s.push({ kind: "block", type: "procedures_defnoreturn", gap: 16, fields: { NAME: r.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_PROCEDURE } }), K.procedures_defreturn && s.push({ kind: "block", type: "procedures_defreturn", gap: 16, fields: { NAME: r.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_PROCEDURE } }), K.procedures_ifreturn && s.push({ kind: "block", type: "procedures_ifreturn", gap: 16 }), s.length && (s[s.length - 1].gap = 24), e = fi(e), o(e[0], "procedures_callnoreturn"), o(e[1], "procedures_callreturn"), s;
        }, La = function(e) {
          var t = [], o = e.getBlocksByType("procedures_mutatorarg", false);
          for (let n = 0, l; l = o[n]; n++) t.push(l.getFieldValue("NAME"));
          o = r.createElement$$module$build$src$core$utils$xml("xml");
          let s = r.createElement$$module$build$src$core$utils$xml("block");
          s.setAttribute("type", "procedures_mutatorarg");
          let i = r.createElement$$module$build$src$core$utils$xml("field");
          i.setAttribute("name", "NAME"), t = Yr(r.DEFAULT_ARG$$module$build$src$core$procedures, t), t = r.createTextNode$$module$build$src$core$utils$xml(t), i.appendChild(t), s.appendChild(i), o.appendChild(s), e.updateToolbox(o);
        }, Na = function(e) {
          if (fr(e) && e.bubbleType === "mutator" && e.isOpen && e.blockId) {
            e = zt(e.workspaceId).getBlockById(e.blockId);
            var t = e.type;
            (t === "procedures_defnoreturn" || t === "procedures_defreturn") && (e = e.getIcon(r.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE).getWorkspace(), La(e), e.addChangeListener(Zp));
          }
        }, Zp = function(e) {
          (Ys(e) || br(e) || Eo(e) || Zl(e)) && (e = zt(e.workspaceId), La(e));
        }, Aa = function(e, t) {
          return t.getAllBlocks(false).filter((o) => Qp(o, e) || Ec(o) && r.Names$$module$build$src$core$names.equals(o.getProcedureCall(), e));
        }, Qp = function(e, t) {
          return Nt(e) && !e.isProcedureDef() && e.getProcedureModel() && r.Names$$module$build$src$core$names.equals(e.getProcedureModel().getName(), t);
        }, r.mutateCallers$$module$build$src$core$procedures = function(e) {
          let t = we();
          var o = e.getProcedureDef()[0];
          let s = e.mutationToDom(true);
          e = Aa(o, e.workspace);
          for (let n = 0, l; l = e[n]; n++) {
            o = (o = l.mutationToDom()) && ls(o), l.domToMutation && l.domToMutation(s);
            var i = l.mutationToDom();
            i = i && ls(i), o !== i && (r.setRecordUndo$$module$build$src$core$events$utils(false), R(new (S(d.BLOCK_CHANGE))(l, "mutation", null, o, i)), r.setRecordUndo$$module$build$src$core$events$utils(t));
          }
        }, r.getDefinition$$module$build$src$core$procedures = function(e, t) {
          for (let o of t.getAllBlocks(false)) if (Nt(o) && o.isProcedureDef() && r.Names$$module$build$src$core$names.equals(o.getProcedureModel().getName(), e) || Co(o) && r.Names$$module$build$src$core$names.equals(o.getProcedureDef()[0], e)) return o;
          return null;
        }, Ii = function(e) {
          return e.isDynamic;
        }, Ma = function(e) {
          return e.pathDown !== void 0 && e.pathUp !== void 0;
        }, Da = function(e) {
          return e.pathLeft !== void 0 && e.pathRight !== void 0;
        }, yi = function(e, t) {
          c(E.RENDERER, e, t);
        }, eg = function(e) {
          p(E.RENDERER, e);
        }, Pa = function(e, t, o) {
          return e = new (Y(E.RENDERER, e))(e), e.init(t, o), e;
        }, Ci = function(e) {
          vo(e.getTargetWorkspace(), void 0, "String");
        }, vi = function(e) {
          vo(e.getTargetWorkspace(), void 0, "Number");
        }, ki = function(e) {
          vo(e.getTargetWorkspace(), void 0, "Colour");
        }, gn = function(e) {
          return Ba(e, false);
        }, Ba = function(e, t = true) {
          return K.variables_set_dynamic || K.variables_get_dynamic || console.warn("There are no dynamic variable blocks, but there is a dynamic variable category."), t ? (me("The XML return value of Blockly.VariablesDynamic.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), tg(e)) : (e.registerButtonCallback("CREATE_VARIABLE_STRING", Ci), e.registerButtonCallback("CREATE_VARIABLE_NUMBER", vi), e.registerButtonCallback("CREATE_VARIABLE_COLOUR", ki), [{ kind: "button", text: r.Msg$$module$build$src$core$msg.NEW_STRING_VARIABLE, callbackkey: "CREATE_VARIABLE_STRING" }, { kind: "button", text: r.Msg$$module$build$src$core$msg.NEW_NUMBER_VARIABLE, callbackkey: "CREATE_VARIABLE_NUMBER" }, { kind: "button", text: r.Msg$$module$build$src$core$msg.NEW_COLOUR_VARIABLE, callbackkey: "CREATE_VARIABLE_COLOUR" }, ...Xr(e, e.getVariableMap().getAllVariables(), false, "variables_get_dynamic", "variables_set_dynamic")]);
        }, tg = function(e) {
          let t = [], o = document.createElement("button");
          return o.setAttribute("text", r.Msg$$module$build$src$core$msg.NEW_STRING_VARIABLE), o.setAttribute("callbackKey", "CREATE_VARIABLE_STRING"), t.push(o), o = document.createElement("button"), o.setAttribute("text", r.Msg$$module$build$src$core$msg.NEW_NUMBER_VARIABLE), o.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER"), t.push(o), o = document.createElement("button"), o.setAttribute("text", r.Msg$$module$build$src$core$msg.NEW_COLOUR_VARIABLE), o.setAttribute("callbackKey", "CREATE_VARIABLE_COLOUR"), t.push(o), e.registerButtonCallback("CREATE_VARIABLE_STRING", Ci), e.registerButtonCallback("CREATE_VARIABLE_NUMBER", vi), e.registerButtonCallback("CREATE_VARIABLE_COLOUR", ki), e = xa(e), t = t.concat(e);
        }, xa = function(e) {
          e = e.getVariableMap().getAllVariables();
          let t = [];
          if (e.length > 0) {
            if (K.variables_set_dynamic) {
              var o = e[e.length - 1];
              let s = r.createElement$$module$build$src$core$utils$xml("block");
              s.setAttribute("type", "variables_set_dynamic"), s.setAttribute("gap", "24"), s.appendChild(ko(o)), t.push(s);
            }
            if (K.variables_get_dynamic) {
              e.sort(as);
              for (let s = 0, i; i = e[s]; s++) o = r.createElement$$module$build$src$core$utils$xml("block"), o.setAttribute("type", "variables_get_dynamic"), o.setAttribute("gap", "8"), o.appendChild(ko(i)), t.push(o);
            }
          }
          return t;
        }, og = function(e) {
          e.resizeContents();
        }, mn = function(e, t) {
          let o = e.toCopyData();
          return pr = o, gr = qs(e) && e.workspace instanceof Ie ? e.workspace : null, Sl = t, o;
        }, _n = function() {
          return pr;
        }, sg = function(e) {
          pr = e;
        }, Tn = function() {
          return gr;
        }, ig = function(e) {
          gr = e;
        }, Fa = function() {
          return Sl;
        }, rg = function(e) {
          Sl = e;
        }, Qt = function(e, t, o) {
          return e && t ? Ha(e, t, o) : pr && gr ? Ha(pr, gr, Sl) : null;
        }, Ha = function(e, t, o) {
          let s;
          t = t.isMutator ? t : (s = t.options.parentWorkspace) != null ? s : t;
          let i, n;
          return (n = (i = ht(E.PASTER, e.paster, false)) == null ? void 0 : i.paste(e, t, o)) != null ? n : null;
        }, fs = function(e) {
          return e && typeof e.toCopyData == "function";
        }, Ua = function() {
          W.registry.register({ name: vt.ESCAPE, preconditionFn(e) {
            return !e.isReadOnly();
          }, callback(e) {
            return e.hideChaff(), true;
          }, keyCodes: [H.ESC] });
        }, Ga = function() {
          W.registry.register({ name: vt.DELETE, preconditionFn(e, t) {
            return t = t.focusedNode, !e.isReadOnly() && t != null && xe(t) && t.isDeletable() && !e.isDragging() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
          }, callback(e, t, o, s) {
            return t.preventDefault(), e = s.focusedNode, e instanceof z ? e.checkAndDelete() : xe(e) && e.isDeletable() && (r.setGroup$$module$build$src$core$events$utils(true), e.dispose(), r.setGroup$$module$build$src$core$events$utils(false)), true;
          }, keyCodes: [H.DELETE, H.BACKSPACE] });
        }, En = function(e) {
          return fs(e) && xe(e) && Ao(e) ? e.isCopyable ? e.isCopyable() : e instanceof z || e instanceof It ? e.isOwnDeletable() && e.isOwnMovable() : e.isDeletable() && e.isMovable() : false;
        }, Va = function(e) {
          return En(e) && xe(e) && e.isDeletable();
        }, Wa = function() {
          let e = W.registry.createSerializedKey(H.C, [H.CTRL]), t = W.registry.createSerializedKey(H.C, [H.META]);
          W.registry.register({ name: vt.COPY, preconditionFn(o, s) {
            return s = s.focusedNode, o = o.isFlyout ? o.targetWorkspace : o, !!s && !!o && !o.isDragging() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken() && En(s);
          }, callback(o, s, i, n) {
            return s.preventDefault(), s = n.focusedNode, !s || !fs(s) || !En(s) || (o = o.isFlyout ? o.targetWorkspace : o, !o) ? false : (s.workspace.isFlyout || o.hideChaff(), o = Ao(s) && s.workspace == o ? s.getRelativeToSurfaceXY() : void 0, !!mn(s, o));
          }, keyCodes: [e, t] });
        }, za = function() {
          let e = W.registry.createSerializedKey(H.X, [H.CTRL]), t = W.registry.createSerializedKey(H.X, [H.META]);
          W.registry.register({ name: vt.CUT, preconditionFn(o, s) {
            return s = s.focusedNode, !!s && !o.isReadOnly() && !o.isDragging() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken() && Va(s);
          }, callback(o, s, i, n) {
            return o = n.focusedNode, !o || !Va(o) || !fs(o) ? false : (s = Ao(o) ? o.getRelativeToSurfaceXY() : void 0, s = mn(o, s), o instanceof z ? o.checkAndDelete() : xe(o) && o.dispose(), !!s);
          }, keyCodes: [e, t] });
        }, Xa = function() {
          let e = W.registry.createSerializedKey(H.V, [H.CTRL]), t = W.registry.createSerializedKey(H.V, [H.META]);
          W.registry.register({ name: vt.PASTE, preconditionFn() {
            var o = Tn();
            return !o || !o.rendered ? false : (o = o.isFlyout ? o.targetWorkspace : o, !!_n() && !!o && !o.isReadOnly() && !o.isDragging() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken());
          }, callback(o, s) {
            if (o = _n(), !o) return false;
            var i = Tn();
            if (!i || (i = i.isFlyout ? i.targetWorkspace : i, !i || i.isReadOnly())) return false;
            if (s instanceof PointerEvent) return s = ii(i, new f(s.clientX, s.clientY)), !!Qt(o, i, s);
            if (s = Fa(), !s) return !!Qt(o, i);
            let { left: n, top: l, width: a, height: _ } = i.getMetricsManager().getViewMetrics(true);
            return new L(l, l + _, n, n + a).contains(s.x, s.y) ? !!Qt(o, i) : (s = new f(n + a / 2, l + _ / 2), !!Qt(o, i, s));
          }, keyCodes: [e, t] });
        }, Ya = function() {
          let e = W.registry.createSerializedKey(H.Z, [H.CTRL]), t = W.registry.createSerializedKey(H.Z, [H.META]);
          W.registry.register({ name: vt.UNDO, preconditionFn(o) {
            return !o.isReadOnly() && !o.isDragging() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
          }, callback(o, s) {
            return o.hideChaff(), o.undo(false), s.preventDefault(), true;
          }, keyCodes: [e, t] });
        }, Ka = function() {
          let e = W.registry.createSerializedKey(H.Z, [H.CTRL, H.SHIFT]), t = W.registry.createSerializedKey(H.Z, [H.META, H.SHIFT]), o = W.registry.createSerializedKey(H.Y, [H.CTRL]);
          W.registry.register({ name: vt.REDO, preconditionFn(s) {
            return !s.isDragging() && !s.isReadOnly() && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
          }, callback(s, i) {
            return s.hideChaff(), s.undo(true), i.preventDefault(), true;
          }, keyCodes: [e, t, o] });
        }, ja = function() {
          Ua(), Ga(), Wa(), za(), Xa(), Ya(), Ka();
        }, Ja = function(e) {
          let t = e.saveState();
          return e.getParameters().length && (t.parameters = e.getParameters().map((o) => o.saveState())), t;
        }, qa = function(e, t, o, s) {
          if (e = e.loadState(o, s), !o.parameters) return e;
          for (let [i, n] of o.parameters.entries()) e.insertParameter(t.loadState(n, s), i);
          return e;
        }, ng = function(e) {
          let t = /* @__PURE__ */ Object.create(null), o = Er(E.SERIALIZER, true);
          for (let s in o) {
            let i, n = (i = o[s]) == null ? void 0 : i.save(e);
            n && (t[s] = n);
          }
          return t;
        }, lg = function(e, t, { recordUndo: o = false } = {}) {
          var s = Er(E.SERIALIZER, true);
          if (s) {
            s = Object.entries(s).sort((n, l) => l[1].priority - n[1].priority);
            var i = we();
            r.setRecordUndo$$module$build$src$core$events$utils(o), (o = r.getGroup$$module$build$src$core$events$utils()) || r.setGroup$$module$build$src$core$events$utils(true), fo(), t instanceof Ie && t.setResizesEnabled(false);
            for (let [, n] of s.reverse()) {
              let l;
              (l = n) == null || l.clear(t);
            }
            for (let [n, l] of s.reverse()) if (e[n]) {
              let a;
              (a = l) == null || a.load(e[n], t);
            }
            t instanceof Ie && t.setResizesEnabled(true), Io(), R(new (S(d.FINISHED_LOADING))(t)), r.setGroup$$module$build$src$core$events$utils(o), r.setRecordUndo$$module$build$src$core$events$utils(i);
          }
        }, Za = function(e, t) {
          let o = null;
          o = typeof e == "string" ? document.getElementById(e) || document.querySelector(e) : e;
          var s;
          if (!document.contains(o) && document !== ((s = o) == null ? void 0 : s.ownerDocument)) throw Error("Error: container is not in current document");
          e = new st(t || {}), s = document.createElement("div"), I(s, "injectionDiv"), t != null && t.rtl && I(s, "blocklyRTL"), o.appendChild(s), t = cg(s, e);
          let i = ag(s, t, e);
          return ug(i), Zs(i), Yt(i), s.addEventListener("focusin", function() {
            Zs(i);
          }), w(s, "keydown", null, ti), i;
        }, cg = function(e, t) {
          e.setAttribute("dir", "LTR"), rc(t.hasCss, t.pathToMedia);
          let o = b($.SVG, { xmlns: Oi, "xmlns:html": Po, "xmlns:xlink": He, version: "1.1", class: "blocklySvg" }, e), s = b($.DEFS, {}, o), i = String(Math.random()).substring(2);
          return t.gridPattern = ul.createDom(i, t.gridOptions, s, e), o;
        }, ag = function(e, t, o) {
          o.parentWorkspace = null, o = new Ie(o);
          let s = o.options;
          o.scale = s.zoomOptions.startScale, t.appendChild(o.createDom("blocklyMainBackground", e));
          var i = o.getRenderer().getClassName();
          return i && I(e, i), (i = o.getTheme().getClassName()) && I(e, i), !s.hasCategories && s.languageTree && (e = o.addFlyout($.SVG), bo(e, t)), s.hasTrashcan && o.addTrashcan(), s.zoomOptions && s.zoomOptions.controls && o.addZoomControls(), o.getThemeManager().subscribe(t, "workspaceBackgroundColour", "background-color"), o.translate(0, 0), o.addChangeListener(Ca(o)), Yt(o), ta(), Jr(), zc(), o;
        }, ug = function(e) {
          let t = e.options;
          var o = e.getParentSvg();
          if (w(o.parentNode, "contextmenu", null, function(s) {
            zs(s) || s.preventDefault();
          }), o = w(window, "resize", null, function() {
            Lt(), e.hideComponents(true), Hc(), ra(), Yt(e), $n(e);
          }), e.setResizeHandlerWrapper(o), hg(), t.languageTree) {
            o = e.getToolbox();
            let s = e.getFlyout(true);
            o ? o.init() : s && (s.init(e), s.show(t.languageTree), typeof s.scrollToStart == "function" && s.scrollToStart());
          }
          t.hasTrashcan && e.trashcan.init(), t.zoomOptions && t.zoomOptions.controls && e.zoomControls_.init(), t.moveOptions && t.moveOptions.scrollbars ? (e.scrollbar = new al(e, t.moveOptions.scrollbars === true || !!t.moveOptions.scrollbars.horizontal, t.moveOptions.scrollbars === true || !!t.moveOptions.scrollbars.vertical, "blocklyMainWorkspaceScrollbar"), e.scrollbar.resize()) : e.setMetrics({ x: 0.5, y: 0.5 }), t.hasSounds && dg(t.pathToMedia, e);
        }, hg = function() {
          s_ || (w(document, "scroll", null, function() {
            let e = is();
            for (let t = 0, o; o = e[t]; t++) o instanceof Ie && o.updateInverseScreenCTM();
          }), ze(document, "touchend", null, dt), ze(document, "touchcancel", null, dt)), s_ = true;
        }, dg = function(e, t) {
          function o() {
            for (; i.length; ) {
              let n = i.pop();
              n && x(n);
            }
            s.preload();
          }
          let s = t.getAudioManager();
          s.load([e + "click.mp3", e + "click.wav", e + "click.ogg"], "click"), s.load([e + "disconnect.wav", e + "disconnect.mp3", e + "disconnect.ogg"], "disconnect"), s.load([e + "delete.mp3", e + "delete.ogg", e + "delete.wav"], "delete");
          let i = [];
          i.push(w(document, "pointermove", null, o, true)), i.push(w(document, "touchstart", null, o, true));
        }, $g = function(e) {
          if (!e || !e.isSimpleReporter()) return false;
          let t;
          return (t = e.getFields().next().value) == null ? void 0 : t.isFullBlockField();
        }, Qa = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.UNDO;
          }, preconditionFn(e) {
            return e.workspace.getUndoStack().length > 0 ? "enabled" : "disabled";
          }, callback(e) {
            e.workspace.undo(false);
          }, scopeType: M.ScopeType.WORKSPACE, id: "undoWorkspace", weight: 1 });
        }, eu = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.REDO;
          }, preconditionFn(e) {
            return e.workspace.getRedoStack().length > 0 ? "enabled" : "disabled";
          }, callback(e) {
            e.workspace.undo(true);
          }, scopeType: M.ScopeType.WORKSPACE, id: "redoWorkspace", weight: 2 });
        }, tu = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.CLEAN_UP;
          }, preconditionFn(e) {
            return e.workspace.isMovable() ? e.workspace.getTopBlocks(false).length > 1 ? "enabled" : "disabled" : "hidden";
          }, callback(e) {
            e.workspace.cleanUp();
          }, scopeType: M.ScopeType.WORKSPACE, id: "cleanWorkspace", weight: 3 });
        }, ou = function(e, t) {
          function o(n) {
            i--, n.setCollapsed(e), i === 0 && r.setGroup$$module$build$src$core$events$utils(false);
          }
          let s = 0, i = 0;
          r.setGroup$$module$build$src$core$events$utils(true);
          for (let n = 0; n < t.length; n++) {
            let l = t[n];
            for (; l; ) i++, setTimeout(o.bind(null, l), s), l = l.getNextBlock(), s += 10;
          }
        }, su = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.COLLAPSE_ALL;
          }, preconditionFn(e) {
            if (e.workspace.options.collapse) {
              e = e.workspace.getTopBlocks(false);
              for (let t = 0; t < e.length; t++) {
                let o = e[t];
                for (; o; ) {
                  if (!o.isCollapsed()) return "enabled";
                  o = o.getNextBlock();
                }
              }
              return "disabled";
            }
            return "hidden";
          }, callback(e) {
            ou(true, e.workspace.getTopBlocks(true));
          }, scopeType: M.ScopeType.WORKSPACE, id: "collapseWorkspace", weight: 4 });
        }, iu = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.EXPAND_ALL;
          }, preconditionFn(e) {
            if (e.workspace.options.collapse) {
              e = e.workspace.getTopBlocks(false);
              for (let t = 0; t < e.length; t++) {
                let o = e[t];
                for (; o; ) {
                  if (o.isCollapsed()) return "enabled";
                  o = o.getNextBlock();
                }
              }
              return "disabled";
            }
            return "hidden";
          }, callback(e) {
            ou(false, e.workspace.getTopBlocks(true));
          }, scopeType: M.ScopeType.WORKSPACE, id: "expandWorkspace", weight: 5 });
        }, ru = function(e, t) {
          if (e.isDeletable()) Array.prototype.push.apply(t, e.getDescendants(false));
          else {
            e = e.getChildren(false);
            for (let o = 0; o < e.length; o++) ru(e[o], t);
          }
        }, bn = function(e) {
          let t = [];
          e = e.getTopBlocks(true);
          for (let o = 0; o < e.length; o++) ru(e[o], t);
          return t;
        }, Ri = function(e, t) {
          t ? r.setGroup$$module$build$src$core$events$utils(t) : (r.setGroup$$module$build$src$core$events$utils(true), t = r.getGroup$$module$build$src$core$events$utils());
          let o = e.shift();
          o && (o.isDeadOrDying() ? Ri(e, t) : (o.dispose(false, true), setTimeout(Ri, 10, e, t))), r.setGroup$$module$build$src$core$events$utils(false);
        }, nu = function() {
          M.registry.register({ displayText(e) {
            return e.workspace ? (e = bn(e.workspace).length, e === 1 ? r.Msg$$module$build$src$core$msg.DELETE_BLOCK : r.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${e}`)) : "";
          }, preconditionFn(e) {
            return e.workspace && bn(e.workspace).length > 0 ? "enabled" : "disabled";
          }, callback(e) {
            if (e.workspace) {
              e.workspace.cancelCurrentGesture();
              var t = bn(e.workspace);
              t.length < 2 ? Ri(t) : Ur(r.Msg$$module$build$src$core$msg.DELETE_ALL_BLOCKS.replace("%1", String(t.length)), function(o) {
                o && Ri(t);
              });
            }
          }, scopeType: M.ScopeType.WORKSPACE, id: "workspaceDelete", weight: 6 });
        }, pg = function() {
          Qa(), eu(), tu(), su(), iu(), nu();
        }, lu = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.DUPLICATE_BLOCK;
          }, preconditionFn(e) {
            return e = e.block, !e.isInFlyout && e.isDeletable() && e.isMovable() ? e.isDuplicatable() ? "enabled" : "disabled" : "hidden";
          }, callback(e) {
            if (e.block) {
              var t = e.block.toCopyData();
              t && Qt(t, e.block.workspace);
            }
          }, scopeType: M.ScopeType.BLOCK, id: "blockDuplicate", weight: 1 });
        }, cu = function() {
          M.registry.register({ displayText(e) {
            return e.block.hasIcon(qe.TYPE) ? r.Msg$$module$build$src$core$msg.REMOVE_COMMENT : r.Msg$$module$build$src$core$msg.ADD_COMMENT;
          }, preconditionFn(e) {
            return e = e.block, !e || e.isInFlyout || !e.workspace.options.comments || e.isCollapsed() || !e.isEditable() || !e.hasIcon(qe.TYPE) && $g(e) ? "hidden" : "enabled";
          }, callback(e) {
            (e = e.block) && e.hasIcon(qe.TYPE) ? e.setCommentText(null) : e.setCommentText("");
          }, scopeType: M.ScopeType.BLOCK, id: "blockComment", weight: 2 });
        }, au = function() {
          M.registry.register({ displayText(e) {
            return e.block.getInputsInline() ? r.Msg$$module$build$src$core$msg.EXTERNAL_INPUTS : r.Msg$$module$build$src$core$msg.INLINE_INPUTS;
          }, preconditionFn(e) {
            if (e = e.block, !e.isInFlyout && e.isMovable() && !e.isCollapsed()) {
              for (let t = 1; t < e.inputList.length; t++) if (!(e.inputList[t - 1] instanceof mr || e.inputList[t] instanceof mr)) return "enabled";
            }
            return "hidden";
          }, callback(e) {
            e.block.setInputsInline(!e.block.getInputsInline());
          }, scopeType: M.ScopeType.BLOCK, id: "blockInline", weight: 3 });
        }, uu = function() {
          M.registry.register({ displayText(e) {
            return e.block.isCollapsed() ? r.Msg$$module$build$src$core$msg.EXPAND_BLOCK : r.Msg$$module$build$src$core$msg.COLLAPSE_BLOCK;
          }, preconditionFn(e) {
            return e = e.block, !e.isInFlyout && e.isMovable() && e.workspace.options.collapse ? "enabled" : "hidden";
          }, callback(e) {
            e.block.setCollapsed(!e.block.isCollapsed());
          }, scopeType: M.ScopeType.BLOCK, id: "blockCollapseExpand", weight: 4 });
        }, hu = function() {
          M.registry.register({ displayText(e) {
            return e.block.hasDisabledReason(Ke) ? r.Msg$$module$build$src$core$msg.ENABLE_BLOCK : r.Msg$$module$build$src$core$msg.DISABLE_BLOCK;
          }, preconditionFn(e) {
            if (e = e.block, !e.isInFlyout && e.workspace.options.disable && e.isEditable()) {
              var t = e.getDisabledReasons();
              return t = t.size > (t.has(Ke) ? 1 : 0), e.getInheritedDisabled() || t ? "disabled" : "enabled";
            }
            return "hidden";
          }, callback(e) {
            e = e.block;
            let t = r.getGroup$$module$build$src$core$events$utils();
            t || r.setGroup$$module$build$src$core$events$utils(true), e.setDisabledReason(!e.hasDisabledReason(Ke), Ke), r.setGroup$$module$build$src$core$events$utils(t);
          }, scopeType: M.ScopeType.BLOCK, id: "blockDisable", weight: 5 });
        }, du = function() {
          M.registry.register({ displayText(e) {
            var t = e.block;
            return e = t.getDescendants(false).length, (t = t.getNextBlock()) && (e -= t.getDescendants(false).length), e === 1 ? r.Msg$$module$build$src$core$msg.DELETE_BLOCK : r.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${e}`);
          }, preconditionFn(e) {
            return !e.block.isInFlyout && e.block.isDeletable() ? "enabled" : "hidden";
          }, callback(e) {
            e.block && e.block.checkAndDelete();
          }, scopeType: M.ScopeType.BLOCK, id: "blockDelete", weight: 6 });
        }, $u = function() {
          M.registry.register({ displayText() {
            return r.Msg$$module$build$src$core$msg.HELP;
          }, preconditionFn(e) {
            return e = e.block, (typeof e.helpUrl == "function" ? e.helpUrl() : e.helpUrl) ? "enabled" : "hidden";
          }, callback(e) {
            e.block.showHelp();
          }, scopeType: M.ScopeType.BLOCK, id: "blockHelp", weight: 7 });
        }, pu = function() {
          M.registry.register({ displayText: () => r.Msg$$module$build$src$core$msg.REMOVE_COMMENT, preconditionFn(e) {
            let t;
            return (t = e.comment) != null && t.isDeletable() ? "enabled" : "hidden";
          }, callback(e) {
            r.setGroup$$module$build$src$core$events$utils(true);
            let t;
            (t = e.comment) == null || t.dispose(), r.setGroup$$module$build$src$core$events$utils(false);
          }, scopeType: M.ScopeType.COMMENT, id: "commentDelete", weight: 6 });
        }, gu = function() {
          M.registry.register({ displayText: () => r.Msg$$module$build$src$core$msg.DUPLICATE_COMMENT, preconditionFn(e) {
            let t;
            return (t = e.comment) != null && t.isMovable() ? "enabled" : "hidden";
          }, callback(e) {
            if (e.comment) {
              var t = e.comment.toCopyData();
              t && Qt(t, e.comment.workspace);
            }
          }, scopeType: M.ScopeType.COMMENT, id: "commentDuplicate", weight: 1 });
        }, mu = function() {
          M.registry.register({ displayText: () => r.Msg$$module$build$src$core$msg.ADD_COMMENT, preconditionFn: (e) => {
            let t;
            return (t = e.workspace) != null && t.isMutator ? "hidden" : "enabled";
          }, callback: (e, t, o, s) => {
            (e = e.workspace) && (r.setGroup$$module$build$src$core$events$utils(true), t = new It(e), t.setPlaceholderText(r.Msg$$module$build$src$core$msg.WORKSPACE_COMMENT_DEFAULT_TEXT), t.moveTo(ii(e, new f(s.x, s.y))), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(t), r.setGroup$$module$build$src$core$events$utils(false));
          }, scopeType: M.ScopeType.WORKSPACE, id: "commentCreate", weight: 8 });
        }, gg = function() {
          lu(), cu(), au(), uu(), hu(), du(), $u();
        }, mg = function() {
          gu(), pu(), mu();
        }, _u = function() {
          pg(), gg();
        }, Tu = function(e) {
          return e && typeof e.paste == "function";
        }, Eu = function(e) {
          return e && typeof e.getSvgRoot == "function";
        }, bu = function(e) {
          return e.isSelectable();
        }, _g = function(e) {
          De().hideChaff(e);
        }, Tg = function(e) {
          return e && typeof e.getRootFocusableNode == "function" && typeof e.getRestoredFocusableNode == "function" && typeof e.getNestedTrees == "function" && typeof e.lookUpFocusableNode == "function" && typeof e.onTreeFocus == "function" && typeof e.onTreeBlur == "function";
        }, m = m || {}, m.scope = {}, m.ASSUME_ES5 = false, m.ASSUME_ES6 = false, m.ASSUME_ES2020 = false, m.ASSUME_NO_NATIVE_MAP = false, m.ASSUME_NO_NATIVE_SET = false, m.ISOLATE_POLYFILLS = false, m.FORCE_POLYFILL_PROMISE = false, m.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false, m.INSTRUMENT_ASYNC_CONTEXT = true, m.objectCreate = m.ASSUME_ES5 || typeof Object.create == "function" ? Object.create : function(e) {
          var t = function() {
          };
          return t.prototype = e, new t();
        }, m.defineProperty = m.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(e, t, o) {
          return e == Array.prototype || e == Object.prototype || (e[t] = o.value), e;
        }, m.getGlobal = function(e) {
          e = [typeof globalThis == "object" && globalThis, e, typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global];
          for (var t = 0; t < e.length; ++t) {
            var o = e[t];
            if (o && o.Math == Math) return o;
          }
          throw Error("Cannot find global object");
        }, m.global = m.ASSUME_ES2020 ? globalThis : m.getGlobal(this), m.IS_SYMBOL_NATIVE = typeof Symbol == "function" && typeof Symbol("x") == "symbol", m.TRUST_ES6_POLYFILLS = !m.ISOLATE_POLYFILLS || m.IS_SYMBOL_NATIVE, m.polyfills = {}, m.propertyToPolyfillSymbol = {}, m.POLYFILL_PREFIX = "$jscp$";
        var rL = function(e, t, o) {
          if (!o || e != null) return o = m.propertyToPolyfillSymbol[t], o == null ? e[t] : (o = e[o], o !== void 0 ? o : e[t]);
        };
        m.polyfill = function(e, t, o, s) {
          t && (m.ISOLATE_POLYFILLS ? m.polyfillIsolated(e, t, o, s) : m.polyfillUnisolated(e, t, o, s));
        }, m.polyfillUnisolated = function(e, t, o, s) {
          for (o = m.global, e = e.split("."), s = 0; s < e.length - 1; s++) {
            var i = e[s];
            if (!(i in o)) return;
            o = o[i];
          }
          e = e[e.length - 1], s = o[e], t = t(s), t != s && t != null && m.defineProperty(o, e, { configurable: true, writable: true, value: t });
        }, m.polyfillIsolated = function(e, t, o, s) {
          var i = e.split(".");
          e = i.length === 1, s = i[0], s = !e && s in m.polyfills ? m.polyfills : m.global;
          for (var n = 0; n < i.length - 1; n++) {
            var l = i[n];
            if (!(l in s)) return;
            s = s[l];
          }
          i = i[i.length - 1], o = m.IS_SYMBOL_NATIVE && o === "es6" ? s[i] : null, t = t(o), t != null && (e ? m.defineProperty(m.polyfills, i, { configurable: true, writable: true, value: t }) : t !== o && (m.propertyToPolyfillSymbol[i] === void 0 && (o = Math.random() * 1e9 >>> 0, m.propertyToPolyfillSymbol[i] = m.IS_SYMBOL_NATIVE ? m.global.Symbol(i) : m.POLYFILL_PREFIX + o + "$" + i), m.defineProperty(s, m.propertyToPolyfillSymbol[i], { configurable: true, writable: true, value: t })));
        }, m.getConstructImplementation = function() {
          function e() {
            function o() {
            }
            return new o(), Reflect.construct(o, [], function() {
            }), new o() instanceof o;
          }
          if (m.TRUST_ES6_POLYFILLS && typeof Reflect < "u" && Reflect.construct) {
            if (e()) return Reflect.construct;
            var t = Reflect.construct;
            return function(o, s, i) {
              return o = t(o, s), i && Reflect.setPrototypeOf(o, i.prototype), o;
            };
          }
          return function(o, s, i) {
            return i === void 0 && (i = o), i = m.objectCreate(i.prototype || Object.prototype), Function.prototype.apply.call(o, i, s) || i;
          };
        }, m.construct = { valueOf: m.getConstructImplementation }.valueOf(), m.underscoreProtoCanBeSet = function() {
          var e = { a: true }, t = {};
          try {
            return t.__proto__ = e, t.a;
          } catch {
          }
          return false;
        }, m.setPrototypeOf = m.ASSUME_ES6 || m.TRUST_ES6_POLYFILLS && typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf : m.underscoreProtoCanBeSet() ? function(e, t) {
          if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + " is not extensible");
          return e;
        } : null, m.inherits = function(e, t) {
          if (e.prototype = m.objectCreate(t.prototype), e.prototype.constructor = e, m.ASSUME_ES6 || m.setPrototypeOf) {
            var o = m.setPrototypeOf;
            o(e, t);
          } else for (o in t) if (o != "prototype") if (Object.defineProperties) {
            var s = Object.getOwnPropertyDescriptor(t, o);
            s && Object.defineProperty(e, o, s);
          } else e[o] = t[o];
          e.superClass_ = t.prototype;
        }, m.arrayIteratorImpl = function(e) {
          var t = 0;
          return function() {
            return t < e.length ? { done: false, value: e[t++] } : { done: true };
          };
        }, m.arrayIterator = function(e) {
          return { next: m.arrayIteratorImpl(e) };
        }, m.makeIterator = function(e) {
          var t = typeof Symbol < "u" && Symbol.iterator && e[Symbol.iterator];
          if (t) return t.call(e);
          if (typeof e.length == "number") return m.arrayIterator(e);
          throw Error(String(e) + " is not an iterable or ArrayLike");
        }, m.arrayFromIterator = function(e) {
          for (var t, o = []; !(t = e.next()).done; ) o.push(t.value);
          return o;
        }, m.arrayFromIterable = function(e) {
          return e instanceof Array ? e : m.arrayFromIterator(m.makeIterator(e));
        }, m.generator = {}, m.generator.ensureIteratorResultIsObject_ = function(e) {
          if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object");
        }, m.generator.Context = function() {
          this.isRunning_ = false, this.yieldAllIterator_ = null, this.yieldResult = void 0, this.nextAddress = 1, this.finallyAddress_ = this.catchAddress_ = 0, this.finallyContexts_ = this.abruptCompletion_ = null;
        }, m.generator.Context.prototype.start_ = function() {
          if (this.isRunning_) throw new TypeError("Generator is already running");
          this.isRunning_ = true;
        }, m.generator.Context.prototype.stop_ = function() {
          this.isRunning_ = false;
        }, m.generator.Context.prototype.jumpToErrorHandler_ = function() {
          this.nextAddress = this.catchAddress_ || this.finallyAddress_;
        }, m.generator.Context.prototype.next_ = function(e) {
          this.yieldResult = e;
        }, m.generator.Context.prototype.throw_ = function(e) {
          this.abruptCompletion_ = { exception: e, isException: true }, this.jumpToErrorHandler_();
        }, m.generator.Context.prototype.return = function(e) {
          this.abruptCompletion_ = { return: e }, this.nextAddress = this.finallyAddress_;
        }, m.generator.Context.prototype.jumpThroughFinallyBlocks = function(e) {
          this.abruptCompletion_ = { jumpTo: e }, this.nextAddress = this.finallyAddress_;
        }, m.generator.Context.prototype.yield = function(e, t) {
          return this.nextAddress = t, { value: e };
        }, m.generator.Context.prototype.yieldAll = function(e, t) {
          e = m.makeIterator(e);
          var o = e.next();
          if (m.generator.ensureIteratorResultIsObject_(o), o.done) this.yieldResult = o.value, this.nextAddress = t;
          else return this.yieldAllIterator_ = e, this.yield(o.value, t);
        }, m.generator.Context.prototype.jumpTo = function(e) {
          this.nextAddress = e;
        }, m.generator.Context.prototype.jumpToEnd = function() {
          this.nextAddress = 0;
        }, m.generator.Context.prototype.setCatchFinallyBlocks = function(e, t) {
          this.catchAddress_ = e, t != null && (this.finallyAddress_ = t);
        }, m.generator.Context.prototype.setFinallyBlock = function(e) {
          this.catchAddress_ = 0, this.finallyAddress_ = e || 0;
        }, m.generator.Context.prototype.leaveTryBlock = function(e, t) {
          this.nextAddress = e, this.catchAddress_ = t || 0;
        }, m.generator.Context.prototype.enterCatchBlock = function(e) {
          return this.catchAddress_ = e || 0, e = this.abruptCompletion_.exception, this.abruptCompletion_ = null, e;
        }, m.generator.Context.prototype.enterFinallyBlock = function(e, t, o) {
          o ? this.finallyContexts_[o] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_], this.catchAddress_ = e || 0, this.finallyAddress_ = t || 0;
        }, m.generator.Context.prototype.leaveFinallyBlock = function(e, t) {
          if (t = this.finallyContexts_.splice(t || 0)[0], t = this.abruptCompletion_ = this.abruptCompletion_ || t) {
            if (t.isException) return this.jumpToErrorHandler_();
            t.jumpTo != null && this.finallyAddress_ < t.jumpTo ? (this.nextAddress = t.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_;
          } else this.nextAddress = e;
        }, m.generator.Context.prototype.forIn = function(e) {
          return new m.generator.Context.PropertyIterator(e);
        }, m.generator.Context.PropertyIterator = function(e) {
          this.object_ = e, this.properties_ = [];
          for (var t in e) this.properties_.push(t);
          this.properties_.reverse();
        }, m.generator.Context.PropertyIterator.prototype.getNext = function() {
          for (; this.properties_.length > 0; ) {
            var e = this.properties_.pop();
            if (e in this.object_) return e;
          }
          return null;
        }, m.generator.Engine_ = function(e) {
          this.context_ = new m.generator.Context(), this.program_ = e;
        }, m.generator.Engine_.prototype.next_ = function(e) {
          return this.context_.start_(), this.context_.yieldAllIterator_ ? this.yieldAllStep_(this.context_.yieldAllIterator_.next, e, this.context_.next_) : (this.context_.next_(e), this.nextStep_());
        }, m.generator.Engine_.prototype.return_ = function(e) {
          this.context_.start_();
          var t = this.context_.yieldAllIterator_;
          return t ? this.yieldAllStep_("return" in t ? t.return : function(o) {
            return { value: o, done: true };
          }, e, this.context_.return) : (this.context_.return(e), this.nextStep_());
        }, m.generator.Engine_.prototype.throw_ = function(e) {
          return this.context_.start_(), this.context_.yieldAllIterator_ ? this.yieldAllStep_(this.context_.yieldAllIterator_.throw, e, this.context_.next_) : (this.context_.throw_(e), this.nextStep_());
        }, m.generator.Engine_.prototype.yieldAllStep_ = function(e, t, o) {
          try {
            var s = e.call(this.context_.yieldAllIterator_, t);
            if (m.generator.ensureIteratorResultIsObject_(s), !s.done) return this.context_.stop_(), s;
            var i = s.value;
          } catch (n) {
            return this.context_.yieldAllIterator_ = null, this.context_.throw_(n), this.nextStep_();
          }
          return this.context_.yieldAllIterator_ = null, o.call(this.context_, i), this.nextStep_();
        }, m.generator.Engine_.prototype.nextStep_ = function() {
          for (; this.context_.nextAddress; ) try {
            var e = this.program_(this.context_);
            if (e) return this.context_.stop_(), { value: e.value, done: false };
          } catch (t) {
            this.context_.yieldResult = void 0, this.context_.throw_(t);
          }
          if (this.context_.stop_(), this.context_.abruptCompletion_) {
            if (e = this.context_.abruptCompletion_, this.context_.abruptCompletion_ = null, e.isException) throw e.exception;
            return { value: e.return, done: true };
          }
          return { value: void 0, done: true };
        }, m.generator.Generator_ = function(e) {
          this.next = function(t) {
            return e.next_(t);
          }, this.throw = function(t) {
            return e.throw_(t);
          }, this.return = function(t) {
            return e.return_(t);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }, m.generator.createGenerator = function(e, t) {
          return t = new m.generator.Generator_(new m.generator.Engine_(t)), m.setPrototypeOf && e.prototype && m.setPrototypeOf(t, e.prototype), t;
        }, m.asyncExecutePromiseGenerator = function(e) {
          function t(s) {
            return e.next(s);
          }
          function o(s) {
            return e.throw(s);
          }
          return new Promise(function(s, i) {
            function n(l) {
              l.done ? s(l.value) : Promise.resolve(l.value).then(t, o).then(n, i);
            }
            n(e.next());
          });
        }, m.asyncExecutePromiseGeneratorFunction = function(e) {
          return m.asyncExecutePromiseGenerator(e());
        }, m.asyncExecutePromiseGeneratorProgram = function(e) {
          return m.asyncExecutePromiseGenerator(new m.generator.Generator_(new m.generator.Engine_(e)));
        }, m.polyfill("globalThis", function(e) {
          return e || m.global;
        }, "es_2020", "es3"), m.polyfill("Array.prototype.includes", function(e) {
          return e || function(t, o) {
            var s = this;
            s instanceof String && (s = String(s));
            var i = s.length;
            for (o = o || 0, o < 0 && (o = Math.max(o + i, 0)); o < i; o++) {
              var n = s[o];
              if (n === t || Object.is(n, t)) return true;
            }
            return false;
          };
        }, "es7", "es3"), m.checkEs6ConformanceViaProxy = function() {
          try {
            var e = {}, t = Object.create(new m.global.Proxy(e, { get: function(o, s, i) {
              return o == e && s == "q" && i == t;
            } }));
            return t.q === true;
          } catch {
            return false;
          }
        }, m.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = false, m.ES6_CONFORMANCE = m.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && m.checkEs6ConformanceViaProxy(), m.initSymbol = function() {
        }, m.iteratorPrototype = function(e) {
          return e = { next: e }, e[Symbol.iterator] = function() {
            return this;
          }, e;
        }, m.owns = function(e, t) {
          return Object.prototype.hasOwnProperty.call(e, t);
        }, m.MapEntry = function() {
        }, m.polyfill("Set.prototype.difference", function(e) {
          return e || function(t) {
            m.checkIsSetInstance(this), m.checkIsSetLike(t);
            var o = m.getSmallerAndLargerSets(this, t);
            t = new Set(this);
            var s = o.smallerSetIterator;
            o = o.largerSet;
            for (var i = s.next(); !i.done; ) o.has(i.value) && t.delete(i.value), i = s.next();
            return t;
          };
        }, "es_next", "es6"), m.checkIsSetLike = function(e) {
          if (typeof e != "object" || e === null || typeof e.size != "number" || e.size < 0 || typeof e.keys != "function" || typeof e.has != "function") throw new TypeError("Argument must be set-like");
        }, m.checkIsValidIterator = function(e) {
          if (typeof e != "object" || e === null || typeof e.next != "function") throw new TypeError("Invalid iterator.");
          return e;
        }, m.getSmallerAndLargerSets = function(e, t) {
          return e.size <= t.size ? { smallerSetIterator: e.keys(), largerSet: t } : { smallerSetIterator: m.checkIsValidIterator(t.keys()), largerSet: e };
        }, m.checkIsSetInstance = function(e) {
          if (!(e instanceof Set)) throw new TypeError("Method must be called on an instance of Set.");
        }, m.iteratorFromArray = function(e, t) {
          if (m.ASSUME_ES6) return e[Symbol.iterator]();
          e instanceof String && (e += "");
          var o = 0, s = false, i = { next: function() {
            if (!s && o < e.length) {
              var n = o++;
              return { value: t(n, e[n]), done: false };
            }
            return s = true, { done: true, value: void 0 };
          } };
          return i[Symbol.iterator] = function() {
            return i;
          }, i;
        }, m.polyfill("Array.prototype.values", function(e) {
          return e || function() {
            return m.iteratorFromArray(this, function(t, o) {
              return o;
            });
          };
        }, "es8", "es3"), m.polyfill("Array.prototype.flatMap", function(e) {
          return e || function(t, o) {
            var s = [];
            return Array.prototype.forEach.call(this, function(i, n) {
              i = t.call(o, i, n, this), Array.isArray(i) ? s.push.apply(s, i) : s.push(i);
            }), s;
          };
        }, "es9", "es5"), m.polyfill("Array.prototype.flat", function(e) {
          return e || function(t) {
            t = t === void 0 ? 1 : t;
            var o = [];
            return Array.prototype.forEach.call(this, function(s) {
              Array.isArray(s) && t > 0 ? (s = Array.prototype.flat.call(s, t - 1), o.push.apply(o, s)) : o.push(s);
            }), o;
          };
        }, "es9", "es5"), m.polyfill("Object.entries", function(e) {
          return e || function(t) {
            var o = [], s;
            for (s in t) m.owns(t, s) && o.push([s, t[s]]);
            return o;
          };
        }, "es8", "es3"), m.polyfill("Object.values", function(e) {
          return e || function(t) {
            var o = [], s;
            for (s in t) m.owns(t, s) && o.push(t[s]);
            return o;
          };
        }, "es8", "es3");
        var eo = /* @__PURE__ */ Object.create(null), q_ = { typeMap: eo }, fn = /* @__PURE__ */ Object.create(null), Fe = "default", E = class {
          constructor(e) {
            this.name = e;
          }
          toString() {
            return this.name;
          }
        };
        E.CONNECTION_CHECKER = new E("connectionChecker"), E.CONNECTION_PREVIEWER = new E("connectionPreviewer"), E.CURSOR = new E("cursor"), E.EVENT = new E("event"), E.FIELD = new E("field"), E.INPUT = new E("input"), E.RENDERER = new E("renderer"), E.TOOLBOX = new E("toolbox"), E.THEME = new E("theme"), E.TOOLBOX_ITEM = new E("toolboxItem"), E.FLYOUTS_VERTICAL_TOOLBOX = new E("flyoutsVerticalToolbox"), E.FLYOUTS_HORIZONTAL_TOOLBOX = new E("flyoutsHorizontalToolbox"), E.FLYOUT_INFLATER = new E("flyoutInflater"), E.METRICS_MANAGER = new E("metricsManager"), E.BLOCK_DRAGGER = new E("blockDragger"), E.SERIALIZER = new E("serializer"), E.ICON = new E("icon"), E.PASTER = new E("paster"), E.VARIABLE_MODEL = new E("variableModel"), E.VARIABLE_MAP = new E("variableMap");
        var At = { DEFAULT: Fe, TEST_ONLY: q_ };
        At.Type = E, At.getAllItems = Er, At.getClass = Y, At.getClassFromOptions = Ce, At.getObject = ht, At.hasItem = G, At.register = c, At.unregister = p;
        var K = /* @__PURE__ */ Object.create(null), nL = { Blocks: K }, Z_ = 750, Eg = "ontouchstart" in globalThis || !!(globalThis.document && document.documentElement && "ontouchstart" in document.documentElement) || !(!globalThis.navigator || !globalThis.navigator.maxTouchPoints && !globalThis.navigator.msMaxTouchPoints), In = null, Mo = { mousedown: ["pointerdown"], mouseenter: ["pointerenter"], mouseleave: ["pointerleave"], mousemove: ["pointermove"], mouseout: ["pointerout"], mouseover: ["pointerover"], mouseup: ["pointerup", "pointercancel"], touchend: ["pointerup"], touchcancel: ["pointercancel"] }, yn = 0, Do = { TOUCH_ENABLED: Eg, TOUCH_MAP: Mo };
        Do.checkTouchIdentifier = ql, Do.clearTouchIdentifier = Oe, Do.getTouchIdentifierFromEvent = es, Do.longStart = Jl, Do.longStop = dt, Do.shouldHandleEvent = Ws;
        var fu, bg, fg, Ig, Cn, vn, Iu, yg, Cg, vg;
        (function(e) {
          function t(s) {
            return o.includes(s.toUpperCase());
          }
          fu = e;
          let o = fu.toUpperCase();
          bg = t("JavaFX"), fg = t("WebKit"), Ig = t("Gecko") && !fg, Cn = t("Android"), e = globalThis.navigator && globalThis.navigator.maxTouchPoints, vn = t("iPad") || t("Macintosh") && e > 0, Iu = t("iPhone") && !vn, yg = t("Macintosh"), Cg = vn || Cn && !t("Mobile") || t("Silk"), vg = !Cg && (Iu || Cn);
        })(globalThis.navigator && globalThis.navigator.userAgent || "");
        var Q_ = fu, kg = bg, Rg = Ig, yu = Cn, kn = vn, Sg = Iu, Cu = yg, Og = vg, eT = { ANDROID: yu, GECKO: Rg, IPAD: kn, IPHONE: Sg, JavaFx: kg, MAC: Cu, MOBILE: Og, raw: Q_ }, wg = 40, Lg = 125, Mt = {};
        Mt.bind = ze, Mt.conditionalBind = w, Mt.getScrollDeltaPixels = Xs, Mt.isRightButton = Qe, Mt.isTargetInput = zs, Mt.mouseToSvg = ts, Mt.unbind = x;
        var d;
        (function(e) {
          e.BLOCK_CREATE = "create", e.BLOCK_DELETE = "delete", e.BLOCK_CHANGE = "change", e.BLOCK_FIELD_INTERMEDIATE_CHANGE = "block_field_intermediate_change", e.BLOCK_MOVE = "move", e.VAR_CREATE = "var_create", e.VAR_DELETE = "var_delete", e.VAR_RENAME = "var_rename", e.VAR_TYPE_CHANGE = "var_type_change", e.UI = "ui", e.BLOCK_DRAG = "drag", e.SELECTED = "selected", e.CLICK = "click", e.MARKER_MOVE = "marker_move", e.BUBBLE_OPEN = "bubble_open", e.TRASHCAN_OPEN = "trashcan_open", e.TOOLBOX_ITEM_SELECT = "toolbox_item_select", e.THEME_CHANGE = "theme_change", e.VIEWPORT_CHANGE = "viewport_change", e.COMMENT_CREATE = "comment_create", e.COMMENT_DELETE = "comment_delete", e.COMMENT_CHANGE = "comment_change", e.COMMENT_MOVE = "comment_move", e.COMMENT_RESIZE = "comment_resize", e.COMMENT_DRAG = "comment_drag", e.COMMENT_COLLAPSE = "comment_collapse", e.FINISHED_LOADING = "finished_loading";
        })(d || (d = {}));
        var vu = [d.BLOCK_CREATE, d.BLOCK_MOVE, d.COMMENT_CREATE, d.COMMENT_MOVE], tT = { BUMP_EVENTS: vu };
        tT.EventType = d;
        var Ng = "!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", ku = { genUid: () => {
          let e = Ng.length, t = [];
          for (let o = 0; o < 20; o++) t[o] = Ng.charAt(Math.random() * e);
          return t.join("");
        } }, lL = ku, oT = 0, Ru = { TEST_ONLY: ku };
        Ru.genUid = wt, Ru.getNextUniqueId = Xe;
        var q = {};
        q.isBlockChange = Eo, q.isBlockCreate = Ys, q.isBlockDelete = br, q.isBlockDrag = Hd, q.isBlockFieldIntermediateChange = Zl, q.isBlockMove = os, q.isBubbleOpen = fr, q.isClick = Ql, q.isCommentChange = Yd, q.isCommentCollapse = qd, q.isCommentCreate = zd, q.isCommentDelete = Xd, q.isCommentDrag = Jd, q.isCommentMove = Kd, q.isCommentResize = jd, q.isFinishedLoading = Zd, q.isSelected = Ud, q.isThemeChange = Wd, q.isToolboxItemSelect = Vd, q.isTrashcanOpen = Gd, q.isVarCreate = Bd, q.isVarDelete = xd, q.isVarRename = Fd, q.isViewportChange = Ks;
        var Ag = "", Si = true, Su = 0, Ou = "ORPHANED_BLOCK", Dt = [], wu = { FIRE_QUEUE: Dt, enqueueEvent: ec, fireNow: Ir, fireInternal: Qd, setGroupInternal: e$ }, Ne = { TEST_ONLY: wu };
        Ne.clearPendingUndo = Cr, Ne.disable = r.disable$$module$build$src$core$events$utils, Ne.disableOrphans = oc, Ne.enable = r.enable$$module$build$src$core$events$utils, Ne.filter = yr, Ne.fire = R, Ne.fromJson = tc, Ne.get = S, Ne.getDescendantIds = js, Ne.getGroup = r.getGroup$$module$build$src$core$events$utils, Ne.getRecordUndo = we, Ne.isEnabled = J, Ne.setGroup = r.setGroup$$module$build$src$core$events$utils, Ne.setRecordUndo = r.setRecordUndo$$module$build$src$core$events$utils;
        var Oi = "http://www.w3.org/2000/svg", Po = "http://www.w3.org/1999/xhtml", He = "http://www.w3.org/1999/xlink", Pt;
        (function(e) {
          e[e.ELEMENT_NODE = 1] = "ELEMENT_NODE", e[e.TEXT_NODE = 3] = "TEXT_NODE", e[e.COMMENT_NODE = 8] = "COMMENT_NODE";
        })(Pt || (Pt = {}));
        var et = null, Lu = 0, wi = null, Te = { HTML_NS: Po };
        Te.NodeType = Pt, Te.SVG_NS = Oi, Te.XLINK_NS = He, Te.addClass = I, Te.createSvgElement = b, Te.getFastTextWidth = t$, Te.getFastTextWidthWithSizeString = Js, Te.getTextWidth = ss, Te.hasClass = kr, Te.insertAfter = bo, Te.measureFontMetrics = Sr, Te.removeClass = P, Te.removeClasses = vr, Te.removeNode = V, Te.setCssTransform = Rr, Te.startTextWidthCache = fo, Te.stopTextWidthCache = Io;
        var de = class {
          static findFocusedNode(e) {
            var t = e.getRootFocusableNode();
            if (!t.canBeFocused()) return null;
            var o = t.getFocusableElement();
            return kr(o, de.ACTIVE_CLASS_NAME) || kr(o, de.PASSIVE_CSS_CLASS_NAME) || (t = o.querySelector(this.ACTIVE_FOCUS_NODE_CSS_SELECTOR), (t instanceof HTMLElement || t instanceof SVGElement) && (t = de.findFocusableNodeFor(t, e))) ? t : (o = o.querySelector(this.PASSIVE_FOCUS_NODE_CSS_SELECTOR), (o instanceof HTMLElement || o instanceof SVGElement) && (e = de.findFocusableNodeFor(o, e)) ? e : null);
          }
          static findFocusableNodeFor(e, t) {
            if (!e.id || e.id === "null" || t.getNestedTrees().map((i) => de.findFocusableNodeFor(e, i)).findIndex((i) => !!i) !== -1) return null;
            var o = t.getRootFocusableNode();
            if (o.canBeFocused() && e === o.getFocusableElement()) return o;
            var s;
            return (o = (s = t.lookUpFocusableNode(e.id)) != null ? s : null) ? o : (s = e.parentElement, !o && s ? de.findFocusableNodeFor(s, t) : null);
          }
        };
        de.ACTIVE_CLASS_NAME = "blocklyActiveFocus", de.PASSIVE_CSS_CLASS_NAME = "blocklyPassiveFocus", de.ACTIVE_FOCUS_NODE_CSS_SELECTOR = `.${de.ACTIVE_CLASS_NAME}`, de.PASSIVE_FOCUS_NODE_CSS_SELECTOR = `.${de.PASSIVE_CSS_CLASS_NAME}`;
        var sT = {};
        sT.FocusableTreeTraverser = de;
        var iT = class {
          constructor(e, t) {
            this.tree = e, this.rootShouldBeAutoTabbable = t;
          }
        }, Ee = class {
          constructor(e) {
            this.previouslyFocusedNode = this.focusedNode = null, this.registeredTrees = [], this.isUpdatingFocusedNode = this.recentlyLostAllFocus = this.lockFocusStateChanges = this.currentlyHoldsEphemeralFocus = false;
            let t = (o) => {
              if (!this.isUpdatingFocusedNode) {
                this.recentlyLostAllFocus = !o;
                var s = null;
                if (o instanceof HTMLElement || o instanceof SVGElement) {
                  for (var i of this.registeredTrees) if (s = de.findFocusableNodeFor(o, i.tree)) break;
                }
                if (s && s.canBeFocused()) {
                  o = s.getFocusableTree();
                  let n;
                  i = (n = this.focusedNode) == null ? void 0 : n.getFocusableTree(), s === o.getRootFocusableNode() && o !== i ? this.focusTree(o) : this.focusNode(s);
                } else this.defocusCurrentFocusedNode();
              }
            };
            e("focusin", (o) => {
              o instanceof FocusEvent && t(document.activeElement);
            }), e("focusout", (o) => {
              o instanceof FocusEvent && t(o.relatedTarget);
            });
          }
          registerTree(e, t = false) {
            if (this.ensureManagerIsUnlocked(), this.isRegistered(e)) throw Error(`Attempted to re-register already registered tree: ${e}.`);
            this.registeredTrees.push(new iT(e, t));
            let o = e.getRootFocusableNode().getFocusableElement();
            if (!o.id || o.id === "null") throw Error(`Attempting to register a tree with a root element that has an invalid ID: ${e}.`);
            t && (o.tabIndex = 0);
          }
          isRegistered(e) {
            return !!this.lookUpRegistration(e);
          }
          lookUpRegistration(e) {
            let t;
            return (t = this.registeredTrees.find((o) => o.tree === e)) != null ? t : null;
          }
          unregisterTree(e) {
            if (this.ensureManagerIsUnlocked(), !this.isRegistered(e)) throw Error(`Attempted to unregister not registered tree: ${e}.`);
            var t = this.registeredTrees.findIndex((i) => i.tree === e);
            let o = this.registeredTrees[t];
            this.registeredTrees.splice(t, 1), t = de.findFocusedNode(e);
            let s = e.getRootFocusableNode();
            t && this.removeHighlight(t), this.focusedNode !== t && this.focusedNode !== s || this.updateFocusedNode(null), this.removeHighlight(s), o.rootShouldBeAutoTabbable && e.getRootFocusableNode().getFocusableElement().removeAttribute("tabindex");
          }
          getFocusedTree() {
            let e, t;
            return (t = (e = this.focusedNode) == null ? void 0 : e.getFocusableTree()) != null ? t : null;
          }
          getFocusedNode() {
            return this.focusedNode;
          }
          focusTree(e) {
            if (this.ensureManagerIsUnlocked(), !this.isRegistered(e)) throw Error(`Attempted to focus unregistered tree: ${e}.`);
            let t = de.findFocusedNode(e), o = e.getRestoredFocusableNode(t);
            e = e.getRootFocusableNode();
            let s;
            this.focusNode((s = o ?? t) != null ? s : e);
          }
          focusNode(e) {
            this.ensureManagerIsUnlocked();
            let t = !this.currentlyHoldsEphemeralFocus;
            t && (this.isUpdatingFocusedNode = true);
            var o, s = ((o = this.focusedNode) == null ? void 0 : o.getFocusableElement()) !== document.activeElement;
            if (this.focusedNode !== e || s) if (e.canBeFocused()) {
              if (o = e.getFocusableTree(), !this.isRegistered(o)) throw Error(`Attempted to focus unregistered node: ${e}.`);
              s = e.getFocusableElement(), s.id && s.id !== "null" || console.warn("Trying to focus a node that has an invalid ID.");
              var i = de.findFocusableNodeFor(s, o);
              s = de.findFocusedNode(o);
              var n = e;
              if (i !== e) {
                n = o.getRestoredFocusableNode(s), e = o.getRootFocusableNode();
                var l;
                n = (l = n ?? s) != null ? l : e;
              }
              e = this.focusedNode, l = e?.getFocusableTree(), e && this.passivelyFocusNode(e, o), o = o.getRootFocusableNode(), s && this.removeHighlight(s), o !== n && this.removeHighlight(o), this.currentlyHoldsEphemeralFocus || this.activelyFocusNode(n, l ?? null), this.updateFocusedNode(n);
            } else console.warn("Trying to focus a node that can't be focused.");
            t && (this.isUpdatingFocusedNode = false);
          }
          takeEphemeralFocus(e) {
            if (this.ensureManagerIsUnlocked(), this.currentlyHoldsEphemeralFocus) throw Error(`Attempted to take ephemeral focus when it's already held, with new element: ${e}.`);
            this.currentlyHoldsEphemeralFocus = true, this.focusedNode && this.passivelyFocusNode(this.focusedNode, null), e.focus({ preventScroll: true });
            let t = false;
            return () => {
              if (t) throw Error(`Attempted to finish ephemeral focus twice for element: ${e}.`);
              if (t = true, this.currentlyHoldsEphemeralFocus = false, this.focusedNode) {
                this.activelyFocusNode(this.focusedNode, null);
                let o = this.focusedNode;
                setTimeout(() => {
                  !this.focusedNode && this.previouslyFocusedNode === o && this.recentlyLostAllFocus && this.focusNode(o);
                }, 0);
              }
            };
          }
          ephemeralFocusTaken() {
            return this.currentlyHoldsEphemeralFocus;
          }
          ensureManagerIsUnlocked() {
            if (this.lockFocusStateChanges) throw Error("FocusManager state changes cannot happen in a tree/node focus/blur callback.");
          }
          updateFocusedNode(e) {
            this.previouslyFocusedNode = this.focusedNode, this.focusedNode = e;
          }
          defocusCurrentFocusedNode() {
            this.focusedNode && !this.currentlyHoldsEphemeralFocus && (this.passivelyFocusNode(this.focusedNode, null), this.updateFocusedNode(null));
          }
          activelyFocusNode(e, t) {
            this.lockFocusStateChanges = true;
            let o = e.getFocusableTree(), s = e.getFocusableElement(), i, n = (i = this.lookUpRegistration(o)) == null ? void 0 : i.rootShouldBeAutoTabbable;
            o !== t && (o.onTreeFocus(e, t), n && (o.getRootFocusableNode().getFocusableElement().tabIndex = -1)), e.onNodeFocus(), this.lockFocusStateChanges = false, n && e === o.getRootFocusableNode() || s.hasAttribute("tabindex") || (s.tabIndex = -1), this.setNodeToVisualActiveFocus(e), s.focus({ preventScroll: true });
          }
          passivelyFocusNode(e, t) {
            this.lockFocusStateChanges = true;
            let o = e.getFocusableTree();
            if (o !== t) {
              o.onTreeBlur(t);
              let s;
              (s = this.lookUpRegistration(o)) != null && s.rootShouldBeAutoTabbable && (o.getRootFocusableNode().getFocusableElement().tabIndex = 0);
            }
            e.onNodeBlur(), this.lockFocusStateChanges = false, o !== t && this.setNodeToVisualPassiveFocus(e);
          }
          setNodeToVisualActiveFocus(e) {
            e = e.getFocusableElement(), I(e, Ee.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME), P(e, Ee.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME);
          }
          setNodeToVisualPassiveFocus(e) {
            e = e.getFocusableElement(), P(e, Ee.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME), I(e, Ee.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME);
          }
          removeHighlight(e) {
            e = e.getFocusableElement(), P(e, Ee.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME), P(e, Ee.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME);
          }
          static getFocusManager() {
            return Ee.focusManager || (Ee.focusManager = new Ee(document.addEventListener)), Ee.focusManager;
          }
        };
        Ee.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME = "blocklyActiveFocus", Ee.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME = "blocklyPassiveFocus", Ee.focusManager = null;
        var Mg = {};
        Mg.FocusManager = Ee, Mg.getFocusManager = r.getFocusManager$$module$build$src$core$focus_manager;
        var rT = {};
        rT.isFocusableNode = Wt;
        var nT = {};
        nT.isSelectable = qs;
        var Dg = {};
        Dg.deepMerge = $t;
        var W = class {
          constructor() {
            this.shortcuts = /* @__PURE__ */ new Map(), this.keyMap = /* @__PURE__ */ new Map(), this.reset();
          }
          reset() {
            this.shortcuts.clear(), this.keyMap.clear();
          }
          register(e, t) {
            if (this.shortcuts.get(e.name) && !t) throw Error(`Shortcut named "${e.name}" already exists.`);
            if (this.shortcuts.set(e.name, e), t = e.keyCodes, t != null && t.length) for (let o of t) this.addKeyMapping(o, e.name, !!e.allowCollision);
          }
          unregister(e) {
            return this.shortcuts.get(e) ? (this.removeAllKeyMappings(e), this.shortcuts.delete(e), true) : (console.warn(`Keyboard shortcut named "${e}" not found.`), false);
          }
          addKeyMapping(e, t, o) {
            e = `${e}`;
            let s = this.keyMap.get(e);
            if (s && !o) throw Error(`Shortcut named "${t}" collides with shortcuts "${s}"`);
            s && o ? s.unshift(t) : this.keyMap.set(e, [t]);
          }
          removeKeyMapping(e, t, o) {
            let s = this.keyMap.get(e);
            if (!s) return o || console.warn(`No keyboard shortcut named "${t}" registered with key code "${e}"`), false;
            let i = s.indexOf(t);
            return i > -1 ? (s.splice(i, 1), s.length === 0 && this.keyMap.delete(e), true) : (o || console.warn(`No keyboard shortcut named "${t}" registered with key code "${e}"`), false);
          }
          removeAllKeyMappings(e) {
            for (let t of this.keyMap.keys()) this.removeKeyMapping(t, e, true);
          }
          setKeyMap(e) {
            this.keyMap.clear();
            for (let t in e) this.keyMap.set(t, e[t]);
          }
          getKeyMap() {
            let e = /* @__PURE__ */ Object.create(null);
            for (let [t, o] of this.keyMap) e[t] = o;
            return e;
          }
          getRegistry() {
            let e = /* @__PURE__ */ Object.create(null);
            for (let [t, o] of this.shortcuts) e[t] = o;
            return $t(/* @__PURE__ */ Object.create(null), e);
          }
          onKeyDown(e, t) {
            var o = this.serializeKeyEvent(t);
            if (o = this.getShortcutNamesByKeyCode(o), !o) return false;
            for (let s of o) {
              o = this.shortcuts.get(s);
              let i;
              if (!o || o.preconditionFn && !o.preconditionFn(e, { focusedNode: (i = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode()) != null ? i : void 0 })) continue;
              let n, l, a;
              if ((l = (n = o).callback) != null && l.call(n, e, t, o, { focusedNode: (a = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode()) != null ? a : void 0 })) return true;
            }
            return false;
          }
          getShortcutNamesByKeyCode(e) {
            let t;
            return ((t = this.keyMap.get(e)) == null ? void 0 : t.slice()) || [];
          }
          getKeyCodesByShortcutName(e) {
            let t = [];
            for (let [o, s] of this.keyMap) s.indexOf(e) > -1 && t.push(o);
            return t;
          }
          serializeKeyEvent(e) {
            let t = "";
            for (let o in W.modifierKeys) e.getModifierState(o) && (t !== "" && (t += "+"), t += o);
            return t !== "" && e.keyCode ? t += "+" + e.keyCode : e.keyCode && (t = String(e.keyCode)), t;
          }
          checkModifiers(e) {
            for (let t of e) if (!(t in W.modifierKeys)) throw Error(t + " is not a valid modifier key.");
          }
          createSerializedKey(e, t) {
            let o = "";
            if (t) {
              this.checkModifiers(t);
              for (let s in W.modifierKeys) t.includes(W.modifierKeys[s]) && (o !== "" && (o += "+"), o += s);
            }
            return o !== "" && e ? o += "+" + e : e && (o = `${e}`), o;
          }
        };
        W.registry = new W(), (function(e) {
          e = e.modifierKeys || (e.modifierKeys = {}), e[e.Shift = 16] = "Shift", e[e.Control = 17] = "Control", e[e.Alt = 18] = "Alt", e[e.Meta = 91] = "Meta";
        })(W || (W = {}));
        var lT = {};
        lT.ShortcutRegistry = W;
        var Li = /* @__PURE__ */ Object.create(null), Pg, Bg, Ni = [], xg = { defineBlocksWithJsonArrayInternal: i$ }, $e = { TEST_ONLY: xg };
        $e.createBlockDefinitionsFromJsonArray = r.createBlockDefinitionsFromJsonArray$$module$build$src$core$common, $e.defineBlocks = r.defineBlocks$$module$build$src$core$common, $e.defineBlocksWithJsonArray = wr, $e.draggingConnections = Ni, $e.fireSelectedEvent = Xt, $e.getAllWorkspaces = is, $e.getBlockTypeCounts = ei, $e.getMainWorkspace = De, $e.getParentContainer = Qs, $e.getSelected = rs, $e.getWorkspaceById = zt, $e.globalShortcutHandler = ti, $e.registerWorkspace = sc, $e.setMainWorkspace = Zs, $e.setParentContainer = Or, $e.setSelected = o$, $e.svgResize = Yt, $e.unregisterWorkpace = ic;
        var Bo = class {
          constructor() {
            this.workspaceId = void 0, this.isUiEvent = false, this.type = "", this.group = r.getGroup$$module$build$src$core$events$utils(), this.recordUndo = we();
          }
          toJson() {
            return { type: this.type, group: this.group };
          }
          static fromJson(e, t, o) {
            return o.isBlank = false, o.group = e.group || "", o.workspaceId = t.id, o;
          }
          isNull() {
            return false;
          }
          run(e) {
          }
          getEventWorkspace_() {
            let e;
            if (this.workspaceId && (e = zt(this.workspaceId)), !e) throw Error("Workspace is null. Event must have been generated from real Blockly events.");
            return e;
          }
        }, cT = {};
        cT.Abstract = Bo;
        var tt = class extends Bo {
          constructor(e) {
            super(), this.recordUndo = false, this.isUiEvent = true, this.isBlank = typeof e > "u", this.workspaceId = e || "";
          }
        }, aT = {};
        aT.UiBase = tt;
        var Rn = class extends tt {
          constructor(e, t, o) {
            t = e ? e.workspace.id : t, t === null && (t = void 0), super(t), this.type = d.CLICK, this.blockId = e ? e.id : void 0, this.targetType = o;
          }
          toJson() {
            let e = super.toJson();
            if (!this.targetType) throw Error("The click target type is undefined. Either pass a block to the constructor, or call fromJson");
            return e.targetType = this.targetType, e.blockId = this.blockId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Rn()), t.targetType = e.targetType, t.blockId = e.blockId, t;
          }
        }, Sn;
        (function(e) {
          e.BLOCK = "block", e.WORKSPACE = "workspace", e.ZOOM_CONTROLS = "zoom_controls";
        })(Sn || (Sn = {})), c(E.EVENT, d.CLICK, Rn);
        var Fg = {};
        Fg.Click = Rn, Fg.ClickTarget = Sn;
        var Hg = {};
        Hg.removeElem = Pe;
        var Bt = class {
          constructor(e) {
            this.name = e;
          }
          toString() {
            return this.name;
          }
        };
        Bt.POSITIONABLE = new Bt("positionable"), Bt.DRAG_TARGET = new Bt("drag_target"), Bt.DELETE_AREA = new Bt("delete_area"), Bt.AUTOHIDEABLE = new Bt("autohideable");
        var j = class {
          constructor() {
            this.componentData = /* @__PURE__ */ new Map(), this.capabilityToComponentIds = /* @__PURE__ */ new Map();
          }
          addComponent(e, t) {
            let o = e.component.id;
            if (!t && this.componentData.has(o)) {
              var s;
              throw Error('Plugin "' + o + '" with capabilities "' + ((s = this.componentData.get(o)) == null ? void 0 : s.capabilities) + '" already added.');
            }
            for (this.componentData.set(o, e), t = [], s = 0; s < e.capabilities.length; s++) {
              let i = String(e.capabilities[s]).toLowerCase();
              if (t.push(i), this.capabilityToComponentIds.has(i)) {
                let n;
                (n = this.capabilityToComponentIds.get(i)) == null || n.push(o);
              } else this.capabilityToComponentIds.set(i, [o]);
            }
            this.componentData.get(o).capabilities = t;
          }
          removeComponent(e) {
            let t = this.componentData.get(e);
            if (t) {
              for (let o = 0; o < t.capabilities.length; o++) {
                let s = String(t.capabilities[o]).toLowerCase();
                Pe(this.capabilityToComponentIds.get(s), e);
              }
              this.componentData.delete(e);
            }
          }
          addCapability(e, t) {
            if (!this.getComponent(e)) throw Error('Cannot add capability, "' + t + '". Plugin "' + e + '" has not been added to the ComponentManager');
            if (this.hasCapability(e, t)) console.warn('Plugin "' + e + 'already has capability "' + t + '"');
            else {
              t = `${t}`.toLowerCase();
              var o;
              (o = this.componentData.get(e)) == null || o.capabilities.push(t);
              var s;
              (s = this.capabilityToComponentIds.get(t)) == null || s.push(e);
            }
          }
          removeCapability(e, t) {
            if (!this.getComponent(e)) throw Error('Cannot remove capability, "' + t + '". Plugin "' + e + '" has not been added to the ComponentManager');
            this.hasCapability(e, t) ? (t = `${t}`.toLowerCase(), Pe(this.componentData.get(e).capabilities, t), Pe(this.capabilityToComponentIds.get(t), e)) : console.warn('Plugin "' + e + `doesn't have capability "` + t + '" to remove');
          }
          hasCapability(e, t) {
            return t = `${t}`.toLowerCase(), this.componentData.has(e) && this.componentData.get(e).capabilities.includes(t);
          }
          getComponent(e) {
            let t;
            return (t = this.componentData.get(e)) == null ? void 0 : t.component;
          }
          getComponents(e, t) {
            if (e = `${e}`.toLowerCase(), e = this.capabilityToComponentIds.get(e), !e) return [];
            let o = [];
            if (t) {
              let s = [];
              e.forEach((i) => {
                s.push(this.componentData.get(i));
              }), s.sort(function(i, n) {
                return i.weight - n.weight;
              }), s.forEach(function(i) {
                o.push(i.component);
              });
            } else e.forEach((s) => {
              o.push(this.componentData.get(s).component);
            });
            return o;
          }
        };
        j.Capability = Bt, (function(e) {
          e = e.ComponentWeight || (e.ComponentWeight = {}), e[e.TOOLBOX_WEIGHT = 0] = "TOOLBOX_WEIGHT", e[e.FLYOUT_WEIGHT = 1] = "FLYOUT_WEIGHT", e[e.TRASHCAN_WEIGHT = 2] = "TRASHCAN_WEIGHT", e[e.ZOOM_CONTROLS_WEIGHT = 3] = "ZOOM_CONTROLS_WEIGHT";
        })(j || (j = {}));
        var uT = j.ComponentWeight, Ug = {};
        Ug.ComponentManager = j, Ug.ComponentWeight = uT;
        var Nu = false, Au = `
.blocklySvg {
  background-color: #fff;
  outline: none;
  overflow: hidden;  /* IE overflows by default. */
  position: absolute;
  display: block;
}

.blocklyWidgetDiv {
  display: none;
  position: absolute;
  z-index: 99999;  /* big value for bootstrap3 compatibility */
}

.injectionDiv {
  height: 100%;
  position: relative;
  overflow: hidden;  /* So blocks in drag surface disappear at edges */
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}

.blocklyBlockCanvas.blocklyCanvasTransitioning,
.blocklyBubbleCanvas.blocklyCanvasTransitioning {
  transition: transform .5s;
}

.blocklyEmboss {
  filter: var(--blocklyEmbossFilter);
}

.blocklyTooltipDiv {
  background-color: #ffffc7;
  border: 1px solid #ddc;
  box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);
  color: #000;
  display: none;
  font: 9pt sans-serif;
  opacity: .9;
  padding: 2px;
  position: absolute;
  z-index: 100000;  /* big value for bootstrap3 compatibility */
}

.blocklyDropDownDiv {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1000;
  display: none;
  border: 1px solid;
  border-color: #dadce0;
  background-color: #fff;
  border-radius: 2px;
  padding: 4px;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv:focus {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownContent {
  max-height: 300px;  /* @todo: spec for maximum height. */
}

.blocklyDropDownArrow {
  position: absolute;
  left: 0;
  top: 0;
  width: 16px;
  height: 16px;
  z-index: -1;
  background-color: inherit;
  border-color: inherit;
  border-top: 1px solid;
  border-left: 1px solid;
  border-top-left-radius: 4px;
  border-color: inherit;
}

.blocklyHighlighted>.blocklyPath {
  filter: var(--blocklyEmbossFilter);
}

.blocklyHighlightedConnectionPath {
  fill: none;
  stroke: #fc3;
  stroke-width: 4px;
}

.blocklyPathLight {
  fill: none;
  stroke-linecap: round;
  stroke-width: 1;
}

.blocklySelected>.blocklyPathLight {
  display: none;
}

.blocklyDraggable {
  cursor: grab;
  cursor: -webkit-grab;
}

.blocklyDragging {
  cursor: grabbing;
  cursor: -webkit-grabbing;
  /* Drag surface disables events to not block the toolbox, so we have to
   * reenable them here for the cursor values to work. */
  pointer-events: auto;
}

  /* Changes cursor on mouse down. Not effective in Firefox because of
     https://bugzilla.mozilla.org/show_bug.cgi?id=771241 */
.blocklyDraggable:active {
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

.blocklyDragging.blocklyDraggingDelete,
.blocklyDragging.blocklyDraggingDelete .blocklyField {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyDragging>.blocklyPath,
.blocklyDragging>.blocklyPathLight {
  fill-opacity: .8;
  stroke-opacity: .8;
}

.blocklyDragging>.blocklyPathDark {
  display: none;
}

.blocklyDisabledPattern>.blocklyPath {
  fill: var(--blocklyDisabledPattern);
  fill-opacity: .5;
  stroke-opacity: .5;
}

.blocklyDisabled>.blocklyPathLight,
.blocklyDisabled>.blocklyPathDark {
  display: none;
}

.blocklyInsertionMarker>.blocklyPath,
.blocklyInsertionMarker>.blocklyPathLight,
.blocklyInsertionMarker>.blocklyPathDark {
  fill-opacity: .2;
  stroke: none;
}

.blocklyNonEditableField>text {
  pointer-events: none;
}

.blocklyFlyout {
  position: absolute;
  z-index: 20;
}

.blocklyText text {
  cursor: default;
}

/*
  Don't allow users to select text.  It gets annoying when trying to
  drag a block and selected text moves instead.
*/
.blocklySvg text {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  cursor: inherit;
}

.blocklyIconGroup {
  cursor: default;
}

.blocklyIconGroup:not(:hover):not(:focus),
.blocklyIconGroupReadonly {
  opacity: .6;
}

.blocklyIconShape {
  fill: #00f;
  stroke: #fff;
  stroke-width: 1px;
}

.blocklyIconSymbol {
  fill: #fff;
}

.blocklyMinimalBody {
  margin: 0;
  padding: 0;
  height: 100%;
}

.blocklyHtmlInput {
  border: none;
  border-radius: 4px;
  height: 100%;
  margin: 0;
  outline: none;
  padding: 0;
  width: 100%;
  text-align: center;
  display: block;
  box-sizing: border-box;
}

/* Remove the increase and decrease arrows on the field number editor */
input.blocklyHtmlInput[type=number]::-webkit-inner-spin-button,
input.blocklyHtmlInput[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type=number] {
  -moz-appearance: textfield;
}

.blocklyMainBackground {
  stroke-width: 1;
  stroke: #c6c6c6;  /* Equates to #ddd due to border being off-pixel. */
}

.blocklyMutatorBackground {
  fill: #fff;
  stroke: #ddd;
  stroke-width: 1;
}

.blocklyFlyoutBackground {
  fill: #ddd;
  fill-opacity: .8;
}

.blocklyMainWorkspaceScrollbar {
  z-index: 20;
}

.blocklyFlyoutScrollbar {
  z-index: 30;
}

.blocklyScrollbarHorizontal,
.blocklyScrollbarVertical {
  position: absolute;
  outline: none;
}

.blocklyScrollbarBackground {
  opacity: 0;
  pointer-events: none;
}

.blocklyScrollbarHandle {
  fill: #ccc;
}

.blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyScrollbarHandle:hover {
  fill: #bbb;
}

/* Darken flyout scrollbars due to being on a grey background. */
/* By contrast, workspace scrollbars are on a white background. */
.blocklyFlyout .blocklyScrollbarHandle {
  fill: #bbb;
}

.blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyFlyout .blocklyScrollbarHandle:hover {
  fill: #aaa;
}

.blocklyInvalidInput {
  background: #faa;
}

.blocklyVerticalMarker {
  stroke-width: 3px;
  fill: rgba(255,255,255,.5);
  pointer-events: none;
}

.blocklyComputeCanvas {
  position: absolute;
  width: 0;
  height: 0;
}

.blocklyNoPointerEvents {
  pointer-events: none;
}

.blocklyContextMenu {
  border-radius: 4px;
  max-height: 100%;
}

.blocklyDropdownMenu {
  border-radius: 2px;
  padding: 0 !important;
}

.blocklyDropdownMenu .blocklyMenuItem {
  /* 28px on the left for icon or checkbox. */
  padding-left: 28px;
}

/* BiDi override for the resting state. */
.blocklyDropdownMenu .blocklyMenuItemRtl {
  /* Flip left/right padding for BiDi. */
  padding-left: 5px;
  padding-right: 28px;
}

.blocklyWidgetDiv .blocklyMenu {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  background: #fff;
  border: 1px solid transparent;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
  font: normal 13px Arial, sans-serif;
  margin: 0;
  outline: none;
  padding: 4px 0;
  position: absolute;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

.blocklyWidgetDiv .blocklyMenu:focus {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv .blocklyMenu {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  background: inherit;  /* Compatibility with gapi, reset from goog-menu */
  border: inherit;  /* Compatibility with gapi, reset from goog-menu */
  font: normal 13px "Helvetica Neue", Helvetica, sans-serif;
  outline: none;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

/* State: resting. */
.blocklyMenuItem {
  border: none;
  color: #000;
  cursor: pointer;
  list-style: none;
  margin: 0;
  /* 7em on the right for shortcut. */
  min-width: 7em;
  padding: 6px 15px;
  white-space: nowrap;
}

/* State: disabled. */
.blocklyMenuItemDisabled {
  color: #ccc;
  cursor: inherit;
}

/* State: hover. */
.blocklyMenuItemHighlight {
  background-color: rgba(0,0,0,.1);
}

/* State: selected/checked. */
.blocklyMenuItemCheckbox {
  height: 16px;
  position: absolute;
  width: 16px;
}

.blocklyMenuItemSelected .blocklyMenuItemCheckbox {
  background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;
  float: left;
  margin-left: -24px;
  position: static;  /* Scroll with the menu. */
}

.blocklyMenuItemRtl .blocklyMenuItemCheckbox {
  float: right;
  margin-right: -24px;
}

.blocklyMenuSeparator {
  background-color: #ccc;
  height: 1px;
  border: 0;
  margin-left: 4px;
  margin-right: 4px;
}

.blocklyBlockDragSurface, .blocklyAnimationLayer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: visible !important;
  z-index: 80;
  pointer-events: none;
}

.blocklyField {
  cursor: default;
}

.blocklyInputField {
  cursor: text;
}

.blocklyDragging .blocklyField,
.blocklyDragging .blocklyIconGroup {
  cursor: grabbing;
}

.blocklyActiveFocus:is(
  .blocklyFlyout,
  .blocklyWorkspace,
  .blocklyField,
  .blocklyPath,
  .blocklyHighlightedConnectionPath,
  .blocklyComment,
  .blocklyBubble,
  .blocklyIconGroup,
  .blocklyTextarea
) {
  outline: none;
}
`, Mu = {};
        Mu.inject = rc, Mu.register = pt;
        var f = class {
          constructor(e, t) {
            this.x = e, this.y = t;
          }
          clone() {
            return new f(this.x, this.y);
          }
          scale(e) {
            return this.x *= e, this.y *= e, this;
          }
          translate(e, t) {
            return this.x += e, this.y += t, this;
          }
          static equals(e, t) {
            return e === t ? true : e && t ? e.x === t.x && e.y === t.y : false;
          }
          static distance(e, t) {
            let o = e.x - t.x;
            return e = e.y - t.y, Math.sqrt(o * o + e * e);
          }
          static magnitude(e) {
            return Math.sqrt(e.x * e.x + e.y * e.y);
          }
          static difference(e, t) {
            return new f(e.x - t.x, e.y - t.y);
          }
          static sum(e, t) {
            return new f(e.x + t.x, e.y + t.y);
          }
        }, hT = {};
        hT.Coordinate = f;
        var $ = class {
          constructor(e) {
            this.tagName = e;
          }
          toString() {
            return this.tagName;
          }
        };
        $.ANIMATE = new $("animate"), $.CIRCLE = new $("circle"), $.CLIPPATH = new $("clipPath"), $.DEFS = new $("defs"), $.FECOMPOSITE = new $("feComposite"), $.FECOMPONENTTRANSFER = new $("feComponentTransfer"), $.FEFLOOD = new $("feFlood"), $.FEFUNCA = new $("feFuncA"), $.FEGAUSSIANBLUR = new $("feGaussianBlur"), $.FEPOINTLIGHT = new $("fePointLight"), $.FESPECULARLIGHTING = new $("feSpecularLighting"), $.FILTER = new $("filter"), $.FOREIGNOBJECT = new $("foreignObject"), $.G = new $("g"), $.IMAGE = new $("image"), $.LINE = new $("line"), $.PATH = new $("path"), $.PATTERN = new $("pattern"), $.POLYGON = new $("polygon"), $.RECT = new $("rect"), $.SVG = new $("svg"), $.TEXT = new $("text"), $.TSPAN = new $("tspan");
        var dT = {};
        dT.Svg = $;
        var L = class {
          constructor(e, t, o, s) {
            this.top = e, this.bottom = t, this.left = o, this.right = s;
          }
          static from(e) {
            return new L(e.y, e.y + e.height, e.x, e.x + e.width);
          }
          clone() {
            return new L(this.top, this.bottom, this.left, this.right);
          }
          getHeight() {
            return this.bottom - this.top;
          }
          getWidth() {
            return this.right - this.left;
          }
          getOrigin() {
            return new f(this.left, this.top);
          }
          contains(e, t) {
            return e >= this.left && e <= this.right && t >= this.top && t <= this.bottom;
          }
          intersects(e) {
            return this.left <= e.right && this.right >= e.left && this.bottom >= e.top && this.top <= e.bottom;
          }
          static equals(e, t) {
            return e === t ? true : e && t ? e.top === t.top && e.bottom === t.bottom && e.left === t.left && e.right === t.right : false;
          }
          static createFromPoint(e, t, o) {
            let s = e.x;
            return e = e.y, new L(e, e + o, s, s + t);
          }
        }, $T = {};
        $T.Rect = L;
        var N = class {
          constructor(e, t) {
            this.width = e, this.height = t;
          }
          static equals(e, t) {
            return e === t ? true : e && t ? e.width === t.width && e.height === t.height : false;
          }
          static max(e, t) {
            return new N(Math.max(e.width, t.width), Math.max(e.height, t.height));
          }
          static min(e, t) {
            return new N(Math.min(e.width, t.width), Math.min(e.height, t.height));
          }
        }, pT = {};
        pT.Size = N;
        var Gg = { getSizeInternal: r$ }, to = { TEST_ONLY: Gg };
        to.getBorderBox = cc, to.getComputedStyle = gt, to.getContainerOffsetToScrollInto = uc, to.getPageOffset = Kt, to.getSize = oi, to.getViewportPageOffset = lc, to.scrollIntoContainerView = ac;
        var Vg = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*)?/, Wg = /transform:\s*translate(?:3d)?\(\s*([-+\d.e]+)\s*px([ ,]\s*([-+\d.e]+)\s*px)?/, gT = { XY_REGEX: Vg, XY_STYLE_REGEX: Wg }, xo = { TEST_ONLY: gT };
        xo.getDocumentScroll = dc, xo.getInjectionDivXY = Lr, xo.getRelativeXY = si, xo.getViewportBBox = hc, xo.screenToWsCoordinates = ii, xo.wsToScreenCoordinates = ns;
        var te = class {
          constructor(e, t, o, s, i) {
            this.workspace = e, this.horizontal = t, this.oldHostMetrics = null, this.ratio = 1, this.origin = new f(0, 0), this.startDragHandle = this.handlePosition = this.handleLength = this.scrollbarLength = this.startDragMouse = 0, this.containerVisible = this.isHandleVisible = true, this.position = new f(0, 0), this.onMouseMoveWrapper_ = this.onMouseUpWrapper_ = null, this.pair = o || false, this.margin = i !== void 0 ? i : te.DEFAULT_SCROLLBAR_MARGIN, e = "blocklyScrollbar" + (this.horizontal ? "Horizontal" : "Vertical"), s && (e += " " + s), this.outerSvg = b($.SVG, { class: e }), s = b($.G, {}, this.outerSvg), this.svgBackground = b($.RECT, { class: "blocklyScrollbarBackground" }, s), e = Math.floor((te.scrollbarThickness - 5) / 2), this.svgHandle = b($.RECT, { class: "blocklyScrollbarHandle", rx: e, ry: e }, s), this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarColour", "fill"), this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarOpacity", "fill-opacity"), bo(this.outerSvg, this.workspace.getParentSvg()), this.setInitialThickness(), t ? (this.lengthAttribute_ = "width", this.positionAttribute_ = "x") : (this.lengthAttribute_ = "height", this.positionAttribute_ = "y"), this.onMouseDownBarWrapper_ = w(this.svgBackground, "pointerdown", this, this.onMouseDownBar), this.onMouseDownHandleWrapper_ = w(this.svgHandle, "pointerdown", this, this.onMouseDownHandle);
          }
          setInitialThickness() {
            let e = te.scrollbarThickness;
            this.horizontal ? (this.svgBackground.setAttribute("height", String(e)), this.outerSvg.setAttribute("height", String(e)), this.svgHandle.setAttribute("height", String(e - 5)), this.svgHandle.setAttribute("y", "2.5")) : (this.svgBackground.setAttribute("width", String(e)), this.outerSvg.setAttribute("width", String(e)), this.svgHandle.setAttribute("width", String(e - 5)), this.svgHandle.setAttribute("x", "2.5"));
          }
          dispose() {
            this.cleanUp(), x(this.onMouseDownBarWrapper_), x(this.onMouseDownHandleWrapper_), V(this.outerSvg), this.workspace.getThemeManager().unsubscribe(this.svgHandle);
          }
          constrainHandleLength(e) {
            return e = e <= 0 || isNaN(e) ? 0 : Math.min(e, this.scrollbarLength);
          }
          setHandleLength(e) {
            this.handleLength = e, this.svgHandle.setAttribute(this.lengthAttribute_, String(this.handleLength));
          }
          constrainHandlePosition(e) {
            return e = e <= 0 || isNaN(e) ? 0 : Math.min(e, this.scrollbarLength - this.handleLength);
          }
          setHandlePosition(e) {
            this.handlePosition = e, this.svgHandle.setAttribute(this.positionAttribute_, String(this.handlePosition));
          }
          setScrollbarLength(e) {
            this.scrollbarLength = e, this.outerSvg.setAttribute(this.lengthAttribute_, String(this.scrollbarLength)), this.svgBackground.setAttribute(this.lengthAttribute_, String(this.scrollbarLength));
          }
          setPosition(e, t) {
            this.position.x = e, this.position.y = t, Rr(this.outerSvg, "translate(" + (this.position.x + this.origin.x) + "px," + (this.position.y + this.origin.y) + "px)");
          }
          resize(e) {
            !e && (e = this.workspace.getMetrics(), !e) || this.oldHostMetrics && te.metricsAreEquivalent(e, this.oldHostMetrics) || (this.horizontal ? this.resizeHorizontal(e) : this.resizeVertical(e), this.oldHostMetrics = e, this.updateMetrics());
          }
          requiresViewResize(e) {
            return this.oldHostMetrics ? this.oldHostMetrics.viewWidth !== e.viewWidth || this.oldHostMetrics.viewHeight !== e.viewHeight || this.oldHostMetrics.absoluteLeft !== e.absoluteLeft || this.oldHostMetrics.absoluteTop !== e.absoluteTop : true;
          }
          resizeHorizontal(e) {
            this.requiresViewResize(e) ? this.resizeViewHorizontal(e) : this.resizeContentHorizontal(e);
          }
          resizeViewHorizontal(e) {
            var t = e.viewWidth - this.margin * 2;
            this.pair && (t -= te.scrollbarThickness), this.setScrollbarLength(Math.max(0, t)), t = e.absoluteLeft + this.margin, this.pair && this.workspace.RTL && (t += te.scrollbarThickness), this.setPosition(t, e.absoluteTop + e.viewHeight - te.scrollbarThickness - this.margin), this.resizeContentHorizontal(e);
          }
          resizeContentHorizontal(e) {
            if (e.viewWidth >= e.scrollWidth) this.setHandleLength(this.scrollbarLength), this.setHandlePosition(0), this.pair || this.setVisible(false);
            else {
              this.pair || this.setVisible(true);
              var t = this.scrollbarLength * e.viewWidth / e.scrollWidth;
              t = this.constrainHandleLength(t), this.setHandleLength(t), t = e.scrollWidth - e.viewWidth;
              var o = this.scrollbarLength - this.handleLength;
              e = (e.viewLeft - e.scrollLeft) / t * o, e = this.constrainHandlePosition(e), this.setHandlePosition(e), this.ratio = o / t;
            }
          }
          resizeVertical(e) {
            this.requiresViewResize(e) ? this.resizeViewVertical(e) : this.resizeContentVertical(e);
          }
          resizeViewVertical(e) {
            let t = e.viewHeight - this.margin * 2;
            this.pair && (t -= te.scrollbarThickness), this.setScrollbarLength(Math.max(0, t)), this.setPosition(this.workspace.RTL ? e.absoluteLeft + this.margin : e.absoluteLeft + e.viewWidth - te.scrollbarThickness - this.margin, e.absoluteTop + this.margin), this.resizeContentVertical(e);
          }
          resizeContentVertical(e) {
            if (e.viewHeight >= e.scrollHeight) this.setHandleLength(this.scrollbarLength), this.setHandlePosition(0), this.pair || this.setVisible(false);
            else {
              this.pair || this.setVisible(true);
              var t = this.scrollbarLength * e.viewHeight / e.scrollHeight;
              t = this.constrainHandleLength(t), this.setHandleLength(t), t = e.scrollHeight - e.viewHeight;
              var o = this.scrollbarLength - this.handleLength;
              e = (e.viewTop - e.scrollTop) / t * o, e = this.constrainHandlePosition(e), this.setHandlePosition(e), this.ratio = o / t;
            }
          }
          isVisible() {
            return this.isHandleVisible;
          }
          setContainerVisible(e) {
            let t = e !== this.containerVisible;
            this.containerVisible = e, t && this.updateDisplay_();
          }
          setVisible(e) {
            if (this.pair) throw Error("Unable to toggle visibility of paired scrollbars.");
            this.setVisibleInternal(e);
          }
          setVisibleInternal(e) {
            let t = e !== this.isVisible();
            this.isHandleVisible = e, t && this.updateDisplay_();
          }
          updateDisplay_() {
            this.containerVisible && this.isVisible() ? this.outerSvg.setAttribute("display", "block") : this.outerSvg.setAttribute("display", "none");
          }
          onMouseDownBar(e) {
            if (this.workspace.markFocused(), Oe(), this.cleanUp(), Qe(e)) e.stopPropagation();
            else {
              var t = ts(e, this.workspace.getParentSvg(), this.workspace.getInverseScreenCTM());
              t = this.horizontal ? t.x : t.y;
              var o = Lr(this.svgHandle);
              o = this.horizontal ? o.x : o.y;
              var s = this.handlePosition, i = this.handleLength * 0.95;
              t <= o ? s -= i : t >= o + this.handleLength && (s += i), this.setHandlePosition(this.constrainHandlePosition(s)), this.updateMetrics(), e.stopPropagation(), e.preventDefault();
            }
          }
          onMouseDownHandle(e) {
            this.workspace.markFocused(), this.cleanUp(), Qe(e) ? e.stopPropagation() : (this.startDragHandle = this.handlePosition, this.startDragMouse = this.horizontal ? e.clientX : e.clientY, this.onMouseUpWrapper_ = w(document, "pointerup", this, this.onMouseUpHandle), this.onMouseMoveWrapper_ = w(document, "pointermove", this, this.onMouseMoveHandle), e.stopPropagation(), e.preventDefault());
          }
          onMouseMoveHandle(e) {
            this.setHandlePosition(this.constrainHandlePosition(this.startDragHandle + ((this.horizontal ? e.clientX : e.clientY) - this.startDragMouse))), this.updateMetrics();
          }
          onMouseUpHandle() {
            Oe(), this.cleanUp();
          }
          cleanUp() {
            this.workspace.hideChaff(true), this.onMouseUpWrapper_ && (x(this.onMouseUpWrapper_), this.onMouseUpWrapper_ = null), this.onMouseMoveWrapper_ && (x(this.onMouseMoveWrapper_), this.onMouseMoveWrapper_ = null);
          }
          getRatio_() {
            let e = this.handlePosition / (this.scrollbarLength - this.handleLength);
            return isNaN(e) && (e = 0), e;
          }
          updateMetrics() {
            let e = this.getRatio_();
            this.horizontal ? this.workspace.setMetrics({ x: e }) : this.workspace.setMetrics({ y: e });
          }
          set(e, t) {
            this.setHandlePosition(this.constrainHandlePosition(e * this.ratio)), (t || t === void 0) && this.updateMetrics();
          }
          setOrigin(e, t) {
            this.origin = new f(e, t);
          }
          static metricsAreEquivalent(e, t) {
            return e.viewWidth === t.viewWidth && e.viewHeight === t.viewHeight && e.viewLeft === t.viewLeft && e.viewTop === t.viewTop && e.absoluteTop === t.absoluteTop && e.absoluteLeft === t.absoluteLeft && e.scrollWidth === t.scrollWidth && e.scrollHeight === t.scrollHeight && e.scrollLeft === t.scrollLeft && e.scrollTop === t.scrollTop;
          }
        };
        te.scrollbarThickness = Eg ? 25 : 15, te.DEFAULT_SCROLLBAR_MARGIN = 0.5;
        var mT = {};
        mT.Scrollbar = te;
        var On = { parseFromString: function() {
          throw Error("DOMParser was not found in the global scope and was not properly injected using injectDependencies");
        } }, Du = { serializeToString: function() {
          throw Error("XMLSerializer was not foundin the global scope and was not properly injected using injectDependencies");
        } }, { document: wn, DOMParser: Ai, XMLSerializer: Mi } = globalThis;
        Ai && (On = new Ai()), Mi && (Du = new Mi());
        var zg = "https://developers.google.com/blockly/xml", _T = /[\x00-\x09\x0B\x0C\x0E-\x1F]/g, Is = { NAME_SPACE: zg };
        Is.createElement = r.createElement$$module$build$src$core$utils$xml, Is.createTextNode = r.createTextNode$$module$build$src$core$utils$xml, Is.domToText = ls, Is.injectDependencies = n$, Is.textToDom = r.textToDom$$module$build$src$core$utils$xml;
        var Pu = "categoryToolbox", Xg = "flyoutToolbox", A;
        (function(e) {
          e[e.TOP = 0] = "TOP", e[e.BOTTOM = 1] = "BOTTOM", e[e.LEFT = 2] = "LEFT", e[e.RIGHT = 3] = "RIGHT";
        })(A || (A = {}));
        var Yg = { hasCategoriesInternal: a$ }, oo = {};
        oo.Position = A, oo.TEST_ONLY = Yg, oo.convertFlyoutDefToJsonArray = ri, oo.convertToolboxDefToJson = Nr, oo.hasCategories = Ar, oo.isCategoryCollapsible = Mr, oo.parseToolboxTree = pc;
        var xt;
        (function(e) {
          e[e.TOP = 0] = "TOP", e[e.BOTTOM = 1] = "BOTTOM";
        })(xt || (xt = {}));
        var ys;
        (function(e) {
          e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT";
        })(ys || (ys = {}));
        var so;
        (function(e) {
          e[e.UP = 0] = "UP", e[e.DOWN = 1] = "DOWN";
        })(so || (so = {}));
        var Fo = {};
        Fo.bumpDirection = so, Fo.bumpPositionRect = xr, Fo.getCornerOppositeToolbox = Br, Fo.getStartPositionRect = Pr, Fo.horizontalPosition = ys, Fo.verticalPosition = xt;
        var ve = { width: 96, height: 124, url: "sprites.png" }, cL = { SPRITE: ve }, Bu = class {
          constructor(e) {
            this.workspace = e, this.id = "zoomControls", this.boundEvents = [], this.zoomResetGroup = this.zoomOutGroup = this.zoomInGroup = null, this.HEIGHT = this.WIDTH = 32, this.SMALL_SPACING = 2, this.LARGE_SPACING = 11, this.MARGIN_HORIZONTAL = this.MARGIN_VERTICAL = 20, this.svgGroup = null, this.top = this.left = 0, this.initialized = false;
          }
          createDom() {
            this.svgGroup = b($.G, {});
            let e = String(Math.random()).substring(2);
            return this.createZoomOutSvg(e), this.createZoomInSvg(e), this.workspace.isMovable() && this.createZoomResetSvg(e), this.svgGroup;
          }
          init() {
            this.workspace.getComponentManager().addComponent({ component: this, weight: j.ComponentWeight.ZOOM_CONTROLS_WEIGHT, capabilities: [j.Capability.POSITIONABLE] }), this.initialized = true;
          }
          dispose() {
            this.workspace.getComponentManager().removeComponent("zoomControls"), this.svgGroup && V(this.svgGroup);
            for (let e of this.boundEvents) x(e);
            this.boundEvents.length = 0;
          }
          getBoundingRectangle() {
            let e = this.SMALL_SPACING + 2 * this.HEIGHT;
            return this.zoomResetGroup && (e += this.LARGE_SPACING + this.HEIGHT), new L(this.top, this.top + e, this.left, this.left + this.WIDTH);
          }
          position(e, t) {
            if (this.initialized) {
              var o = Br(this.workspace, e), s = this.SMALL_SPACING + 2 * this.HEIGHT;
              if (this.zoomResetGroup && (s += this.LARGE_SPACING + this.HEIGHT), e = Pr(o, new N(this.WIDTH, s), this.MARGIN_HORIZONTAL, this.MARGIN_VERTICAL, e, this.workspace), o = o.vertical, t = xr(e, this.MARGIN_VERTICAL, o === xt.TOP ? so.DOWN : so.UP, t), o === xt.TOP) {
                var i = this.SMALL_SPACING + this.HEIGHT, n;
                (n = this.zoomInGroup) == null || n.setAttribute("transform", "translate(0, " + i + ")"), this.zoomResetGroup && this.zoomResetGroup.setAttribute("transform", "translate(0, " + (i + this.LARGE_SPACING + this.HEIGHT) + ")");
              } else {
                n = this.zoomResetGroup ? this.LARGE_SPACING + this.HEIGHT : 0;
                let a;
                (a = this.zoomInGroup) == null || a.setAttribute("transform", "translate(0, " + n + ")"), n = n + this.SMALL_SPACING + this.HEIGHT, (i = this.zoomOutGroup) == null || i.setAttribute("transform", "translate(0, " + n + ")");
              }
              this.top = t.top, this.left = t.left;
              var l;
              (l = this.svgGroup) == null || l.setAttribute("transform", "translate(" + this.left + "," + this.top + ")");
            }
          }
          createZoomOutSvg(e) {
            this.zoomOutGroup = b($.G, { class: "blocklyZoom blocklyZoomOut" }, this.svgGroup);
            let t = b($.CLIPPATH, { id: "blocklyZoomoutClipPath" + e }, this.zoomOutGroup);
            b($.RECT, { width: 32, height: 32 }, t), b($.IMAGE, { width: ve.width, height: ve.height, x: -64, y: -92, "clip-path": "url(#blocklyZoomoutClipPath" + e + ")" }, this.zoomOutGroup).setAttributeNS(He, "xlink:href", this.workspace.options.pathToMedia + ve.url), this.boundEvents.push(w(this.zoomOutGroup, "pointerdown", null, this.zoom.bind(this, -1)));
          }
          createZoomInSvg(e) {
            this.zoomInGroup = b($.G, { class: "blocklyZoom blocklyZoomIn" }, this.svgGroup);
            let t = b($.CLIPPATH, { id: "blocklyZoominClipPath" + e }, this.zoomInGroup);
            b($.RECT, { width: 32, height: 32 }, t), b($.IMAGE, { width: ve.width, height: ve.height, x: -32, y: -92, "clip-path": "url(#blocklyZoominClipPath" + e + ")" }, this.zoomInGroup).setAttributeNS(He, "xlink:href", this.workspace.options.pathToMedia + ve.url), this.boundEvents.push(w(this.zoomInGroup, "pointerdown", null, this.zoom.bind(this, 1)));
          }
          zoom(e, t) {
            this.workspace.markFocused(), this.workspace.zoomCenter(e), this.fireZoomEvent(), Oe(), t.stopPropagation(), t.preventDefault();
          }
          createZoomResetSvg(e) {
            this.zoomResetGroup = b($.G, { class: "blocklyZoom blocklyZoomReset" }, this.svgGroup);
            let t = b($.CLIPPATH, { id: "blocklyZoomresetClipPath" + e }, this.zoomResetGroup);
            b($.RECT, { width: 32, height: 32 }, t), b($.IMAGE, { width: ve.width, height: ve.height, y: -92, "clip-path": "url(#blocklyZoomresetClipPath" + e + ")" }, this.zoomResetGroup).setAttributeNS(He, "xlink:href", this.workspace.options.pathToMedia + ve.url), this.boundEvents.push(w(this.zoomResetGroup, "pointerdown", null, this.resetZoom.bind(this)));
          }
          resetZoom(e) {
            this.workspace.markFocused();
            let t = Math.log(this.workspace.options.zoomOptions.startScale / this.workspace.scale) / Math.log(this.workspace.options.zoomOptions.scaleSpeed);
            this.workspace.beginCanvasTransition(), this.workspace.zoomCenter(t), this.workspace.scrollCenter(), setTimeout(this.workspace.endCanvasTransition.bind(this.workspace), 500), this.fireZoomEvent(), Oe(), e.stopPropagation(), e.preventDefault();
          }
          fireZoomEvent() {
            let e = new (S(d.CLICK))(null, this.workspace.id, "zoom_controls");
            R(e);
          }
        };
        pt(`
.blocklyZoom>image, .blocklyZoom>svg>image {
  opacity: .4;
}

.blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {
  opacity: .6;
}

.blocklyZoom>image:active, .blocklyZoom>svg>image:active {
  opacity: .8;
}
`);
        var TT = {};
        TT.ZoomControls = Bu;
        var Kg = 100, jg = 75, Jg = 50, qg = 25, ET = { BLOCKS: Jg, PROCEDURES: jg, VARIABLES: Kg, WORKSPACE_COMMENTS: qg }, xu = {};
        xu.register = ni, xu.unregister = h$;
        var aL = yo, Zg = class {
          constructor() {
            this.priority = qg;
          }
          save(e) {
            let t = [];
            for (let o of e.getTopComments()) (e = yo(o, { addCoordinates: true, saveIds: true })) && t.push(e);
            return t.length ? t : null;
          }
          load(e, t) {
            for (let o of e) li(o, t, { recordUndo: we() });
          }
          clear(e) {
            for (let t of e.getTopComments()) t.dispose();
          }
        };
        ni("workspaceComments", new Zg());
        var Ln = {};
        Ln.WorkspaceCommentSerializer = Zg, Ln.append = li, Ln.save = yo;
        var Fu = {};
        Fu.register = Fr, Fu.unregister = d$;
        var Di = class {
          paste(e, t, o) {
            e = e.commentState, o && (e.x = o.x, e.y = o.y), r.disable$$module$build$src$core$events$utils();
            let s;
            try {
              s = li(e, t), $$(s);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
            return s ? (J() && R(new (S(d.COMMENT_CREATE))(s)), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(s), s) : null;
          }
        };
        Di.TYPE = "workspace-comment", Fr(Di.TYPE, new Di());
        var bT = {};
        bT.WorkspaceCommentPaster = Di;
        var Hu, fT;
        Hu = 28, r.config$$module$build$src$core$config = { dragRadius: 5, flyoutDragRadius: 10, snapRadius: Hu, connectingSnapRadius: Hu, currentConnectionPreference: 8, bumpDelay: 250 }, fT = { config: r.config$$module$build$src$core$config };
        var IT = "aria-", yT = "role", Ue;
        (function(e) {
          e.GRID = "grid", e.GRIDCELL = "gridcell", e.GROUP = "group", e.LISTBOX = "listbox", e.MENU = "menu", e.MENUITEM = "menuitem", e.MENUITEMCHECKBOX = "menuitemcheckbox", e.OPTION = "option", e.PRESENTATION = "presentation", e.ROW = "row", e.TREE = "tree", e.TREEITEM = "treeitem", e.SEPARATOR = "separator", e.STATUS = "status";
        })(Ue || (Ue = {}));
        var ne;
        (function(e) {
          e.ACTIVEDESCENDANT = "activedescendant", e.COLCOUNT = "colcount", e.DISABLED = "disabled", e.EXPANDED = "expanded", e.INVALID = "invalid", e.LABEL = "label", e.LABELLEDBY = "labelledby", e.LEVEL = "level", e.ORIENTATION = "orientation", e.POSINSET = "posinset", e.ROWCOUNT = "rowcount", e.SELECTED = "selected", e.SETSIZE = "setsize", e.VALUEMAX = "valuemax", e.VALUEMIN = "valuemin", e.LIVE = "live", e.HIDDEN = "hidden";
        })(ne || (ne = {}));
        var Pi = {};
        Pi.Role = Ue, Pi.State = ne, Pi.setRole = mt, Pi.setState = ae;
        var Bi = class {
          constructor(e, t) {
            this.content = e, this.opt_value = t, this.enabled = true, this.element = null, this.rightToLeft = false, this.roleName = null, this.highlight = this.checked = this.checkable = false, this.actionHandler = null;
          }
          createDom() {
            let e = document.createElement("div");
            e.id = Xe(), this.element = e, e.className = "blocklyMenuItem " + (this.enabled ? "" : "blocklyMenuItemDisabled ") + (this.checked ? "blocklyMenuItemSelected " : "") + (this.highlight ? "blocklyMenuItemHighlight " : "") + (this.rightToLeft ? "blocklyMenuItemRtl " : "");
            let t = document.createElement("div");
            if (t.className = "blocklyMenuItemContent", this.checkable) {
              var o = document.createElement("div");
              o.className = "blocklyMenuItemCheckbox ", t.appendChild(o);
            }
            return o = this.content, typeof this.content == "string" && (o = document.createTextNode(this.content)), t.appendChild(o), e.appendChild(t), this.roleName && mt(e, this.roleName), ae(e, ne.SELECTED, this.checkable && this.checked || false), ae(e, ne.DISABLED, !this.enabled), e;
          }
          dispose() {
            this.element = null;
          }
          getElement() {
            return this.element;
          }
          getId() {
            return this.element.id;
          }
          getValue() {
            let e;
            return (e = this.opt_value) != null ? e : null;
          }
          setRightToLeft(e) {
            this.rightToLeft = e;
          }
          setRole(e) {
            this.roleName = e;
          }
          setCheckable(e) {
            this.checkable = e;
          }
          setChecked(e) {
            this.checked = e;
          }
          setHighlighted(e) {
            this.highlight = e;
            let t = this.getElement();
            t && this.isEnabled() && (e ? I(t, "blocklyMenuItemHighlight") : P(t, "blocklyMenuItemHighlight"));
          }
          isEnabled() {
            return this.enabled;
          }
          setEnabled(e) {
            this.enabled = e;
          }
          performAction(e) {
            this.isEnabled() && this.actionHandler && this.actionHandler(this, e);
          }
          onAction(e, t) {
            this.actionHandler = e.bind(t);
          }
        }, CT = {};
        CT.MenuItem = Bi;
        var Nn = class {
          constructor() {
            this.menuItems = [], this.roleName = this.element = this.onKeyDownHandler = this.pointerLeaveHandler = this.pointerEnterHandler = this.clickHandler = this.pointerMoveHandler = this.highlightedItem = this.openingCoords = null;
          }
          addChild(e) {
            this.menuItems.push(e);
          }
          render(e) {
            let t = document.createElement("div");
            t.className = "blocklyMenu", t.tabIndex = 0, this.roleName && mt(t, this.roleName), this.element = t;
            for (let o = 0, s; s = this.menuItems[o]; o++) t.appendChild(s.createDom());
            return this.pointerMoveHandler = w(t, "pointermove", this, this.handlePointerMove, true), this.clickHandler = w(t, "pointerup", this, this.handleClick, true), this.pointerEnterHandler = w(t, "pointerenter", this, this.handlePointerEnter, true), this.pointerLeaveHandler = w(t, "pointerleave", this, this.handlePointerLeave, true), this.onKeyDownHandler = w(t, "keydown", this, this.handleKeyEvent), e.appendChild(t), t;
          }
          getElement() {
            return this.element;
          }
          focus() {
            let e = this.getElement();
            e && e.focus({ preventScroll: true });
          }
          blur() {
            let e = this.getElement();
            e && e.blur();
          }
          setRole(e) {
            this.roleName = e;
          }
          dispose() {
            this.pointerMoveHandler && (x(this.pointerMoveHandler), this.pointerMoveHandler = null), this.clickHandler && (x(this.clickHandler), this.clickHandler = null), this.pointerEnterHandler && (x(this.pointerEnterHandler), this.pointerEnterHandler = null), this.pointerLeaveHandler && (x(this.pointerLeaveHandler), this.pointerLeaveHandler = null), this.onKeyDownHandler && (x(this.onKeyDownHandler), this.onKeyDownHandler = null);
            for (let e = 0, t; t = this.menuItems[e]; e++) t.dispose();
            this.element = null;
          }
          getMenuItem(e) {
            let t = this.getElement();
            for (; e && e !== t; ) {
              if (e.classList.contains("blocklyMenuItem")) {
                let o = this.getMenuItems();
                for (let s = 0, i; i = o[s]; s++) if (i.getElement() === e) return i;
              }
              e = e.parentElement;
            }
            return null;
          }
          setHighlighted(e) {
            var t = this.highlightedItem;
            if (t && (t.setHighlighted(false), this.highlightedItem = null), e) {
              e.setHighlighted(true), this.highlightedItem = e, t = this.getElement();
              let o = e.getElement();
              t && o && (ac(o, t), ae(t, ne.ACTIVEDESCENDANT, e.getId()));
            }
          }
          highlightNext() {
            let e = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
            this.highlightHelper(e, 1);
          }
          highlightPrevious() {
            let e = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
            this.highlightHelper(e < 0 ? this.menuItems.length : e, -1);
          }
          highlightFirst() {
            this.highlightHelper(-1, 1);
          }
          highlightLast() {
            this.highlightHelper(this.menuItems.length, -1);
          }
          highlightHelper(e, t) {
            e += t;
            let o, s = this.getMenuItems();
            for (; o = s[e]; ) {
              if (o.isEnabled()) {
                this.setHighlighted(o);
                break;
              }
              e += t;
            }
          }
          handlePointerMove(e) {
            Math.max(Math.abs(e.movementX), Math.abs(e.movementY)) !== 0 && (e = this.getMenuItem(e.target)) && (e.isEnabled() ? this.highlightedItem !== e && this.setHighlighted(e) : this.setHighlighted(null));
          }
          handleClick(e) {
            var t = this.openingCoords;
            if (this.openingCoords = null, t && typeof e.clientX == "number") {
              let o = new f(e.clientX, e.clientY);
              if (f.distance(t, o) < 1) return;
            }
            (t = this.getMenuItem(e.target)) && t.performAction(e);
          }
          handlePointerEnter(e) {
            this.focus();
          }
          handlePointerLeave(e) {
            this.getElement() && this.setHighlighted(null);
          }
          handleKeyEvent(e) {
            if (this.menuItems.length && !(e.shiftKey || e.ctrlKey || e.metaKey || e.altKey)) {
              var t = this.highlightedItem;
              switch (e.key) {
                case "Enter":
                case " ":
                  t && t.performAction(e);
                  break;
                case "ArrowUp":
                  this.highlightPrevious();
                  break;
                case "ArrowDown":
                  this.highlightNext();
                  break;
                case "PageUp":
                case "Home":
                  this.highlightFirst();
                  break;
                case "PageDown":
                case "End":
                  this.highlightLast();
                  break;
                default:
                  return;
              }
              e.preventDefault(), e.stopPropagation();
            }
          }
          getSize() {
            let e = this.getElement(), t = oi(e);
            return t.height = e.scrollHeight, t;
          }
          getMenuItems() {
            return this.menuItems.filter((e) => e instanceof Bi);
          }
        }, vT = {};
        vT.Menu = Nn;
        var Uu = class {
          constructor() {
            this.element = null;
          }
          createDom() {
            return this.element = document.createElement("hr"), this.element.className = "blocklyMenuSeparator", mt(this.element, Ue.SEPARATOR), this.element;
          }
          dispose() {
            let e;
            (e = this.element) == null || e.remove(), this.element = null;
          }
        }, kT = {};
        kT.MenuSeparator = Uu;
        var Cs = "_TEMP_COLLAPSED_INPUT", xi = "_TEMP_COLLAPSED_FIELD", Ke = "MANUALLY_DISABLED", RT = { COLLAPSED_FIELD_NAME: xi, COLLAPSED_INPUT_NAME: Cs, MANUALLY_DISABLED: Ke };
        (function(e) {
          e[e.VALUE = 1] = "VALUE", e[e.STATEMENT = 3] = "STATEMENT", e[e.DUMMY = 5] = "DUMMY", e[e.CUSTOM = 6] = "CUSTOM", e[e.END_ROW = 7] = "END_ROW";
        })(r.inputTypes$$module$build$src$core$inputs$input_types || (r.inputTypes$$module$build$src$core$inputs$input_types = {}));
        var ST = {};
        ST.inputTypes = r.inputTypes$$module$build$src$core$inputs$input_types;
        var OT = {};
        OT.isSerializable = cs;
        var An = /* @__PURE__ */ new Set(), Gu = /* @__PURE__ */ new WeakSet(), Vu = /* @__PURE__ */ new WeakMap(), vs = null, Wu = null, Qg = 0, Mn = {};
        Mn.finishQueuedRenders = _t, Mn.queueRender = gc, Mn.triggerQueuedRenders = jt;
        var zu, em;
        r.Msg$$module$build$src$core$msg = /* @__PURE__ */ Object.create(null), zu = function(e) {
          Object.keys(e).forEach(function(t) {
            r.Msg$$module$build$src$core$msg[t] = e[t];
          });
        }, em = { Msg: r.Msg$$module$build$src$core$msg, setLocale: zu };
        var Fi = "blocklyToast", tm = "blocklyToastMessage", om = "blocklyToastCloseButton", io = class {
          static show(e, t) {
            if (t.oncePerSession && t.id) {
              if (this.shownIds.has(t.id)) return;
              this.shownIds.add(t.id);
            }
            this.hide(e);
            let o = this.createDom(e, t);
            requestAnimationFrame(() => {
              o.style.bottom = "2rem";
            });
          }
          static createDom(e, t) {
            let { message: o, duration: s = 5, assertiveness: i = io.Assertiveness.POLITE } = t, n = document.createElement("div");
            e.getInjectionDiv().appendChild(n), n.dataset.toastId = t.id, n.className = Fi, mt(n, Ue.STATUS), ae(n, ne.LIVE, i), t = n.appendChild(document.createElement("div")), t.className = tm, t.innerText = o, t = n.appendChild(document.createElement("button")), t.className = om, ae(t, ne.LABEL, r.Msg$$module$build$src$core$msg.CLOSE);
            var l = b($.SVG, { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none" }, t);
            ae(l, ne.HIDDEN, true), b($.RECT, { x: 19.7782, y: 2.80762, width: 2, height: 24, transform: "rotate(45, 19.7782, 2.80762)", fill: "black" }, l), b($.RECT, { x: 2.80762, y: 4.22183, width: 2, height: 24, transform: "rotate(-45, 2.80762, 4.22183)", fill: "black" }, l), t.addEventListener("click", () => {
              n.remove(), e.markFocused();
            });
            let a;
            return t = () => {
              a = setTimeout(() => n.remove(), s * 1e3);
            }, l = () => clearTimeout(a), n.addEventListener("focusin", l), n.addEventListener("focusout", t), n.addEventListener("mouseenter", l), n.addEventListener("mousemove", l), n.addEventListener("mouseleave", t), t(), n;
          }
          static hide(e, t) {
            e = e.getInjectionDiv().querySelector(`.${Fi}`), e instanceof HTMLElement && (!t || t === e.dataset.toastId) && e.remove();
          }
        };
        io.shownIds = /* @__PURE__ */ new Set(), (function(e) {
          e = e.Assertiveness || (e.Assertiveness = {}), e.ASSERTIVE = "assertive", e.POLITE = "polite";
        })(io || (io = {})), pt(`
.${Fi} {
  font-size: 1.2rem;
  position: absolute;
  bottom: -10rem;
  right: 2rem;
  padding: 1rem;
  color: black;
  background-color: white;
  border: 2px solid black;
  border-radius: 0.4rem;
  z-index: 999;
  display: flex;
  align-items: center;
  gap: 0.8rem;
  line-height: 1.5;
  transition: bottom 0.3s ease-out;
}

.${Fi} .${tm} {
  maxWidth: 18rem;
}

.${Fi} .${om} {
  margin: 0;
  padding: 0.2rem;
  background-color: transparent;
  color: black;
  border: none;
  cursor: pointer;
}
`);
        var wT = {};
        wT.Toast = io;
        var sm = function(e, t) {
          window.alert(e), t && t();
        }, im = sm, rm = function(e, t) {
          t(window.confirm(e));
        }, nm = rm, lm = function(e, t, o) {
          o(window.prompt(e, t));
        }, cm = lm, am = io.show.bind(io), um = am, Ft = {};
        Ft.alert = ci, Ft.confirm = Ur, Ft.prompt = Gr, Ft.setAlert = _$, Ft.setConfirm = T$, Ft.setPrompt = E$, Ft.setToast = f$, Ft.toast = b$;
        var hm = {};
        hm.isLegacyProcedureCallBlock = Ec, hm.isLegacyProcedureDefBlock = Co;
        var LT = {};
        LT.isVariableBackedParameterModel = Vr;
        var dm = /* @__PURE__ */ new Set(), $m = {};
        $m.warn = me;
        var Dn = "VARIABLE", Xu = "ijkmnopqrstuvwxyzabcdefgh", pm = { generateUniqueNameInternal: y$ }, le = { CATEGORY_NAME: Dn, TEST_ONLY: pm, VAR_LETTER_OPTIONS: Xu };
        le.allDeveloperVariables = r.allDeveloperVariables$$module$build$src$core$variables, le.allUsedVarModels = r.allUsedVarModels$$module$build$src$core$variables, le.compareByName = as, le.createVariableButtonHandler = vo, le.deleteVariable = r.deleteVariable$$module$build$src$core$variables, le.flyoutCategory = bc, le.flyoutCategoryBlocks = fc, le.generateUniqueName = Ic, le.generateUniqueNameFromOptions = Yr, le.generateVariableFieldDom = ko, le.getAddedVariables = ai, le.getOrCreateVariablePackage = r.getOrCreateVariablePackage$$module$build$src$core$variables, le.getVariable = r.getVariable$$module$build$src$core$variables, le.getVariableUsesById = us, le.internalFlyoutCategory = Wr, le.jsonFlyoutCategoryBlocks = Xr, le.nameUsedWithAnyType = yc, le.nameUsedWithConflictingParam = Cc, le.promptName = Kr, le.renameVariable = r.renameVariable$$module$build$src$core$variables;
        var ks = class extends Error {
        }, gm = class extends ks {
          constructor(e) {
            super("Expected to find a 'type' property, defining the block type"), this.state = e;
          }
        }, Hi = class extends ks {
          constructor(e, t, o) {
            super(`The block ${t.toDevString()} is missing a(n) ${e}
connection`), this.block = t, this.state = o;
          }
        }, mm = class extends ks {
          constructor(e, t, o, s) {
            super(`The block ${o.toDevString()} could not connect its
${t} to its parent, because: ${e}`), this.childBlock = o, this.childState = s;
          }
        }, _m = class extends ks {
          constructor(e) {
            super(`Encountered a real block which is defined as a child of a shadow
block. It is an invariant of Blockly that shadow blocks only have shadow
children`), this.state = e;
          }
        }, Tm = class extends ks {
          constructor(e, t, o) {
            super(`Cannot add an icon of type '${e}' to the block ${t.toDevString()}, because there is no icon registered with type '${e}'. Make sure that all of your icons have been registered.`), this.block = t, this.state = o;
          }
        }, Ho = {};
        Ho.BadConnectionCheck = mm, Ho.DeserializationError = ks, Ho.MissingBlockType = gm, Ho.MissingConnection = Hi, Ho.RealChildOfShadow = _m, Ho.UnregisteredIcon = Tm;
        var uL = Be, Em = class {
          constructor() {
            this.priority = Jg;
          }
          save(e) {
            let t = [];
            for (let o of e.getTopBlocks(false)) (e = Be(o, { addCoordinates: true, doFullSerialization: false })) && t.push(e);
            return t.length ? { languageVersion: 0, blocks: t } : null;
          }
          load(e, t) {
            e = e.blocks;
            for (let o of e) Jt(o, t, { recordUndo: we() });
          }
          clear(e) {
            for (let t of e.getTopBlocks(false)) t.dispose(false);
          }
        };
        ni("blocks", new Em());
        var Ui = {};
        Ui.BlockSerializer = Em, Ui.append = Jt, Ui.appendInternal = hs, Ui.save = Be;
        var ue = class {
          constructor(e) {
            this.name = e;
          }
          toString() {
            return this.name;
          }
          equals(e) {
            return this.name === e.toString();
          }
        };
        ue.MUTATOR = new ue("mutator"), ue.WARNING = new ue("warning"), ue.COMMENT = new ue("comment");
        var NT = {};
        NT.IconType = ue;
        var AT = {};
        AT.hasBubble = qt;
        var ro = class extends Bo {
          constructor(e) {
            super(), this.isBlank = !e, e && (this.blockId = e.id, this.workspaceId = e.workspace.id);
          }
          toJson() {
            let e = super.toJson();
            if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            return e.blockId = this.blockId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new ro()), t.blockId = e.blockId, t;
          }
        }, MT = {};
        MT.BlockBase = ro;
        var no = class extends ro {
          constructor(e, t, o, s, i) {
            super(e), this.type = d.BLOCK_CHANGE, e && (this.element = t, this.name = o || void 0, this.oldValue = s, this.newValue = i);
          }
          toJson() {
            let e = super.toJson();
            if (!this.element) throw Error("The changed element is undefined. Either pass an element to the constructor, or call fromJson");
            return e.element = this.element, e.name = this.name, e.oldValue = this.oldValue, e.newValue = this.newValue, this.disabledReason && (e.disabledReason = this.disabledReason), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new no()), t.element = e.element, t.name = e.name, t.oldValue = e.oldValue, t.newValue = e.newValue, e.disabledReason !== void 0 && (t.disabledReason = e.disabledReason), t;
          }
          setDisabledReason(e) {
            if (this.element !== "disabled") throw Error('Cannot set the disabled reason for a BlockChange event if the element is not "disabled".');
            this.disabledReason = e;
          }
          isNull() {
            return this.oldValue === this.newValue;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            if (t = t.getBlockById(this.blockId), !t) throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
            let o = t.getIcon(ue.MUTATOR);
            switch (o && qt(o) && o.bubbleIsVisible() && o.setBubbleVisible(false), e = e ? this.newValue : this.oldValue, this.element) {
              case "field":
                (t = t.getField(this.name)) ? t.setValue(e) : console.warn("Can't set non-existent field: " + this.name);
                break;
              case "comment":
                t.setCommentText(e || null);
                break;
              case "collapsed":
                t.setCollapsed(!!e);
                break;
              case "disabled":
                var s;
                t.setDisabledReason(!!e, (s = this.disabledReason) != null ? s : Ke);
                break;
              case "inline":
                t.setInputsInline(!!e);
                break;
              case "mutation":
                s = no.getExtraBlockState_(t), t.loadExtraState ? t.loadExtraState(JSON.parse(e || "{}")) : t.domToMutation && t.domToMutation(r.textToDom$$module$build$src$core$utils$xml(e || "<mutation/>")), R(new no(t, "mutation", null, s, e));
                break;
              default:
                console.warn("Unknown change type: " + this.element);
            }
          }
          static getExtraBlockState_(e) {
            return e.saveExtraState ? (e = e.saveExtraState(true)) ? JSON.stringify(e) : "" : e.mutationToDom && (e = e.mutationToDom()) ? Et(e) : "";
          }
        };
        c(E.EVENT, d.BLOCK_CHANGE, no);
        var DT = {};
        DT.BlockChange = no;
        var Pn = {};
        Pn.clamp = ds, Pn.toDegrees = z$, Pn.toRadians = jr;
        var Gi = 16, Yu = 1, bm = 12, Ku = 16, Bn = 0.25, ju = null, Uo = null, fm = "", Im = "", oe, Vi, Go, Ju = null, lo = null, ym = null, xn = null, Fn = null, Hn = { getBoundsInfo: function() {
          let e = Kt(Ju), t = oi(Ju);
          return { left: e.x, right: e.x + t.width, top: e.y, bottom: e.y + t.height, width: t.width, height: t.height };
        }, getPositionMetrics: function(e, t, o, s) {
          let i = Hn.getBoundsInfo(), n = oi(oe);
          return t + n.height < i.bottom ? Pc(e, t, i, n) : s - n.height > i.top ? Bc(o, s, i, n) : t + n.height < document.documentElement.clientHeight ? Pc(e, t, i, n) : s - n.height > document.documentElement.clientTop ? Bc(o, s, i, n) : Y$(e, i, n);
        } }, hL = Hn, fe = { ANIMATION_TIME: Bn, ARROW_HORIZONTAL_PADDING: bm, ARROW_SIZE: Gi, BORDER_SIZE: Yu, PADDING_Y: Ku, TEST_ONLY: Hn };
        fe.clearContent = Zr, fe.createDom = Jr, fe.getContentDiv = qr, fe.getOwner = Oc, fe.getPositionX = ui, fe.hide = en, fe.hideIfOwner = Qr, fe.hideWithoutAnimation = Tt, fe.isVisible = xc, fe.repositionForWindowResize = Hc, fe.setBoundsElement = Sc, fe.setColour = wc, fe.show = Dc, fe.showPositionedByBlock = X$, fe.showPositionedByField = Lc;
        var Rs = {};
        Rs.commonWordPrefix = Uc, Rs.commonWordSuffix = Gc, Rs.isNumber = r.isNumber$$module$build$src$core$utils$string, Rs.shortestStringLength = hi, Rs.wrap = r.wrap$$module$build$src$core$utils$string;
        var Un = void 0, Wi = false, Ss = false, Cm = 50, vm = 0, Vo = 0, qu = 0, Zu = 0, je = null, zi = null, Qu = 0, eh = 10, km = 10, Rm = 750, Gn = 5, he = null, Ge = { HOVER_MS: Rm, LIMIT: Cm, MARGINS: Gn, OFFSET_X: Qu, OFFSET_Y: eh, RADIUS_OK: km };
        Ge.bindMouseEvents = di, Ge.block = jc, Ge.createDom = zc, Ge.dispose = Kc, Ge.getCustomTooltip = q$, Ge.getDiv = Q$, Ge.getTooltipOfObject = $s, Ge.hide = Lt, Ge.isVisible = Z$, Ge.setCustomTooltip = J$, Ge.unbindMouseEvents = Xc, Ge.unblock = Jc;
        var th = 0.45, oh = 0.65, Sm = { aqua: "#00ffff", black: "#000000", blue: "#0000ff", fuchsia: "#ff00ff", gray: "#808080", green: "#008000", lime: "#00ff00", maroon: "#800000", navy: "#000080", olive: "#808000", purple: "#800080", red: "#ff0000", silver: "#c0c0c0", teal: "#008080", white: "#ffffff", yellow: "#ffff00" }, Je = {};
        Je.blend = So, Je.getHsvSaturation = qc, Je.getHsvValue = Zc, Je.hexToRgb = on, Je.hsvToHex = sn, Je.hueToHex = Qc, Je.names = Sm, Je.parse = Ro, Je.rgbToHex = $i, Je.setHsvSaturation = np, Je.setHsvValue = lp;
        var Xi = {};
        Xi.checkMessageReferences = cp, Xi.parseBlockColour = ps, Xi.replaceMessageReferences = ie, Xi.tokenizeInterpolation = ea;
        var F = class {
          get size_() {
            return this.size;
          }
          set size_(e) {
            this.size = e;
          }
          constructor(e, t, o) {
            this.DEFAULT_VALUE = null, this.name = void 0, this.tooltip = this.validator_ = null, this.size = new N(0, 0), this.constants_ = this.mouseDownWrapper = this.textContent_ = this.textElement_ = this.borderRect_ = this.fieldGroup_ = null, this.disposed = false, this.maxDisplayLength = 50, this.sourceBlock_ = null, this.enabled_ = this.visible_ = this.isDirty_ = true, this.suffixField = this.prefixField = this.clickTarget_ = null, this.EDITABLE = true, this.SERIALIZABLE = false, this.id_ = null, this.value_ = "DEFAULT_VALUE" in new.target.prototype ? new.target.prototype.DEFAULT_VALUE : this.DEFAULT_VALUE, this.size_ = new N(0, 0), e !== F.SKIP_SETUP && (o && this.configure_(o), this.setValue(e), t && this.setValidator(t));
          }
          configure_(e) {
            e.tooltip && this.setTooltip(ie(e.tooltip));
          }
          setSourceBlock(e) {
            if (this.sourceBlock_) throw Error("Field already bound to a block");
            if (this.sourceBlock_ = e, e.id.includes("_field")) throw Error(`Field ID indicator is contained in block ID. This may cause problems with focus: ${e.id}.`);
            this.id_ = `${e.id}_field_${Xe()}`;
          }
          getConstants() {
            return !this.constants_ && this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && this.sourceBlock_.workspace.rendered && (this.constants_ = this.sourceBlock_.workspace.getRenderer().getConstants()), this.constants_;
          }
          getSourceBlock() {
            return this.sourceBlock_;
          }
          init() {
            if (!this.fieldGroup_) {
              var e = this.id_;
              if (!e) throw Error("Expected ID to be defined prior to init.");
              this.fieldGroup_ = b($.G, { id: e }), this.isVisible() || (this.fieldGroup_.style.display = "none"), this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_), this.initView(), this.updateEditable(), this.setTooltip(this.tooltip), this.bindEvents_(), this.initModel(), this.applyColour();
            }
          }
          initView() {
            this.createBorderRect_(), this.createTextElement_(), this.fieldGroup_ && I(this.fieldGroup_, "blocklyField");
          }
          initModel() {
          }
          isFullBlockField() {
            return !this.borderRect_;
          }
          createBorderRect_() {
            this.borderRect_ = b($.RECT, { rx: this.getConstants().FIELD_BORDER_RECT_RADIUS, ry: this.getConstants().FIELD_BORDER_RECT_RADIUS, x: 0, y: 0, height: this.size_.height, width: this.size_.width, class: "blocklyFieldRect" }, this.fieldGroup_);
          }
          createTextElement_() {
            this.textElement_ = b($.TEXT, { class: "blocklyText blocklyFieldText" }, this.fieldGroup_), this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.textElement_.setAttribute("dominant-baseline", "central"), this.textContent_ = document.createTextNode(""), this.textElement_.appendChild(this.textContent_);
          }
          bindEvents_() {
            let e = this.getClickTarget_();
            if (!e) throw Error("A click target has not been set.");
            di(e), this.mouseDownWrapper = w(e, "pointerdown", this, this.onMouseDown_);
          }
          fromXml(e) {
            this.setValue(e.textContent);
          }
          toXml(e) {
            return e.textContent = this.getValue(), e;
          }
          saveState(e) {
            return e = this.saveLegacyState(F), e !== null ? e : this.getValue();
          }
          loadState(e) {
            this.loadLegacyState(F, e) || this.setValue(e);
          }
          saveLegacyState(e) {
            return e.prototype.saveState === this.saveState && e.prototype.toXml !== this.toXml ? (e = r.createElement$$module$build$src$core$utils$xml("field"), e.setAttribute("name", this.name || ""), ls(this.toXml(e)).replace(' xmlns="https://developers.google.com/blockly/xml"', "")) : null;
          }
          loadLegacyState(e, t) {
            return e.prototype.loadState === this.loadState && e.prototype.fromXml !== this.fromXml ? (this.fromXml(r.textToDom$$module$build$src$core$utils$xml(t)), true) : false;
          }
          dispose() {
            Qr(this), Oo(this);
            let e;
            (e = this.getSourceBlock()) != null && e.isDeadOrDying() || V(this.fieldGroup_), this.disposed = true;
          }
          updateEditable() {
            let e = this.fieldGroup_, t = this.getSourceBlock();
            this.EDITABLE && e && t && (this.enabled_ && t.isEditable() ? (I(e, "blocklyEditableField"), P(e, "blocklyNonEditableField")) : (I(e, "blocklyNonEditableField"), P(e, "blocklyEditableField")));
          }
          setEnabled(e) {
            this.enabled_ = e, this.updateEditable();
          }
          isEnabled() {
            return this.enabled_;
          }
          isClickable() {
            return this.enabled_ && !!this.sourceBlock_ && this.sourceBlock_.isEditable() && this.showEditor_ !== F.prototype.showEditor_;
          }
          isClickableInFlyout(e) {
            return !e;
          }
          isCurrentlyEditable() {
            return this.enabled_ && this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable();
          }
          isSerializable() {
            let e = false;
            return this.name && (this.SERIALIZABLE ? e = true : this.EDITABLE && (console.warn("Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization."), e = true)), e;
          }
          isVisible() {
            return this.visible_;
          }
          setVisible(e) {
            if (this.visible_ !== e) {
              this.visible_ = e;
              var t = this.fieldGroup_;
              t && (t.style.display = e ? "block" : "none");
            }
          }
          setValidator(e) {
            this.validator_ = e;
          }
          getValidator() {
            return this.validator_;
          }
          getSvgRoot() {
            return this.fieldGroup_;
          }
          getBorderRect() {
            if (!this.borderRect_) throw Error(`The border rectangle is ${this.borderRect_}.`);
            return this.borderRect_;
          }
          getTextElement() {
            if (!this.textElement_) throw Error(`The text element is ${this.textElement_}.`);
            return this.textElement_;
          }
          getTextContent() {
            if (!this.textContent_) throw Error(`The text content is ${this.textContent_}.`);
            return this.textContent_;
          }
          applyColour() {
          }
          render_() {
            this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_()), this.updateSize_();
          }
          showEditor(e) {
            this.isClickable() && this.showEditor_(e);
          }
          showEditor_(e) {
          }
          repositionForWindowResize() {
            return false;
          }
          updateSize_(e) {
            let t = this.getConstants();
            e = e !== void 0 ? e : this.isFullBlockField() ? 0 : this.getConstants().FIELD_BORDER_RECT_X_PADDING;
            let o = e * 2, s = t.FIELD_TEXT_HEIGHT, i = 0;
            this.textElement_ && (i = ss(this.textElement_), o += i), this.isFullBlockField() || (s = Math.max(s, t.FIELD_BORDER_RECT_HEIGHT)), this.size_ = new N(o, s), this.positionTextElement_(e, i), this.positionBorderRect_();
          }
          positionTextElement_(e, t) {
            if (this.textElement_) {
              var o = this.getConstants(), s = this.size_.height / 2, i;
              this.textElement_.setAttribute("x", String((i = this.getSourceBlock()) != null && i.RTL ? this.size_.width - t - e : e)), this.textElement_.setAttribute("y", String(o.FIELD_TEXT_BASELINE_CENTER ? s : s - o.FIELD_TEXT_HEIGHT / 2 + o.FIELD_TEXT_BASELINE));
            }
          }
          positionBorderRect_() {
            this.borderRect_ && (this.borderRect_.setAttribute("width", String(this.size_.width)), this.borderRect_.setAttribute("height", String(this.size_.height)), this.borderRect_.setAttribute("rx", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)), this.borderRect_.setAttribute("ry", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)));
          }
          getSize() {
            return this.isVisible() ? (this.isDirty_ && (this.render_(), this.isDirty_ = false), this.size_) : new N(0, 0);
          }
          getScaledBBox() {
            let e;
            var t = this.getSourceBlock();
            if (!t) throw new se();
            if (this.isFullBlockField()) {
              var o = this.sourceBlock_.getHeightWidth();
              let s = t.workspace.scale;
              e = this.getAbsoluteXY_(), t = (o.width + 1) * s, o = (o.height + 1) * s, Rg ? (e.x += 1.5 * s, e.y += 1.5 * s) : (e.x -= 0.5 * s, e.y -= 0.5 * s);
            } else o = this.borderRect_.getBoundingClientRect(), e = Kt(this.borderRect_), t = o.width, o = o.height;
            return new L(e.y, e.y + o, e.x, e.x + t);
          }
          onLocationChange(e) {
          }
          getDisplayText_() {
            let e = this.getText();
            return e.length > this.maxDisplayLength && (e = e.substring(0, this.maxDisplayLength - 2) + "\u2026"), e = e.replace(/\s/g, F.NBSP), this.sourceBlock_ && this.sourceBlock_.RTL && (e += "\u200F"), e;
          }
          getText() {
            let e = this.getText_();
            return String(e !== null ? e : this.getValue());
          }
          getText_() {
            return null;
          }
          markDirty() {
            this.isDirty_ = true, this.constants_ = null;
          }
          forceRerender() {
            this.isDirty_ = true, this.sourceBlock_ && this.sourceBlock_.rendered && this.sourceBlock_.queueRender();
          }
          setValue(e, t = true) {
            if (e !== null) {
              var o = r.getGroup$$module$build$src$core$events$utils();
              o || r.setGroup$$module$build$src$core$events$utils(true);
              try {
                let _ = this.doClassValidation_(e), v = this.processValidation(e, _, t);
                if (!(v instanceof Error)) {
                  var s, i = (s = this.getValidator()) == null ? void 0 : s.call(this, v), n = this.processValidation(v, i, t);
                  if (!(n instanceof Error)) {
                    var l = this.sourceBlock_;
                    if (!l || !l.disposed) {
                      var a = this.getValue();
                      a === n ? this.doValueUpdate_(n) : (this.doValueUpdate_(n), t && l && J() && R(new (S(d.BLOCK_CHANGE))(l, "field", this.name || null, a, n)), this.isDirty_ && this.forceRerender());
                    }
                  }
                }
              } finally {
                r.setGroup$$module$build$src$core$events$utils(o);
              }
            }
          }
          processValidation(e, t, o) {
            return t === null ? (this.doValueInvalid_(e, o), this.isDirty_ && this.forceRerender(), Error()) : t === void 0 ? e : t;
          }
          getValue() {
            return this.value_;
          }
          doClassValidation_(e) {
            return e ?? null;
          }
          doValueUpdate_(e) {
            this.value_ = e, this.isDirty_ = true;
          }
          doValueInvalid_(e, t) {
          }
          onMouseDown_(e) {
            this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && (e = this.sourceBlock_.workspace.getGesture(e)) && e.setStartField(this);
          }
          setTooltip(e) {
            e || e === "" || (e = this.sourceBlock_);
            let t = this.getClickTarget_();
            t ? t.tooltip = e : this.tooltip = e;
          }
          getTooltip() {
            let e = this.getClickTarget_();
            return $s(e || { tooltip: this.tooltip });
          }
          getClickTarget_() {
            return this.clickTarget_ || this.getSvgRoot();
          }
          getAbsoluteXY_() {
            return Kt(this.getClickTarget_());
          }
          referencesVariables() {
            return false;
          }
          refreshVariableName() {
          }
          getParentInput() {
            let e = null, t = this.getSourceBlock();
            if (!t) throw new se();
            let o = t.inputList;
            for (let s = 0; s < t.inputList.length; s++) {
              let i = o[s], n = i.fieldRow;
              for (let l = 0; l < n.length; l++) if (n[l] === this) {
                e = i;
                break;
              }
            }
            return e;
          }
          getFlipRtl() {
            return false;
          }
          onShortcut(e) {
            return false;
          }
          getFocusableElement() {
            if (!this.fieldGroup_) throw Error("This field currently has no representative DOM element.");
            return this.fieldGroup_;
          }
          getFocusableTree() {
            let e = this.getSourceBlock();
            if (!e) throw new se();
            return e.workspace;
          }
          onNodeFocus() {
            let e = this.getSourceBlock();
            e.workspace.scrollBoundsIntoView(e.getBoundingRectangleWithoutChildren());
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
          static fromJson(e) {
            throw Error("Attempted to instantiate a field from the registry that hasn't defined a 'fromJson' method.");
          }
        };
        F.NBSP = "\xA0", F.SKIP_SETUP = Symbol("SKIP_SETUP");
        var se = class extends Error {
          constructor() {
            super("The field has not yet been attached to its input. Call appendField to attach it.");
          }
        }, Om = {};
        Om.Field = F, Om.UnattachedFieldError = se;
        var Os = null, wm = null, Vn = null, sh = "blocklyWidgetDiv", ws = "", Ls = "", Ve, Wn = null, ot = {};
        ot.createDom = ta, ot.getDiv = gs, ot.hide = ms, ot.hideIfOwner = Oo, ot.hideIfOwnerIsInWorkspace = pi, ot.isVisible = oa, ot.positionWithAnchor = ia, ot.repositionForWindowResize = ra, ot.show = nn, ot.testOnly_setDiv = ap;
        var zn = null, Lm = {}, Xn = null, Wo = {};
        Wo.callbackFactory = r.callbackFactory$$module$build$src$core$contextmenu, Wo.dispose = la, Wo.getCurrentBlock = $p, Wo.hide = gi, Wo.setCurrentBlock = na, Wo.show = _s;
        var M = class {
          constructor() {
            this.registeredItems = /* @__PURE__ */ new Map(), this.reset();
          }
          reset() {
            this.registeredItems.clear();
          }
          register(e) {
            if (this.registeredItems.has(e.id)) throw Error('Menu item with ID "' + e.id + '" is already registered.');
            this.registeredItems.set(e.id, e);
          }
          unregister(e) {
            if (!this.registeredItems.has(e)) throw Error('Menu item with ID "' + e + '" not found.');
            this.registeredItems.delete(e);
          }
          getItem(e) {
            let t;
            return (t = this.registeredItems.get(e)) != null ? t : null;
          }
          getContextMenuOptions(e, t) {
            let o = [];
            for (let s of this.registeredItems.values()) {
              if (s.scopeType && (s.scopeType === Yn.BLOCK && !e.block || s.scopeType === Yn.COMMENT && !e.comment || s.scopeType === Yn.WORKSPACE && !e.workspace)) continue;
              let i;
              if (i = { scope: e, weight: s.weight }, s.separator) i = Object.assign({}, i, { separator: true });
              else {
                let n = s.preconditionFn(e, t);
                if (n === "hidden") continue;
                let l = typeof s.displayText == "function" ? s.displayText(e) : s.displayText;
                i = Object.assign({}, i, { text: l, callback: s.callback, enabled: n === "enabled" });
              }
              o.push(i);
            }
            return o.sort(function(s, i) {
              return s.weight - i.weight;
            }), o;
          }
        };
        (function(e) {
          var t = e.ScopeType || (e.ScopeType = {});
          t.BLOCK = "block", t.WORKSPACE = "workspace", t.COMMENT = "comment", e.registry = new e();
        })(M || (M = {}));
        var Yn = M.ScopeType, Nm = {};
        Nm.ContextMenuRegistry = M, Nm.ScopeType = Yn;
        var co = 50, Kn = 100, PT = { BLOCK: co, BUBBLE: Kn }, ih = class {
          constructor(e) {
            this.comment = e, this.startLoc = null, this.workspace = e.workspace;
          }
          isMovable() {
            return this.comment.isOwnMovable() && !this.comment.isDeadOrDying() && !this.workspace.isReadOnly();
          }
          startDrag() {
            this.fireDragStartEvent(), this.startLoc = this.comment.getRelativeToSurfaceXY(), this.workspace.setResizesEnabled(false);
            let e;
            (e = this.workspace.getLayerManager()) == null || e.moveToDragLayer(this.comment), this.comment.setDragging(true);
          }
          drag(e) {
            this.comment.moveDuringDrag(e);
          }
          endDrag() {
            this.fireDragEndEvent(), this.fireMoveEvent();
            let e;
            (e = this.workspace.getLayerManager()) == null || e.moveOffDragLayer(this.comment, co), this.comment.setDragging(false), this.comment.snapToGrid(), this.workspace.setResizesEnabled(true);
          }
          fireDragStartEvent() {
            let e = new (S(d.COMMENT_DRAG))(this.comment, true);
            R(e);
          }
          fireDragEndEvent() {
            let e = new (S(d.COMMENT_DRAG))(this.comment, false);
            R(e);
          }
          fireMoveEvent() {
            if (!this.comment.isDeadOrDying()) {
              var e = new (S(d.COMMENT_MOVE))(this.comment);
              e.setReason(["drag"]), e.oldCoordinate_ = this.startLoc, e.recordNew(), R(e);
            }
          }
          revertDrag() {
            this.startLoc && this.comment.moveDuringDrag(this.startLoc);
          }
        }, BT = {};
        BT.CommentDragStrategy = ih;
        var Am = /* @__PURE__ */ new WeakMap(), Mm = {};
        Mm.move = _i, Mm.start = mi;
        var Yi = class {
          constructor(e, t, o, s) {
            this.id = e, this.workspace = t, this.container = o, this.commentView = s;
          }
          isVisible() {
            return this.icon.checkVisibility();
          }
          getCommentView() {
            return this.commentView;
          }
          getSize(e = false) {
            var t = this.icon.getBBox();
            return t = L.from(t), e && (e = this.getMargin(), t.left -= e, t.top -= e, t.bottom += e, t.right += e), t;
          }
          getMargin() {
            return (this.container.getBBox().height - this.icon.getBBox().height) / 2;
          }
          getFocusableElement() {
            return this.icon;
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            let e = this.getCommentView();
            var t = e.getRelativeToSurfaceXY();
            let o = e.getSize();
            t = new L(t.y, t.y + o.height, t.x, t.x + o.width), e.workspace.scrollBoundsIntoView(t);
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return this.isVisible();
          }
        }, xT = {};
        xT.CommentBarButton = Yi;
        var rh = "_collapse_bar_button", nh = class extends Yi {
          constructor(e, t, o, s) {
            super(e, t, o, s), this.id = e, this.workspace = t, this.container = o, this.commentView = s, this.icon = b($.IMAGE, { class: "blocklyFoldoutIcon", href: `${this.workspace.options.pathToMedia}foldout-icon.svg`, id: `${this.id}${rh}` }, this.container), this.bindId = w(this.icon, "pointerdown", this, this.performAction.bind(this));
          }
          dispose() {
            x(this.bindId);
          }
          reposition() {
            let e = this.getMargin();
            this.icon.setAttribute("y", `${e}`), this.icon.setAttribute("x", `${e}`);
          }
          performAction(e) {
            Oe(), this.getCommentView().bringToFront(), e && e instanceof PointerEvent && Qe(e) ? e.stopPropagation() : (this.getCommentView().setCollapsed(!this.getCommentView().isCollapsed()), this.workspace.hideChaff(), e?.stopPropagation());
          }
        }, FT = { COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER: rh };
        FT.CollapseCommentBarButton = nh;
        var jn = "_comment_textarea_", Ki = class {
          constructor(e, t, o) {
            this.workspace = e, this.onFinishEditing = o, this.textChangeListeners = [], this.text = "", this.foreignObject = b($.FOREIGNOBJECT, { class: "blocklyCommentForeignObject" }), e = document.createElementNS(Po, "body"), e.setAttribute("xmlns", Po), e.className = "blocklyMinimalBody", this.textArea = document.createElementNS(Po, "textarea"), this.textArea.setAttribute("tabindex", "-1"), this.textArea.setAttribute("dir", this.workspace.RTL ? "RTL" : "LTR"), I(this.textArea, "blocklyCommentText"), I(this.textArea, "blocklyTextarea"), I(this.textArea, "blocklyText"), e.appendChild(this.textArea), this.foreignObject.appendChild(e), t && (this.id = t + jn, this.textArea.setAttribute("id", this.id)), w(this.textArea, "change", this, this.onTextChange), w(this.textArea, "pointerdown", this, (s) => {
              s.stopPropagation(), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this), Oe();
            }), w(this.textArea, "wheel", this, (s) => {
              s.stopPropagation();
            }), w(this.textArea, "keydown", this, this.handleKeyDown);
          }
          getDom() {
            return this.foreignObject;
          }
          getText() {
            return this.text;
          }
          setText(e) {
            this.textArea.value = e, this.onTextChange();
          }
          onTextChange() {
            let e = this.text;
            this.text = this.textArea.value;
            for (let t = this.textChangeListeners.length - 1; t >= 0; t--) this.textChangeListeners[t](e, this.text);
          }
          handleKeyDown(e) {
            (e.key === "Escape" || e.key === "Enter" && (e.ctrlKey || e.metaKey)) && (this.onFinishEditing && this.onFinishEditing(), e.stopPropagation());
          }
          addTextChangeListener(e) {
            this.textChangeListeners.push(e);
          }
          removeTextChangeListener(e) {
            this.textChangeListeners.splice(this.textChangeListeners.indexOf(e), 1);
          }
          setPlaceholderText(e) {
            this.textArea.placeholder = e;
          }
          setEditable(e) {
            e ? this.textArea.removeAttribute("readonly") : this.textArea.setAttribute("readonly", "true");
          }
          updateSize(e, t) {
            this.foreignObject.setAttribute("height", `${e.height - t.height}`), this.foreignObject.setAttribute("width", `${e.width}`), this.foreignObject.setAttribute("y", `${t.height}`), this.workspace.RTL && this.foreignObject.setAttribute("x", `${-e.width}`);
          }
          getFocusableElement() {
            return this.textArea;
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            let e = L.from(this.foreignObject.getBoundingClientRect());
            this.workspace.scrollBoundsIntoView(L.createFromPoint(ii(this.workspace, e.getOrigin()), e.getWidth(), e.getHeight()));
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return !!this.id;
          }
        }, HT = { COMMENT_EDITOR_FOCUS_IDENTIFIER: jn };
        HT.CommentEditor = Ki;
        var lh = "_delete_bar_button", ch = class extends Yi {
          constructor(e, t, o, s) {
            super(e, t, o, s), this.id = e, this.workspace = t, this.container = o, this.commentView = s, this.icon = b($.IMAGE, { class: "blocklyDeleteIcon", href: `${this.workspace.options.pathToMedia}delete-icon.svg`, id: `${this.id}${lh}` }, o), this.bindId = w(this.icon, "pointerdown", this, this.performAction.bind(this));
          }
          dispose() {
            x(this.bindId);
          }
          reposition() {
            let e = this.getMargin();
            this.icon.setAttribute("x", "0");
            let t = this.container.getBBox();
            this.icon.setAttribute("y", `${e}`), this.icon.setAttribute("x", `${t.width - this.getSize(true).getWidth()}`);
          }
          performAction(e) {
            Oe(), e && e instanceof PointerEvent && Qe(e) ? e.stopPropagation() : (this.getCommentView().dispose(), e?.stopPropagation(), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.workspace));
          }
        }, UT = { COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER: lh };
        UT.DeleteCommentBarButton = ch;
        var Ns = class {
          constructor(e, t) {
            this.workspace = e, this.commentId = t, this.collapsed = false, this.editable = true, this.location = new f(0, 0), this.sizeChangeListeners = [], this.disposeListeners = [], this.collapseChangeListeners = [], this.resizePointerMoveListener = this.resizePointerUpListener = null, this.disposed = this.disposing = false, this.svgRoot = b($.G, { class: "blocklyComment blocklyEditable blocklyDraggable" }), this.highlightRect = this.createHighlightRect(this.svgRoot), { topBarGroup: this.topBarGroup, topBarBackground: this.topBarBackground, deleteButton: this.deleteButton, foldoutButton: this.foldoutButton, textPreview: this.textPreview, textPreviewNode: this.textPreviewNode } = this.createTopBar(this.svgRoot), this.commentEditor = this.createTextArea(), this.resizeHandle = this.createResizeHandle(this.svgRoot, e);
            let o;
            (o = e.getLayerManager()) == null || o.append(this, co), this.size = Ns.defaultCommentSize, this.setSizeWithoutFiringEvents(this.size), this.moveTo(new f(0, 0));
          }
          createHighlightRect(e) {
            return b($.RECT, { class: "blocklyCommentHighlight" }, e);
          }
          createTopBar(e) {
            e = b($.G, { class: "blocklyCommentTopbar" }, e);
            let t = b($.RECT, { class: "blocklyCommentTopbarBackground" }, e), o = new ch(this.commentId, this.workspace, e, this), s = new nh(this.commentId, this.workspace, e, this);
            this.addDisposeListener(() => {
              o.dispose(), s.dispose();
            });
            let i = b($.TEXT, { class: "blocklyCommentPreview blocklyCommentText blocklyText" }, e), n = document.createTextNode("");
            return i.appendChild(n), { topBarGroup: e, topBarBackground: t, deleteButton: o, foldoutButton: s, textPreview: i, textPreviewNode: n };
          }
          createTextArea() {
            let e = new Ki(this.workspace, this.commentId, () => this.svgRoot.focus());
            return this.svgRoot.appendChild(e.getDom()), e.addTextChangeListener((t, o) => {
              this.updateTextPreview(o), this.setSize(this.size);
            }), e;
          }
          getEditorFocusableNode() {
            return this.commentEditor;
          }
          createResizeHandle(e, t) {
            return e = b($.IMAGE, { class: "blocklyResizeHandle", href: `${t.options.pathToMedia}resize-handle.svg` }, e), w(e, "pointerdown", this, this.onResizePointerDown), e;
          }
          getSvgRoot() {
            return this.svgRoot;
          }
          getSize() {
            return this.collapsed ? this.topBarBackground.getBBox() : this.size;
          }
          setSizeWithoutFiringEvents(e) {
            let t = this.topBarBackground.getBBox(), o = this.textPreview.getBBox(), s = this.resizeHandle.getBBox();
            this.size = e = N.max(e, this.calcMinSize(t)), this.svgRoot.setAttribute("height", `${e.height}`), this.svgRoot.setAttribute("width", `${e.width}`), this.updateHighlightRect(e), this.updateTopBarSize(e), this.commentEditor.updateSize(e, t), this.deleteButton.reposition(), this.foldoutButton.reposition(), this.updateTextPreviewSize(e, t, o), this.updateResizeHandlePosition(e, s);
          }
          setSize(e) {
            let t = this.preResizeSize || this.size;
            this.setSizeWithoutFiringEvents(e), this.onSizeChange(t, this.size);
          }
          calcMinSize(e) {
            var t;
            this.updateTextPreview((t = this.commentEditor.getText()) != null ? t : "");
            let o = t = ss(this.textPreview);
            return this.foldoutButton.isVisible() ? o += this.foldoutButton.getSize(true).getWidth() : t && (o += 4), this.deleteButton.isVisible() ? o += this.deleteButton.getSize(true).getWidth() : t && (o += 4), new N(o, e.height + 20);
          }
          updateHighlightRect(e) {
            this.highlightRect.setAttribute("height", `${e.height}`), this.highlightRect.setAttribute("width", `${e.width}`), this.workspace.RTL && this.highlightRect.setAttribute("x", `${-e.width}`);
          }
          updateTopBarSize(e) {
            this.topBarBackground.setAttribute("width", `${e.width}`);
          }
          updateTextPreviewSize(e, t, o) {
            t = (t.height - o.height) / 2;
            let s = this.foldoutButton.getSize(true), i = this.deleteButton.getSize(true);
            e = e.width - s.getWidth() - i.getWidth(), this.textPreview.setAttribute("x", `${(this.workspace.RTL ? -1 : 1) * s.getWidth()}`), this.textPreview.setAttribute("y", `${t + o.height / 2}`), this.textPreview.setAttribute("width", `${e}`);
          }
          updateResizeHandlePosition(e, t) {
            this.resizeHandle.setAttribute("y", `${e.height - t.height}`), this.resizeHandle.setAttribute("x", `${e.width - t.width}`);
          }
          onSizeChange(e, t) {
            for (let o = this.sizeChangeListeners.length - 1; o >= 0; o--) this.sizeChangeListeners[o](e, t);
          }
          addSizeChangeListener(e) {
            this.sizeChangeListeners.push(e);
          }
          removeSizeChangeListener(e) {
            this.sizeChangeListeners.splice(this.sizeChangeListeners.indexOf(e), 1);
          }
          onResizePointerDown(e) {
            this.isEditable() && (this.bringToFront(), Qe(e) || (this.preResizeSize = this.getSize(), mi(this.workspace, e, new f(this.workspace.RTL ? -this.getSize().width : this.getSize().width, this.getSize().height)), this.resizePointerUpListener = w(document, "pointerup", this, this.onResizePointerUp), this.resizePointerMoveListener = w(document, "pointermove", this, this.onResizePointerMove), this.workspace.hideChaff()), e.stopPropagation());
          }
          onResizePointerUp(e) {
            Oe(), this.resizePointerUpListener && (x(this.resizePointerUpListener), this.resizePointerUpListener = null), this.resizePointerMoveListener && (x(this.resizePointerMoveListener), this.resizePointerMoveListener = null), this.setSize(this.size), this.preResizeSize = void 0;
          }
          onResizePointerMove(e) {
            e = _i(this.workspace, e), this.setSizeWithoutFiringEvents(new N(this.workspace.RTL ? -e.x : e.x, e.y));
          }
          isCollapsed() {
            return this.collapsed;
          }
          setCollapsed(e) {
            (this.collapsed = e) ? I(this.svgRoot, "blocklyCollapsed") : P(this.svgRoot, "blocklyCollapsed"), this.setSizeWithoutFiringEvents(this.size), this.onCollapse();
          }
          onCollapse() {
            for (let e = this.collapseChangeListeners.length - 1; e >= 0; e--) this.collapseChangeListeners[e](this.collapsed);
          }
          addOnCollapseListener(e) {
            this.collapseChangeListeners.push(e);
          }
          removeOnCollapseListener(e) {
            this.collapseChangeListeners.splice(this.collapseChangeListeners.indexOf(e), 1);
          }
          isEditable() {
            return this.editable;
          }
          setEditable(e) {
            (this.editable = e) ? (I(this.svgRoot, "blocklyEditable"), P(this.svgRoot, "blocklyReadonly")) : (P(this.svgRoot, "blocklyEditable"), I(this.svgRoot, "blocklyReadonly")), this.commentEditor.setEditable(e);
          }
          getRelativeToSurfaceXY() {
            return this.location;
          }
          moveTo(e) {
            this.location = e, this.svgRoot.setAttribute("transform", `translate(${e.x}, ${e.y})`);
          }
          getText() {
            return this.commentEditor.getText();
          }
          setText(e) {
            this.commentEditor.setText(e);
          }
          setPlaceholderText(e) {
            this.commentEditor.setPlaceholderText(e);
          }
          addTextChangeListener(e) {
            this.commentEditor.addTextChangeListener(e);
          }
          removeTextChangeListener(e) {
            this.commentEditor.removeTextChangeListener(e);
          }
          updateTextPreview(e) {
            this.textPreviewNode.textContent = this.truncateText(e);
          }
          truncateText(e) {
            return e.length >= 12 ? `${e.substring(0, 9)}...` : e;
          }
          bringToFront() {
            let e = this.svgRoot.parentNode, t = e.childNodes;
            t[t.length - 1] !== this.svgRoot && e.appendChild(this.svgRoot);
          }
          onDeleteDown(e) {
            Oe(), Qe(e) || this.dispose(), e.stopPropagation();
          }
          dispose() {
            this.disposing = true, V(this.svgRoot);
            for (let e = this.disposeListeners.length - 1; e >= 0; e--) this.disposeListeners[e]();
            this.disposeListeners.length = 0, this.disposed = true;
          }
          isDisposed() {
            return this.disposed;
          }
          isDeadOrDying() {
            return this.disposing || this.disposed;
          }
          addDisposeListener(e) {
            this.disposeListeners.push(e);
          }
          removeDisposeListener(e) {
            this.disposeListeners.splice(this.disposeListeners.indexOf(e), 1);
          }
          getCommentBarButtons() {
            return [this.foldoutButton, this.deleteButton];
          }
        };
        Ns.defaultCommentSize = new N(120, 100), pt(`
.injectionDiv {
  --commentFillColour: #FFFCC7;
  --commentBorderColour: #F2E49B;
}

.blocklyComment .blocklyTextarea {
  background-color: var(--commentFillColour);
  border: 1px solid var(--commentBorderColour);
  box-sizing: border-box;
  display: block;
  outline: 0;
  padding: 5px;
  resize: none;
  width: 100%;
  height: 100%;
}

.blocklyReadonly.blocklyComment .blocklyTextarea {
  cursor: inherit;
}

.blocklyDeleteIcon {
  width: 20px;
  height: 20px;
  display: none;
  cursor: pointer;
}

.blocklyFoldoutIcon {
  width: 20px;
  height: 20px;
  transform-origin: 12px 12px;
  cursor: pointer;
}
.blocklyResizeHandle {
  width: 12px;
  height: 12px;
  cursor: se-resize;
}
.blocklyReadonly.blocklyComment .blocklyResizeHandle {
  cursor: inherit;
}

.blocklyCommentTopbarBackground {
  fill: var(--commentBorderColour);
  height: 24px;
}

.blocklyComment .blocklyCommentPreview.blocklyText {
  fill: #000;
  dominant-baseline: middle;
  visibility: hidden;
}

.blocklyCollapsed.blocklyComment .blocklyCommentPreview {
  visibility: visible;
}

.blocklyCollapsed.blocklyComment .blocklyCommentForeignObject,
.blocklyCollapsed.blocklyComment .blocklyResizeHandle {
  display: none;
}

.blocklyCollapsed.blocklyComment .blocklyFoldoutIcon {
  transform: rotate(-90deg);
}

.blocklyRTL .blocklyCommentTopbar {
  transform: scale(-1, 1);
}

.blocklyRTL .blocklyCommentForeignObject {
  direction: rtl;
}

.blocklyRTL .blocklyCommentPreview {
  /* Revert the scale and control RTL using direction instead. */
  transform: scale(-1, 1);
  direction: rtl;
}

.blocklyRTL .blocklyResizeHandle {
  transform: scale(-1, 1);
  cursor: sw-resize;
}

.blocklyCommentHighlight {
  fill: none;
}

.blocklyCommentText.blocklyActiveFocus {
  border-color: #fc3;
  border-width: 2px;
}

.blocklySelected .blocklyCommentHighlight {
  stroke: #fc3;
  stroke-width: 3px;
}

.blocklyCollapsed.blocklySelected .blocklyCommentHighlight {
  stroke: none;
}

.blocklyCollapsed.blocklySelected .blocklyCommentTopbarBackground {
  stroke: #fc3;
  stroke-width: 3px;
}
`);
        var GT = {};
        GT.CommentView = Ns;
        var ji = class {
          constructor(e, t) {
            this.workspace = e, this.text = "", this.collapsed = false, this.deletable = this.movable = this.editable = true, this.location = new f(0, 0), this.disposing = this.disposed = false, this.id = t && !e.getCommentById(t) ? t : wt(), this.size = Ns.defaultCommentSize, e.addTopComment(this), this.fireCreateEvent();
          }
          fireCreateEvent() {
            J() && R(new (S(d.COMMENT_CREATE))(this));
          }
          fireDeleteEvent() {
            J() && R(new (S(d.COMMENT_DELETE))(this));
          }
          fireChangeEvent(e, t) {
            J() && R(new (S(d.COMMENT_CHANGE))(this, e, t));
          }
          fireCollapseEvent(e) {
            J() && R(new (S(d.COMMENT_COLLAPSE))(this, e));
          }
          setText(e) {
            let t = this.text;
            this.text = e, this.fireChangeEvent(t, e);
          }
          getText() {
            return this.text;
          }
          setSize(e) {
            let t = new (S(d.COMMENT_RESIZE))(this);
            this.size = e, t.recordCurrentSizeAsNewSize(), R(t);
          }
          getSize() {
            return this.size;
          }
          setCollapsed(e) {
            this.collapsed = e, this.fireCollapseEvent(e);
          }
          isCollapsed() {
            return this.collapsed;
          }
          setEditable(e) {
            this.editable = e;
          }
          isEditable() {
            return this.isOwnEditable() && !this.workspace.isReadOnly();
          }
          isOwnEditable() {
            return this.editable;
          }
          setMovable(e) {
            this.movable = e;
          }
          isMovable() {
            return this.isOwnMovable() && !this.workspace.isReadOnly() && !this.workspace.isFlyout;
          }
          isOwnMovable() {
            return this.movable;
          }
          setDeletable(e) {
            this.deletable = e;
          }
          isDeletable() {
            return this.isOwnDeletable() && !this.isDeadOrDying() && !this.workspace.isReadOnly() && !this.workspace.isFlyout;
          }
          isOwnDeletable() {
            return this.deletable;
          }
          moveTo(e, t) {
            let o = new (S(d.COMMENT_MOVE))(this);
            t && o.setReason(t), this.location = e, o.recordNew(), R(o);
          }
          getRelativeToSurfaceXY() {
            return this.location;
          }
          dispose() {
            this.disposing = true, this.fireDeleteEvent(), this.workspace.removeTopComment(this), this.disposed = true;
          }
          isDisposed() {
            return this.disposed;
          }
          isDeadOrDying() {
            return this.disposing || this.disposed;
          }
        }, VT = {};
        VT.WorkspaceComment = ji;
        var It = class extends ji {
          constructor(e, t) {
            super(e, t), this.dragStrategy = new ih(this), this.workspace = e, this.view = new Ns(e, this.id), this.view.setSize(this.getSize()), this.view.setEditable(this.isEditable()), this.view.getSvgRoot().setAttribute("data-id", this.id), this.view.getSvgRoot().setAttribute("id", this.id), this.addModelUpdateBindings(), w(this.view.getSvgRoot(), "pointerdown", this, this.startGesture);
          }
          addModelUpdateBindings() {
            this.view.addTextChangeListener((e, t) => void super.setText(t)), this.view.addSizeChangeListener((e, t) => void super.setSize(t)), this.view.addOnCollapseListener(() => void super.setCollapsed(this.view.isCollapsed())), this.view.addDisposeListener(() => {
              this.isDeadOrDying() || this.dispose();
            });
          }
          setText(e) {
            this.view.setText(e);
          }
          setPlaceholderText(e) {
            this.view.setPlaceholderText(e);
          }
          setSize(e) {
            this.view.setSize(e);
          }
          setCollapsed(e) {
            this.view.setCollapsed(e);
          }
          setEditable(e) {
            super.setEditable(e), this.view.setEditable(this.isEditable());
          }
          getSvgRoot() {
            return this.view.getSvgRoot();
          }
          getSize() {
            return super.getSize();
          }
          getBoundingRectangle() {
            let e = this.getRelativeToSurfaceXY();
            var t, o;
            let s = (o = (t = this.view) == null ? void 0 : t.getSize()) != null ? o : this.getSize();
            return this.workspace.RTL ? (t = e.x - s.width, o = e.x) : (t = e.x, o = e.x + s.width), new L(e.y, e.y + s.height, t, o);
          }
          moveBy(e, t, o) {
            let s = this.getRelativeToSurfaceXY();
            e = new f(s.x + e, s.y + t), this.moveTo(e, o);
          }
          moveTo(e, t) {
            super.moveTo(e, t), this.view.moveTo(e);
          }
          moveDuringDrag(e) {
            this.location = e, this.view.moveTo(e);
          }
          setDragging(e) {
            e ? I(this.getSvgRoot(), "blocklyDragging") : P(this.getSvgRoot(), "blocklyDragging");
          }
          dispose() {
            this.disposing = true;
            let e = r.getFocusManager$$module$build$src$core$focus_manager();
            e.getFocusedNode() === this && setTimeout(() => e.focusTree(this.workspace), 0), this.view.isDeadOrDying() || this.view.dispose(), super.dispose();
          }
          startGesture(e) {
            let t = this.workspace.getGesture(e);
            t && (t.handleCommentStart(e, this), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this));
          }
          setDeleteStyle(e) {
            e ? I(this.getSvgRoot(), "blocklyDraggingDelete") : P(this.getSvgRoot(), "blocklyDraggingDelete");
          }
          isCopyable() {
            return this.isOwnMovable() && this.isOwnDeletable();
          }
          isMovable() {
            return this.dragStrategy.isMovable();
          }
          startDrag() {
            this.dragStrategy.startDrag();
          }
          drag(e) {
            this.dragStrategy.drag(e);
          }
          endDrag() {
            this.dragStrategy.endDrag();
          }
          revertDrag() {
            this.dragStrategy.revertDrag();
          }
          select() {
            I(this.getSvgRoot(), "blocklySelected"), Xt(this);
          }
          unselect() {
            P(this.getSvgRoot(), "blocklySelected"), Xt(null);
          }
          toCopyData() {
            return { paster: Di.TYPE, commentState: yo(this, { addCoordinates: true, saveIds: false }) };
          }
          showContextMenu(e) {
            let t = M.registry.getContextMenuOptions({ comment: this, focusedNode: this }, e), o;
            o = e instanceof PointerEvent ? new f(e.clientX, e.clientY) : ns(this.workspace, this.getRelativeToSurfaceXY()).translate(10, 10), _s(e, t, this.workspace.RTL, this.workspace, o);
          }
          snapToGrid() {
            if (!this.isDeadOrDying()) {
              var e = this.workspace.getGrid();
              if (e != null && e.shouldSnap()) {
                var t = this.getRelativeToSurfaceXY();
                e = e.alignXY(t), e !== t && this.moveTo(e, ["snap"]);
              }
            }
          }
          getEditorFocusableNode() {
            return this.view.getEditorFocusableNode();
          }
          getFocusableElement() {
            return this.getSvgRoot();
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            this.select();
            let e;
            (e = this.workspace.getLayerManager()) == null || e.append(this, co), this.workspace.scrollBoundsIntoView(this.getBoundingRectangle());
          }
          onNodeBlur() {
            this.unselect();
          }
          canBeFocused() {
            return true;
          }
        }, WT = {};
        WT.RenderedWorkspaceComment = It;
        var ke = {};
        ke.appendDomToWorkspace = yp, ke.blockToDom = Zt, ke.blockToDomWithXY = Ei, ke.clearWorkspaceAndLoadFromXml = Ip, ke.deleteNext = Np, ke.domToBlock = r.domToBlock$$module$build$src$core$xml, ke.domToBlockInternal = wo, ke.domToPrettyText = fp, ke.domToText = Et, ke.domToVariables = da, ke.domToWorkspace = r.domToWorkspace$$module$build$src$core$xml, ke.loadWorkspaceComment = ha, ke.saveWorkspaceComment = Ti, ke.variablesToDom = aa, ke.workspaceToDom = Tp;
        var Jn = class extends ro {
          constructor(e) {
            super(e), this.type = d.BLOCK_CREATE, e && (e.isShadow() && (this.recordUndo = false), this.xml = Ei(e), this.ids = js(e), this.json = Be(e, { addCoordinates: true }));
          }
          toJson() {
            let e = super.toJson();
            if (!this.xml) throw Error("The block XML is undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.json) throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
            return e.xml = Et(this.xml), e.ids = this.ids, e.json = this.json, this.recordUndo || (e.recordUndo = this.recordUndo), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Jn()), t.xml = r.textToDom$$module$build$src$core$utils$xml(e.xml), t.ids = e.ids, t.json = e.json, e.recordUndo !== void 0 && (t.recordUndo = e.recordUndo), t;
          }
          run(e) {
            let t = this.getEventWorkspace_();
            if (!this.json) throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
            if (!zT(t, this.ids)) if (e) Jt(this.json, t);
            else for (e = 0; e < this.ids.length; e++) {
              let o = this.ids[e], s = t.getBlockById(o);
              s ? s.dispose(false) : o === this.blockId && console.warn("Can't uncreate non-existent block: " + o);
            }
          }
        }, zT = function(e, t) {
          return t.map((o) => e.getBlockById(o)).filter((o) => o && o.isShadow()).length === t.length;
        };
        c(E.EVENT, d.BLOCK_CREATE, Jn);
        var XT = {};
        XT.BlockCreate = Jn;
        var qn = class extends tt {
          constructor(e, t) {
            super(t), this.type = d.THEME_CHANGE, this.themeName = e;
          }
          toJson() {
            let e = super.toJson();
            if (!this.themeName) throw Error("The theme name is undefined. Either pass a theme name to the constructor, or call fromJson");
            return e.themeName = this.themeName, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new qn()), t.themeName = e.themeName, t;
          }
        };
        c(E.EVENT, d.THEME_CHANGE, qn);
        var YT = {};
        YT.ThemeChange = qn;
        var Zn = class extends tt {
          constructor(e, t, o, s, i) {
            super(s), this.type = d.VIEWPORT_CHANGE, this.viewTop = e, this.viewLeft = t, this.scale = o, this.oldScale = i;
          }
          toJson() {
            let e = super.toJson();
            if (this.viewTop === void 0) throw Error("The view top is undefined. Either pass a value to the constructor, or call fromJson");
            if (this.viewLeft === void 0) throw Error("The view left is undefined. Either pass a value to the constructor, or call fromJson");
            if (this.scale === void 0) throw Error("The scale is undefined. Either pass a value to the constructor, or call fromJson");
            if (this.oldScale === void 0) throw Error("The old scale is undefined. Either pass a value to the constructor, or call fromJson");
            return e.viewTop = this.viewTop, e.viewLeft = this.viewLeft, e.scale = this.scale, e.oldScale = this.oldScale, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Zn()), t.viewTop = e.viewTop, t.viewLeft = e.viewLeft, t.scale = e.scale, t.oldScale = e.oldScale, t;
          }
        };
        c(E.EVENT, d.VIEWPORT_CHANGE, Zn);
        var KT = {};
        KT.ViewportChange = Zn;
        var Dm = { fromJsonInternal: Mp }, Qn = { TEST_ONLY: Dm };
        Qn.fromJson = r.fromJson$$module$build$src$core$field_registry, Qn.register = bt, Qn.unregister = Ap;
        var be = class extends F {
          constructor(e, t, o) {
            super(F.SKIP_SETUP), this.svgArrow = this.arrow = this.imageElement = this.menu_ = this.selectedMenuItem = null, this.SERIALIZABLE = true, this.clickTarget_ = this.suffixField = this.prefixField = this.generatedOptions = null, e !== F.SKIP_SETUP && (this.setOptions(e), o && this.configure_(o), t && this.setValidator(t));
          }
          fromXml(e) {
            this.isOptionListDynamic() && this.getOptions(false), this.setValue(e.textContent);
          }
          loadState(e) {
            this.loadLegacyState(be, e) || (this.isOptionListDynamic() && this.getOptions(false), this.setValue(e));
          }
          initView() {
            this.shouldAddBorderRect_() ? this.createBorderRect_() : this.clickTarget_ = this.sourceBlock_.getSvgRoot(), this.createTextElement_(), this.imageElement = b($.IMAGE, {}, this.fieldGroup_), this.getConstants().FIELD_DROPDOWN_SVG_ARROW ? this.createSVGArrow_() : this.createTextArrow_(), this.borderRect_ && I(this.borderRect_, "blocklyDropdownRect"), this.fieldGroup_ && (I(this.fieldGroup_, "blocklyField"), I(this.fieldGroup_, "blocklyDropdownField"));
          }
          shouldAddBorderRect_() {
            let e;
            return !this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW && !((e = this.getSourceBlock()) != null && e.isShadow());
          }
          createTextArrow_() {
            this.arrow = b($.TSPAN, {}, this.textElement_);
            let e;
            this.arrow.appendChild(document.createTextNode((e = this.getSourceBlock()) != null && e.RTL ? be.ARROW_CHAR + " " : " " + be.ARROW_CHAR)), this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.arrow.setAttribute("dominant-baseline", "central");
            let t;
            (t = this.getSourceBlock()) != null && t.RTL ? this.getTextElement().insertBefore(this.arrow, this.textContent_) : this.getTextElement().appendChild(this.arrow);
          }
          createSVGArrow_() {
            this.svgArrow = b($.IMAGE, { height: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px", width: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px" }, this.fieldGroup_), this.svgArrow.setAttributeNS(He, "xlink:href", this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI);
          }
          showEditor_(e) {
            var t = this.getSourceBlock();
            if (!t) throw new se();
            this.dropdownCreate(), this.menu_ && (this.menu_.openingCoords = e && typeof e.clientX == "number" ? new f(e.clientX, e.clientY) : null, Zr(), e = this.menu_.render(qr()), I(e, "blocklyDropdownMenu"), this.getConstants().FIELD_DROPDOWN_COLOURED_DIV && (t = t.getColour(), e = this.sourceBlock_.getColourTertiary(), wc(t, e)), Lc(this, this.dropdownDispose_.bind(this)), qr().style.height = `${this.menu_.getSize().height}px`, this.menu_.focus(), this.selectedMenuItem && this.menu_.setHighlighted(this.selectedMenuItem), this.applyColour());
          }
          dropdownCreate() {
            let e = this.getSourceBlock();
            if (!e) throw new se();
            let t = new Nn();
            t.setRole(Ue.LISTBOX), this.menu_ = t;
            let o = this.getOptions(false);
            this.selectedMenuItem = null;
            for (let i = 0; i < o.length; i++) {
              var s = o[i];
              if (s === be.SEPARATOR) {
                t.addChild(new Uu());
                continue;
              }
              let [n, l] = s;
              Ts(n) ? (s = new Image(n.width, n.height), s.src = n.src, s.alt = n.alt) : s = n, s = new Bi(s, l), s.setRole(Ue.OPTION), s.setRightToLeft(e.RTL), s.setCheckable(true), t.addChild(s), s.setChecked(l === this.value_), l === this.value_ && (this.selectedMenuItem = s), s.onAction(this.handleMenuActionEvent, this);
            }
          }
          dropdownDispose_() {
            this.menu_ && this.menu_.dispose(), this.selectedMenuItem = this.menu_ = null, this.applyColour();
          }
          handleMenuActionEvent(e) {
            Qr(this, true), this.onItemSelected_(this.menu_, e);
          }
          onItemSelected_(e, t) {
            this.setValue(t.getValue());
          }
          isOptionListDynamic() {
            return typeof this.menuGenerator_ == "function";
          }
          getOptions(e) {
            if (!this.menuGenerator_) throw TypeError("A menu generator was never defined.");
            return Array.isArray(this.menuGenerator_) ? this.menuGenerator_ : e && this.generatedOptions ? this.generatedOptions : (this.generatedOptions = this.menuGenerator_(), this.validateOptions(this.generatedOptions), this.generatedOptions);
          }
          setOptions(e) {
            Array.isArray(e) ? (this.validateOptions(e), e = this.trimOptions(e), this.menuGenerator_ = e.options, this.prefixField = e.prefix || null, this.suffixField = e.suffix || null) : this.menuGenerator_ = e, this.selectedOption = this.getOptions(false)[0], this.setValue(this.selectedOption[1]);
          }
          doClassValidation_(e) {
            return this.getOptions(true).some((t) => t[1] === e) ? e : (this.sourceBlock_ && console.warn("Cannot set the dropdown's value to an unavailable option. Block type: " + this.sourceBlock_.type + ", Field name: " + this.name + ", Value: " + e), null);
          }
          doValueUpdate_(e) {
            super.doValueUpdate_(e), e = this.getOptions(true);
            for (let t = 0, o; o = e[t]; t++) o[1] === this.value_ && (this.selectedOption = o);
          }
          applyColour() {
            let e = this.sourceBlock_;
            this.borderRect_ && (this.borderRect_.setAttribute("stroke", e.getColourTertiary()), this.menu_ ? this.borderRect_.setAttribute("fill", e.getColourTertiary()) : this.borderRect_.setAttribute("fill", "transparent")), e && this.arrow && (e.isShadow() ? this.arrow.style.fill = e.getColourSecondary() : this.arrow.style.fill = e.getColour());
          }
          render_() {
            this.getTextContent().nodeValue = "", this.imageElement.style.display = "none";
            let e = this.selectedOption && this.selectedOption[0];
            Ts(e) ? this.renderSelectedImage(e) : this.renderSelectedText(), this.positionBorderRect_();
          }
          renderSelectedImage(e) {
            let t = this.getSourceBlock();
            if (!t) throw new se();
            this.imageElement.style.display = "", this.imageElement.setAttributeNS(He, "xlink:href", e.src), this.imageElement.setAttribute("height", String(e.height)), this.imageElement.setAttribute("width", String(e.width));
            let o = Number(e.height);
            e = Number(e.width);
            var s = !!this.borderRect_;
            let i = Math.max(s ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, o + be.IMAGE_Y_PADDING);
            s = s ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
            let n;
            n = this.svgArrow ? this.positionSVGArrow(e + s, i / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2) : ss(this.arrow), this.size_ = new N(e + n + s * 2, i);
            let l = 0;
            t.RTL ? this.imageElement.setAttribute("x", `${s + n}`) : (l = e + n, this.getTextElement().setAttribute("text-anchor", "end"), this.imageElement.setAttribute("x", `${s}`)), this.imageElement.setAttribute("y", String(i / 2 - o / 2)), this.positionTextElement_(l + s, e + n);
          }
          renderSelectedText() {
            this.getTextContent().nodeValue = this.getDisplayText_();
            var e = this.getTextElement();
            I(e, "blocklyDropdownText"), e.setAttribute("text-anchor", "start");
            var t = !!this.borderRect_;
            e = Math.max(t ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, this.getConstants().FIELD_TEXT_HEIGHT);
            let o = ss(this.getTextElement());
            t = t ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
            let s = 0;
            this.svgArrow && (s = this.positionSVGArrow(o + t, e / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2)), this.size_ = new N(o + s + t * 2, e), this.positionTextElement_(t, o);
          }
          positionSVGArrow(e, t) {
            if (!this.svgArrow) return 0;
            let o = this.getSourceBlock();
            if (!o) throw new se();
            let s = this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0, i = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING, n = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;
            return this.svgArrow.setAttribute("transform", "translate(" + (o.RTL ? s : e + i) + "," + t + ")"), n + i;
          }
          getText_() {
            if (!this.selectedOption) return null;
            let e = this.selectedOption[0];
            if (Ts(e)) return e.alt;
            if (typeof HTMLElement < "u" && e instanceof HTMLElement) {
              let t, o;
              return (o = (t = e.title) != null ? t : e.ariaLabel) != null ? o : e.innerText;
            }
            return typeof e == "string" ? e : (console.warn("Can't get text for existing dropdown option. If you're using HTMLElement dropdown options in node, ensure you're using jsdom-global or similar."), null);
          }
          static fromJson(e) {
            if (!e.options) throw Error("options are required for the dropdown field. The options property must be assigned an array of [humanReadableValue, languageNeutralValue] tuples.");
            return new this(e.options, void 0, e);
          }
          trimOptions(e) {
            let t = false, o = e.map((l) => {
              if (l === be.SEPARATOR) return t = true, l;
              let [a, _] = l;
              return typeof a == "string" ? [ie(a), _] : (t = true, [Ts(a) ? Object.assign({}, a, { alt: ie(a.alt) }) : a, _]);
            });
            if (t || e.length < 2) return { options: o };
            var s = o.map(([l]) => l), i = hi(s);
            e = Uc(s, i);
            let n = Gc(s, i);
            return !e && !n || i <= e + n ? { options: o } : (i = e ? s[0].substring(0, e - 1) : void 0, s = n ? s[0].substr(1 - n) : void 0, { options: this.applyTrim(o, e, n), prefix: i, suffix: s });
          }
          applyTrim(e, t, o) {
            return e.map(([s, i]) => [s.substring(t, s.length - o), i]);
          }
          validateOptions(e) {
            if (!Array.isArray(e)) throw TypeError("FieldDropdown options must be an array.");
            if (!e.length) throw TypeError("FieldDropdown options must not be an empty array.");
            let t = false;
            for (let o = 0; o < e.length; o++) {
              let s = e[o];
              Array.isArray(s) || s === be.SEPARATOR ? typeof s[1] != "string" ? (t = true, console.error(`Invalid option[${o}]: Each FieldDropdown option id must be a string.
          Found ${s[1]} in: ${s}`)) : !s[0] || typeof s[0] == "string" || Ts(s[0]) || typeof HTMLElement < "u" && s[0] instanceof HTMLElement || (t = true, console.error(`Invalid option[${o}]: Each FieldDropdown option must have a string
          label, image description, or HTML element. Found ${s[0]} in: ${s}`)) : (t = true, console.error(`Invalid option[${o}]: Each FieldDropdown option must be an array or
          the string literal 'separator'. Found: ${s}`));
            }
            if (t) throw TypeError("Found invalid FieldDropdown options.");
          }
        };
        be.SEPARATOR = "separator", be.ARROW_CHAR = "\u25BE", be.IMAGE_Y_OFFSET = 5, be.IMAGE_Y_PADDING = be.IMAGE_Y_OFFSET * 2, bt("field_dropdown", be);
        var jT = {};
        jT.FieldDropdown = be;
        var ao = class {
          constructor(e, t, o, s) {
            this.name = e, this.startHats = false, this.blockStyles = t || /* @__PURE__ */ Object.create(null), this.categoryStyles = o || /* @__PURE__ */ Object.create(null), this.componentStyles = s || /* @__PURE__ */ Object.create(null), this.fontStyle = /* @__PURE__ */ Object.create(null), c(E.THEME, e, this, true);
          }
          getClassName() {
            return this.name + "-theme";
          }
          setBlockStyle(e, t) {
            this.blockStyles[e] = t;
          }
          setCategoryStyle(e, t) {
            this.categoryStyles[e] = t;
          }
          getComponentStyle(e) {
            if (e = this.componentStyles[e], !e) return null;
            if (typeof e == "string") {
              let t = this.getComponentStyle(e);
              if (t) return t;
            }
            return `${e}`;
          }
          setComponentStyle(e, t) {
            this.componentStyles[e] = t;
          }
          setFontStyle(e) {
            this.fontStyle = e;
          }
          setStartHats(e) {
            this.startHats = e;
          }
          static defineTheme(e, t) {
            e = e.toLowerCase();
            let o = new ao(e), s = t.base;
            if (s) {
              if (typeof s == "string") {
                let i;
                s = (i = ht(E.THEME, s)) != null ? i : void 0;
              }
              s instanceof ao && ($t(o, s), o.name = e);
            }
            return $t(o.blockStyles, t.blockStyles), $t(o.categoryStyles, t.categoryStyles), $t(o.componentStyles, t.componentStyles), $t(o.fontStyle, t.fontStyle), t.startHats !== null && (o.startHats = t.startHats), o;
          }
        }, JT = {};
        JT.Theme = ao;
        var qT = { colour_blocks: { colourPrimary: "20" }, list_blocks: { colourPrimary: "260" }, logic_blocks: { colourPrimary: "210" }, loop_blocks: { colourPrimary: "120" }, math_blocks: { colourPrimary: "230" }, procedure_blocks: { colourPrimary: "290" }, text_blocks: { colourPrimary: "160" }, variable_blocks: { colourPrimary: "330" }, variable_dynamic_blocks: { colourPrimary: "310" }, hat_blocks: { colourPrimary: "330", hat: "cap" } }, ZT = { colour_category: { colour: "20" }, list_category: { colour: "260" }, logic_category: { colour: "210" }, loop_category: { colour: "120" }, math_category: { colour: "230" }, procedure_category: { colour: "290" }, text_category: { colour: "160" }, variable_category: { colour: "330" }, variable_dynamic_category: { colour: "310" } }, Ji = new ao("classic", qT, ZT), dL = { Classic: Ji }, st = class {
          constructor(e) {
            this.gridPattern = null, this.getMetrics = this.setMetrics = void 0;
            let t = null, o = false;
            var s = false, i = false, n = false, l = false, a = false;
            let _ = !!e.readOnly;
            if (!_) {
              var v;
              t = Nr((v = e.toolbox) != null ? v : null), o = Ar(t), s = e.trashcan, s = s === void 0 ? o : s, i = e.collapse, i = i === void 0 ? o : i, n = e.comments, n = n === void 0 ? o : n, l = e.disable, l = l === void 0 ? o : l, a = e.sounds, a = a === void 0 ? true : a;
            }
            v = e.maxTrashcanContents, s ? v === void 0 && (v = 32) : v = 0;
            let Q = !!e.rtl, X = e.horizontalLayout;
            X === void 0 && (X = false);
            var ye = e.toolboxPosition !== "end";
            ye = X ? ye ? A.TOP : A.BOTTOM : ye === Q ? A.RIGHT : A.LEFT;
            let Gt = e.css;
            Gt === void 0 && (Gt = true);
            let Ot = "https://blockly-demo.appspot.com/static/media/";
            e.media && (Ot = e.media.endsWith("/") ? e.media : e.media + "/");
            let L_ = e.oneBasedIndex, vI = e.renderer || "geras", kI = e.plugins || {}, yd = e.modalInputs;
            yd === void 0 && (yd = true), this.RTL = Q, this.oneBasedIndex = L_ === void 0 ? true : L_, this.collapse = i, this.comments = n, this.disable = l, this.readOnly = _, this.maxBlocks = e.maxBlocks || 1 / 0;
            let N_;
            this.maxInstances = (N_ = e.maxInstances) != null ? N_ : null, this.modalInputs = yd, this.pathToMedia = Ot, this.hasCategories = o, this.moveOptions = st.parseMoveOptions(e, o), this.hasScrollbars = !!this.moveOptions.scrollbars, this.hasTrashcan = s, this.maxTrashcanContents = v, this.hasSounds = a, this.hasCss = Gt, this.horizontalLayout = X, this.languageTree = t, this.gridOptions = st.parseGridOptions(e), this.zoomOptions = st.parseZoomOptions(e), this.toolboxPosition = ye, this.theme = st.parseThemeOptions(e), this.renderer = vI;
            let A_;
            this.rendererOverrides = (A_ = e.rendererOverrides) != null ? A_ : null;
            let M_;
            this.parentWorkspace = (M_ = e.parentWorkspace) != null ? M_ : null, this.plugins = kI;
          }
          static parseMoveOptions(e, t) {
            let o = e.move || {}, s = {};
            return o.scrollbars === void 0 && e.scrollbars === void 0 ? s.scrollbars = t : typeof o.scrollbars == "object" ? (s.scrollbars = { horizontal: !!o.scrollbars.horizontal, vertical: !!o.scrollbars.vertical }, s.scrollbars.horizontal && s.scrollbars.vertical ? s.scrollbars = true : s.scrollbars.horizontal || s.scrollbars.vertical || (s.scrollbars = false)) : s.scrollbars = !!o.scrollbars || !!e.scrollbars, s.wheel = s.scrollbars && o.wheel !== void 0 ? !!o.wheel : typeof s.scrollbars == "object", s.drag = s.scrollbars ? o.drag === void 0 ? true : !!o.drag : false, s;
          }
          static parseZoomOptions(e) {
            e = e.zoom || {};
            let t = {};
            return t.controls = e.controls === void 0 ? false : !!e.controls, t.wheel = e.wheel === void 0 ? false : !!e.wheel, t.startScale = e.startScale === void 0 ? 1 : Number(e.startScale), t.maxScale = e.maxScale === void 0 ? 3 : Number(e.maxScale), t.minScale = e.minScale === void 0 ? 0.3 : Number(e.minScale), t.scaleSpeed = e.scaleSpeed === void 0 ? 1.2 : Number(e.scaleSpeed), t.pinch = e.pinch === void 0 ? t.wheel || t.controls : !!e.pinch, t;
          }
          static parseGridOptions(e) {
            e = e.grid || {};
            let t = {};
            return t.spacing = Number(e.spacing) || 0, t.colour = e.colour || "#888", t.length = e.length === void 0 ? 1 : Number(e.length), t.snap = t.spacing > 0 && !!e.snap, t;
          }
          static parseThemeOptions(e) {
            return e = e.theme || Ji, typeof e == "string" ? ht(E.THEME, e) : e instanceof ao ? e : ao.defineTheme(e.name || "builtin" + Xe(), e);
          }
        }, QT = {};
        QT.Options = st;
        var ah = class {
          constructor(e, t) {
            this.bubble = e, this.workspace = t, this.startLoc = null;
          }
          isMovable() {
            return true;
          }
          startDrag() {
            this.startLoc = this.bubble.getRelativeToSurfaceXY(), this.workspace.setResizesEnabled(false);
            let e;
            (e = this.workspace.getLayerManager()) == null || e.moveToDragLayer(this.bubble), this.bubble.setDragging && this.bubble.setDragging(true);
          }
          drag(e) {
            this.bubble.moveDuringDrag(e);
          }
          endDrag() {
            this.workspace.setResizesEnabled(true);
            let e;
            (e = this.workspace.getLayerManager()) == null || e.moveOffDragLayer(this.bubble, Kn), this.bubble.setDragging(false);
          }
          revertDrag() {
            this.startLoc && this.bubble.moveDuringDrag(this.startLoc);
          }
        }, eE = {};
        eE.BubbleDragStrategy = ah;
        var We, B = class {
          constructor(e, t, o, s, i) {
            this.workspace = e, this.anchor = t, this.ownerRect = o, this.owner = i, this.size = new N(0, 0), this.colour = "#ffffff", this.disposed = false, this.relativeLeft = this.relativeTop = 0, this.dragStrategy = new ah(this, this.workspace), this.id = Xe(), this.svgRoot = b($.G, { class: "blocklyBubble" }, e.getBubbleCanvas()), e = b($.G, { class: "blocklyEmboss" }, this.svgRoot), this.tail = b($.PATH, { class: "blocklyBubbleTail" }, e), this.background = b($.RECT, { class: "blocklyDraggable", x: 0, y: 0, rx: We.BORDER_WIDTH, ry: We.BORDER_WIDTH }, e), this.contentContainer = b($.G, {}, this.svgRoot), this.focusableElement = s ?? this.svgRoot, this.focusableElement.setAttribute("id", this.id), w(this.background, "pointerdown", this, this.onMouseDown), w(this.focusableElement, "keydown", this, this.onKeyDown);
          }
          dispose() {
            V(this.svgRoot), this.disposed = true;
          }
          setAnchorLocation(e, t = false) {
            this.anchor = e, t ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor(), this.renderTail();
          }
          setPositionRelativeToAnchor(e, t) {
            this.relativeLeft = e, this.relativeTop = t, this.positionRelativeToAnchor(), this.renderTail();
          }
          getSize() {
            return this.size;
          }
          setSize(e, t = false) {
            e.width = Math.max(e.width, We.MIN_SIZE), e.height = Math.max(e.height, We.MIN_SIZE), this.size = e, this.background.setAttribute("width", `${e.width}`), this.background.setAttribute("height", `${e.height}`), t ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor(), this.renderTail();
          }
          getColour() {
            return this.colour;
          }
          setColour(e) {
            this.colour = e, this.tail.setAttribute("fill", e), this.background.setAttribute("fill", e);
          }
          onMouseDown(e) {
            let t;
            (t = this.workspace.getGesture(e)) == null || t.handleBubbleStart(e, this), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this);
          }
          onKeyDown(e) {
            e.key === "Escape" && this.owner && (this.owner.setBubbleVisible(false), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.owner));
          }
          positionRelativeToAnchor() {
            let e = this.anchor.x;
            e = this.workspace.RTL ? e - (this.relativeLeft + this.size.width) : e + this.relativeLeft, this.moveTo(e, this.relativeTop + this.anchor.y);
          }
          moveTo(e, t) {
            this.svgRoot.setAttribute("transform", `translate(${e}, ${t})`);
          }
          positionByRect(e = new L(0, 0, 0, 0)) {
            var t = this.workspace.getMetricsManager().getViewMetrics(true), o = this.getOptimalRelativeLeft(t), s = this.getOptimalRelativeTop(t);
            let i = { x: o, y: -this.size.height - this.workspace.getRenderer().getConstants().MIN_BLOCK_HEIGHT }, n = { x: -this.size.width - 30, y: s };
            s = { x: e.getWidth(), y: s };
            var l = { x: o, y: e.getHeight() };
            o = e.getWidth() < e.getHeight() ? s : l, e = e.getWidth() < e.getHeight() ? l : s, s = this.getOverlap(i, t), l = this.getOverlap(n, t);
            let a = this.getOverlap(o, t);
            t = this.getOverlap(e, t), t = Math.max(s, l, a, t), s === t ? (this.relativeLeft = i.x, this.relativeTop = i.y) : l === t ? (this.relativeLeft = n.x, this.relativeTop = n.y) : a === t ? (this.relativeLeft = o.x, this.relativeTop = o.y) : (this.relativeLeft = e.x, this.relativeTop = e.y), this.positionRelativeToAnchor();
          }
          getOverlap(e, t) {
            var o = this.workspace.RTL ? this.anchor.x - e.x - this.size.width : e.x + this.anchor.x;
            return e = e.y + this.anchor.y, Math.max(0, Math.min(1, (Math.min(o + this.size.width, t.left + t.width) - Math.max(o, t.left)) * (Math.min(e + this.size.height, t.top + t.height) - Math.max(e, t.top)) / (this.size.width * this.size.height)));
          }
          getOptimalRelativeLeft(e) {
            let t = -this.size.width / 4;
            if (this.size.width > e.width) return t;
            if (e = this.getWorkspaceViewRect(e), this.workspace.RTL) {
              var o = this.anchor.x - t;
              o - this.size.width < e.left ? t = -(e.left - this.anchor.x + this.size.width) : o > e.right && (t = -(e.right - this.anchor.x));
            } else {
              o = t + this.anchor.x;
              let s = o + this.size.width;
              o < e.left ? t = e.left - this.anchor.x : s > e.right && (t = e.right - this.anchor.x - this.size.width);
            }
            return t;
          }
          getOptimalRelativeTop(e) {
            let t = -this.size.height / 4;
            if (this.size.height > e.height) return t;
            let o = this.anchor.y + t, s = o + this.size.height;
            return e = this.getWorkspaceViewRect(e), o < e.top ? t = e.top - this.anchor.y : s > e.bottom && (t = e.bottom - this.anchor.y - this.size.height), t;
          }
          getWorkspaceViewRect(e) {
            let t = e.top, o = e.top + e.height, s = e.left;
            return e = e.left + e.width, o -= this.getScrollbarThickness(), this.workspace.RTL ? s -= this.getScrollbarThickness() : e -= this.getScrollbarThickness(), new L(t, o, s, e);
          }
          getScrollbarThickness() {
            return te.scrollbarThickness / this.workspace.scale;
          }
          renderTail() {
            let e = [];
            var t = this.size.width / 2, o = this.size.height / 2, s = -this.relativeLeft, i = -this.relativeTop;
            if (t === s && o === i) e.push("M " + t + "," + o);
            else {
              i -= o, s -= t, this.workspace.RTL && (s *= -1);
              var n = Math.sqrt(i * i + s * s), l = Math.acos(s / n);
              i < 0 && (l = 2 * Math.PI - l);
              var a = l + Math.PI / 2;
              a > Math.PI * 2 && (a -= Math.PI * 2);
              var _ = Math.sin(a);
              let Q = Math.cos(a), X = (this.size.width + this.size.height) / We.TAIL_THICKNESS;
              X = Math.min(X, this.size.width, this.size.height) / 4, a = 1 - We.ANCHOR_RADIUS / n, s = t + a * s, i = o + a * i, a = t + X * Q;
              let ye = o + X * _;
              t -= X * Q, o -= X * _, _ = jr(this.workspace.RTL ? -We.TAIL_ANGLE : We.TAIL_ANGLE), _ = l + _, _ > Math.PI * 2 && (_ -= Math.PI * 2), l = Math.sin(_) * n / We.TAIL_BEND, n = Math.cos(_) * n / We.TAIL_BEND, e.push("M" + a + "," + ye), e.push("C" + (a + n) + "," + (ye + l) + " " + s + "," + i + " " + s + "," + i), e.push("C" + s + "," + i + " " + (t + n) + "," + (o + l) + " " + t + "," + o);
            }
            e.push("z");
            let v;
            (v = this.tail) == null || v.setAttribute("d", e.join(" "));
          }
          bringToFront() {
            let e, t = (e = this.svgRoot) == null ? void 0 : e.parentNode;
            return this.svgRoot && t?.lastChild !== this.svgRoot ? (t?.appendChild(this.svgRoot), true) : false;
          }
          getRelativeToSurfaceXY() {
            return new f(this.workspace.RTL ? -this.relativeLeft + this.anchor.x - this.size.width : this.anchor.x + this.relativeLeft, this.anchor.y + this.relativeTop);
          }
          getSvgRoot() {
            return this.svgRoot;
          }
          moveDuringDrag(e) {
            this.moveTo(e.x, e.y), this.relativeLeft = this.workspace.RTL ? this.anchor.x - e.x - this.size.width : e.x - this.anchor.x, this.relativeTop = e.y - this.anchor.y, this.renderTail();
          }
          setDragging(e) {
          }
          setDeleteStyle(e) {
          }
          isDeletable() {
            return false;
          }
          showContextMenu(e) {
          }
          isMovable() {
            return true;
          }
          startDrag() {
            this.dragStrategy.startDrag();
          }
          drag(e) {
            this.dragStrategy.drag(e);
          }
          endDrag() {
            this.dragStrategy.endDrag();
          }
          revertDrag() {
            this.dragStrategy.revertDrag();
          }
          select() {
            Xt(this);
          }
          unselect() {
            Xt(null);
          }
          getFocusableElement() {
            return this.focusableElement;
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            this.select(), this.bringToFront();
            var e = this.getRelativeToSurfaceXY();
            let t = this.getSize();
            e = new L(e.y, e.y + t.height, e.x, e.x + t.width), this.workspace.scrollBoundsIntoView(e);
          }
          onNodeBlur() {
            this.unselect();
          }
          canBeFocused() {
            return true;
          }
          getOwner() {
            return this.owner;
          }
        };
        We = B, B.BORDER_WIDTH = 6, B.DOUBLE_BORDER = We.BORDER_WIDTH * 2, B.MIN_SIZE = We.DOUBLE_BORDER, B.TAIL_THICKNESS = 1, B.TAIL_ANGLE = 20, B.TAIL_BEND = 4, B.ANCHOR_RADIUS = 8;
        var tE = {};
        tE.Bubble = B;
        var yt = class extends B {
          constructor(e, t, o, s) {
            super(t, o, s), this.workspace = t, this.anchor = o, this.ownerRect = s, this.autoLayout = true, t = new st(e), this.validateWorkspaceOptions(t), this.svgDialog = b($.SVG, { x: B.BORDER_WIDTH, y: B.BORDER_WIDTH }, this.contentContainer), e.parentWorkspace = this.workspace, this.miniWorkspace = this.newWorkspaceSvg(new st(e)), this.miniWorkspace.internalIsMutator = true, e = this.miniWorkspace.createDom("blocklyMutatorBackground"), this.svgDialog.appendChild(e), t.languageTree && (e.insertBefore(this.miniWorkspace.addFlyout($.G), this.miniWorkspace.getCanvas()), e = this.miniWorkspace.getFlyout(), e?.init(this.miniWorkspace), e?.show(t.languageTree)), I(this.svgRoot, "blocklyMiniWorkspaceBubble"), this.miniWorkspace.addChangeListener(this.onWorkspaceChange.bind(this));
            let i, n;
            (i = this.miniWorkspace.getFlyout()) == null || (n = i.getWorkspace()) == null || n.addChangeListener(this.onWorkspaceChange.bind(this)), this.updateBubbleSize();
          }
          dispose() {
            this.miniWorkspace.dispose(), super.dispose();
          }
          getWorkspace() {
            return this.miniWorkspace;
          }
          addWorkspaceChangeListener(e) {
            this.miniWorkspace.addChangeListener(e);
          }
          validateWorkspaceOptions(e) {
            if (e.hasCategories) throw Error("The miniworkspace bubble does not support toolboxes with categories");
            if (e.hasTrashcan) throw Error("The miniworkspace bubble does not support trashcans");
            if (e.zoomOptions.controls || e.zoomOptions.wheel || e.zoomOptions.pinch) throw Error("The miniworkspace bubble does not support zooming");
            if (e.moveOptions.scrollbars || e.moveOptions.wheel || e.moveOptions.drag) throw Error("The miniworkspace bubble does not scrolling/moving the workspace");
            if (e.horizontalLayout) throw Error("The miniworkspace bubble does not support horizontal layouts");
          }
          onWorkspaceChange() {
            this.bumpBlocksIntoBounds(), this.updateBubbleSize();
          }
          bumpBlocksIntoBounds() {
            if (!this.miniWorkspace.isDragging() || this.miniWorkspace.keyboardMoveInProgress) for (let e of this.miniWorkspace.getTopBlocks(false)) {
              let t = e.getRelativeToSurfaceXY();
              if (t.y < 20 && e.moveBy(0, 20 - t.y), e.RTL) {
                let o = -20, s = this.miniWorkspace.getFlyout();
                s && (o -= s.getWidth()), t.x > o && e.moveBy(o - t.x, 0);
              } else t.x < 20 && e.moveBy(20 - t.x, 0);
            }
          }
          updateBubbleSize() {
            if (!this.miniWorkspace.isDragging() || this.miniWorkspace.keyboardMoveInProgress) {
              this.autoLayout && (this.autoLayout = !this.miniWorkspace.keyboardMoveInProgress);
              var e = this.getSize(), t = this.calculateWorkspaceSize();
              Math.abs(e.width - t.width) < yt.MINIMUM_VIEW_CHANGE && Math.abs(e.height - t.height) < yt.MINIMUM_VIEW_CHANGE || (this.svgDialog.setAttribute("width", `${t.width}px`), this.svgDialog.setAttribute("height", `${t.height}px`), this.miniWorkspace.setCachedParentSvgSize(t.width, t.height), this.miniWorkspace.RTL && this.miniWorkspace.getCanvas().setAttribute("transform", `translate(${t.width}, 0)`), this.setSize(new N(t.width + B.DOUBLE_BORDER, t.height + B.DOUBLE_BORDER), this.autoLayout), this.miniWorkspace.resize(), this.miniWorkspace.recordDragTargets());
            }
          }
          calculateWorkspaceSize() {
            var e = this.miniWorkspace.getCanvas().getBBox();
            let t = e.width + yt.MARGIN;
            e = e.height + yt.MARGIN;
            let o = this.miniWorkspace.getFlyout();
            if (o) {
              let s = o.getWorkspace().getMetricsManager().getScrollMetrics();
              e = Math.max(e, s.height + 20), t += o.getWidth();
            }
            return new N(t, e);
          }
          updateBlockStyles() {
            for (var e of this.miniWorkspace.getAllBlocks(false)) e.setStyle(e.getStyleName());
            let t;
            if (e = (t = this.miniWorkspace.getFlyout()) == null ? void 0 : t.getWorkspace()) for (let o of e.getAllBlocks(false)) o.setStyle(o.getStyleName());
          }
          moveDuringDrag(e) {
            super.moveDuringDrag(e), this.autoLayout = false;
          }
          moveTo(e, t) {
            super.moveTo(e, t), this.miniWorkspace.recordDragTargets();
          }
          newWorkspaceSvg(e) {
            throw Error("The implementation of newWorkspaceSvg should be monkey-patched in by blockly.ts");
          }
        };
        yt.MINIMUM_VIEW_CHANGE = 10, yt.MARGIN = B.DOUBLE_BORDER * 3;
        var oE = {};
        oE.MiniWorkspaceBubble = yt;
        var As = class {
          constructor(e) {
            this.sourceBlock = e, this.offsetInBlock = new f(0, 0), this.workspaceLocation = new f(0, 0), this.svgRoot = null, this.tooltip = e, this.id = Xe();
          }
          getType() {
            throw Error("Icons must implement getType");
          }
          initView(e) {
            if (!this.svgRoot) {
              var t = this.sourceBlock;
              this.svgRoot = b($.G, { class: "blocklyIconGroup", id: this.id }), t.getSvgRoot().appendChild(this.svgRoot), this.updateSvgRootOffset(), w(this.svgRoot, "pointerdown", this, e), this.svgRoot.tooltip = this, di(this.svgRoot);
            }
          }
          dispose() {
            Xc(this.svgRoot), V(this.svgRoot);
          }
          getWeight() {
            return -1;
          }
          getSize() {
            return new N(0, 0);
          }
          setTooltip(e) {
            this.tooltip = e ?? this.sourceBlock;
          }
          getTooltip() {
            return this.tooltip;
          }
          applyColour() {
          }
          updateEditable() {
          }
          updateCollapsed() {
            this.svgRoot && (this.sourceBlock.isCollapsed() ? this.svgRoot.style.display = "none" : this.svgRoot.style.display = "block", qt(this) && this.setBubbleVisible(false));
          }
          hideForInsertionMarker() {
            this.svgRoot && (this.svgRoot.style.display = "none");
          }
          isShownWhenCollapsed() {
            return false;
          }
          setOffsetInBlock(e) {
            this.offsetInBlock = e, this.updateSvgRootOffset();
          }
          updateSvgRootOffset() {
            let e;
            (e = this.svgRoot) == null || e.setAttribute("transform", `translate(${this.offsetInBlock.x}, ${this.offsetInBlock.y})`);
          }
          onLocationChange(e) {
            this.workspaceLocation = f.sum(e, this.offsetInBlock);
          }
          onClick() {
          }
          isClickableInFlyout(e) {
            return true;
          }
          getFocusableElement() {
            let e = this.svgRoot;
            if (!e) throw Error("Attempting to focus uninitialized icon.");
            return e;
          }
          getFocusableTree() {
            return this.sourceBlock.workspace;
          }
          onNodeFocus() {
            var e = this.sourceBlock.getBoundingRectangle();
            e = new L(e.top + this.offsetInBlock.y, e.top + this.offsetInBlock.y + this.getSize().height, e.left + this.offsetInBlock.x, e.left + this.offsetInBlock.x + this.getSize().width), this.sourceBlock.workspace.scrollBoundsIntoView(e);
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
          getSourceBlock() {
            return this.sourceBlock;
          }
        }, sE = {};
        sE.Icon = As;
        var el, tl;
        el = 17, tl = 16, r.MutatorIcon$$module$build$src$core$icons$mutator_icon = class extends As {
          constructor(e, t) {
            super(t), this.flyoutBlockTypes = e, this.sourceBlock = t, this.saveConnectionsListener = this.updateWorkspacePid = this.rootBlock = this.miniWorkspaceBubble = null;
          }
          getType() {
            return r.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE;
          }
          initView(e) {
            this.svgRoot || (super.initView(e), b($.RECT, { class: "blocklyIconShape", rx: "4", ry: "4", height: "16", width: "16" }, this.svgRoot), b($.PATH, { class: "blocklyIconSymbol", d: "m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 -0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z" }, this.svgRoot), b($.CIRCLE, { class: "blocklyIconShape", r: "2.7", cx: "8", cy: "8" }, this.svgRoot), I(this.svgRoot, "blocklyMutatorIcon"));
          }
          dispose() {
            super.dispose();
            let e;
            (e = this.miniWorkspaceBubble) == null || e.dispose();
          }
          getWeight() {
            return r.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT;
          }
          getSize() {
            return new N(el, el);
          }
          applyColour() {
            super.applyColour();
            let e;
            (e = this.miniWorkspaceBubble) == null || e.setColour(this.sourceBlock.getColour());
            let t;
            (t = this.miniWorkspaceBubble) == null || t.updateBlockStyles();
          }
          updateCollapsed() {
            super.updateCollapsed(), this.sourceBlock.isCollapsed() && this.setBubbleVisible(false);
          }
          onLocationChange(e) {
            super.onLocationChange(e);
            let t;
            (t = this.miniWorkspaceBubble) == null || t.setAnchorLocation(this.getAnchorLocation());
          }
          onClick() {
            super.onClick(), this.sourceBlock.isEditable() && this.setBubbleVisible(!this.bubbleIsVisible());
          }
          isClickableInFlyout() {
            return false;
          }
          bubbleIsVisible() {
            return !!this.miniWorkspaceBubble;
          }
          setBubbleVisible(e) {
            let t = this;
            return (0, m.asyncExecutePromiseGeneratorFunction)(function* () {
              if (t.bubbleIsVisible() !== e) {
                if (yield _t(), e) {
                  t.miniWorkspaceBubble = new yt(t.getMiniWorkspaceConfig(), t.sourceBlock.workspace, t.getAnchorLocation(), t.getBubbleOwnerRect()), t.applyColour(), t.createRootBlock(), t.addSaveConnectionsListener();
                  let o;
                  (o = t.miniWorkspaceBubble) == null || o.addWorkspaceChangeListener(t.createMiniWorkspaceChangeListener());
                } else {
                  let o;
                  (o = t.miniWorkspaceBubble) == null || o.dispose(), t.miniWorkspaceBubble = null, t.saveConnectionsListener && t.sourceBlock.workspace.removeChangeListener(t.saveConnectionsListener), t.saveConnectionsListener = null;
                }
                R(new (S(d.BUBBLE_OPEN))(t.sourceBlock, e, "mutator"));
              }
            });
          }
          getBubble() {
            return this.miniWorkspaceBubble;
          }
          getMiniWorkspaceConfig() {
            let e, t = { disable: false, media: this.sourceBlock.workspace.options.pathToMedia, rtl: this.sourceBlock.RTL, renderer: this.sourceBlock.workspace.options.renderer, rendererOverrides: (e = this.sourceBlock.workspace.options.rendererOverrides) != null ? e : void 0 };
            return this.flyoutBlockTypes.length && (t.toolbox = { kind: "flyoutToolbox", contents: this.flyoutBlockTypes.map((o) => ({ kind: "block", type: o })) }), t;
          }
          getAnchorLocation() {
            let e = el / 2;
            return f.sum(this.workspaceLocation, new f(e, e));
          }
          getBubbleOwnerRect() {
            let e = this.sourceBlock.getSvgRoot().getBBox();
            return new L(e.y, e.y + e.height, e.x, e.x + e.width);
          }
          createRootBlock() {
            if (!this.sourceBlock.decompose) throw Error("Blocks with mutator icons must include a decompose method");
            this.rootBlock = this.sourceBlock.decompose(this.miniWorkspaceBubble.getWorkspace());
            for (var e of this.rootBlock.getDescendants(false)) e.queueRender();
            this.rootBlock.setMovable(false), this.rootBlock.setDeletable(false);
            let t, o, s, i;
            e = (i = (t = this.miniWorkspaceBubble) == null || (o = t.getWorkspace()) == null || (s = o.getFlyout()) == null ? void 0 : s.getWidth()) != null ? i : 0, this.rootBlock.moveBy(this.rootBlock.RTL ? -(e + tl) : tl, tl);
          }
          addSaveConnectionsListener() {
            this.sourceBlock.saveConnections && this.rootBlock && (this.saveConnectionsListener = () => {
              this.sourceBlock.saveConnections && this.rootBlock && this.sourceBlock.saveConnections(this.rootBlock);
            }, this.saveConnectionsListener(), this.sourceBlock.workspace.addChangeListener(this.saveConnectionsListener));
          }
          createMiniWorkspaceChangeListener() {
            return (e) => {
              r.MutatorIcon$$module$build$src$core$icons$mutator_icon.isIgnorableMutatorEvent(e) || this.updateWorkspacePid || (this.updateWorkspacePid = setTimeout(() => {
                this.updateWorkspacePid = null, this.recomposeSourceBlock();
              }, 0));
            };
          }
          static isIgnorableMutatorEvent(e) {
            return e.isUiEvent || Ys(e) || Eo(e) && e.element === "disabled";
          }
          recomposeSourceBlock() {
            if (this.rootBlock) {
              if (!this.sourceBlock.compose) throw Error("Blocks with mutator icons must include a compose method");
              var e = r.getGroup$$module$build$src$core$events$utils();
              e || r.setGroup$$module$build$src$core$events$utils(true);
              var t = no.getExtraBlockState_(this.sourceBlock);
              this.sourceBlock.compose(this.rootBlock);
              var o = no.getExtraBlockState_(this.sourceBlock);
              t !== o && R(new (S(d.BLOCK_CHANGE))(this.sourceBlock, "mutation", null, t, o)), r.setGroup$$module$build$src$core$events$utils(e);
            }
          }
          getWorkspace() {
            let e;
            return (e = this.miniWorkspaceBubble) == null ? void 0 : e.getWorkspace();
          }
        }, r.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE = ue.MUTATOR, r.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT = 1;
        var iE = {};
        iE.MutatorIcon = r.MutatorIcon$$module$build$src$core$icons$mutator_icon;
        var Ms = /* @__PURE__ */ Object.create(null), rE = { allExtensions: Ms };
        r.register$$module$build$src$core$extensions("parent_tooltip_when_inline", Gp);
        var it = { TEST_ONLY: rE };
        it.apply = cn, it.buildTooltipForDropdown = r.buildTooltipForDropdown$$module$build$src$core$extensions, it.buildTooltipWithFieldText = r.buildTooltipWithFieldText$$module$build$src$core$extensions, it.isRegistered = ga, it.register = r.register$$module$build$src$core$extensions, it.registerMixin = r.registerMixin$$module$build$src$core$extensions, it.registerMutator = r.registerMutator$$module$build$src$core$extensions, it.runAfterPageLoad = Hp, it.unregister = Dp;
        var H;
        (function(e) {
          e[e.WIN_KEY_FF_LINUX = 0] = "WIN_KEY_FF_LINUX", e[e.MAC_ENTER = 3] = "MAC_ENTER", e[e.BACKSPACE = 8] = "BACKSPACE", e[e.TAB = 9] = "TAB", e[e.NUM_CENTER = 12] = "NUM_CENTER", e[e.ENTER = 13] = "ENTER", e[e.SHIFT = 16] = "SHIFT", e[e.CTRL = 17] = "CTRL", e[e.ALT = 18] = "ALT", e[e.PAUSE = 19] = "PAUSE", e[e.CAPS_LOCK = 20] = "CAPS_LOCK", e[e.ESC = 27] = "ESC", e[e.SPACE = 32] = "SPACE", e[e.PAGE_UP = 33] = "PAGE_UP", e[e.PAGE_DOWN = 34] = "PAGE_DOWN", e[e.END = 35] = "END", e[e.HOME = 36] = "HOME", e[e.LEFT = 37] = "LEFT", e[e.UP = 38] = "UP", e[e.RIGHT = 39] = "RIGHT", e[e.DOWN = 40] = "DOWN", e[e.PLUS_SIGN = 43] = "PLUS_SIGN", e[e.PRINT_SCREEN = 44] = "PRINT_SCREEN", e[e.INSERT = 45] = "INSERT", e[e.DELETE = 46] = "DELETE", e[e.ZERO = 48] = "ZERO", e[e.ONE = 49] = "ONE", e[e.TWO = 50] = "TWO", e[e.THREE = 51] = "THREE", e[e.FOUR = 52] = "FOUR", e[e.FIVE = 53] = "FIVE", e[e.SIX = 54] = "SIX", e[e.SEVEN = 55] = "SEVEN", e[e.EIGHT = 56] = "EIGHT", e[e.NINE = 57] = "NINE", e[e.FF_SEMICOLON = 59] = "FF_SEMICOLON", e[e.FF_EQUALS = 61] = "FF_EQUALS", e[e.FF_DASH = 173] = "FF_DASH", e[e.FF_HASH = 163] = "FF_HASH", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.AT_SIGN = 64] = "AT_SIGN", e[e.A = 65] = "A", e[e.B = 66] = "B", e[e.C = 67] = "C", e[e.D = 68] = "D", e[e.E = 69] = "E", e[e.F = 70] = "F", e[e.G = 71] = "G", e[e.H = 72] = "H", e[e.I = 73] = "I", e[e.J = 74] = "J", e[e.K = 75] = "K", e[e.L = 76] = "L", e[e.M = 77] = "M", e[e.N = 78] = "N", e[e.O = 79] = "O", e[e.P = 80] = "P", e[e.Q = 81] = "Q", e[e.R = 82] = "R", e[e.S = 83] = "S", e[e.T = 84] = "T", e[e.U = 85] = "U", e[e.V = 86] = "V", e[e.W = 87] = "W", e[e.X = 88] = "X", e[e.Y = 89] = "Y", e[e.Z = 90] = "Z", e[e.META = 91] = "META", e[e.WIN_KEY_RIGHT = 92] = "WIN_KEY_RIGHT", e[e.CONTEXT_MENU = 93] = "CONTEXT_MENU", e[e.NUM_ZERO = 96] = "NUM_ZERO", e[e.NUM_ONE = 97] = "NUM_ONE", e[e.NUM_TWO = 98] = "NUM_TWO", e[e.NUM_THREE = 99] = "NUM_THREE", e[e.NUM_FOUR = 100] = "NUM_FOUR", e[e.NUM_FIVE = 101] = "NUM_FIVE", e[e.NUM_SIX = 102] = "NUM_SIX", e[e.NUM_SEVEN = 103] = "NUM_SEVEN", e[e.NUM_EIGHT = 104] = "NUM_EIGHT", e[e.NUM_NINE = 105] = "NUM_NINE", e[e.NUM_MULTIPLY = 106] = "NUM_MULTIPLY", e[e.NUM_PLUS = 107] = "NUM_PLUS", e[e.NUM_MINUS = 109] = "NUM_MINUS", e[e.NUM_PERIOD = 110] = "NUM_PERIOD", e[e.NUM_DIVISION = 111] = "NUM_DIVISION", e[e.F1 = 112] = "F1", e[e.F2 = 113] = "F2", e[e.F3 = 114] = "F3", e[e.F4 = 115] = "F4", e[e.F5 = 116] = "F5", e[e.F6 = 117] = "F6", e[e.F7 = 118] = "F7", e[e.F8 = 119] = "F8", e[e.F9 = 120] = "F9", e[e.F10 = 121] = "F10", e[e.F11 = 122] = "F11", e[e.F12 = 123] = "F12", e[e.NUMLOCK = 144] = "NUMLOCK", e[e.SCROLL_LOCK = 145] = "SCROLL_LOCK", e[e.FIRST_MEDIA_KEY = 166] = "FIRST_MEDIA_KEY", e[e.LAST_MEDIA_KEY = 183] = "LAST_MEDIA_KEY", e[e.SEMICOLON = 186] = "SEMICOLON", e[e.DASH = 189] = "DASH", e[e.EQUALS = 187] = "EQUALS", e[e.COMMA = 188] = "COMMA", e[e.PERIOD = 190] = "PERIOD", e[e.SLASH = 191] = "SLASH", e[e.APOSTROPHE = 192] = "APOSTROPHE", e[e.TILDE = 192] = "TILDE", e[e.SINGLE_QUOTE = 222] = "SINGLE_QUOTE", e[e.OPEN_SQUARE_BRACKET = 219] = "OPEN_SQUARE_BRACKET", e[e.BACKSLASH = 220] = "BACKSLASH", e[e.CLOSE_SQUARE_BRACKET = 221] = "CLOSE_SQUARE_BRACKET", e[e.WIN_KEY = 224] = "WIN_KEY", e[e.MAC_FF_META = 224] = "MAC_FF_META", e[e.MAC_WK_CMD_LEFT = 91] = "MAC_WK_CMD_LEFT", e[e.MAC_WK_CMD_RIGHT = 93] = "MAC_WK_CMD_RIGHT", e[e.WIN_IME = 229] = "WIN_IME", e[e.VK_NONAME = 252] = "VK_NONAME", e[e.PHANTOM = 255] = "PHANTOM";
        })(H || (H = {}));
        var nE = {};
        nE.KeyCodes = H;
        var Ht = {};
        Ht.arc = re, Ht.curve = Le, Ht.line = Es, Ht.lineOnAxis = O, Ht.lineTo = ft, Ht.moveBy = ee, Ht.moveTo = _e, Ht.point = k;
        var Z = {};
        Z.Coordinate = f, Z.KeyCodes = H, Z.Rect = L, Z.Size = N, Z.Svg = $, Z.aria = Pi, Z.array = Hg, Z.browserEvents = Mt, Z.colour = Je, Z.deprecation = $m, Z.dom = Te, Z.extensions = it, Z.idGenerator = Ru, Z.math = Pn, Z.object = Dg, Z.parsing = Xi, Z.string = Rs, Z.style = to, Z.svgMath = xo, Z.svgPaths = Ht, Z.toolbox = oo, Z.userAgent = eT, Z.xml = Is;
        var qi = class extends B {
          constructor(e, t, o, s) {
            super(e, t, o, void 0, s), this.workspace = e, this.anchor = t, this.ownerRect = o, this.owner = s, this.resizePointerMoveListener = this.resizePointerUpListener = null, this.sizeChangeListeners = [], this.locationChangeListeners = [], this.DEFAULT_SIZE = new N(160 + B.DOUBLE_BORDER, 80 + B.DOUBLE_BORDER), this.MIN_SIZE = new N(45 + B.DOUBLE_BORDER, 20 + B.DOUBLE_BORDER), this.editable = true, I(this.svgRoot, "blocklyTextInputBubble"), this.editor = new Ki(e, this.id, () => {
              r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this);
            }), this.contentContainer.appendChild(this.editor.getDom()), this.resizeGroup = this.createResizeHandle(this.svgRoot, e), this.setSize(this.DEFAULT_SIZE, true);
          }
          getText() {
            return this.editor.getText();
          }
          setText(e) {
            this.editor.setText(e);
          }
          setEditable(e) {
            this.editable = e, this.editor.setEditable(e);
          }
          isEditable() {
            return this.editable;
          }
          addTextChangeListener(e) {
            this.editor.addTextChangeListener(e);
          }
          addSizeChangeListener(e) {
            this.sizeChangeListeners.push(e);
          }
          addLocationChangeListener(e) {
            this.locationChangeListeners.push(e);
          }
          createResizeHandle(e, t) {
            return e = b($.IMAGE, { class: "blocklyResizeHandle", href: `${t.options.pathToMedia}resize-handle.svg` }, e), w(e, "pointerdown", this, this.onResizePointerDown), e;
          }
          setSize(e, t = false) {
            e.width = Math.max(e.width, this.MIN_SIZE.width), e.height = Math.max(e.height, this.MIN_SIZE.height);
            let o = e.width - B.DOUBLE_BORDER, s = e.height - B.DOUBLE_BORDER;
            this.editor.updateSize(new N(o, s), new N(0, 0)), this.editor.getDom().setAttribute("x", `${B.DOUBLE_BORDER / 2}`), this.editor.getDom().setAttribute("y", `${B.DOUBLE_BORDER / 2}`), this.resizeGroup.setAttribute("y", `${s}`), this.workspace.RTL ? this.resizeGroup.setAttribute("x", `${-B.DOUBLE_BORDER}`) : this.resizeGroup.setAttribute("x", `${o}`), super.setSize(e, t), this.onSizeChange();
          }
          getSize() {
            return super.getSize();
          }
          moveDuringDrag(e) {
            super.moveDuringDrag(e), this.onLocationChange();
          }
          setPositionRelativeToAnchor(e, t) {
            super.setPositionRelativeToAnchor(e, t), this.onLocationChange();
          }
          positionByRect(e = new L(0, 0, 0, 0)) {
            super.positionByRect(e), this.onLocationChange();
          }
          onResizePointerDown(e) {
            this.bringToFront(), Qe(e) || (mi(this.workspace, e, new f(this.workspace.RTL ? -this.getSize().width : this.getSize().width, this.getSize().height)), this.resizePointerUpListener = w(document, "pointerup", this, this.onResizePointerUp), this.resizePointerMoveListener = w(document, "pointermove", this, this.onResizePointerMove), this.workspace.hideChaff()), e.stopPropagation();
          }
          onResizePointerUp(e) {
            Oe(), this.resizePointerUpListener && (x(this.resizePointerUpListener), this.resizePointerUpListener = null), this.resizePointerMoveListener && (x(this.resizePointerMoveListener), this.resizePointerMoveListener = null);
          }
          onResizePointerMove(e) {
            e = _i(this.workspace, e), this.setSize(new N(this.workspace.RTL ? -e.x : e.x, e.y), false), this.onSizeChange();
          }
          onSizeChange() {
            for (let e of this.sizeChangeListeners) e();
          }
          onLocationChange() {
            for (let e of this.locationChangeListeners) e();
          }
          getEditor() {
            return this.editor;
          }
        };
        pt(`
.blocklyTextInputBubble .blocklyTextarea {
  background-color: var(--commentFillColour);
  border: 0;
  box-sizing: border-box;
  display: block;
  outline: 0;
  padding: 5px;
  resize: none;
  width: 100%;
  height: 100%;
}
`);
        var lE = {};
        lE.TextInputBubble = qi;
        var C;
        (function(e) {
          e[e.INPUT_VALUE = 1] = "INPUT_VALUE", e[e.OUTPUT_VALUE = 2] = "OUTPUT_VALUE", e[e.NEXT_STATEMENT = 3] = "NEXT_STATEMENT", e[e.PREVIOUS_STATEMENT = 4] = "PREVIOUS_STATEMENT";
        })(C || (C = {}));
        var cE = {};
        cE.ConnectionType = C;
        var zo = class {
          constructor(e) {
            this.connectionChecker = e, this.connections = [];
          }
          addConnection(e, t) {
            t = this.calculateIndexForYPos(t), this.connections.splice(t, 0, e);
          }
          findIndexOfConnection(e, t) {
            if (!this.connections.length) return -1;
            let o = this.calculateIndexForYPos(t);
            if (o >= this.connections.length) return -1;
            t = e.y;
            let s = o;
            for (; s >= 0 && this.connections[s].y === t; ) {
              if (this.connections[s] === e) return s;
              s--;
            }
            for (s = o; s < this.connections.length && this.connections[s].y === t; ) {
              if (this.connections[s] === e) return s;
              s++;
            }
            return -1;
          }
          calculateIndexForYPos(e) {
            if (!this.connections.length) return 0;
            let t = 0, o = this.connections.length;
            for (; t < o; ) {
              let s = Math.floor((t + o) / 2);
              if (this.connections[s].y < e) t = s + 1;
              else if (this.connections[s].y > e) o = s;
              else {
                t = s;
                break;
              }
            }
            return t;
          }
          removeConnection(e, t) {
            if (e = this.findIndexOfConnection(e, t), e === -1) throw Error("Unable to find connection in connectionDB.");
            this.connections.splice(e, 1);
          }
          getNeighbours(e, t) {
            function o(v) {
              let Q = i - s[v].x, X = n - s[v].y;
              return Math.sqrt(Q * Q + X * X) <= t && _.push(s[v]), X < t;
            }
            let s = this.connections, i = e.x, n = e.y;
            e = 0;
            let l = s.length - 2, a = l;
            for (; e < a; ) s[a].y < n ? e = a : l = a, a = Math.floor((e + l) / 2);
            let _ = [];
            if (l = e = a, s.length) {
              for (; e >= 0 && o(e); ) e--;
              do
                l++;
              while (l < s.length && o(l));
            }
            return _;
          }
          isInYRange(e, t, o) {
            return Math.abs(this.connections[e].y - t) <= o;
          }
          searchForClosest(e, t, o) {
            if (!this.connections.length) return { connection: null, radius: t };
            let s = e.y, i = e.x;
            e.x = i + o.x, e.y = s + o.y;
            var n = this.calculateIndexForYPos(e.y);
            o = null;
            let l = t, a, _ = n - 1;
            for (; _ >= 0 && this.isInYRange(_, e.y, t); ) a = this.connections[_], this.connectionChecker.canConnect(e, a, true, l) && (o = a, l = a.distanceFrom(e)), _--;
            for (; n < this.connections.length && this.isInYRange(n, e.y, t); ) a = this.connections[n], this.connectionChecker.canConnect(e, a, true, l) && (o = a, l = a.distanceFrom(e)), n++;
            return e.x = i, e.y = s, { connection: o, radius: l };
          }
          static init(e) {
            let t = [];
            return t[C.INPUT_VALUE] = new zo(e), t[C.OUTPUT_VALUE] = new zo(e), t[C.NEXT_STATEMENT] = new zo(e), t[C.PREVIOUS_STATEMENT] = new zo(e), t;
          }
        }, aE = {};
        aE.ConnectionDB = zo;
        var ol = class extends tt {
          constructor(e, t, o) {
            super(o), this.type = d.SELECTED, this.oldElementId = e ?? void 0, this.newElementId = t ?? void 0;
          }
          toJson() {
            let e = super.toJson();
            return e.oldElementId = this.oldElementId, e.newElementId = this.newElementId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new ol()), t.oldElementId = e.oldElementId, t.newElementId = e.newElementId, t;
          }
        };
        c(E.EVENT, d.SELECTED, ol);
        var uE = {};
        uE.Selected = ol;
        var sl = class extends ro {
          constructor(e) {
            if (super(e), this.type = d.BLOCK_DELETE, e) {
              if (e.getParent()) throw Error("Connected blocks cannot be deleted.");
              e.isShadow() && (this.recordUndo = false), this.oldXml = Ei(e), this.ids = js(e), this.wasShadow = e.isShadow(), this.oldJson = Be(e, { addCoordinates: true });
            }
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldXml) throw Error("The old block XML is undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
            if (this.wasShadow === void 0) throw Error("Whether the block was a shadow is undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.oldJson) throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
            return e.oldXml = Et(this.oldXml), e.ids = this.ids, e.wasShadow = this.wasShadow, e.oldJson = this.oldJson, this.recordUndo || (e.recordUndo = this.recordUndo), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new sl()), t.oldXml = r.textToDom$$module$build$src$core$utils$xml(e.oldXml), t.ids = e.ids, t.wasShadow = e.wasShadow || t.oldXml.tagName.toLowerCase() === "shadow", t.oldJson = e.oldJson, e.recordUndo !== void 0 && (t.recordUndo = e.recordUndo), t;
          }
          run(e) {
            let t = this.getEventWorkspace_();
            if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
            if (!this.oldJson) throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
            if (e) for (e = 0; e < this.ids.length; e++) {
              let o = this.ids[e], s = t.getBlockById(o);
              s ? s.dispose(false) : o === this.blockId && console.warn("Can't delete non-existent block: " + o);
            }
            else Jt(this.oldJson, t);
          }
        };
        c(E.EVENT, d.BLOCK_DELETE, sl);
        var hE = {};
        hE.BlockDelete = sl;
        var D = class {
          constructor(e, t) {
            if (this.type = t, this.targetConnection = null, this.disposed = false, this.shadowDom = this.check = null, this.y = this.x = 0, this.shadowState = null, this.sourceBlock_ = e, e.id.includes("_connection")) throw Error(`Connection ID indicator is contained in block ID. This will cause problems with focus: ${e.id}.`);
            this.id = `${e.id}_connection_${Xe()}`;
          }
          connect_(e) {
            let t = C.INPUT_VALUE, o = this.getSourceBlock();
            var s = e.getSourceBlock();
            e.isConnected() && e.disconnectInternal(false);
            let i;
            if (this.isConnected()) {
              let l = this.stashShadowState(), a = this.targetBlock();
              a.isShadow() ? a.dispose(false) : (this.disconnectInternal(), i = a), this.applyShadowState(l);
            }
            let n;
            J() && (n = new (S(d.BLOCK_MOVE))(s), n.setReason(["connect"])), Vp(this, e), s.setParent(o), n && (n.recordNew(), R(n)), i && (e = this.type === t ? i.outputConnection : i.previousConnection) && ((s = D.getConnectionForOrphanedConnection(s, e)) ? e.connect(s) : e.onFailedConnect(this));
          }
          dispose() {
            if (this.isConnected()) {
              this.isSuperior() && this.setShadowStateInternal();
              let e = this.targetBlock();
              e && !e.isDeadOrDying() && e.unplug();
            }
            this.disposed = true;
          }
          getSourceBlock() {
            return this.sourceBlock_;
          }
          isSuperior() {
            return this.type === C.INPUT_VALUE || this.type === C.NEXT_STATEMENT;
          }
          isConnected() {
            return !!this.targetConnection;
          }
          getConnectionChecker() {
            return this.sourceBlock_.workspace.connectionChecker;
          }
          onFailedConnect(e) {
          }
          connect(e) {
            if (this.targetConnection === e) return true;
            if (this.getConnectionChecker().canConnect(this, e, false)) {
              let t = r.getGroup$$module$build$src$core$events$utils();
              t || r.setGroup$$module$build$src$core$events$utils(true), this.isSuperior() ? this.connect_(e) : e.connect_(this), r.setGroup$$module$build$src$core$events$utils(t);
            }
            return this.isConnected();
          }
          disconnect() {
            this.disconnectInternal();
          }
          disconnectInternal(e = true) {
            let { parentConnection: t, childConnection: o } = this.getParentAndChildConnections();
            if (!t || !o) throw Error("Source connection not connected.");
            let s = r.getGroup$$module$build$src$core$events$utils();
            s || r.setGroup$$module$build$src$core$events$utils(true);
            let i;
            J() && (i = new (S(d.BLOCK_MOVE))(o.getSourceBlock()), i.setReason(["disconnect"]));
            let n = this.targetConnection;
            n && (n.targetConnection = null), this.targetConnection = null, e && o.getSourceBlock().setParent(null), i && (i.recordNew(), R(i)), o.getSourceBlock().isShadow() || t.respawnShadow_(), r.setGroup$$module$build$src$core$events$utils(s);
          }
          getParentAndChildConnections() {
            return this.targetConnection ? this.isSuperior() ? { parentConnection: this, childConnection: this.targetConnection } : { parentConnection: this.targetConnection, childConnection: this } : {};
          }
          respawnShadow_() {
            this.createShadowBlock(true);
          }
          reconnect(e, t) {
            if (this.getSourceBlock().isDeadOrDying()) return false;
            var o;
            return t = (o = e.getInput(t)) == null ? void 0 : o.connection, o = this.targetBlock(), o && o !== e || !t || t.targetConnection === this ? false : (t.isConnected() && t.disconnect(), t.connect(this), true);
          }
          targetBlock() {
            if (this.isConnected()) {
              let e, t;
              return (t = (e = this.targetConnection) == null ? void 0 : e.getSourceBlock()) != null ? t : null;
            }
            return null;
          }
          onCheckChanged_() {
            !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, false) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug();
          }
          setCheck(e) {
            return e ? (Array.isArray(e) || (e = [e]), this.check = e, this.onCheckChanged_()) : this.check = null, this;
          }
          getCheck() {
            return this.check;
          }
          setShadowDom(e) {
            this.setShadowStateInternal({ shadowDom: e });
          }
          getShadowDom(e) {
            return e && this.targetBlock().isShadow() ? Zt(this.targetBlock()) : this.shadowDom;
          }
          setShadowState(e) {
            this.setShadowStateInternal({ shadowState: e });
          }
          getShadowState(e) {
            return e && this.targetBlock() && this.targetBlock().isShadow() ? Be(this.targetBlock()) : this.shadowState;
          }
          neighbours(e) {
            return [];
          }
          getParentInput() {
            let e = null, t = this.sourceBlock_.inputList;
            for (let o = 0; o < t.length; o++) if (t[o].connection === this) {
              e = t[o];
              break;
            }
            return e;
          }
          toString() {
            let e = this.sourceBlock_;
            if (!e) return "Orphan Connection";
            if (e.outputConnection === this) var t = "Output Connection of ";
            else if (e.previousConnection === this) t = "Previous Connection of ";
            else if (e.nextConnection === this) t = "Next Connection of ";
            else {
              t = null;
              for (let o = 0, s; s = e.inputList[o]; o++) if (s.connection === this) {
                t = s;
                break;
              }
              if (t) t = 'Input "' + t.name + '" connection on ';
              else return console.warn("Connection not actually connected to sourceBlock_"), "Orphan Connection";
            }
            return t + e.toDevString();
          }
          stashShadowState() {
            let e = this.getShadowDom(true), t = this.getShadowState(true);
            return this.shadowState = this.shadowDom = null, { shadowDom: e, shadowState: t };
          }
          applyShadowState({ shadowDom: e, shadowState: t }) {
            this.shadowDom = e, this.shadowState = t;
          }
          setShadowStateInternal({ shadowDom: e = null, shadowState: t = null } = {}) {
            this.shadowDom = e, this.shadowState = t, this.getSourceBlock().isDeadOrDying() || ((e = this.targetBlock()) ? e.isShadow() ? (e.dispose(false), this.respawnShadow_(), this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock())) : (e = this.createShadowBlock(false), this.serializeShadow(e), e && e.dispose(false)) : (this.respawnShadow_(), this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock())));
          }
          createShadowBlock(e) {
            var t = this.getSourceBlock();
            let o = this.getShadowState(), s = this.getShadowDom();
            if (t.isDeadOrDying() || !o && !s) return null;
            if (o) return t = hs(o, t.workspace, { parentConnection: e ? this : void 0, isShadow: true, recordUndo: false });
            if (s) {
              if (t = wo(s, t.workspace), e) if (this.type === C.INPUT_VALUE) {
                if (!t.outputConnection) throw Error("Shadow block is missing an output connection");
                if (!this.connect(t.outputConnection)) throw Error("Could not connect shadow block to connection");
              } else if (this.type === C.NEXT_STATEMENT) {
                if (!t.previousConnection) throw Error("Shadow block is missing previous connection");
                if (!this.connect(t.previousConnection)) throw Error("Could not connect shadow block to connection");
              } else throw Error("Cannot connect a shadow block to a previous/output connection");
              return t;
            }
            return null;
          }
          serializeShadow(e) {
            e && (this.shadowDom = Zt(e), this.shadowState = Be(e));
          }
          static getConnectionForOrphanedConnection(e, t) {
            if (t.type === C.OUTPUT_VALUE) return zp(e, t.getSourceBlock());
            e = e.lastConnectionInStack(true);
            let o = t.getConnectionChecker();
            return e && o.canConnect(t, e, false) ? e : null;
          }
        };
        D.CAN_CONNECT = 0, D.REASON_SELF_CONNECTION = 1, D.REASON_WRONG_TYPE = 2, D.REASON_TARGET_NULL = 3, D.REASON_CHECKS_FAILED = 4, D.REASON_DIFFERENT_WORKSPACES = 5, D.REASON_SHADOW_PARENT = 6, D.REASON_DRAG_CHECKS_FAILED = 7, D.REASON_PREVIOUS_AND_OUTPUT = 8;
        var dE = {};
        dE.Connection = D;
        var Pm = class extends Error {
          constructor(e) {
            super(`Tried to append an icon of type ${e.getType()} when an icon of that type already exists on the block. Use getIcon to access the existing icon.`), this.icon = e;
          }
        }, Bm = {};
        Bm.DuplicateIconType = Pm, (function(e) {
          e[e.LEFT = -1] = "LEFT", e[e.CENTRE = 0] = "CENTRE", e[e.RIGHT = 1] = "RIGHT";
        })(r.Align$$module$build$src$core$inputs$align || (r.Align$$module$build$src$core$inputs$align = {}));
        var $E = {};
        $E.Align = r.Align$$module$build$src$core$inputs$align;
        var uo = class extends F {
          constructor(e, t, o) {
            super(F.SKIP_SETUP), this.class = null, this.EDITABLE = false, this.maxDisplayLength = 1 / 0, e !== F.SKIP_SETUP && (o ? this.configure_(o) : this.class = t || null, this.setValue(e));
          }
          configure_(e) {
            super.configure_(e), e.class && (this.class = e.class);
          }
          initView() {
            this.createTextElement_(), this.class && I(this.getTextElement(), this.class), this.fieldGroup_ && I(this.fieldGroup_, "blocklyLabelField");
          }
          doClassValidation_(e) {
            return e == null ? null : `${e}`;
          }
          setClass(e) {
            this.textElement_ && (this.class && P(this.textElement_, this.class), e && I(this.textElement_, e)), this.class = e;
          }
          static fromJson(e) {
            return new this(ie(e.text), void 0, e);
          }
        };
        bt("field_label", uo), uo.prototype.DEFAULT_VALUE = "";
        var pE = {};
        pE.FieldLabel = uo;
        var il = 30, Ut = [];
        Ut[C.INPUT_VALUE] = C.OUTPUT_VALUE, Ut[C.OUTPUT_VALUE] = C.INPUT_VALUE, Ut[C.NEXT_STATEMENT] = C.PREVIOUS_STATEMENT, Ut[C.PREVIOUS_STATEMENT] = C.NEXT_STATEMENT;
        var Zi = "RENAME_VARIABLE_ID", Qi = "DELETE_VARIABLE_ID", $L = { COLLAPSE_CHARS: il, DELETE_VARIABLE_ID: Qi, OPPOSITE_TYPE: Ut, RENAME_VARIABLE_ID: Zi }, xm = 10, pe = class extends D {
          constructor(e, t) {
            super(e, t), this.highlighted = false, this.targetConnection = null, this.db = e.workspace.connectionDBList[t], this.dbOpposite = e.workspace.connectionDBList[Ut[t]], this.offsetInBlock = new f(0, 0), this.trackedState = pe.TrackedState.WILL_TRACK;
          }
          dispose() {
            super.dispose(), this.trackedState === pe.TrackedState.TRACKED && this.db.removeConnection(this, this.y);
            let e, t;
            (t = (e = this.sourceBlock_.pathObject).removeConnectionHighlight) == null || t.call(e, this);
          }
          getSourceBlock() {
            return super.getSourceBlock();
          }
          targetBlock() {
            return super.targetBlock();
          }
          distanceFrom(e) {
            let t = this.x - e.x;
            return e = this.y - e.y, Math.sqrt(t * t + e * e);
          }
          bumpAwayFrom(e, t = false) {
            if (!this.sourceBlock_.workspace.isDragging()) {
              var o = r.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * xm), s = r.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * xm), i = e.sourceBlock_.getRootBlock(), n = this.sourceBlock_.getRootBlock();
              if (!i.isInFlyout && !n.isInFlyout) {
                var l = true;
                if (n.isMovable()) i.isMovable() && t && (s = -s);
                else if (i.isMovable()) l = false, o = -o, s = -s;
                else return;
                t = l ? e : this, e = l ? this : e, i = l ? n : i, i.RTL && (o = -o), i.moveBy(t.x + o - e.x, t.y + s - e.y, ["bump"]);
              }
            }
          }
          moveTo(e, t) {
            let o = false;
            return this.trackedState === pe.TrackedState.WILL_TRACK ? (this.db.addConnection(this, t), this.trackedState = pe.TrackedState.TRACKED, o = true) : this.trackedState === pe.TrackedState.TRACKED && (this.db.removeConnection(this, this.y), this.db.addConnection(this, t), o = true), this.x = e, this.y = t, o;
          }
          moveBy(e, t) {
            return this.moveTo(this.x + e, this.y + t);
          }
          moveToOffset(e) {
            return this.moveTo(e.x + this.offsetInBlock.x, e.y + this.offsetInBlock.y);
          }
          setOffsetInBlock(e, t) {
            this.offsetInBlock.x = e, this.offsetInBlock.y = t;
          }
          getOffsetInBlock() {
            return this.offsetInBlock;
          }
          tightenEfficiently() {
            var e = this.targetConnection;
            let t = this.targetBlock();
            e && t && (e = f.difference(this.offsetInBlock, e.offsetInBlock), t.translate(e.x, e.y));
          }
          closest(e, t) {
            return this.dbOpposite.searchForClosest(this, e, t);
          }
          highlight() {
            this.highlighted = true;
            let e = this.findHighlightSvg();
            e && (e.style.display = "");
          }
          unhighlight() {
            this.highlighted = false;
            let e = this.findHighlightSvg();
            e && (e.style.display = "none");
          }
          isHighlighted() {
            return this.highlighted;
          }
          setTracking(e) {
            e && this.trackedState === pe.TrackedState.TRACKED || !e && this.trackedState === pe.TrackedState.UNTRACKED || this.sourceBlock_.isInFlyout || (e ? (this.db.addConnection(this, this.y), this.trackedState = pe.TrackedState.TRACKED) : (this.trackedState === pe.TrackedState.TRACKED && this.db.removeConnection(this, this.y), this.trackedState = pe.TrackedState.UNTRACKED));
          }
          stopTrackingAll() {
            if (this.setTracking(false), this.targetConnection) {
              let e = this.targetBlock().getDescendants(false);
              for (let t = 0; t < e.length; t++) {
                let o = e[t], s = o.getConnections_(true);
                for (let i = 0; i < s.length; i++) s[i].setTracking(false);
                for (let i of o.getIcons()) qt(i) && i.setBubbleVisible(false);
              }
            }
          }
          startTrackingAll() {
            this.setTracking(true);
            let e = [];
            if (this.type !== C.INPUT_VALUE && this.type !== C.NEXT_STATEMENT) return e;
            let t = this.targetBlock();
            if (t) {
              let o;
              t.isCollapsed() ? (o = [], t.outputConnection && o.push(t.outputConnection), t.nextConnection && o.push(t.nextConnection), t.previousConnection && o.push(t.previousConnection)) : o = t.getConnections_(true);
              for (let s = 0; s < o.length; s++) e.push(...o[s].startTrackingAll());
              e.length || (e = [t]);
            }
            return e;
          }
          onFailedConnect(e) {
            let t = this.getSourceBlock();
            if (we()) {
              let o = r.getGroup$$module$build$src$core$events$utils();
              setTimeout(function() {
                t.isDisposed() || t.getParent() || (r.setGroup$$module$build$src$core$events$utils(o), this.bumpAwayFrom(e), r.setGroup$$module$build$src$core$events$utils(false));
              }.bind(this), r.config$$module$build$src$core$config.bumpDelay);
            }
          }
          disconnectInternal(e = true) {
            let { parentConnection: t, childConnection: o } = this.getParentAndChildConnections();
            if (t && o) {
              var s = r.getGroup$$module$build$src$core$events$utils();
              s || r.setGroup$$module$build$src$core$events$utils(true);
              var i = t.getSourceBlock(), n = o.getSourceBlock();
              super.disconnectInternal(e), i.queueRender(), n.updateDisabled(), n.queueRender(), n.getSvgRoot().style.display = "block", r.setGroup$$module$build$src$core$events$utils(s);
            }
          }
          respawnShadow_() {
            super.respawnShadow_();
            let e = this.targetBlock();
            e && (e.initSvg(), e.queueRender());
          }
          neighbours(e) {
            return this.dbOpposite.getNeighbours(this, e);
          }
          connect_(e) {
            super.connect_(e);
            var t = this.getSourceBlock();
            e = e.getSourceBlock(), t.updateDisabled(), e.updateDisabled(), e.queueRender(), (t = t.getInputWithBlock(e)) && (t = t.isVisible(), e.getSvgRoot().style.display = t ? "block" : "none");
          }
          onCheckChanged_() {
            !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, false) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug();
          }
          setCheck(e) {
            return super.setCheck(e), this.sourceBlock_.queueRender(), this;
          }
          showContextMenu(e) {
            let t = M.registry.getContextMenuOptions({ focusedNode: this }, e);
            if (t.length) {
              var o = this.getSourceBlock(), s = o.workspace;
              if (e instanceof PointerEvent) var i = new f(e.clientX, e.clientY);
              else i = new f(this.x, this.y), i = ns(s, i).translate(o.RTL ? -5 : 5, 5);
              _s(e, t, o.RTL, s, i);
            }
          }
          getFocusableElement() {
            let e = this.findHighlightSvg();
            if (e) return e;
            throw Error("No highlight SVG found corresponding to this connection.");
          }
          getFocusableTree() {
            return this.getSourceBlock().workspace;
          }
          onNodeFocus() {
            this.highlight(), this.getSourceBlock().workspace.scrollBoundsIntoView(this.getSourceBlock().getBoundingRectangleWithoutChildren());
          }
          onNodeBlur() {
            this.unhighlight();
          }
          canBeFocused() {
            return true;
          }
          findHighlightSvg() {
            return document.getElementById(this.id);
          }
        };
        (function(e) {
          e = e.TrackedState || (e.TrackedState = {}), e[e.WILL_TRACK = -1] = "WILL_TRACK", e[e.UNTRACKED = 0] = "UNTRACKED", e[e.TRACKED = 1] = "TRACKED";
        })(pe || (pe = {}));
        var gE = pe.TrackedState, Fm = {};
        Fm.RenderedConnection = pe, Fm.TrackedState = gE;
        var Xo = class {
          constructor(e, t) {
            this.name = e, this.sourceBlock = t, this.fieldRow = [], this.align = r.Align$$module$build$src$core$inputs$align.LEFT, this.visible = true, this.type = r.inputTypes$$module$build$src$core$inputs$input_types.CUSTOM, this.connection = null;
          }
          getSourceBlock() {
            return this.sourceBlock;
          }
          appendField(e, t) {
            return this.insertFieldAt(this.fieldRow.length, e, t), this;
          }
          insertFieldAt(e, t, o) {
            if (e < 0 || e > this.fieldRow.length) throw Error("index " + e + " out of bounds.");
            return (t || t === "" && o) && (typeof t == "string" && (t = r.fromJson$$module$build$src$core$field_registry({ type: "field_label", text: t })), t.setSourceBlock(this.sourceBlock), this.sourceBlock.initialized && this.initField(t), t.name = o, t.setVisible(this.isVisible()), t.prefixField && (e = this.insertFieldAt(e, t.prefixField)), this.fieldRow.splice(e, 0, t), e++, t.suffixField && (e = this.insertFieldAt(e, t.suffixField)), this.sourceBlock.rendered && this.sourceBlock.queueRender()), e;
          }
          removeField(e, t) {
            for (let o = 0, s; s = this.fieldRow[o]; o++) if (s.name === e) return s.dispose(), this.fieldRow.splice(o, 1), this.sourceBlock.rendered && this.sourceBlock.queueRender(), true;
            if (t) return false;
            throw Error('Field "' + e + '" not found.');
          }
          isVisible() {
            return this.visible;
          }
          setVisible(e) {
            let t = [];
            if (this.visible === e) return t;
            this.visible = e;
            for (let o = 0, s; s = this.fieldRow[o]; o++) s.setVisible(e);
            if (this.connection && this.connection instanceof pe) {
              e ? t = this.connection.startTrackingAll() : this.connection.stopTrackingAll();
              let o = this.connection.targetBlock();
              o && (o.getSvgRoot().style.display = e ? "block" : "none");
            }
            return t;
          }
          markDirty() {
            for (let e = 0, t; t = this.fieldRow[e]; e++) t.markDirty();
          }
          setCheck(e) {
            if (!this.connection) throw Error("This input does not have a connection.");
            return this.connection.setCheck(e), this;
          }
          setAlign(e) {
            return this.align = e, this.sourceBlock.rendered && this.sourceBlock.queueRender(), this;
          }
          setShadowDom(e) {
            if (!this.connection) throw Error("This input does not have a connection.");
            return this.connection.setShadowDom(e), this;
          }
          getShadowDom() {
            if (!this.connection) throw Error("This input does not have a connection.");
            return this.connection.getShadowDom();
          }
          init() {
            for (let e of this.fieldRow) e.init();
          }
          initModel() {
            for (let e of this.fieldRow) e.initModel();
          }
          initField(e) {
            this.sourceBlock.rendered ? e.init() : e.initModel();
          }
          dispose() {
            for (let e = 0, t; t = this.fieldRow[e]; e++) t.dispose();
            this.connection && this.connection.dispose();
          }
          makeConnection(e) {
            return this.sourceBlock.makeConnection_(e);
          }
        }, mE = {};
        mE.Input = Xo;
        var rt = class extends Xo {
          constructor(e, t) {
            super(e, t), this.name = e, this.type = r.inputTypes$$module$build$src$core$inputs$input_types.DUMMY;
          }
        }, _E = {};
        _E.DummyInput = rt;
        var Ct = class extends Xo {
          constructor(e, t) {
            super(e, t), this.name = e, this.type = r.inputTypes$$module$build$src$core$inputs$input_types.END_ROW;
          }
        }, TE = {};
        TE.EndRowInput = Ct;
        var Ae = class extends Xo {
          constructor(e, t) {
            if (!e) throw Error("Statement inputs must have a non-empty name");
            super(e, t), this.name = e, this.type = r.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT, this.connection = this.makeConnection(C.NEXT_STATEMENT);
          }
        }, EE = {};
        EE.StatementInput = Ae;
        var Hm;
        r.ValueInput$$module$build$src$core$inputs$value_input = class extends Xo {
          constructor(e, t) {
            if (!e) throw Error("Value inputs must have a non-empty name");
            super(e, t), this.name = e, this.type = r.inputTypes$$module$build$src$core$inputs$input_types.VALUE, this.connection = this.makeConnection(C.INPUT_VALUE);
          }
        }, Hm = {}, Hm.ValueInput = r.ValueInput$$module$build$src$core$inputs$value_input;
        var bE = {};
        bE.isIcon = hn;
        var fE = {};
        fE.isCommentIcon = Ta;
        var Yo = class {
          constructor(e, t, o) {
            if (this.data = null, this.disposed = false, this.hue = null, this.colour_ = "#000000", this.styleName_ = "", this.suppressPrefixSuffix = false, this.previousConnection = this.nextConnection = this.outputConnection = null, this.inputList = [], this.icons = [], this.disabledReasons = /* @__PURE__ */ new Set(), this.tooltip = "", this.contextMenu = true, this.parentBlock_ = null, this.childBlocks_ = [], this.editable = this.movable = this.deletable = true, this.collapsed_ = this.shadow = false, this.outputShape_ = null, this.rendered = this.isInsertionMarker_ = this.initialized = this.disposing = false, this.onchangeWrapper = this.helpUrl = null, this.statementInputCount = 0, this.workspace = e, this.id = o && !e.getBlockById(o) ? o : wt(), e.setBlockById(this.id, this), this.xy = new f(0, 0), this.isInFlyout = e.isFlyout, this.isInMutator = e.isMutator, this.RTL = e.RTL, t) {
              if (this.type = t, o = K[t], !o || typeof o != "object") throw TypeError("Invalid block definition for type: " + t);
              Object.assign(this, o);
            }
            e.addTopBlock(this), e.addTypedBlock(this), new.target === Yo && this.doInit_();
          }
          doInit_() {
            let e = r.getGroup$$module$build$src$core$events$utils();
            e || r.setGroup$$module$build$src$core$events$utils(true);
            let t = we();
            try {
              typeof this.init == "function" && (r.setRecordUndo$$module$build$src$core$events$utils(false), this.init(), r.setRecordUndo$$module$build$src$core$events$utils(t)), J() && R(new (S(d.BLOCK_CREATE))(this));
            } finally {
              r.setGroup$$module$build$src$core$events$utils(e), r.setRecordUndo$$module$build$src$core$events$utils(t);
            }
            this.inputsInlineDefault = this.inputsInline, typeof this.onchange == "function" && this.setOnChange(this.onchange);
          }
          dispose(e = false) {
            this.disposing = true, this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper), this.unplug(e), J() && R(new (S(d.BLOCK_DELETE))(this)), this.workspace.removeTopBlock(this), this.disposeInternal();
          }
          disposeInternal() {
            this.disposing = true, this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper), this.workspace.removeTypedBlock(this), this.workspace.removeBlockById(this.id), typeof this.destroy == "function" && this.destroy(), this.childBlocks_.forEach((e) => e.disposeInternal()), this.inputList.forEach((e) => e.dispose()), this.inputList.length = 0, this.getConnections_(true).forEach((e) => e.dispose()), this.disposed = true;
          }
          isDeadOrDying() {
            return this.disposing || this.disposed;
          }
          initModel() {
            if (!this.initialized) {
              for (let e of this.inputList) e.initModel();
              this.initialized = true;
            }
          }
          unplug(e) {
            this.outputConnection && this.unplugFromRow(e), this.previousConnection && this.unplugFromStack(e);
          }
          unplugFromRow(e) {
            let t = null, o;
            (o = this.outputConnection) != null && o.isConnected() && (t = this.outputConnection.targetConnection, this.outputConnection.disconnect()), t && e && (e = this.getOnlyValueConnection()) && e.isConnected() && !e.targetBlock().isShadow() && (e = e.targetConnection, e?.disconnect(), this.workspace.connectionChecker.canConnect(e, t, false) ? t.connect(e) : e?.onFailedConnect(t));
          }
          getOnlyValueConnection() {
            let e = null;
            for (let t = 0; t < this.inputList.length; t++) {
              let o = this.inputList[t].connection;
              if (o && o.type === C.INPUT_VALUE && o.targetConnection) {
                if (e) return null;
                e = o;
              }
            }
            return e;
          }
          unplugFromStack(e) {
            let t = null, o;
            if ((o = this.previousConnection) != null && o.isConnected() && (t = this.previousConnection.targetConnection, this.previousConnection.disconnect()), e) {
              for (e = this.getNextBlock(); e && (e.isShadow() || !e.isMovable()); ) e = e.getNextBlock();
              if (e) {
                var s, i, n, l;
                e = (l = (s = e.previousConnection) == null || (i = s.targetBlock()) == null || (n = i.nextConnection) == null ? void 0 : n.targetConnection) != null ? l : null, e?.disconnect(), t && this.workspace.connectionChecker.canConnect(t, e, false) && t.connect(e);
              }
            }
          }
          getConnections_(e) {
            e = [], this.outputConnection && e.push(this.outputConnection), this.previousConnection && e.push(this.previousConnection), this.nextConnection && e.push(this.nextConnection);
            for (let t = 0, o; o = this.inputList[t]; t++) o.connection && e.push(o.connection);
            return e;
          }
          lastConnectionInStack(e) {
            let t = this.nextConnection;
            for (; t; ) {
              let o = t.targetBlock();
              if (!o || e && o.isShadow()) return t;
              t = o.nextConnection;
            }
            return null;
          }
          bumpNeighbours() {
          }
          getParent() {
            return this.parentBlock_;
          }
          getInputWithBlock(e) {
            for (let t = 0, o; o = this.inputList[t]; t++) if (o.connection && o.connection.targetBlock() === e) return o;
            return null;
          }
          getSurroundParent() {
            let e = this, t;
            do
              if (t = e, e = e.getParent(), !e) return null;
            while (e.getNextBlock() === t);
            return e;
          }
          getNextBlock() {
            return this.nextConnection && this.nextConnection.targetBlock();
          }
          getPreviousBlock() {
            return this.previousConnection && this.previousConnection.targetBlock();
          }
          getRootBlock() {
            let e, t = this;
            do
              e = t, t = e.parentBlock_;
            while (t);
            return e;
          }
          getTopStackBlock() {
            let e = this, t;
            do
              t = e.getPreviousBlock();
            while (t && t.getNextBlock() === e && (e = t));
            return e;
          }
          getChildren(e) {
            if (!e) return this.childBlocks_;
            e = [];
            for (let o = 0, s; s = this.inputList[o]; o++) if (s.connection) {
              var t = s.connection.targetBlock();
              t && e.push(t);
            }
            return (t = this.getNextBlock()) && e.push(t), e;
          }
          setParent(e) {
            if (e !== this.parentBlock_) {
              var t = this.previousConnection && this.previousConnection.targetBlock() || this.outputConnection && this.outputConnection.targetBlock(), o = !!t;
              if (o && e && t !== e) throw Error("Block connected to superior one that is not new parent.");
              if (!o && e) throw Error("Block not connected to new parent.");
              if (o && !e) throw Error("Cannot set parent to null while block is still connected to superior block.");
              this.parentBlock_ ? Pe(this.parentBlock_.childBlocks_, this) : this.workspace.removeTopBlock(this), (this.parentBlock_ = e) ? e.childBlocks_.push(this) : this.workspace.addTopBlock(this);
            }
          }
          getDescendants(e) {
            let t = [this], o = this.getChildren(e);
            for (let s, i = 0; s = o[i]; i++) t.push(...s.getDescendants(e));
            return t;
          }
          isDeletable() {
            return this.deletable && !this.isInFlyout && !this.shadow && !this.isDeadOrDying() && !this.workspace.isReadOnly();
          }
          isOwnDeletable() {
            return this.deletable;
          }
          setDeletable(e) {
            this.deletable = e;
          }
          isMovable() {
            return this.movable && !this.isInFlyout && !this.shadow && !this.isDeadOrDying() && !this.workspace.isReadOnly();
          }
          isOwnMovable() {
            return this.movable;
          }
          setMovable(e) {
            this.movable = e;
          }
          isDuplicatable() {
            return this.workspace.hasBlockLimits() ? this.workspace.isCapacityAvailable(ei(this, true)) : true;
          }
          isShadow() {
            return this.shadow;
          }
          setShadow(e) {
            this.shadow = e;
          }
          isInsertionMarker() {
            return this.isInsertionMarker_;
          }
          setInsertionMarker(e) {
            this.isInsertionMarker_ = e;
          }
          isEditable() {
            return this.editable && !this.isDeadOrDying() && !this.workspace.isReadOnly();
          }
          isOwnEditable() {
            return this.editable;
          }
          setEditable(e) {
            this.editable = e;
            for (let t of this.getFields()) t.updateEditable();
          }
          isDisposed() {
            return this.disposed;
          }
          isSimpleReporter() {
            if (!this.outputConnection) return false;
            for (let e of this.inputList) if (e.connection || e.fieldRow.length > 1) return false;
            return true;
          }
          getMatchingConnection(e, t) {
            let o = this.getConnections_(true);
            if (e = e.getConnections_(true), o.length !== e.length) throw Error("Connection lists did not match in length.");
            for (let s = 0; s < e.length; s++) if (e[s] === t) return o[s];
            return null;
          }
          setHelpUrl(e) {
            this.helpUrl = e;
          }
          setTooltip(e) {
            this.tooltip = e;
          }
          getTooltip() {
            return $s(this);
          }
          getColour() {
            return this.colour_;
          }
          getStyleName() {
            return this.styleName_;
          }
          getHue() {
            return this.hue;
          }
          setColour(e) {
            e = ps(e), this.hue = e.hue, this.colour_ = e.hex;
          }
          setStyle(e) {
            this.styleName_ = e;
          }
          setOnChange(e) {
            if (e && typeof e != "function") throw Error("onchange must be a function.");
            this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper), this.onchange = e, this.onchangeWrapper = e.bind(this), this.workspace.addChangeListener(this.onchangeWrapper);
          }
          getField(e) {
            if (typeof e != "string") throw TypeError("Block.prototype.getField expects a string with the field name but received " + (e === void 0 ? "nothing" : e + " of type " + typeof e) + " instead");
            for (let t of this.getFields()) if (t.name === e) return t;
            return null;
          }
          *getFields() {
            for (let e of this.inputList) for (let t of e.fieldRow) yield t;
          }
          getVars() {
            let e = [];
            for (let t of this.getFields()) t.referencesVariables() && e.push(t.getValue());
            return e;
          }
          getVarModels() {
            let e = [];
            for (let t of this.getFields()) if (t.referencesVariables()) {
              let o = this.workspace.getVariableById(t.getValue());
              o && e.push(o);
            }
            return e;
          }
          updateVarName(e) {
            for (let t of this.getFields()) t.referencesVariables() && e.getId() === t.getValue() && t.refreshVariableName();
          }
          renameVarById(e, t) {
            for (let o of this.getFields()) o.referencesVariables() && e === o.getValue() && o.setValue(t);
          }
          getFieldValue(e) {
            return (e = this.getField(e)) ? e.getValue() : null;
          }
          setFieldValue(e, t) {
            let o = this.getField(t);
            if (!o) throw Error('Field "' + t + '" not found.');
            o.setValue(e);
          }
          setPreviousStatement(e, t) {
            if (e) t === void 0 && (t = null), this.previousConnection || (this.previousConnection = this.makeConnection_(C.PREVIOUS_STATEMENT)), this.previousConnection.setCheck(t);
            else if (this.previousConnection) {
              if (this.previousConnection.isConnected()) throw Error("Must disconnect previous statement before removing connection.");
              this.previousConnection.dispose(), this.previousConnection = null;
            }
          }
          setNextStatement(e, t) {
            if (e) t === void 0 && (t = null), this.nextConnection || (this.nextConnection = this.makeConnection_(C.NEXT_STATEMENT)), this.nextConnection.setCheck(t);
            else if (this.nextConnection) {
              if (this.nextConnection.isConnected()) throw Error("Must disconnect next statement before removing connection.");
              this.nextConnection.dispose(), this.nextConnection = null;
            }
          }
          setOutput(e, t) {
            if (e) t === void 0 && (t = null), this.outputConnection || (this.outputConnection = this.makeConnection_(C.OUTPUT_VALUE)), this.outputConnection.setCheck(t);
            else if (this.outputConnection) {
              if (this.outputConnection.isConnected()) throw Error("Must disconnect output value before removing connection.");
              this.outputConnection.dispose(), this.outputConnection = null;
            }
          }
          setInputsInline(e) {
            this.inputsInline !== e && (R(new (S(d.BLOCK_CHANGE))(this, "inline", null, this.inputsInline, e)), this.inputsInline = e);
          }
          getInputsInline() {
            if (this.inputsInline !== void 0) return this.inputsInline;
            for (var e = 1; e < this.inputList.length; e++) if (this.inputList[e - 1] instanceof rt && this.inputList[e] instanceof rt) return false;
            for (e = 1; e < this.inputList.length; e++) if (this.inputList[e - 1] instanceof r.ValueInput$$module$build$src$core$inputs$value_input && this.inputList[e] instanceof rt) return true;
            for (e = 0; e < this.inputList.length; e++) if (this.inputList[e] instanceof Ct) return true;
            return false;
          }
          setOutputShape(e) {
            this.outputShape_ = e;
          }
          getOutputShape() {
            return this.outputShape_;
          }
          isEnabled() {
            return this.disabledReasons.size === 0;
          }
          setDisabledReason(e, t) {
            e || this.workspace.options.disable || !this.hasDisabledReason(Ke) || t == Ke || this.setDisabledReason(false, Ke), this.disabledReasons.has(t) !== e && (e ? this.disabledReasons.add(t) : this.disabledReasons.delete(t), e = new (S(d.BLOCK_CHANGE))(this, "disabled", null, !e, e), e.setDisabledReason(t), R(e));
          }
          getInheritedDisabled() {
            let e = this.getSurroundParent();
            for (; e; ) {
              if (!e.isEnabled()) return true;
              e = e.getSurroundParent();
            }
            return false;
          }
          hasDisabledReason(e) {
            return this.disabledReasons.has(e);
          }
          getDisabledReasons() {
            return this.disabledReasons;
          }
          isCollapsed() {
            return this.collapsed_;
          }
          setCollapsed(e) {
            this.collapsed_ !== e && (R(new (S(d.BLOCK_CHANGE))(this, "collapsed", null, this.collapsed_, e)), this.collapsed_ = e);
          }
          toString(e, t) {
            t = this.toTokens(t);
            for (let s = 2; s < t.length; s++) t[s - 2] === "(" && t[s] === ")" && (t[s - 2] = t[s - 1], t.splice(s - 1, 2));
            let o = "";
            return t = t.reduce((s, i) => (s = s + (o === "(" || i === ")" ? "" : " ") + i, o = i[i.length - 1], s), ""), t = t.trim() || "???", e && t.length > e && (t = t.substring(0, e - 3) + "..."), t;
          }
          toTokens(e = "?") {
            let t = [];
            for (let s of this.inputList) if (s.name != Cs) {
              for (let i of s.fieldRow) t.push(i.getText());
              if (s.connection) {
                let i = s.connection.targetBlock();
                if (i) {
                  var o = s.connection;
                  let n = o.getCheck();
                  !n && o.targetConnection && (n = o.targetConnection.getCheck()), (o = !!n && (n.includes("Boolean") || n.includes("Number"))) && t.push("("), t.push(...i.toTokens(e)), o && t.push(")");
                } else t.push(e);
              }
            }
            return t;
          }
          appendValueInput(e) {
            return this.appendInput(new r.ValueInput$$module$build$src$core$inputs$value_input(e, this));
          }
          appendStatementInput(e) {
            return this.statementInputCount++, this.appendInput(new Ae(e, this));
          }
          appendDummyInput(e = "") {
            return this.appendInput(new rt(e, this));
          }
          appendEndRowInput(e = "") {
            return this.appendInput(new Ct(e, this));
          }
          appendInput(e) {
            return this.inputList.push(e), e;
          }
          appendInputFromRegistry(e, t) {
            return (e = Y(E.INPUT, e, false)) ? this.appendInput(new e(t, this)) : null;
          }
          jsonInit(e) {
            var t = e.type ? 'Block "' + e.type + '": ' : "";
            if (e.output && e.previousStatement) throw Error(t + "Must not have both an output and a previousStatement.");
            for (var o = 0; e["args" + o]; ) {
              if (e["message" + o] === void 0) throw Error(t + `args${o} must have a corresponding message (message${o}).`);
              o++;
            }
            if (e.style && e.style.hat && (this.hat = e.style.hat, e.style = null), e.style && e.colour) throw Error(t + "Must not have both a colour and a style.");
            for (e.style ? this.jsonInitStyle(e, t) : this.jsonInitColour(e, t), o = 0; e["message" + o] !== void 0; ) this.interpolate(e["message" + o], e["args" + o] || [], e["implicitAlign" + o] || e["lastDummyAlign" + o], t), o++;
            if (e.inputsInline !== void 0 && (r.disable$$module$build$src$core$events$utils(), this.setInputsInline(e.inputsInline), r.enable$$module$build$src$core$events$utils()), e.output !== void 0 && this.setOutput(true, e.output), e.outputShape !== void 0 && this.setOutputShape(e.outputShape), e.previousStatement !== void 0 && this.setPreviousStatement(true, e.previousStatement), e.nextStatement !== void 0 && this.setNextStatement(true, e.nextStatement), e.tooltip !== void 0 && (o = ie(e.tooltip), this.setTooltip(o)), e.enableContextMenu !== void 0 && (this.contextMenu = !!e.enableContextMenu), e.suppressPrefixSuffix !== void 0 && (this.suppressPrefixSuffix = !!e.suppressPrefixSuffix), e.helpUrl !== void 0 && (o = ie(e.helpUrl), this.setHelpUrl(o)), typeof e.extensions == "string" && (console.warn(t + "JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '" + e.type + "' block."), e.extensions = [e.extensions]), e.mutator !== void 0 && cn(e.mutator, this, true), e = e.extensions, Array.isArray(e)) for (t = 0; t < e.length; t++) cn(e[t], this, false);
          }
          jsonInitColour(e, t) {
            if ("colour" in e) if (e.colour === void 0) console.warn(t + "Undefined colour value.");
            else {
              e = e.colour;
              try {
                this.setColour(e);
              } catch {
                console.warn(t + "Illegal colour value: ", e);
              }
            }
          }
          jsonInitStyle(e, t) {
            e = e.style;
            try {
              this.setStyle(e);
            } catch {
              console.warn(t + "Style does not exist: ", e);
            }
          }
          mixin(e, t) {
            if (t !== void 0 && typeof t != "boolean") throw Error("opt_disableCheck must be a boolean if provided");
            if (!t) {
              t = [];
              for (let o in e) this[o] !== void 0 && t.push(o);
              if (t.length) throw Error("Mixin will overwrite block members: " + JSON.stringify(t));
            }
            Object.assign(this, e);
          }
          interpolate(e, t, o, s) {
            e = ea(e), this.validateTokens(e, t.length), t = this.interpolateArguments(e, t, o), o = [];
            for (let i = 0, n; n = t[i]; i++) if (this.isInputKeyword(n.type)) {
              if (e = this.inputFromJson(n, s)) {
                for (let l = 0, a; a = o[l]; l++) e.appendField(a[0], a[1]);
                o.length = 0;
              }
            } else (e = this.fieldFromJson(n)) && o.push([e, n.name]);
          }
          validateTokens(e, t) {
            let o = [], s = 0;
            for (let i = 0; i < e.length; i++) {
              let n = e[i];
              if (typeof n == "number") {
                if (n < 1 || n > t) throw Error('Block "' + this.type + '": Message index %' + n + " out of range.");
                if (o[n]) throw Error('Block "' + this.type + '": Message index %' + n + " duplicated.");
                o[n] = true, s++;
              }
            }
            if (s !== t) throw Error('Block "' + this.type + '": Message does not reference all ' + t + " arg(s).");
          }
          interpolateArguments(e, t, o) {
            let s = [];
            for (let n = 0; n < e.length; n++) {
              var i = e[n];
              if (typeof i == "number" && (i = t[i - 1]), typeof i == "string") {
                if (i === `
`) i = { type: "input_end_row" }, o && (i.align = o);
                else if (i = this.stringToFieldJson(i), !i) continue;
              }
              s.push(i);
            }
            return (e = s.length) && !this.isInputKeyword(s[e - 1].type) && (e = { type: "input_dummy" }, o && (e.align = o), s.push(e)), s;
          }
          fieldFromJson(e) {
            let t = r.fromJson$$module$build$src$core$field_registry(e);
            return !t && e.alt ? typeof e.alt == "string" ? (e = this.stringToFieldJson(e.alt)) ? this.fieldFromJson(e) : null : this.fieldFromJson(e.alt) : t;
          }
          inputFromJson(e, t) {
            var o = { LEFT: r.Align$$module$build$src$core$inputs$align.LEFT, RIGHT: r.Align$$module$build$src$core$inputs$align.RIGHT, CENTRE: r.Align$$module$build$src$core$inputs$align.CENTRE, CENTER: r.Align$$module$build$src$core$inputs$align.CENTRE };
            let s;
            switch (e.type) {
              case "input_value":
                s = this.appendValueInput(e.name);
                break;
              case "input_statement":
                s = this.appendStatementInput(e.name);
                break;
              case "input_dummy":
                s = this.appendDummyInput(e.name);
                break;
              case "input_end_row":
                s = this.appendEndRowInput(e.name);
                break;
              default:
                s = this.appendInputFromRegistry(e.type, e.name);
            }
            return s ? (e.check && s.setCheck(e.check), e.align && (o = o[e.align.toUpperCase()], o === void 0 ? console.warn(t + "Illegal align value: ", e.align) : s.setAlign(o)), s) : null;
          }
          isInputKeyword(e) {
            return e === "input_value" || e === "input_statement" || e === "input_dummy" || e === "input_end_row" || G(E.INPUT, e);
          }
          stringToFieldJson(e) {
            return (e = e.trim()) ? { type: "field_label", text: e } : null;
          }
          moveInputBefore(e, t) {
            if (e !== t) {
              var o = -1, s = t ? -1 : this.inputList.length;
              for (let i = 0, n; n = this.inputList[i]; i++) if (n.name === e) {
                if (o = i, s !== -1) break;
              } else if (t && n.name === t && (s = i, o !== -1)) break;
              if (o === -1) throw Error('Named input "' + e + '" not found.');
              if (s === -1) throw Error('Reference input "' + t + '" not found.');
              this.moveNumberedInputBefore(o, s);
            }
          }
          moveNumberedInputBefore(e, t) {
            if (e === t) throw Error("Can't move input to itself.");
            if (e >= this.inputList.length) throw RangeError("Input index " + e + " out of bounds.");
            if (t > this.inputList.length) throw RangeError("Reference input " + t + " out of bounds.");
            let o = this.inputList[e];
            this.inputList.splice(e, 1), e < t && t--, this.inputList.splice(t, 0, o);
          }
          removeInput(e, t) {
            for (let o = 0, s; s = this.inputList[o]; o++) if (s.name === e) return s instanceof Ae && this.statementInputCount--, s.dispose(), this.inputList.splice(o, 1), true;
            if (t) return false;
            throw Error("Input not found: " + e);
          }
          getInput(e) {
            for (let t = 0, o; o = this.inputList[t]; t++) if (o.name === e) return o;
            return null;
          }
          getInputTargetBlock(e) {
            return (e = this.getInput(e)) && e.connection && e.connection.targetBlock();
          }
          getCommentText() {
            let e, t;
            return (t = (e = this.getIcon(ue.COMMENT)) == null ? void 0 : e.getText()) != null ? t : null;
          }
          setCommentText(e) {
            var t;
            let o, s = (o = (t = this.getIcon(ue.COMMENT)) == null ? void 0 : t.getText()) != null ? o : null;
            if (s !== e) {
              if (e !== null) {
                if (t = this.getIcon(ue.COMMENT), !t) {
                  if (t = Y(E.ICON, ue.COMMENT.toString(), false), !t) throw Error("No comment icon class is registered, so a comment cannot be set");
                  if (t = new t(this), !Ta(t)) throw Error("The class registered as a comment icon does not conform to the ICommentIcon interface");
                  t = this.addIcon(t);
                }
                r.disable$$module$build$src$core$events$utils(), t.setText(e), r.enable$$module$build$src$core$events$utils();
              } else this.removeIcon(ue.COMMENT);
              R(new (S(d.BLOCK_CHANGE))(this, "comment", null, s, e));
            }
          }
          setWarningText(e, t) {
          }
          setMutator(e) {
          }
          addIcon(e) {
            if (this.hasIcon(e.getType())) throw new Pm(e);
            return this.icons.push(e), this.icons.sort((t, o) => t.getWeight() - o.getWeight()), e;
          }
          removeIcon(e) {
            if (!this.hasIcon(e)) return false;
            let t;
            return (t = this.getIcon(e)) == null || t.dispose(), this.icons = this.icons.filter((o) => !o.getType().equals(e)), true;
          }
          hasIcon(e) {
            return this.icons.some((t) => t.getType().equals(e));
          }
          getIcon(e) {
            return e instanceof ue ? this.icons.find((t) => t.getType().equals(e)) : this.icons.find((t) => t.getType().toString() === e);
          }
          getIcons() {
            return [...this.icons];
          }
          getRelativeToSurfaceXY() {
            return this.xy;
          }
          moveBy(e, t, o) {
            if (this.parentBlock_) throw Error("Block has parent");
            let s = new (S(d.BLOCK_MOVE))(this);
            o && s.setReason(o), this.xy.translate(e, t), s.recordNew(), R(s);
          }
          makeConnection_(e) {
            return new D(this, e);
          }
          allInputsFilled(e) {
            if (e === void 0 && (e = true), !e && this.isShadow()) return false;
            for (let o = 0, s; s = this.inputList[o]; o++) if (s.connection) {
              var t = s.connection.targetBlock();
              if (!t || !t.allInputsFilled(e)) return false;
            }
            return (t = this.getNextBlock()) ? t.allInputsFilled(e) : true;
          }
          toDevString() {
            let e = this.type ? '"' + this.type + '" block' : "Block";
            return this.id && (e += ' (id="' + this.id + '")'), e;
          }
        };
        Yo.COLLAPSED_INPUT_NAME = Cs, Yo.COLLAPSED_FIELD_NAME = xi;
        var IE = {};
        IE.Block = Yo;
        var rl = null, er = null, tr = {};
        tr.connectionUiEffect = ba, tr.disconnectUiEffect = fa, tr.disconnectUiStop = bs, tr.disposeUiEffect = dn;
        var Ds = class {
          paste(e, t, o) {
            if (!t.isCapacityAvailable(e.typeCounts)) return null;
            o && (e.blockState.x = o.x, e.blockState.y = o.y), o = o || new f(e.blockState.x || 0, e.blockState.y || 0), r.disable$$module$build$src$core$events$utils();
            let s;
            try {
              s = Jt(e.blockState, t), ya(s, o);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
            if (!s) return s;
            J() && !s.isShadow() && R(new (S(d.BLOCK_CREATE))(s));
            let i = s;
            return _t().then(() => r.getFocusManager$$module$build$src$core$focus_manager().focusNode(i)), s;
          }
        };
        Ds.TYPE = "block", Fr(Ds.TYPE, new Ds());
        var Um = {};
        Um.BlockPaster = Ds, Um.moveBlockToNotConflict = ya;
        var pL = Lo, nl = {};
        nl.bumpIntoBounds = Lo, nl.bumpIntoBoundsHandler = Ca, nl.bumpTopObjectsIntoBounds = $n;
        var uh = class {
          constructor(e) {
            this.block = e, this.connectionPreviewer = this.connectionCandidate = this.startLoc = this.startChildConn = this.startParentConn = null, this.dragging = false, this.dragOffset = new f(0, 0), this.originalEventGroup = "", this.workspace = e.workspace;
          }
          isMovable() {
            if (this.block.isShadow()) {
              let e, t;
              return (t = (e = this.block.getParent()) == null ? void 0 : e.isMovable()) != null ? t : false;
            }
            return this.block.isOwnMovable() && !this.block.isDeadOrDying() && !this.workspace.isReadOnly() && !this.block.isInFlyout;
          }
          startDrag(e) {
            if (this.block.isShadow()) this.startDraggingShadow(e);
            else {
              this.dragging = true, this.fireDragStartEvent(), this.startLoc = this.block.getRelativeToSurfaceXY(), this.connectionCandidate = null, this.connectionPreviewer = new (Ce(E.CONNECTION_PREVIEWER, this.workspace.options))(this.block), fo(), this.workspace.setResizesEnabled(false), bs(), e = this.shouldHealStack(e), this.shouldDisconnect(e) && this.disconnectBlock(e), this.block.setDragging(true);
              var t;
              (t = this.workspace.getLayerManager()) == null || t.moveToDragLayer(this.block);
            }
          }
          shouldHealStack(e) {
            return !!e && (e.altKey || e.ctrlKey || e.metaKey);
          }
          startDraggingShadow(e) {
            let t = this.block.getParent();
            if (!t) throw Error("Tried to drag a shadow block with no parent. Shadow blocks should always have parents.");
            this.dragOffset = f.difference(t.getRelativeToSurfaceXY(), this.block.getRelativeToSurfaceXY()), t.startDrag(e);
          }
          shouldDisconnect(e) {
            return !!(this.block.getParent() || e && this.block.nextConnection && this.block.nextConnection.targetBlock());
          }
          disconnectBlock(e) {
            let t, o, s;
            if (this.startParentConn = (s = (t = this.block.outputConnection) == null ? void 0 : t.targetConnection) != null ? s : (o = this.block.previousConnection) == null ? void 0 : o.targetConnection, e) {
              let i;
              this.startChildConn = (i = this.block.nextConnection) == null ? void 0 : i.targetConnection;
            }
            this.block.unplug(e), fa(this.block);
          }
          fireDragStartEvent() {
            let e = new (S(d.BLOCK_DRAG))(this.block, true, this.block.getDescendants(false));
            R(e);
          }
          fireDragEndEvent() {
            let e = new (S(d.BLOCK_DRAG))(this.block, false, this.block.getDescendants(false));
            R(e);
          }
          fireMoveEvent() {
            if (!this.block.isDeadOrDying()) {
              var e = new (S(d.BLOCK_MOVE))(this.block);
              e.setReason(["drag"]), e.oldCoordinate = this.startLoc, e.recordNew(), R(e);
            }
          }
          drag(e) {
            if (this.block.isShadow()) {
              let t;
              (t = this.block.getParent()) == null || t.drag(f.sum(e, this.dragOffset));
            } else this.block.moveDuringDrag(e), this.updateConnectionPreview(this.block, f.difference(e, this.startLoc));
          }
          updateConnectionPreview(e, t) {
            var o = this.connectionCandidate;
            let s = this.getConnectionCandidate(e, t);
            if (s) {
              this.connectionCandidate = t = o && this.currCandidateIsBetter(o, t, s) ? o : s;
              var { local: i, neighbour: n } = t;
              t = i.type === C.OUTPUT_VALUE || i.type === C.PREVIOUS_STATEMENT;
              var l;
              if (o = n.isConnected() && !((l = n.targetBlock()) != null && l.isInsertionMarker()), t && o && !this.orphanCanConnectAtEnd(e, n.targetBlock(), i.type)) {
                let _;
                (_ = this.connectionPreviewer) == null || _.previewReplacement(i, n, n.targetBlock());
              } else {
                var a;
                (a = this.connectionPreviewer) == null || a.previewConnection(i, n);
              }
            } else {
              let _;
              (_ = this.connectionPreviewer) == null || _.hidePreview(), this.connectionCandidate = null;
            }
          }
          orphanCanConnectAtEnd(e, t, o) {
            return !!D.getConnectionForOrphanedConnection(e, o === C.OUTPUT_VALUE ? t.outputConnection : t.previousConnection);
          }
          currCandidateIsBetter(e, t, o) {
            let { local: s, neighbour: i } = e;
            e = new f(s.x, s.y);
            let n = new f(i.x, i.y);
            return t = f.distance(f.sum(e, t), n), o.distance > t - r.config$$module$build$src$core$config.currentConnectionPreference;
          }
          getConnectionCandidate(e, t) {
            e = this.getLocalConnections(e);
            let o = this.getSearchRadius(), s = null;
            for (let i of e) {
              let { connection: n, radius: l } = i.closest(o, t);
              n && (s = { local: i, neighbour: n, distance: l }, o = l);
            }
            return s;
          }
          getSearchRadius() {
            return this.connectionCandidate ? r.config$$module$build$src$core$config.connectingSnapRadius : r.config$$module$build$src$core$config.snapRadius;
          }
          getLocalConnections(e) {
            let t = e.getConnections_(false), o = e.lastConnectionInStack(true);
            return o && o !== e.nextConnection && t.push(o), t;
          }
          endDrag(e) {
            if (this.block.isShadow()) {
              let o;
              (o = this.block.getParent()) == null || o.endDrag(e);
            } else {
              this.originalEventGroup = r.getGroup$$module$build$src$core$events$utils(), this.fireDragEndEvent(), this.fireMoveEvent(), Io(), bs();
              var t;
              if ((t = this.connectionPreviewer) == null || t.hidePreview(), !this.block.isDeadOrDying() && this.dragging) {
                let o;
                (o = this.workspace.getLayerManager()) == null || o.moveOffDragLayer(this.block, co), this.block.setDragging(false);
              }
              this.connectionCandidate ? (this.applyConnections(this.connectionCandidate), this.disposeStep()) : this.block.queueRender().then(() => this.disposeStep());
            }
          }
          disposeStep() {
            let e = r.getGroup$$module$build$src$core$events$utils();
            r.setGroup$$module$build$src$core$events$utils(this.originalEventGroup), this.block.snapToGrid();
            let t;
            (t = this.connectionPreviewer) == null || t.dispose(), this.workspace.setResizesEnabled(true), r.setGroup$$module$build$src$core$events$utils(e);
          }
          applyConnections(e) {
            let { local: t, neighbour: o } = e;
            t.connect(o);
            let s = t.isSuperior() ? o : t, i = this.block.getRootBlock();
            _t().then(() => {
              ba(s.getSourceBlock()), setTimeout(() => {
                i.bringToFront();
              }, 0);
            });
          }
          revertDrag() {
            if (this.block.isShadow()) {
              let o;
              (o = this.block.getParent()) == null || o.revertDrag();
            } else {
              var e;
              (e = this.connectionPreviewer) == null || e.hidePreview(), this.connectionCandidate = null;
              var t;
              if ((t = this.startChildConn) == null || t.connect(this.block.nextConnection), this.startParentConn) switch (this.startParentConn.type) {
                case C.INPUT_VALUE:
                  this.startParentConn.connect(this.block.outputConnection);
                  break;
                case C.NEXT_STATEMENT:
                  this.startParentConn.connect(this.block.previousConnection);
              }
              else {
                this.block.moveTo(this.startLoc, ["drag"]);
                let o;
                (o = this.workspace.getLayerManager()) == null || o.moveOffDragLayer(this.block, co), Lo(this.workspace, this.workspace.getMetricsManager().getScrollMetrics(true), this.block);
              }
              this.startParentConn = this.startChildConn = null, this.block.setDragging(false), this.dragging = false;
            }
          }
        }, yE = {};
        yE.BlockDragStrategy = uh;
        var hh = class extends B {
          constructor(e, t, o, s) {
            super(t, o, s), this.text = e, this.workspace = t, this.anchor = o, this.ownerRect = s, this.paragraph = this.stringToSvg(e, this.contentContainer), this.updateBubbleSize(), I(this.svgRoot, "blocklyTextBubble");
          }
          getText() {
            return this.text;
          }
          setText(e) {
            this.text = e, V(this.paragraph), this.paragraph = this.stringToSvg(e, this.contentContainer), this.updateBubbleSize();
          }
          stringToSvg(e, t) {
            return t = this.createParagraph(t), e = this.createTextFragments(t, e), this.workspace.RTL && this.rightAlignTextFragments(t.getBBox().width, e), t;
          }
          createParagraph(e) {
            return b($.G, { class: "blocklyText blocklyBubbleText blocklyNoPointerEvents", transform: `translate(0,${B.BORDER_WIDTH})`, style: `direction: ${this.workspace.RTL ? "rtl" : "ltr"}` }, e);
          }
          createTextFragments(e, t) {
            let o = 1;
            return t.split(`
`).map((s) => {
              let i = b($.TEXT, { y: `${o}em`, x: B.BORDER_WIDTH }, e);
              return s = document.createTextNode(s), i.appendChild(s), o += 1, i;
            });
          }
          rightAlignTextFragments(e, t) {
            for (let o of t) o.setAttribute("text-anchor", "start"), o.setAttribute("x", `${e + B.BORDER_WIDTH}`);
          }
          updateBubbleSize() {
            let e = this.paragraph.getBBox();
            this.setSize(new N(e.width + B.BORDER_WIDTH * 2, e.height + B.BORDER_WIDTH * 2), true);
          }
        }, CE = {};
        CE.TextBubble = hh;
        var dh = 17, nt = class extends As {
          constructor(e) {
            super(e), this.sourceBlock = e, this.textMap = /* @__PURE__ */ new Map(), this.textBubble = null;
          }
          getType() {
            return nt.TYPE;
          }
          initView(e) {
            this.svgRoot || (super.initView(e), b($.PATH, { class: "blocklyIconShape", d: "M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z" }, this.svgRoot), b($.PATH, { class: "blocklyIconSymbol", d: "m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z" }, this.svgRoot), b($.RECT, { class: "blocklyIconSymbol", x: "7", y: "11", height: "2", width: "2" }, this.svgRoot), I(this.svgRoot, "blocklyWarningIcon"));
          }
          dispose() {
            super.dispose();
            let e;
            (e = this.textBubble) == null || e.dispose();
          }
          getWeight() {
            return nt.WEIGHT;
          }
          getSize() {
            return new N(dh, dh);
          }
          applyColour() {
            super.applyColour();
            let e;
            (e = this.textBubble) == null || e.setColour(this.sourceBlock.getColour());
          }
          updateCollapsed() {
          }
          isShownWhenCollapsed() {
            return true;
          }
          onLocationChange(e) {
            super.onLocationChange(e);
            let t;
            (t = this.textBubble) == null || t.setAnchorLocation(this.getAnchorLocation());
          }
          addMessage(e, t) {
            if (this.textMap.get(t) === e) return this;
            e ? this.textMap.set(t, e) : this.textMap.delete(t);
            let o;
            return (o = this.textBubble) == null || o.setText(this.getText()), this;
          }
          getText() {
            return [...this.textMap.values()].join(`
`);
          }
          onClick() {
            super.onClick(), this.setBubbleVisible(!this.bubbleIsVisible());
          }
          isClickableInFlyout() {
            return false;
          }
          bubbleIsVisible() {
            return !!this.textBubble;
          }
          setBubbleVisible(e) {
            let t = this;
            return (0, m.asyncExecutePromiseGeneratorFunction)(function* () {
              if (t.bubbleIsVisible() !== e) {
                if (yield _t(), e) t.textBubble = new hh(t.getText(), t.sourceBlock.workspace, t.getAnchorLocation(), t.getBubbleOwnerRect()), t.applyColour();
                else {
                  let o;
                  (o = t.textBubble) == null || o.dispose(), t.textBubble = null;
                }
                R(new (S(d.BUBBLE_OPEN))(t.sourceBlock, e, "warning"));
              }
            });
          }
          getBubble() {
            return this.textBubble;
          }
          getAnchorLocation() {
            let e = dh / 2;
            return f.sum(this.workspaceLocation, new f(e, e));
          }
          getBubbleOwnerRect() {
            let e = this.sourceBlock.getSvgRoot().getBBox();
            return new L(e.y, e.y + e.height, e.x, e.x + e.width);
          }
        };
        nt.TYPE = ue.WARNING, nt.WEIGHT = 2;
        var vE = {};
        vE.WarningIcon = nt;
        var z = class extends Yo {
          constructor(e, t, o) {
            if (super(e, t, o), this.childlessWidth = this.width = this.height = 0, this.warningTextDb = /* @__PURE__ */ new Map(), this.mutator = null, this.rendered = true, this.visuallyDisabled = false, this.translation = "", this.dragging = false, this.relativeCoords = new f(0, 0), this.dragStrategy = new uh(this), !e.rendered) throw TypeError("Cannot create a rendered block in a headless workspace");
            this.workspace = e, this.svgGroup = b($.G, {}), t && I(this.svgGroup, t), this.style = e.getRenderer().getConstants().getBlockStyle(null), this.pathObject = e.getRenderer().makePathObject(this.svgGroup, this.style), e = this.pathObject.svgPath, e.tooltip = this, di(e), this.svgGroup.setAttribute("data-id", this.id), e.id = Xe(), this.doInit_();
          }
          initSvg() {
            if (!this.initialized) {
              for (var e of this.inputList) e.init();
              for (let t of this.getIcons()) t.initView(this.createIconPointerDownListener(t)), t.updateEditable();
              this.applyColour(), this.pathObject.updateMovable(this.isMovable() || this.isInFlyout), (e = this.getSvgRoot()) && w(e, "pointerdown", this, this.onMouseDown), e.parentNode || this.workspace.getCanvas().appendChild(e), this.initialized = true;
            }
          }
          getColourSecondary() {
            return this.style.colourSecondary;
          }
          getColourTertiary() {
            return this.style.colourTertiary;
          }
          select() {
            this.addSelect(), Xt(this);
          }
          unselect() {
            this.removeSelect(), Xt(null);
          }
          setParent(e) {
            var t = this.parentBlock_;
            if (e !== t) {
              fo(), super.setParent(e), Io();
              var o = this.getSvgRoot();
              if (!this.workspace.isClearing && o) {
                var s = this.getRelativeToSurfaceXY(), i = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode(), n, l = this.getSvgRoot().contains((n = i?.getFocusableElement()) != null ? n : null);
                e ? (e.getSvgRoot().appendChild(o), l && i && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(i)) : t && (e = this.workspace.getCanvas().querySelector(".blocklyDragging"), t = e?.parentElement, n = this.workspace.getCanvas(), t === n ? n.insertBefore(o, e) : (n.appendChild(o), l && i && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(i)), this.translate(s.x, s.y)), this.applyColour();
              }
            }
          }
          getRelativeToSurfaceXY() {
            let e = this.workspace.getLayerManager();
            if (!e) throw Error("Cannot calculate position because the workspace has not been appended");
            let t = 0, o = 0, s = this.getSvgRoot();
            if (s) do {
              let i = si(s);
              t += i.x, o += i.y, s = s.parentNode;
            } while (s && !e.hasLayer(s));
            return new f(t, o);
          }
          moveBy(e, t, o) {
            if (this.parentBlock_) throw Error("Block has parent");
            let s = J(), i = null;
            s && (i = new (S(d.BLOCK_MOVE))(this), o && i.setReason(o)), e = new f(e, t), t = this.getRelativeToSurfaceXY(), e = f.sum(t, e), this.translate(e.x, e.y), this.updateComponentLocations(e), s && i && (i.recordNew(), R(i)), this.workspace.resizeContents();
          }
          translate(e, t) {
            this.translation = `translate(${e}, ${t})`, this.relativeCoords = new f(e, t), this.getSvgRoot().setAttribute("transform", this.getTranslation());
          }
          getTranslation() {
            return this.translation;
          }
          moveTo(e, t) {
            let o = this.getRelativeToSurfaceXY();
            this.moveBy(e.x - o.x, e.y - o.y, t);
          }
          moveDuringDrag(e) {
            this.translate(e.x, e.y), this.getSvgRoot().setAttribute("transform", this.getTranslation()), this.updateComponentLocations(e);
          }
          snapToGrid() {
            if (!this.isDeadOrDying() && !this.getParent() && !this.isInFlyout) {
              var e = this.workspace.getGrid();
              if (e != null && e.shouldSnap()) {
                var t = this.getRelativeToSurfaceXY();
                e = e.alignXY(t), e !== t && this.moveTo(e, ["snap"]);
              }
            }
          }
          getBoundingRectangle() {
            return this.getBoundingRectangleWithDimensions(this.getHeightWidth());
          }
          getBoundingRectangleWithoutChildren() {
            return this.getBoundingRectangleWithDimensions({ height: this.height, width: this.childlessWidth });
          }
          getBoundingRectangleWithDimensions(e) {
            let t = this.getRelativeToSurfaceXY(), o, s;
            return this.RTL ? (o = t.x - e.width, s = t.x) : (o = t.x, s = t.x + e.width), new L(t.y, t.y + e.height, o, s);
          }
          markDirty() {
            this.pathObject.constants = this.workspace.getRenderer().getConstants();
            for (let e = 0, t; t = this.inputList[e]; e++) t.markDirty();
          }
          setCollapsed(e) {
            this.collapsed_ !== e && (super.setCollapsed(e), this.updateCollapsed());
          }
          childHasWarning() {
            let e = this.getChildren(false);
            for (let t of e) if (t.getIcon(nt.TYPE) || t.childHasWarning()) return true;
            return false;
          }
          updateCollapsed() {
            var e = this.isCollapsed();
            let t = Cs, o = xi;
            for (let i = 0, n; n = this.inputList[i]; i++) n.name !== t && n.setVisible(!e);
            for (var s of this.getIcons()) s.updateCollapsed();
            e ? (I(this.svgGroup, "blocklyCollapsed"), this.childHasWarning() && this.setWarningText(r.Msg$$module$build$src$core$msg.COLLAPSED_WARNINGS_WARNING, z.COLLAPSED_WARNING_ID), e = this.toString(il), (s = this.getField(o)) ? s.setValue(e) : (this.getInput(t) || this.appendDummyInput(t)).appendField(new uo(e), o)) : (this.updateDisabled(), this.removeInput(t), P(this.svgGroup, "blocklyCollapsed"), this.setWarningText(null, z.COLLAPSED_WARNING_ID));
          }
          onMouseDown(e) {
            if (!this.workspace.isReadOnly()) {
              var t = this.workspace.getGesture(e);
              t && t.handleBlockStart(e, this);
            }
          }
          showHelp() {
            let e = typeof this.helpUrl == "function" ? this.helpUrl() : this.helpUrl;
            e && window.open(e);
          }
          generateContextMenu(e) {
            return this.workspace.isReadOnly() || !this.contextMenu ? null : (e = M.registry.getContextMenuOptions({ block: this, focusedNode: this }, e), this.customContextMenu && this.customContextMenu(e), e);
          }
          calculateContextMenuLocation(e) {
            if (e instanceof PointerEvent) return new f(e.clientX, e.clientY);
            e = ns(this.workspace, this.getRelativeToSurfaceXY());
            let t, o, s = (t = this.inputList.filter((i) => i.isVisible()).flatMap((i) => i.fieldRow).find((i) => i.isVisible())) == null || (o = t.getSvgRoot()) == null ? void 0 : o.getBoundingClientRect();
            return new f(this.RTL ? e.x - 5 : e.x + 5, (s && s.height ? s.y + s.height : e.y + this.height) + 5);
          }
          showContextMenu(e) {
            let t = this.generateContextMenu(e), o = this.calculateContextMenuLocation(e);
            t && t.length && (_s(e, t, this.RTL, this.workspace, o), na(this));
          }
          updateComponentLocations(e) {
            this.dragging || this.updateConnectionLocations(e), this.updateIconLocations(e), this.updateFieldLocations(e);
            for (let t of this.getChildren(false)) t.updateComponentLocations(f.sum(e, t.relativeCoords));
          }
          updateConnectionLocations(e) {
            for (let t of this.getConnections_(false)) t.moveToOffset(e);
          }
          updateIconLocations(e) {
            for (let t of this.getIcons()) t.onLocationChange(e);
          }
          updateFieldLocations(e) {
            for (let t of this.inputList) for (let o of t.fieldRow) o.onLocationChange(e);
          }
          addClass(e) {
            I(this.svgGroup, e);
          }
          removeClass(e) {
            P(this.svgGroup, e);
          }
          setDragging(e) {
            (this.dragging = e) ? (this.translation = "", Ni.push(...this.getConnections_(true)), this.addClass("blocklyDragging")) : (Ni.length = 0, this.removeClass("blocklyDragging"));
            for (let t = 0; t < this.childBlocks_.length; t++) this.childBlocks_[t].setDragging(e);
          }
          setMovable(e) {
            super.setMovable(e), this.pathObject.updateMovable(e);
          }
          setEditable(e) {
            super.setEditable(e), e ? P(this.svgGroup, "blocklyNotEditable") : I(this.svgGroup, "blocklyNotEditable"), e = this.getIcons();
            for (let t = 0; t < e.length; t++) e[t].updateEditable();
          }
          setShadow(e) {
            super.setShadow(e), this.applyColour();
          }
          setInsertionMarker(e) {
            this.isInsertionMarker_ !== e && (this.isInsertionMarker_ = e) && (this.setColour(this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR), this.pathObject.updateInsertionMarker(true));
          }
          getSvgRoot() {
            return this.svgGroup;
          }
          dispose(e, t) {
            this.disposing = true, Kc(), gi();
            let o = r.getFocusManager$$module$build$src$core$focus_manager();
            var s, i;
            if (this.getSvgRoot().contains((i = (s = o.getFocusedNode()) == null ? void 0 : s.getFocusableElement()) != null ? i : null)) {
              if (s = this.getParent(), !s) {
                let n;
                if (i = (n = this.outputConnection) != null ? n : this.previousConnection) {
                  let l;
                  s = (l = i.closest(0, new f(0, 0)).connection) == null ? void 0 : l.getSourceBlock();
                }
              }
              s ? o.focusNode(s) : setTimeout(() => o.focusTree(this.workspace), 0);
            }
            t && (this.unplug(e), dn(this)), super.dispose(!!e), V(this.svgGroup);
          }
          disposeInternal() {
            this.disposing = true, super.disposeInternal(), r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === this && this.workspace.cancelCurrentGesture(), [...this.warningTextDb.values()].forEach((e) => clearTimeout(e)), this.warningTextDb.clear(), this.getIcons().forEach((e) => e.dispose());
          }
          checkAndDelete() {
            this.workspace.isFlyout || (r.setGroup$$module$build$src$core$events$utils(true), this.workspace.hideChaff(), this.outputConnection ? this.dispose(false, true) : this.dispose(true, true), r.setGroup$$module$build$src$core$events$utils(false));
          }
          toCopyData(e = false) {
            return this.isInsertionMarker_ ? null : { paster: Ds.TYPE, blockState: Be(this, { addCoordinates: true, addNextBlocks: e, saveIds: false }), typeCounts: ei(this, true) };
          }
          applyColour() {
            var e, t;
            for ((t = (e = this.pathObject).applyColour) == null || t.call(e, this), e = this.getIcons(), t = 0; t < e.length; t++) e[t].applyColour();
            for (let o of this.getFields()) o.applyColour();
          }
          updateDisabled() {
            let e = !this.isEnabled() || this.getInheritedDisabled();
            if (this.visuallyDisabled === e) {
              let t;
              (t = this.getNextBlock()) == null || t.updateDisabled();
            } else {
              this.applyColour(), this.visuallyDisabled = e;
              for (let t of this.getChildren(false)) t.updateDisabled();
            }
          }
          setWarningText(e, t = "") {
            if (t) this.warningTextDb.has(t) && (clearTimeout(this.warningTextDb.get(t)), this.warningTextDb.delete(t));
            else {
              for (var o of this.warningTextDb.values()) clearTimeout(o);
              this.warningTextDb.clear();
            }
            if (this.workspace.isDragging()) this.warningTextDb.set(t, setTimeout(() => {
              this.isDeadOrDying() || (this.warningTextDb.delete(t), this.setWarningText(e, t));
            }, 100));
            else if (this.isInFlyout && (e = null), o = this.getIcon(nt.TYPE), e) {
              let s = this.getSurroundParent(), i = null;
              for (; s; ) s.isCollapsed() && (i = s), s = s.getSurroundParent();
              i && i.setWarningText(r.Msg$$module$build$src$core$msg.COLLAPSED_WARNINGS_WARNING, z.COLLAPSED_WARNING_ID), o ? o.addMessage(e, t) : this.addIcon(new nt(this).addMessage(e, t));
            } else o && (t ? (o.addMessage("", t), o.getText() || this.removeIcon(nt.TYPE)) : this.removeIcon(nt.TYPE));
          }
          setMutator(e) {
            this.removeIcon(r.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE), e && this.addIcon(e);
          }
          addIcon(e) {
            return super.addIcon(e), e instanceof r.MutatorIcon$$module$build$src$core$icons$mutator_icon && (this.mutator = e), e.initView(this.createIconPointerDownListener(e)), e.applyColour(), e.updateEditable(), this.queueRender(), e;
          }
          createIconPointerDownListener(e) {
            return (t) => {
              this.isDeadOrDying() || (t = this.workspace.getGesture(t)) && t.setStartIcon(e);
            };
          }
          removeIcon(e) {
            let t = super.removeIcon(e);
            return e.equals(r.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE) && (this.mutator = null), this.queueRender(), t;
          }
          setDisabledReason(e, t) {
            let o = this.isEnabled();
            super.setDisabledReason(e, t), this.isEnabled() === o || this.getInheritedDisabled() || this.updateDisabled();
          }
          setDeletable(e) {
            super.setDeletable(e), e ? P(this.svgGroup, "blocklyNotDeletable") : I(this.svgGroup, "blocklyNotDeletable");
          }
          setHighlighted(e) {
            this.pathObject.updateHighlighted(e);
          }
          addSelect() {
            this.pathObject.updateSelected(true);
          }
          removeSelect() {
            this.pathObject.updateSelected(false);
          }
          setDeleteStyle(e) {
            this.pathObject.updateDraggingDelete(e);
          }
          getColour() {
            return this.style.colourPrimary;
          }
          setColour(e) {
            super.setColour(e), e = this.workspace.getRenderer().getConstants().getBlockStyleForColour(this.colour_);
            let t, o;
            (o = (t = this.pathObject).setStyle) == null || o.call(t, e.style), this.style = e.style, this.styleName_ = e.name, this.applyColour();
          }
          setStyle(e) {
            let t = this.workspace.getRenderer().getConstants().getBlockStyle(e);
            if (this.styleName_ && P(this.svgGroup, this.styleName_), t) {
              this.hat = t.hat;
              let o, s;
              (s = (o = this.pathObject).setStyle) == null || s.call(o, t), this.colour_ = t.colourPrimary, this.style = t, this.applyColour(), I(this.svgGroup, e), this.styleName_ = e;
            } else throw Error("Invalid style name: " + e);
          }
          getStyle() {
            return this.style;
          }
          bringToFront(e = false) {
            let t = r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode(), o = this;
            if (!o.isDeadOrDying()) {
              do {
                let s = o.getSvgRoot(), i = s.parentNode, n = i.childNodes;
                if (n[n.length - 1] !== s && i.appendChild(s), e) break;
                o = o.getParent();
              } while (o);
              t && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(t);
            }
          }
          setPreviousStatement(e, t) {
            super.setPreviousStatement(e, t), this.queueRender();
          }
          setNextStatement(e, t) {
            super.setNextStatement(e, t), this.queueRender();
          }
          setOutput(e, t) {
            super.setOutput(e, t), this.queueRender();
          }
          setInputsInline(e) {
            super.setInputsInline(e), this.queueRender();
          }
          removeInput(e, t) {
            return e = super.removeInput(e, t), this.queueRender(), e;
          }
          moveNumberedInputBefore(e, t) {
            super.moveNumberedInputBefore(e, t), this.queueRender();
          }
          appendInput(e) {
            return super.appendInput(e), this.queueRender(), e;
          }
          setConnectionTracking(e) {
            if (this.previousConnection && this.previousConnection.setTracking(e), this.outputConnection && this.outputConnection.setTracking(e), this.nextConnection) {
              this.nextConnection.setTracking(e);
              var t = this.nextConnection.targetBlock();
              t && t.setConnectionTracking(e);
            }
            if (!this.collapsed_) for (t = 0; t < this.inputList.length; t++) {
              var o = this.inputList[t].connection;
              o && (o.setTracking(e), (o = o.targetBlock()) && o.setConnectionTracking(e));
            }
          }
          getConnections_(e) {
            let t = [];
            if (this.outputConnection && t.push(this.outputConnection), this.previousConnection && t.push(this.previousConnection), this.nextConnection && t.push(this.nextConnection), e || !this.collapsed_) for (let o = 0, s; s = this.inputList[o]; o++) s.connection && t.push(s.connection);
            return t;
          }
          lastConnectionInStack(e) {
            return super.lastConnectionInStack(e);
          }
          getMatchingConnection(e, t) {
            return super.getMatchingConnection(e, t);
          }
          makeConnection_(e) {
            return new pe(this, e);
          }
          getNextBlock() {
            return super.getNextBlock();
          }
          getPreviousBlock() {
            return super.getPreviousBlock();
          }
          bumpNeighbours() {
            let e = this.getRootBlock();
            if (!(this.isDeadOrDying() || this.workspace.isDragging() || e.isInFlyout)) for (let t of this.getConnections_(false)) {
              if (t.isSuperior()) {
                let o;
                (o = t.targetBlock()) == null || o.bumpNeighbours();
              }
              for (let o of t.neighbours(r.config$$module$build$src$core$config.snapRadius)) o.getSourceBlock().getRootBlock() !== e && (t.isConnected() && o.isConnected() || (t.isSuperior() ? o.bumpAwayFrom(t, false) : t.bumpAwayFrom(o, true)));
            }
          }
          scheduleSnapAndBump() {
            this.snapToGrid(), this.bumpNeighbours();
          }
          positionNearConnection(e, t, o) {
            if (e.type === C.NEXT_STATEMENT || e.type === C.INPUT_VALUE) {
              let s = t.x;
              t = t.y, s += o.x - e.getOffsetInBlock().x, t += o.y - e.getOffsetInBlock().y, this.moveBy(s, t);
            }
          }
          getChildren(e) {
            return super.getChildren(e);
          }
          queueRender() {
            return gc(this);
          }
          render() {
            this.queueRender(), jt();
          }
          renderEfficiently() {
            fo(), this.isCollapsed() && this.updateCollapsed(), this.isEnabled() || this.updateDisabled(), this.workspace.getRenderer().render(this), this.tightenChildrenEfficiently(), Io();
          }
          tightenChildrenEfficiently() {
            for (let e of this.inputList) {
              let t = e.connection;
              t && t.tightenEfficiently();
            }
            this.nextConnection && this.nextConnection.tightenEfficiently();
          }
          getHeightWidth() {
            let e = this.height, t = this.width;
            var o = this.getNextBlock();
            if (o) {
              o = o.getHeightWidth();
              let s = this.workspace.getRenderer().getConstants().NOTCH_HEIGHT;
              e += o.height - s, t = Math.max(t, o.width);
            }
            return { height: e, width: t };
          }
          fadeForReplacement(e) {
            this.pathObject.updateReplacementFade(e);
          }
          highlightShapeForInput(e, t) {
            this.pathObject.updateShapeForInputHighlight(e, t);
          }
          getDragStrategy() {
            return this.dragStrategy;
          }
          setDragStrategy(e) {
            this.dragStrategy = e;
          }
          isCopyable() {
            return this.isOwnDeletable() && this.isOwnMovable();
          }
          isMovable() {
            return this.dragStrategy.isMovable();
          }
          startDrag(e) {
            this.dragStrategy.startDrag(e);
          }
          drag(e, t) {
            this.dragStrategy.drag(e, t);
          }
          endDrag(e) {
            this.dragStrategy.endDrag(e);
          }
          revertDrag() {
            this.dragStrategy.revertDrag();
          }
          toFlyoutInfo() {
            let e = Object.assign({}, { kind: "BLOCK" }, Be(this)), t = /* @__PURE__ */ new Set(["id", "height", "width", "pinned", "enabled"]), o = function(s) {
              for (let i in s) t.has(i) ? delete s[i] : typeof s[i] == "object" && o(s[i]);
            };
            return o(e), [e];
          }
          jsonInit(e) {
            super.jsonInit(e), e.classes && this.addClass(Array.isArray(e.classes) ? e.classes.join(" ") : e.classes);
          }
          getFocusableElement() {
            return this.pathObject.svgPath;
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            this.select(), this.workspace.scrollBoundsIntoView(this.getBoundingRectangleWithoutChildren());
          }
          onNodeBlur() {
            this.unselect();
          }
          canBeFocused() {
            return true;
          }
        };
        z.INLINE = -1, z.COLLAPSED_WARNING_ID = "TEMP_COLLAPSED_WARNING_";
        var kE = {};
        kE.BlockSvg = z;
        var $h = class {
          constructor() {
          }
          onDragEnter(e) {
          }
          onDragOver(e) {
          }
          onDragExit(e) {
          }
          onDrop(e) {
          }
          getClientRect() {
            return null;
          }
          shouldPreventMove(e) {
            return false;
          }
        }, RE = {};
        RE.DragTarget = $h;
        var SE = {};
        SE.isDeletable = xe;
        var or = class extends $h {
          constructor() {
            super(), this.wouldDelete_ = false;
          }
          wouldDelete(e) {
            return e instanceof z ? (e = !e.getParent() && e.isDeletable(), this.updateWouldDelete_(e)) : this.updateWouldDelete_(xe(e) && e.isDeletable()), this.wouldDelete_;
          }
          updateWouldDelete_(e) {
            this.wouldDelete_ = e;
          }
        }, OE = {};
        OE.DeleteArea = or;
        var Ko = class {
          constructor(e, t) {
            this.element = e, this.type = t;
          }
          getElement() {
            return this.element;
          }
          getType() {
            return this.type;
          }
        }, wE = {};
        wE.FlyoutItem = Ko;
        var ll = class {
          constructor(e) {
            this.workspace_ = e;
          }
          getDimensionsPx_(e) {
            let t = 0, o = 0;
            return e && (t = e.getWidth(), o = e.getHeight()), new N(t, o);
          }
          getFlyoutMetrics(e) {
            return e = this.getDimensionsPx_(this.workspace_.getFlyout(e)), { width: e.width, height: e.height, position: this.workspace_.toolboxPosition };
          }
          getToolboxMetrics() {
            let e = this.getDimensionsPx_(this.workspace_.getToolbox());
            return { width: e.width, height: e.height, position: this.workspace_.toolboxPosition };
          }
          getSvgMetrics() {
            return this.workspace_.getCachedParentSvgSize();
          }
          getAbsoluteMetrics() {
            let e = 0, t = 0, o = this.getToolboxMetrics(), s = this.getFlyoutMetrics(), i = !!this.workspace_.getToolbox();
            var n;
            let l = !((n = this.workspace_.getFlyout()) != null && n.autoClose);
            n = i ? o.position : s.position;
            let a = n === A.TOP;
            return n === A.LEFT && (i && (e += o.width), l && (e += s.width)), a && (i && (t += o.height), l && (t += s.height)), { top: t, left: e };
          }
          getViewMetrics(e) {
            e = e ? this.workspace_.scale : 1;
            let t = this.getSvgMetrics(), o = this.getToolboxMetrics(), s = this.getFlyoutMetrics(), i = !!this.workspace_.getToolbox();
            var n;
            let l = !((n = this.workspace_.getFlyout()) != null && n.autoClose);
            n = i ? o.position : s.position;
            let a = n === A.LEFT || n === A.RIGHT;
            return (n === A.TOP || n === A.BOTTOM) && (i && (t.height -= o.height), l && (t.height -= s.height)), a && (i && (t.width -= o.width), l && (t.width -= s.width)), { height: t.height / e, width: t.width / e, top: -this.workspace_.scrollY / e, left: -this.workspace_.scrollX / e };
          }
          getContentMetrics(e) {
            e = e ? 1 : this.workspace_.scale;
            let t = this.workspace_.getBlocksBoundingBox();
            return { height: (t.bottom - t.top) * e, width: (t.right - t.left) * e, top: t.top * e, left: t.left * e };
          }
          hasFixedEdges() {
            return !this.workspace_.isMovableHorizontally() || !this.workspace_.isMovableVertically();
          }
          getComputedFixedEdges_(e) {
            if (!this.hasFixedEdges()) return {};
            let t = this.workspace_.isMovableHorizontally(), o = this.workspace_.isMovableVertically();
            e = e || this.getViewMetrics(false);
            let s = {};
            return o || (s.top = e.top, s.bottom = e.top + e.height), t || (s.left = e.left, s.right = e.left + e.width), s;
          }
          getPaddedContent_(e, t) {
            let o = t.top + t.height, s = t.left + t.width, i = e.width;
            e = e.height;
            let n = i / 2, l = e / 2;
            return { top: Math.min(t.top - l, o - e), bottom: Math.max(o + l, t.top + e), left: Math.min(t.left - n, s - i), right: Math.max(s + n, t.left + i) };
          }
          getScrollMetrics(e, t, o) {
            e = e ? this.workspace_.scale : 1, t = t || this.getViewMetrics(false);
            var s = o || this.getContentMetrics();
            o = this.getComputedFixedEdges_(t), t = this.getPaddedContent_(t, s), s = o.top !== void 0 ? o.top : t.top;
            let i = o.left !== void 0 ? o.left : t.left;
            return { top: s / e, left: i / e, width: ((o.right !== void 0 ? o.right : t.right) - i) / e, height: ((o.bottom !== void 0 ? o.bottom : t.bottom) - s) / e };
          }
          getUiMetrics() {
            return { viewMetrics: this.getViewMetrics(), absoluteMetrics: this.getAbsoluteMetrics(), toolboxMetrics: this.getToolboxMetrics() };
          }
          getMetrics() {
            let e = this.getToolboxMetrics(), t = this.getFlyoutMetrics(true), o = this.getSvgMetrics(), s = this.getAbsoluteMetrics(), i = this.getViewMetrics(), n = this.getContentMetrics(), l = this.getScrollMetrics(false, i, n);
            return { contentHeight: n.height, contentWidth: n.width, contentTop: n.top, contentLeft: n.left, scrollHeight: l.height, scrollWidth: l.width, scrollTop: l.top, scrollLeft: l.left, viewHeight: i.height, viewWidth: i.width, viewTop: i.top, viewLeft: i.left, absoluteTop: s.top, absoluteLeft: s.left, svgHeight: o.height, svgWidth: o.width, toolboxWidth: e.width, toolboxHeight: e.height, toolboxPosition: e.position, flyoutWidth: t.width, flyoutHeight: t.height };
          }
        };
        c(E.METRICS_MANAGER, Fe, ll);
        var LE = {};
        LE.MetricsManager = ll;
        var ph = class extends ll {
          constructor(e, t) {
            super(e), this.flyout_ = t;
          }
          getBoundingBox() {
            let e;
            try {
              e = this.workspace_.getCanvas().getBBox();
            } catch {
              e = { height: 0, y: 0, width: 0, x: 0 };
            }
            return e;
          }
          getContentMetrics(e) {
            let t = this.getBoundingBox();
            return e = e ? 1 : this.workspace_.scale, { height: t.height * e, width: t.width * e, top: t.y * e, left: t.x * e };
          }
          getScrollMetrics(e, t, o) {
            return t = o || this.getContentMetrics(), o = this.flyout_.MARGIN * this.workspace_.scale, e = e ? this.workspace_.scale : 1, { height: (t.height + 2 * o) / e, width: (t.width + t.left + o) / e, top: 0, left: 0 };
          }
        }, NE = {};
        NE.FlyoutMetricsManager = ph;
        var Re = class {
          constructor(e, t, o, s) {
            this.workspace = e, this.targetWorkspace = t, this.isFlyoutLabel = s, this.height = this.width = 0, this.cursorSvg = this.svgText = null, this.text = o.text, this.position = new f(0, 0), this.callbackKey = o.callbackKey || o.callbackkey, this.cssClass = o["web-class"] || null, this.info = o, e = this.isFlyoutLabel ? "blocklyFlyoutLabel" : "blocklyFlyoutButton", this.cssClass && (e += " " + this.cssClass), this.id = Xe(), this.svgGroup = b($.G, { id: this.id, class: e }, this.workspace.getCanvas());
            let i;
            this.isFlyoutLabel || (i = b($.RECT, { class: "blocklyFlyoutButtonShadow", rx: Re.BORDER_RADIUS, ry: Re.BORDER_RADIUS, x: 1, y: 1 }, this.svgGroup)), e = b($.RECT, { class: this.isFlyoutLabel ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground", rx: Re.BORDER_RADIUS, ry: Re.BORDER_RADIUS }, this.svgGroup), t = b($.TEXT, { class: this.isFlyoutLabel ? "blocklyFlyoutLabelText" : "blocklyText", x: 0, y: 0, "text-anchor": "middle" }, this.svgGroup), o = ie(this.text), this.workspace.RTL && (o += "\u200F"), t.textContent = o, this.isFlyoutLabel && (this.svgText = t, this.workspace.getThemeManager().subscribe(this.svgText, "flyoutForegroundColour", "fill")), s = gt(t, "fontSize");
            let n = gt(t, "fontWeight"), l = gt(t, "fontFamily");
            if (this.width = Js(t, s, n, l), o = Sr(o, s, n, l), this.height = this.height || o.height, !this.isFlyoutLabel) {
              this.width += 2 * Re.TEXT_MARGIN_X, this.height += 2 * Re.TEXT_MARGIN_Y;
              let a;
              (a = i) == null || a.setAttribute("width", String(this.width));
              let _;
              (_ = i) == null || _.setAttribute("height", String(this.height));
            }
            e.setAttribute("width", String(this.width)), e.setAttribute("height", String(this.height)), t.setAttribute("x", String(this.width / 2)), t.setAttribute("y", String(this.height / 2 - o.height / 2 + o.baseline)), this.updateTransform(), this.onMouseDownWrapper = w(this.svgGroup, "pointerdown", this, this.onMouseDown), this.onMouseUpWrapper = w(this.svgGroup, "pointerup", this, this.onMouseUp);
          }
          createDom() {
            return this.svgGroup;
          }
          show() {
            this.updateTransform(), this.svgGroup.setAttribute("display", "block");
          }
          updateTransform() {
            this.svgGroup.setAttribute("transform", "translate(" + this.position.x + "," + this.position.y + ")");
          }
          moveTo(e, t) {
            this.position.x = e, this.position.y = t, this.updateTransform();
          }
          moveBy(e, t, o) {
            this.moveTo(this.position.x + e, this.position.y + t);
          }
          isLabel() {
            return this.isFlyoutLabel;
          }
          getPosition() {
            return this.position;
          }
          getBoundingRectangle() {
            return new L(this.position.y, this.position.y + this.height, this.position.x, this.position.x + this.width);
          }
          getButtonText() {
            return this.text;
          }
          getTargetWorkspace() {
            return this.targetWorkspace;
          }
          getWorkspace() {
            return this.workspace;
          }
          dispose() {
            x(this.onMouseDownWrapper), x(this.onMouseUpWrapper), this.svgGroup && V(this.svgGroup), this.svgText && this.workspace.getThemeManager().unsubscribe(this.svgText);
          }
          setCursorSvg(e) {
            e ? this.svgGroup && (this.svgGroup.appendChild(e), this.cursorSvg = e) : this.cursorSvg = null;
          }
          onMouseUp(e) {
            (e = this.targetWorkspace.getGesture(e)) && e.cancel(), this.isFlyoutLabel && this.callbackKey ? console.warn("Labels should not have callbacks. Label text: " + this.text) : this.isFlyoutLabel || this.callbackKey && this.targetWorkspace.getButtonCallback(this.callbackKey) ? this.isFlyoutLabel || (e = this.targetWorkspace.getButtonCallback(this.callbackKey)) && e(this) : console.warn("Buttons should have callbacks. Button text: " + this.text);
          }
          onMouseDown(e) {
            let t = this.targetWorkspace.getGesture(e), o = this.targetWorkspace.getFlyout();
            t && o && t.handleFlyoutStart(e, o);
          }
          getSvgRoot() {
            return this.svgGroup;
          }
          getFocusableElement() {
            return this.svgGroup;
          }
          getFocusableTree() {
            return this.workspace;
          }
          onNodeFocus() {
            var e = this.getPosition();
            e = new L(e.y, e.y + this.height, e.x, e.x + this.width), this.workspace.scrollBoundsIntoView(e);
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
        };
        Re.TEXT_MARGIN_X = 5, Re.TEXT_MARGIN_Y = 2, Re.BORDER_RADIUS = 4, pt(`
.blocklyFlyoutButton {
  fill: #888;
  cursor: default;
}

.blocklyFlyoutButtonShadow {
  fill: #666;
}

.blocklyFlyoutButton:hover {
  fill: #aaa;
}

.blocklyFlyoutLabel {
  cursor: default;
}

.blocklyFlyoutLabelBackground {
  opacity: 0;
}
`);
        var AE = {};
        AE.FlyoutButton = Re;
        var gh = class {
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return e.getWorkspace();
          }
          getNextSibling(e) {
            return null;
          }
          getPreviousSibling(e) {
            return null;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof Re;
          }
        }, ME = {};
        ME.FlyoutButtonNavigationPolicy = gh;
        var mh = class {
          constructor(e, t) {
            this.policy = e, this.flyout = t;
          }
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return this.policy.getParent(e);
          }
          getNextSibling(e) {
            let t = this.flyout.getContents();
            if (!t) return null;
            let o = t.findIndex((s) => s.getElement() === e);
            return o === -1 ? null : (o++, o >= t.length && (o = 0), t[o].getElement());
          }
          getPreviousSibling(e) {
            let t = this.flyout.getContents();
            if (!t) return null;
            let o = t.findIndex((s) => s.getElement() === e);
            return o === -1 ? null : (o--, o < 0 && (o = t.length - 1), t[o].getElement());
          }
          isNavigable(e) {
            return this.policy.isNavigable(e);
          }
          isApplicable(e) {
            return this.policy.isApplicable(e);
          }
        }, DE = {};
        DE.FlyoutNavigationPolicy = mh;
        var sr = class {
          constructor(e, t) {
            this.gap = e, this.axis = t, this.y = this.x = 0;
          }
          getBoundingRectangle() {
            switch (this.axis) {
              case "x":
                return new L(this.y, this.y, this.x, this.x + this.gap);
              case "y":
                return new L(this.y, this.y + this.gap, this.x, this.x);
            }
          }
          moveBy(e, t, o) {
            this.x += e, this.y += t;
          }
          isNavigable() {
            return false;
          }
          getFocusableElement() {
            throw Error("Cannot be focused");
          }
          getFocusableTree() {
            throw Error("Cannot be focused");
          }
          onNodeFocus() {
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return false;
          }
        }, PE = {};
        PE.FlyoutSeparator = sr;
        var _h = class {
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return null;
          }
          getNextSibling(e) {
            return null;
          }
          getPreviousSibling(e) {
            return null;
          }
          isNavigable(e) {
            return false;
          }
          isApplicable(e) {
            return e instanceof sr;
          }
        }, BE = {};
        BE.FlyoutSeparatorNavigationPolicy = _h;
        var Gm = class {
          getFirstChild(e) {
            return e.getEditor();
          }
          getParent(e) {
            let t;
            return (t = e.getOwner()) != null ? t : null;
          }
          getNextSibling(e) {
            return null;
          }
          getPreviousSibling(e) {
            return null;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof qi;
          }
        }, xE = {};
        xE.BlockCommentNavigationPolicy = Gm;
        var Th = class {
          getFirstChild(e) {
            return va(e, true)[0];
          }
          getParent(e) {
            var t;
            if ((t = e.previousConnection) != null && t.targetBlock()) {
              if (t = e.getSurroundParent()) return t;
            } else {
              let o;
              if ((o = e.outputConnection) != null && o.targetBlock()) return e.outputConnection.targetBlock();
            }
            return e.workspace;
          }
          getNextSibling(e) {
            let t;
            if ((t = e.nextConnection) != null && t.targetBlock()) {
              let s;
              return (s = e.nextConnection) == null ? void 0 : s.targetBlock();
            }
            let o;
            return (o = e.outputConnection) != null && o.targetBlock() ? Ye(e, 1) : e.getSurroundParent() ? Ye(e.getTopStackBlock(), 1) : this.getParent(e) instanceof Ie ? No(e, 1) : null;
          }
          getPreviousSibling(e) {
            let t;
            if ((t = e.previousConnection) != null && t.targetBlock()) {
              let s;
              return (s = e.previousConnection) == null ? void 0 : s.targetBlock();
            }
            let o;
            return (o = e.outputConnection) != null && o.targetBlock() ? Ye(e, -1) : this.getParent(e) instanceof Ie ? No(e, -1) : null;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof z;
          }
        }, Eh = {};
        Eh.BlockNavigationPolicy = Th, Eh.navigateBlock = Ye, Eh.navigateStacks = No;
        var Vm = class {
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return e.getCommentView().workspace.getCommentById(e.getCommentView().commentId);
          }
          getNextSibling(e) {
            let t = e.getCommentView().getCommentBarButtons();
            return e = t.indexOf(e), e >= 0 && e + 1 < t.length ? t[e + 1] : null;
          }
          getPreviousSibling(e) {
            let t = e.getCommentView().getCommentBarButtons();
            return e = t.indexOf(e), e > 0 ? t[e - 1] : null;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof Yi;
          }
        }, FE = {};
        FE.CommentBarButtonNavigationPolicy = Vm;
        var Wm = class {
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return null;
          }
          getNextSibling(e) {
            return null;
          }
          getPreviousSibling(e) {
            return null;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof Ki;
          }
        }, HE = {};
        HE.CommentEditorNavigationPolicy = Wm;
        var bh = class {
          getFirstChild(e) {
            return e.getParentInput() ? e.targetConnection : null;
          }
          getParent(e) {
            return e.getSourceBlock();
          }
          getNextSibling(e) {
            if (e.getParentInput()) return Ye(e, 1);
            if (e.type === C.NEXT_STATEMENT) {
              let o = e.targetConnection;
              var t = e.getSourceBlock();
              if (!o && t.getRootBlock().lastConnectionInStack(false) === e) {
                e = t.workspace.getTopBlocks(true), t = e.indexOf(t.getRootBlock()) + 1, t >= e.length && (t = 0), t = e[t];
                let s;
                return (s = this.getParentConnection(t)) != null ? s : t;
              }
              return o;
            }
            return e.getSourceBlock();
          }
          getPreviousSibling(e) {
            if (e.getParentInput()) return Ye(e, -1);
            if (e.type === C.PREVIOUS_STATEMENT || e.type === C.OUTPUT_VALUE) {
              let o = e.targetConnection && !e.targetConnection.getParentInput() ? e.targetConnection : null;
              var t = e.getSourceBlock();
              if (!o && this.getParentConnection(t.getRootBlock()) === e) {
                e = t.workspace.getTopBlocks(true), t = e.indexOf(t.getRootBlock()) - 1, t < 0 && (t = e.length - 1), t = e[t];
                let s;
                return (s = t.lastConnectionInStack(false)) != null ? s : t;
              }
              return o;
            }
            return e.type === C.NEXT_STATEMENT ? e.getSourceBlock() : null;
          }
          getParentConnection(e) {
            let t;
            return !e.outputConnection || (t = e.previousConnection) != null && t.isConnected() ? e.previousConnection : e.outputConnection;
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof pe;
          }
        }, UE = {};
        UE.ConnectionNavigationPolicy = bh;
        var fh = class {
          getFirstChild(e) {
            return null;
          }
          getParent(e) {
            return e.getSourceBlock();
          }
          getNextSibling(e) {
            return Ye(e, 1);
          }
          getPreviousSibling(e) {
            return Ye(e, -1);
          }
          isNavigable(e) {
            let t;
            return e.canBeFocused() && e.isVisible() && (e.isClickable() || e.isCurrentlyEditable()) && !((t = e.getSourceBlock()) != null && t.isSimpleReporter() && e.isFullBlockField()) && e.getParentInput().isVisible();
          }
          isApplicable(e) {
            return e instanceof F;
          }
        }, GE = {};
        GE.FieldNavigationPolicy = fh;
        var Ih = {};
        Ih.register = ka, Ih.unregister = jp;
        var yh = 17, zm = 160, Xm = 80, qe = class extends As {
          constructor(e) {
            super(e), this.sourceBlock = e, this.textInputBubble = null, this.text = "", this.bubbleSize = new N(zm, Xm), this.bubbleVisiblity = false;
          }
          getType() {
            return qe.TYPE;
          }
          initView(e) {
            this.svgRoot || (super.initView(e), b($.CIRCLE, { class: "blocklyIconShape", r: "8", cx: "8", cy: "8" }, this.svgRoot), b($.PATH, { class: "blocklyIconSymbol", d: "m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.4050.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25-1.201,0.998 -1.201,1.528 -1.204,2.19z" }, this.svgRoot), b($.RECT, { class: "blocklyIconSymbol", x: "6.8", y: "10.78", height: "2", width: "2" }, this.svgRoot), I(this.svgRoot, "blocklyCommentIcon"));
          }
          dispose() {
            super.dispose();
            let e;
            (e = this.textInputBubble) == null || e.dispose();
          }
          getWeight() {
            return qe.WEIGHT;
          }
          getSize() {
            return new N(yh, yh);
          }
          applyColour() {
            super.applyColour();
            let e = this.sourceBlock.getColour(), t;
            (t = this.textInputBubble) == null || t.setColour(e);
          }
          updateEditable() {
            let e = this, t = () => super.updateEditable;
            return (0, m.asyncExecutePromiseGeneratorFunction)(function* () {
              t().call(e), e.bubbleIsVisible() && (yield e.setBubbleVisible(false), yield e.setBubbleVisible(true));
            });
          }
          onLocationChange(e) {
            let t = this.workspaceLocation;
            super.onLocationChange(e), this.bubbleLocation && (e = f.difference(this.workspaceLocation, t), this.bubbleLocation = f.sum(this.bubbleLocation, e)), e = this.getAnchorLocation();
            let o;
            (o = this.textInputBubble) == null || o.setAnchorLocation(e);
          }
          setText(e) {
            let t = this.text;
            R(new (S(d.BLOCK_CHANGE))(this.sourceBlock, "comment", null, t, e)), this.text = e;
            let o;
            (o = this.textInputBubble) == null || o.setText(this.text);
          }
          getText() {
            return this.text;
          }
          setBubbleSize(e) {
            this.bubbleSize = e;
            let t;
            (t = this.textInputBubble) == null || t.setSize(this.bubbleSize, true);
          }
          getBubbleSize() {
            return this.bubbleSize;
          }
          setBubbleLocation(e) {
            this.bubbleLocation = e;
            let t;
            (t = this.textInputBubble) == null || t.moveDuringDrag(e);
          }
          getBubbleLocation() {
            return this.bubbleLocation;
          }
          saveState() {
            if (this.text) {
              let e = { text: this.text, pinned: this.bubbleIsVisible(), height: this.bubbleSize.height, width: this.bubbleSize.width }, t = this.getBubbleLocation();
              return t && (e.x = this.sourceBlock.workspace.RTL ? this.sourceBlock.workspace.getWidth() - (t.x + this.bubbleSize.width) : t.x, e.y = t.y), e;
            }
            return null;
          }
          loadState(e) {
            let t;
            this.text = (t = e.text) != null ? t : "";
            let o, s;
            this.bubbleSize = new N((o = e.width) != null ? o : zm, (s = e.height) != null ? s : Xm);
            let i;
            this.bubbleVisiblity = (i = e.pinned) != null ? i : false, this.setBubbleVisible(this.bubbleVisiblity);
            let n = e.x, l = e.y;
            _t().then(() => {
              n && l && (n = this.sourceBlock.workspace.RTL ? this.sourceBlock.workspace.getWidth() - (n + this.bubbleSize.width) : n, this.setBubbleLocation(new f(n, l)));
            });
          }
          onClick() {
            super.onClick(), this.setBubbleVisible(!this.bubbleIsVisible());
          }
          isClickableInFlyout() {
            return false;
          }
          onTextChange() {
            if (this.textInputBubble) {
              var e = this.textInputBubble.getText();
              this.text !== e && (R(new (S(d.BLOCK_CHANGE))(this.sourceBlock, "comment", null, this.text, e)), this.text = e);
            }
          }
          onSizeChange() {
            this.textInputBubble && (this.bubbleSize = this.textInputBubble.getSize());
          }
          onBubbleLocationChange() {
            this.textInputBubble && (this.bubbleLocation = this.textInputBubble.getRelativeToSurfaceXY());
          }
          bubbleIsVisible() {
            return this.bubbleVisiblity;
          }
          setBubbleVisible(e) {
            let t = this;
            return (0, m.asyncExecutePromiseGeneratorFunction)(function* () {
              t.bubbleVisiblity !== e && (t.bubbleVisiblity = e, yield _t(), !t.sourceBlock.rendered || t.sourceBlock.isInFlyout || t.sourceBlock.isInsertionMarker() || (e ? (t.sourceBlock.isEditable() ? t.showEditableBubble() : t.showNonEditableBubble(), t.applyColour()) : t.hideBubble(), R(new (S(d.BUBBLE_OPEN))(t.sourceBlock, e, "comment"))));
            });
          }
          getBubble() {
            return this.textInputBubble;
          }
          showEditableBubble() {
            this.createBubble();
            let e;
            (e = this.textInputBubble) == null || e.addTextChangeListener(() => this.onTextChange());
            let t;
            (t = this.textInputBubble) == null || t.addSizeChangeListener(() => this.onSizeChange());
          }
          showNonEditableBubble() {
            this.createBubble();
            let e;
            (e = this.textInputBubble) == null || e.setEditable(false);
          }
          createBubble() {
            this.textInputBubble = new qi(this.sourceBlock.workspace, this.getAnchorLocation(), this.getBubbleOwnerRect(), this), this.textInputBubble.setText(this.getText()), this.textInputBubble.setSize(this.bubbleSize, true), this.bubbleLocation && this.textInputBubble.moveDuringDrag(this.bubbleLocation), this.textInputBubble.addTextChangeListener(() => this.onTextChange()), this.textInputBubble.addSizeChangeListener(() => this.onSizeChange()), this.textInputBubble.addLocationChangeListener(() => this.onBubbleLocationChange());
          }
          hideBubble() {
            let e;
            (e = this.textInputBubble) == null || e.dispose(), this.textInputBubble = null;
          }
          getAnchorLocation() {
            let e = yh / 2;
            return f.sum(this.workspaceLocation, new f(e, e));
          }
          getBubbleOwnerRect() {
            return this.sourceBlock.getBoundingRectangleWithoutChildren();
          }
        };
        qe.TYPE = ue.COMMENT, qe.WEIGHT = 3, ka(qe.TYPE, qe);
        var VE = {};
        VE.CommentIcon = qe;
        var Ym = class {
          getFirstChild(e) {
            if (e instanceof r.MutatorIcon$$module$build$src$core$icons$mutator_icon && e.bubbleIsVisible() && r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === e) {
              let t, o;
              return (o = (t = e.getBubble()) == null ? void 0 : t.getWorkspace()) != null ? o : null;
            }
            if (e instanceof qe && e.bubbleIsVisible() && r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === e) {
              let t, o;
              return (o = (t = e.getBubble()) == null ? void 0 : t.getEditor()) != null ? o : null;
            }
            return null;
          }
          getParent(e) {
            return e.getSourceBlock();
          }
          getNextSibling(e) {
            return Ye(e, 1);
          }
          getPreviousSibling(e) {
            return Ye(e, -1);
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof As;
          }
        }, WE = {};
        WE.IconNavigationPolicy = Ym;
        var Km = class {
          getFirstChild(e) {
            return e.view.getCommentBarButtons()[0];
          }
          getParent(e) {
            return e.workspace;
          }
          getNextSibling(e) {
            return No(e, 1);
          }
          getPreviousSibling(e) {
            return No(e, -1);
          }
          isNavigable(e) {
            return e.canBeFocused();
          }
          isApplicable(e) {
            return e instanceof It;
          }
        }, zE = {};
        zE.WorkspaceCommentNavigationPolicy = Km;
        var Ch = class {
          getFirstChild(e) {
            return e = e.getTopBlocks(true), e.length ? e[0] : null;
          }
          getParent(e) {
            return null;
          }
          getNextSibling(e) {
            return null;
          }
          getPreviousSibling(e) {
            return null;
          }
          isNavigable(e) {
            return e.canBeFocused() && !e.isMutator;
          }
          isApplicable(e) {
            return e instanceof Ie;
          }
        }, XE = {};
        XE.WorkspaceNavigationPolicy = Ch;
        var cl = class {
          constructor() {
            this.rules = [new Th(), new fh(), new bh(), new Ch(), new Ym(), new Km(), new Vm(), new Gm(), new Wm()];
          }
          addNavigationPolicy(e) {
            this.rules.push(e);
          }
          get(e) {
            return this.rules.find((t) => t.isApplicable(e));
          }
          getFirstChild(e) {
            let t, o = (t = this.get(e)) == null ? void 0 : t.getFirstChild(e);
            if (!o) return null;
            let s;
            return (s = this.get(o)) != null && s.isNavigable(o) ? o : this.getFirstChild(o) || this.getNextSibling(o);
          }
          getParent(e) {
            let t, o = (t = this.get(e)) == null ? void 0 : t.getParent(e);
            if (!o) return null;
            let s;
            return (s = this.get(o)) != null && s.isNavigable(o) ? o : this.getParent(o);
          }
          getNextSibling(e) {
            let t, o = (t = this.get(e)) == null ? void 0 : t.getNextSibling(e);
            if (!o) return null;
            let s;
            return (s = this.get(o)) != null && s.isNavigable(o) ? o : this.getNextSibling(o);
          }
          getPreviousSibling(e) {
            let t, o = (t = this.get(e)) == null ? void 0 : t.getPreviousSibling(e);
            if (!o) return null;
            let s;
            return (s = this.get(o)) != null && s.isNavigable(o) ? o : this.getPreviousSibling(o);
          }
        }, YE = {};
        YE.Navigator = cl;
        var vh = class extends cl {
          constructor(e) {
            super(), this.rules.push(new gh(), new _h()), this.rules = this.rules.map((t) => new mh(t, e));
          }
        }, KE = {};
        KE.FlyoutNavigator = vh;
        var al = class {
          constructor(e, t, o, s, i) {
            this.workspace = e, this.oldHostMetrics = this.corner_ = this.vScroll = this.hScroll = null, t = t === void 0 ? true : t, o = o === void 0 ? true : o;
            let n = t && o;
            t && (this.hScroll = new te(e, true, n, s, i)), o && (this.vScroll = new te(e, false, n, s, i)), n && (this.corner_ = b($.RECT, { height: te.scrollbarThickness, width: te.scrollbarThickness, class: "blocklyScrollbarBackground" }), bo(this.corner_, e.getBubbleCanvas()));
          }
          dispose() {
            V(this.corner_), this.oldHostMetrics = this.corner_ = null, this.hScroll && (this.hScroll.dispose(), this.hScroll = null), this.vScroll && (this.vScroll.dispose(), this.vScroll = null);
          }
          resize() {
            let e = this.workspace.getMetrics();
            if (e) {
              var t = false, o = false;
              if (this.oldHostMetrics && this.oldHostMetrics.viewWidth === e.viewWidth && this.oldHostMetrics.viewHeight === e.viewHeight && this.oldHostMetrics.absoluteTop === e.absoluteTop && this.oldHostMetrics.absoluteLeft === e.absoluteLeft ? (this.oldHostMetrics && this.oldHostMetrics.scrollWidth === e.scrollWidth && this.oldHostMetrics.viewLeft === e.viewLeft && this.oldHostMetrics.scrollLeft === e.scrollLeft || (t = true), this.oldHostMetrics && this.oldHostMetrics.scrollHeight === e.scrollHeight && this.oldHostMetrics.viewTop === e.viewTop && this.oldHostMetrics.scrollTop === e.scrollTop || (o = true)) : o = t = true, t || o) {
                try {
                  r.disable$$module$build$src$core$events$utils(), this.hScroll && t && this.hScroll.resize(e), this.vScroll && o && this.vScroll.resize(e);
                } finally {
                  r.enable$$module$build$src$core$events$utils();
                }
                this.workspace.maybeFireViewportChangeEvent();
              }
              if (this.hScroll && this.vScroll) {
                if (!this.oldHostMetrics || this.oldHostMetrics.viewWidth !== e.viewWidth || this.oldHostMetrics.absoluteLeft !== e.absoluteLeft) {
                  let s;
                  (s = this.corner_) == null || s.setAttribute("x", String(this.vScroll.position.x));
                }
                if (!this.oldHostMetrics || this.oldHostMetrics.viewHeight !== e.viewHeight || this.oldHostMetrics.absoluteTop !== e.absoluteTop) {
                  let s;
                  (s = this.corner_) == null || s.setAttribute("y", String(this.hScroll.position.y));
                }
              }
              this.oldHostMetrics = e;
            }
          }
          canScrollHorizontally() {
            return !!this.hScroll;
          }
          canScrollVertically() {
            return !!this.vScroll;
          }
          setOrigin(e, t) {
            this.hScroll && this.hScroll.setOrigin(e, t), this.vScroll && this.vScroll.setOrigin(e, t);
          }
          set(e, t, o) {
            this.hScroll && this.hScroll.set(e, false), this.vScroll && this.vScroll.set(t, false), (o || o === void 0) && (e = {}, this.hScroll && (e.x = this.hScroll.getRatio_()), this.vScroll && (e.y = this.vScroll.getRatio_()), this.workspace.setMetrics(e));
          }
          setX(e) {
            this.hScroll && this.hScroll.set(e, true);
          }
          setY(e) {
            this.vScroll && this.vScroll.set(e, true);
          }
          setContainerVisible(e) {
            this.hScroll && this.hScroll.setContainerVisible(e), this.vScroll && this.vScroll.setContainerVisible(e);
          }
          isVisible() {
            let e = false;
            return this.hScroll && (e = this.hScroll.isVisible()), this.vScroll && (e = e || this.vScroll.isVisible()), e;
          }
          setVisible(e) {
            this.hScroll && this.hScroll.setVisibleInternal(e), this.vScroll && this.vScroll.setVisibleInternal(e);
          }
          resizeContent(e) {
            this.hScroll && this.hScroll.resizeContentHorizontal(e), this.vScroll && this.vScroll.resizeContentVertical(e);
          }
          resizeView(e) {
            this.hScroll && this.hScroll.resizeViewHorizontal(e), this.vScroll && this.vScroll.resizeViewVertical(e);
          }
        }, jE = {};
        jE.ScrollbarPair = al;
        var jo = "sep", kh = class {
          load(e, t) {
            return e = new sr(0, t.horizontalLayout ? "x" : "y"), new Ko(e, jo);
          }
          gapForItem(e, t) {
            let o;
            return (o = parseInt(String(e.gap))) != null ? o : t;
          }
          disposeItem(e) {
          }
          getType() {
            return jo;
          }
        };
        c(E.FLYOUT_INFLATER, jo, kh);
        var JE = { SEPARATOR_TYPE: jo };
        JE.SeparatorFlyoutInflater = kh;
        var ir = class extends or {
          constructor(e) {
            super(), this.horizontalLayout = false, this.boundEvents = [], this.reflowWrapper = null, this.contents = [], this.autoClose = true, this.visible = false, this.containerVisible = true, this.CORNER_RADIUS = 8, this.SCROLLBAR_MARGIN = 2.5, this.height_ = this.width_ = 0, this.dragAngleRange_ = 70, this.svgGroup_ = this.svgBackground_ = null, this.inflaters = /* @__PURE__ */ new Map(), e.setMetrics = this.setMetrics_.bind(this), this.workspace_ = new Ie(e), this.workspace_.setMetricsManager(new ph(this.workspace_, this)), this.workspace_.internalIsFlyout = true, this.workspace_.setVisible(this.visible), this.workspace_.setNavigator(new vh(this)), this.id = wt(), this.RTL = !!e.RTL, this.toolboxPosition_ = e.toolboxPosition, this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH, this.MARGIN = this.CORNER_RADIUS, this.GAP_X = this.MARGIN * 3, this.GAP_Y = this.MARGIN * 3;
          }
          createDom(e) {
            return this.svgGroup_ = b(e, { class: "blocklyFlyout" }), this.svgGroup_.style.display = "none", this.svgBackground_ = b($.PATH, { class: "blocklyFlyoutBackground" }, this.svgGroup_), this.svgGroup_.appendChild(this.workspace_.createDom()), this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutBackgroundColour", "fill"), this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutOpacity", "fill-opacity"), this.svgGroup_;
          }
          init(e) {
            this.targetWorkspace = e, this.workspace_.targetWorkspace = e, this.workspace_.scrollbar = new al(this.workspace_, this.horizontalLayout, !this.horizontalLayout, "blocklyFlyoutScrollbar", this.SCROLLBAR_MARGIN), this.hide(), this.boundEvents.push(w(this.svgGroup_, "wheel", this, this.wheel_)), this.boundEvents.push(w(this.svgBackground_, "pointerdown", this, this.onMouseDown)), this.workspace_.getGesture = this.targetWorkspace.getGesture.bind(this.targetWorkspace), this.workspace_.setVariableMap(this.targetWorkspace.getVariableMap()), this.workspace_.createPotentialVariableMap(), e.getComponentManager().addComponent({ component: this, weight: j.ComponentWeight.FLYOUT_WEIGHT, capabilities: [j.Capability.AUTOHIDEABLE, j.Capability.DELETE_AREA, j.Capability.DRAG_TARGET] });
          }
          dispose() {
            this.hide(), this.targetWorkspace.getComponentManager().removeComponent(this.id);
            for (let e of this.boundEvents) x(e);
            this.boundEvents.length = 0, this.workspace_ && (this.workspace_.getThemeManager().unsubscribe(this.svgBackground_), this.workspace_.dispose()), this.svgGroup_ && V(this.svgGroup_);
          }
          getWidth() {
            return this.width_;
          }
          getHeight() {
            return this.height_;
          }
          getFlyoutScale() {
            return this.targetWorkspace.scale;
          }
          getWorkspace() {
            return this.workspace_;
          }
          setAutoClose(e) {
            this.autoClose = e, this.targetWorkspace.recordDragTargets(), this.targetWorkspace.resizeContents();
          }
          autoHide(e) {
            !e && this.targetWorkspace.getFlyout(true) === this && this.autoClose && this.hide();
          }
          getTargetWorkspace() {
            return this.targetWorkspace;
          }
          isVisible() {
            return this.visible;
          }
          setVisible(e) {
            let t = e !== this.isVisible();
            this.visible = e, t && (this.autoClose || this.targetWorkspace.recordDragTargets(), this.updateDisplay());
          }
          setContainerVisible(e) {
            let t = e !== this.containerVisible;
            this.containerVisible = e, t && this.updateDisplay();
          }
          getContents() {
            return this.contents;
          }
          setContents(e) {
            this.contents = e;
          }
          updateDisplay() {
            let e;
            e = this.containerVisible ? this.isVisible() : false, this.svgGroup_ && (this.svgGroup_.style.display = e ? "block" : "none");
            let t;
            (t = this.workspace_.scrollbar) == null || t.setContainerVisible(e);
          }
          positionAt_(e, t, o, s) {
            let i;
            (i = this.svgGroup_) == null || i.setAttribute("width", `${e}`);
            let n;
            (n = this.svgGroup_) == null || n.setAttribute("height", `${t}`), this.workspace_.setCachedParentSvgSize(e, t), this.svgGroup_ && Rr(this.svgGroup_, "translate(" + o + "px," + s + "px)"), (e = this.workspace_.scrollbar) && (e.setOrigin(o, s), e.resize(), e.hScroll && e.hScroll.setPosition(e.hScroll.position.x, e.hScroll.position.y), e.vScroll && e.vScroll.setPosition(e.vScroll.position.x, e.vScroll.position.y));
          }
          hide() {
            this.isVisible() && (this.setVisible(false), this.reflowWrapper && (this.workspace_.removeChangeListener(this.reflowWrapper), this.reflowWrapper = null));
          }
          show(e) {
            this.workspace_.setResizesEnabled(false), this.hide(), this.clearOldBlocks(), typeof e == "string" && (e = this.getDynamicCategoryContents(e)), this.setVisible(true), e = ri(e), e = this.createFlyoutInfo(e), jt(this.workspace_), this.setContents(e), this.layout_(e), this.horizontalLayout ? this.height_ = 0 : this.width_ = 0, this.reflow(), this.workspace_.setResizesEnabled(true), this.reflowWrapper = (t) => {
              t.type !== d.BLOCK_CHANGE && t.type !== d.BLOCK_FIELD_INTERMEDIATE_CHANGE || this.reflow();
            }, this.workspace_.addChangeListener(this.reflowWrapper);
          }
          createFlyoutInfo(e) {
            let t = [], o = this.horizontalLayout ? this.GAP_X : this.GAP_Y;
            for (let s of e) "custom" in s && (e = this.getDynamicCategoryContents(s.custom), e = ri(e), t.push(...this.createFlyoutInfo(e))), e = s.kind.toLowerCase(), (e = this.getInflaterForType(e)) && (t.push(e.load(s, this)), (e = e.gapForItem(s, o)) && t.push(new Ko(new sr(e, this.horizontalLayout ? "x" : "y"), jo)));
            return this.normalizeSeparators(t);
          }
          normalizeSeparators(e) {
            for (let t = e.length - 1; t > 0; t--) {
              let o = e[t].getType().toLowerCase(), s = e[t - 1].getType().toLowerCase();
              o === jo && s === jo && e.splice(t - 1, 1);
            }
            return e;
          }
          getDynamicCategoryContents(e) {
            if (e = this.workspace_.targetWorkspace.getToolboxCategoryCallback(e), typeof e != "function") throw TypeError("Couldn't find a callback function when opening a toolbox category.");
            return e(this.workspace_.targetWorkspace);
          }
          clearOldBlocks() {
            this.getContents().forEach((t) => {
              let o;
              (o = this.getInflaterForType(t.getType())) == null || o.disposeItem(t);
            });
            let e;
            (e = this.workspace_.getPotentialVariableMap()) == null || e.clear();
          }
          onMouseDown(e) {
            let t = this.targetWorkspace.getGesture(e);
            t && t.handleFlyoutStart(e, this);
          }
          isBlockCreatable(e) {
            return e.isEnabled() && !this.getTargetWorkspace().isReadOnly();
          }
          createBlock(e) {
            let t = null;
            r.disable$$module$build$src$core$events$utils();
            var o = this.targetWorkspace.getAllVariables();
            this.targetWorkspace.setResizesEnabled(false);
            try {
              t = this.placeNewBlock(e);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
            if (this.targetWorkspace.hideChaff(), e = ai(this.targetWorkspace, o), J()) {
              for (r.setGroup$$module$build$src$core$events$utils(true), o = 0; o < e.length; o++) {
                let s = e[o];
                R(new (S(d.VAR_CREATE))(s));
              }
              R(new (S(d.BLOCK_CREATE))(t));
            }
            return this.autoClose && this.hide(), t;
          }
          reflow() {
            this.reflowWrapper && this.workspace_.removeChangeListener(this.reflowWrapper), this.reflowInternal_(), this.reflowWrapper && this.workspace_.addChangeListener(this.reflowWrapper);
          }
          isScrollable() {
            return this.workspace_.scrollbar ? this.workspace_.scrollbar.isVisible() : false;
          }
          placeNewBlock(e) {
            var t = this.targetWorkspace;
            if (!e.getSvgRoot()) throw Error("oldBlock is not rendered");
            let o = this.serializeBlock(e);
            return t.setResizesEnabled(false), t = Jt(o, t), this.positionNewBlock(e, t), t;
          }
          serializeBlock(e) {
            return Be(e);
          }
          positionNewBlock(e, t) {
            let o = this.targetWorkspace;
            var s = o.getOriginOffsetInPixels(), i = this.workspace_.getOriginOffsetInPixels();
            e = e.getRelativeToSurfaceXY(), e.scale(this.workspace_.scale), i = f.sum(i, e), s = f.difference(i, s), s.scale(1 / o.scale), t.moveTo(new f(s.x, s.y));
          }
          getInflaterForType(e) {
            if (this.inflaters.has(e)) {
              var t;
              return (t = this.inflaters.get(e)) != null ? t : null;
            }
            return (t = Y(E.FLYOUT_INFLATER, e)) ? (t = new t(), this.inflaters.set(e, t), t) : null;
          }
          getFocusableElement() {
            throw Error("Flyouts are not directly focusable.");
          }
          getFocusableTree() {
            throw Error("Flyouts are not directly focusable.");
          }
          onNodeFocus() {
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return false;
          }
          getRootFocusableNode() {
            throw Error("Flyouts are not directly focusable.");
          }
          getRestoredFocusableNode(e) {
            throw Error("Flyouts are not directly focusable.");
          }
          getNestedTrees() {
            throw Error("Flyouts are not directly focusable.");
          }
          lookUpFocusableNode(e) {
            throw Error("Flyouts are not directly focusable.");
          }
          onTreeFocus(e, t) {
          }
          onTreeBlur(e) {
            throw Error("Flyouts are not directly focusable.");
          }
        }, qE = {};
        qE.Flyout = ir;
        var ZE = {};
        ZE.isDraggable = Ao;
        var Rh = class {
          constructor() {
            this.isActive = false, this.activeClassName = "blocklyKeyboardNavigation";
          }
          setIsActive(e = true) {
            this.isActive = e, this.updateActiveVisualization();
          }
          getIsActive() {
            return this.isActive;
          }
          updateActiveVisualization() {
            this.isActive ? document.body.classList.add(this.activeClassName) : document.body.classList.remove(this.activeClassName);
          }
        }, rr = new Rh(), jm = {};
        jm.KeyboardNavigationController = Rh, jm.keyboardNavigationController = rr;
        var Sh = class {
          constructor(e) {
            this.workspace = e, this.horizontalScrollEnabled = this.workspace.isMovableHorizontally(), this.verticalScrollEnabled = this.workspace.isMovableVertically(), this.startScrollXY_ = new f(e.scrollX, e.scrollY);
          }
          dispose() {
            this.workspace = null;
          }
          startDrag() {
          }
          endDrag(e) {
            this.drag(e);
          }
          drag(e) {
            if (e = f.sum(this.startScrollXY_, e), this.horizontalScrollEnabled && this.verticalScrollEnabled) this.workspace.scroll(e.x, e.y);
            else if (this.horizontalScrollEnabled) this.workspace.scroll(e.x, this.workspace.scrollY);
            else if (this.verticalScrollEnabled) this.workspace.scroll(this.workspace.scrollX, e.y);
            else throw new TypeError("Invalid state.");
          }
        }, QE = {};
        QE.WorkspaceDragger = Sh;
        var eb = 5, tb = 6, nr = class {
          constructor(e, t) {
            this.creatorWorkspace = t, this.mouseDownXY = new f(0, 0), this.startWorkspace_ = this.targetBlock = this.startComment = this.startBlock = this.startIcon = this.startField = this.startBubble = null, this.hasExceededDragRadius = false, this.boundEvents = [], this.workspaceDragger = this.dragger = null, this.dragging = false, this.flyout = null, this.multiTouch = this.isEnding_ = this.gestureHasStarted = this.calledUpdateIsDragging = false, this.cachedPoints = /* @__PURE__ */ new Map(), this.startDistance = this.previousScale = 0, this.currentDropdownOwner = this.isPinchZoomEnabled = null, this.mostRecentEvent = e, this.currentDragDeltaXY = new f(0, 0);
          }
          dispose() {
            Oe(), Jc(), this.creatorWorkspace.clearGesture();
            for (let e of this.boundEvents) x(e);
            this.boundEvents.length = 0, this.workspaceDragger && this.workspaceDragger.dispose();
          }
          updateFromEvent(e) {
            let t = new f(e.clientX, e.clientY);
            this.updateDragDelta(t) && (this.updateIsDragging(e), dt()), this.mostRecentEvent = e;
          }
          updateDragDelta(e) {
            return this.currentDragDeltaXY = f.difference(e, this.mouseDownXY), this.hasExceededDragRadius ? false : this.hasExceededDragRadius = f.magnitude(this.currentDragDeltaXY) > (this.flyout ? r.config$$module$build$src$core$config.flyoutDragRadius : r.config$$module$build$src$core$config.dragRadius);
          }
          updateIsDraggingFromFlyout() {
            let e;
            if (!this.targetBlock || (e = this.flyout) == null || !e.isBlockCreatable(this.targetBlock)) return false;
            if (!this.flyout.targetWorkspace) throw Error(`Cannot update dragging from the flyout because the ' +
          'flyout's target workspace is undefined`);
            return !this.flyout.isScrollable() || this.flyout.isDragTowardWorkspace(this.currentDragDeltaXY) ? (this.startWorkspace_ = this.flyout.targetWorkspace, this.startWorkspace_.updateScreenCalculationsIfScrolled(), r.getGroup$$module$build$src$core$events$utils() || r.setGroup$$module$build$src$core$events$utils(true), this.startBlock = null, this.targetBlock = this.flyout.createBlock(this.targetBlock), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.targetBlock), true) : false;
          }
          updateIsDraggingWorkspace() {
            if (!this.startWorkspace_) throw Error("Cannot update dragging the workspace because the start workspace is undefined");
            (this.flyout ? this.flyout.isScrollable() : this.startWorkspace_ && this.startWorkspace_.isDraggable()) && (this.dragging = true, this.workspaceDragger = new Sh(this.startWorkspace_), this.workspaceDragger.startDrag());
          }
          updateIsDragging(e) {
            if (!this.startWorkspace_) throw Error("Cannot update dragging because the start workspace is undefined");
            if (this.calledUpdateIsDragging) throw Error("updateIsDragging_ should only be called once per gesture.");
            this.calledUpdateIsDragging = true, this.flyout && this.updateIsDraggingFromFlyout();
            let t = rs();
            t && Ao(t) && t.isMovable() ? (this.dragging = true, this.dragger = this.createDragger(t, this.startWorkspace_), this.dragger.onDragStart(e), this.dragger.onDrag(e, this.currentDragDeltaXY)) : this.updateIsDraggingWorkspace();
          }
          createDragger(e, t) {
            return new (Ce(E.BLOCK_DRAGGER, this.creatorWorkspace.options, true))(e, t);
          }
          doStart(e) {
            if (!this.startWorkspace_) throw Error("Cannot start the touch gesture becauase the start workspace is undefined");
            this.isPinchZoomEnabled = this.startWorkspace_.options.zoomOptions && this.startWorkspace_.options.zoomOptions.pinch, zs(e) ? this.cancel() : (this.gestureHasStarted = true, bs(), this.startWorkspace_.updateScreenCalculationsIfScrolled(), this.startWorkspace_.isMutator && this.startWorkspace_.resize(), this.currentDropdownOwner = Oc(), this.startWorkspace_.hideChaff(!!this.flyout), this.startWorkspace_.markFocused(), this.mostRecentEvent = e, jc(), Qe(e) ? this.handleRightClick(e) : (e.type.toLowerCase() === "pointerdown" && e.pointerType !== "mouse" && Jl(e, this), this.mouseDownXY = new f(e.clientX, e.clientY), this.bindMouseEvents(e), this.isEnding_ || this.handleTouchStart(e)));
          }
          bindMouseEvents(e) {
            this.boundEvents.push(w(document, "pointerdown", null, this.handleStart.bind(this), true)), this.boundEvents.push(w(document, "pointermove", null, this.handleMove.bind(this), true)), this.boundEvents.push(w(document, "pointerup", null, this.handleUp.bind(this), true)), this.boundEvents.push(w(document, "pointercancel", null, this.handleUp.bind(this), true)), e.preventDefault(), e.stopPropagation();
          }
          handleStart(e) {
            this.isDragging() || (this.handleTouchStart(e), this.isMultiTouch() && dt());
          }
          handleMove(e) {
            this.isDragging() && Ws(e) || !this.isMultiTouch() ? (this.updateFromEvent(e), this.workspaceDragger ? this.workspaceDragger.drag(this.currentDragDeltaXY) : this.dragger && this.dragger.onDrag(this.mostRecentEvent, this.currentDragDeltaXY), e.preventDefault(), e.stopPropagation()) : this.isMultiTouch() && (this.handleTouchMove(e), dt());
          }
          handleUp(e) {
            if (this.isDragging() || this.handleTouchEnd(e), !this.isMultiTouch() || this.isDragging()) {
              if (!Ws(e)) return;
              if (this.updateFromEvent(e), dt(), this.isEnding_) {
                console.log("Trying to end a gesture recursively.");
                return;
              }
              this.isEnding_ = true, this.dragger ? (rr.setIsActive(false), this.dragger.onDragEnd(e, this.currentDragDeltaXY)) : this.workspaceDragger ? (rr.setIsActive(false), this.workspaceDragger.endDrag(this.currentDragDeltaXY)) : this.isBubbleClick() || this.isCommentClick() || (this.isFieldClick() ? this.doFieldClick() : this.isIconClick() ? this.doIconClick() : this.isBlockClick() ? this.doBlockClick() : this.isWorkspaceClick() && this.doWorkspaceClick(e));
            }
            e.preventDefault(), e.stopPropagation(), this.dispose();
          }
          handleTouchStart(e) {
            var t = es(e);
            this.cachedPoints.set(t, this.getTouchPoint(e));
            var o = Array.from(this.cachedPoints.keys());
            o.length === 2 && (t = this.cachedPoints.get(o[0]), o = this.cachedPoints.get(o[1]), this.startDistance = f.distance(t, o), this.multiTouch = true, e.preventDefault());
          }
          handleTouchMove(e) {
            let t = es(e);
            this.cachedPoints.set(t, this.getTouchPoint(e)), this.isPinchZoomEnabled && this.cachedPoints.size === 2 ? this.handlePinch(e) : (this.updateFromEvent(e), this.workspaceDragger ? this.workspaceDragger.drag(this.currentDragDeltaXY) : this.dragger && this.dragger.onDrag(this.mostRecentEvent, this.currentDragDeltaXY), e.preventDefault(), e.stopPropagation());
          }
          handlePinch(e) {
            var t = Array.from(this.cachedPoints.keys()), o = this.cachedPoints.get(t[0]);
            if (t = this.cachedPoints.get(t[1]), o = f.distance(o, t) / this.startDistance, this.previousScale > 0 && this.previousScale < 1 / 0) {
              if (t = o - this.previousScale, t = t > 0 ? t * eb : t * tb, !this.startWorkspace_) throw Error("Cannot handle a pinch because the start workspace is undefined");
              let s = this.startWorkspace_, i = ts(e, s.getParentSvg(), s.getInverseScreenCTM());
              s.zoom(i.x, i.y, t);
            }
            this.previousScale = o, e.preventDefault();
          }
          handleTouchEnd(e) {
            e = es(e), this.cachedPoints.has(e) && this.cachedPoints.delete(e), this.cachedPoints.size < 2 && (this.cachedPoints.clear(), this.previousScale = 0);
          }
          getTouchPoint(e) {
            return this.startWorkspace_ ? new f(e.pageX, e.pageY) : null;
          }
          isMultiTouch() {
            return this.multiTouch;
          }
          cancel() {
            this.isEnding_ || (dt(), this.dragger ? this.dragger.onDragEnd(this.mostRecentEvent, this.currentDragDeltaXY) : this.workspaceDragger && this.workspaceDragger.endDrag(this.currentDragDeltaXY), this.dispose());
          }
          handleRightClick(e) {
            this.targetBlock ? (this.bringBlockToFront(), this.targetBlock.workspace.hideChaff(!!this.flyout), this.targetBlock.showContextMenu(e)) : this.startBubble ? this.startBubble.showContextMenu(e) : this.startComment ? (this.startComment.workspace.hideChaff(), this.startComment.showContextMenu(e)) : this.startWorkspace_ && !this.flyout && (this.startWorkspace_.hideChaff(), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.startWorkspace_), this.startWorkspace_.showContextMenu(e)), e.preventDefault(), e.stopPropagation(), rr.setIsActive(false), this.dispose();
          }
          handleWsStart(e, t) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.handleWsStart, but the gesture had already been started.");
            this.setStartWorkspace(t), this.mostRecentEvent = e, this.startBlock || this.startBubble || this.startComment ? this.startBlock && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.startBlock) : r.getFocusManager$$module$build$src$core$focus_manager().focusNode(t), this.doStart(e);
          }
          fireWorkspaceClick(e) {
            R(new (S(d.CLICK))(null, e.id, "workspace"));
          }
          handleFlyoutStart(e, t) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.handleFlyoutStart, but the gesture had already been started.");
            this.setStartFlyout(t), this.handleWsStart(e, t.getWorkspace());
          }
          handleBlockStart(e, t) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.handleBlockStart, but the gesture had already been started.");
            this.setStartBlock(t), this.mostRecentEvent = e;
          }
          handleBubbleStart(e, t) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.handleBubbleStart, but the gesture had already been started.");
            this.setStartBubble(t), this.mostRecentEvent = e;
          }
          handleCommentStart(e, t) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.handleCommentStart, but the gesture had already been started.");
            this.setStartComment(t), this.mostRecentEvent = e;
          }
          doFieldClick() {
            if (!this.startField) throw Error("Cannot do a field click because the start field is undefined");
            this.bringBlockToFront(), this.currentDropdownOwner !== this.startField && this.startField.showEditor(this.mostRecentEvent);
          }
          doIconClick() {
            if (!this.startIcon) throw Error("Cannot do an icon click because the start icon is undefined");
            this.bringBlockToFront(), this.startIcon.onClick();
          }
          doBlockClick() {
            if (this.flyout && this.flyout.autoClose) {
              if (!this.targetBlock) throw Error("Cannot do a block click because the target block is undefined");
              if (this.flyout.isBlockCreatable(this.targetBlock)) {
                r.getGroup$$module$build$src$core$events$utils() || r.setGroup$$module$build$src$core$events$utils(true);
                var e = this.flyout.createBlock(this.targetBlock);
                e.snapToGrid(), e.bumpNeighbours(), r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e);
              }
            } else {
              if (!this.startWorkspace_) throw Error("Cannot do a block click because the start workspace is undefined");
              e = new (S(d.CLICK))(this.startBlock, this.startWorkspace_.id, "block"), R(e);
            }
            this.bringBlockToFront(), r.setGroup$$module$build$src$core$events$utils(false);
          }
          doWorkspaceClick(e) {
            this.fireWorkspaceClick(this.startWorkspace_ || this.creatorWorkspace);
          }
          bringBlockToFront() {
            this.targetBlock && !this.flyout && (r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.targetBlock), this.targetBlock.bringToFront());
          }
          setStartField(e) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.setStartField, but the gesture had already been started.");
            this.startField || (this.startField = e);
          }
          setStartIcon(e) {
            if (this.gestureHasStarted) throw Error("Tried to call gesture.setStartIcon, but the gesture had already been started.");
            this.startIcon || (this.startIcon = e);
          }
          setStartBubble(e) {
            this.startBubble || (this.startBubble = e);
          }
          setStartComment(e) {
            this.startComment || (this.startComment = e);
          }
          setStartBlock(e) {
            this.startBlock || this.startBubble || (this.startBlock = e, e.isInFlyout && e !== e.getRootBlock() ? this.setTargetBlock(e.getRootBlock()) : this.setTargetBlock(e));
          }
          setTargetBlock(e) {
            e.isShadow() ? this.setTargetBlock(e.getParent()) : (this.targetBlock = e, r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e));
          }
          setStartWorkspace(e) {
            this.startWorkspace_ || (this.startWorkspace_ = e);
          }
          setStartFlyout(e) {
            this.flyout || (this.flyout = e);
          }
          isBubbleClick() {
            return !!this.startBubble && !this.hasExceededDragRadius;
          }
          isCommentClick() {
            return !!this.startComment && !this.hasExceededDragRadius;
          }
          isBlockClick() {
            return !!this.startBlock && !this.hasExceededDragRadius && !this.isFieldClick() && !this.isIconClick();
          }
          isFieldClick() {
            return this.startField ? this.startField.isClickable() && !this.hasExceededDragRadius && (!this.flyout || this.startField.isClickableInFlyout(this.flyout.autoClose)) : false;
          }
          isIconClick() {
            if (!this.startIcon) return false;
            let e = !this.flyout || !this.startIcon.isClickableInFlyout || this.startIcon.isClickableInFlyout(this.flyout.autoClose);
            return !this.hasExceededDragRadius && e;
          }
          isWorkspaceClick() {
            return !this.startBlock && !this.startBubble && !this.startField && !this.hasExceededDragRadius;
          }
          getCurrentDragger() {
            let e, t;
            return (t = (e = this.workspaceDragger) != null ? e : this.dragger) != null ? t : null;
          }
          isDragging() {
            return this.dragging;
          }
          hasStarted() {
            return this.gestureHasStarted;
          }
          static inProgress() {
            let e = is();
            for (let t = 0, o; o = e[t]; t++) if (o.currentGesture_) return true;
            return false;
          }
        }, ob = {};
        ob.Gesture = nr;
        var ul = class {
          constructor(e, t) {
            this.pattern = e, this.scale = 1;
            let o;
            this.spacing = (o = t.spacing) != null ? o : 0;
            let s;
            this.length = (s = t.length) != null ? s : 1, this.line2 = (this.line1 = e.firstChild) && this.line1.nextSibling;
            let i;
            this.snapToGrid = (i = t.snap) != null ? i : false;
          }
          setSpacing(e) {
            this.spacing = e, this.update(this.scale);
          }
          getSpacing() {
            return this.spacing;
          }
          setLength(e) {
            this.length = e, this.update(this.scale);
          }
          getLength() {
            return this.length;
          }
          setSnapToGrid(e) {
            this.snapToGrid = e;
          }
          shouldSnap() {
            return this.snapToGrid;
          }
          getPatternId() {
            return this.pattern.id;
          }
          update(e) {
            this.scale = e;
            var t = this.spacing * e;
            this.pattern.setAttribute("width", `${t}`), this.pattern.setAttribute("height", `${t}`), t = Math.floor(this.spacing / 2) + 0.5;
            let o = t - this.length / 2, s = t + this.length / 2;
            t *= e, o *= e, s *= e, this.setLineAttributes(this.line1, e, o, s, t, t), this.setLineAttributes(this.line2, e, t, t, o, s);
          }
          setLineAttributes(e, t, o, s, i, n) {
            e && (e.setAttribute("stroke-width", `${t}`), e.setAttribute("x1", `${o}`), e.setAttribute("y1", `${i}`), e.setAttribute("x2", `${s}`), e.setAttribute("y2", `${n}`));
          }
          moveTo(e, t) {
            this.pattern.setAttribute("x", `${e}`), this.pattern.setAttribute("y", `${t}`);
          }
          alignXY(e) {
            var t = this.getSpacing();
            let o = t / 2, s = Math.round(Math.round((e.x - o) / t) * t + o);
            return t = Math.round(Math.round((e.y - o) / t) * t + o), s === e.x && t === e.y ? e : new f(s, t);
          }
          static createDom(e, t, o, s) {
            e = b($.PATTERN, { id: "blocklyGridPattern" + e, patternUnits: "userSpaceOnUse" }, o);
            let i, n;
            if (((i = t.length) != null ? i : 1) > 0 && ((n = t.spacing) != null ? n : 0) > 0) {
              b($.LINE, { stroke: t.colour }, e);
              let l;
              (l = t.length) != null && l && b($.LINE, { stroke: t.colour }, e);
            } else b($.LINE, {}, e);
            return s && s.style.setProperty("--blocklyGridPattern", `url(#${e.id})`), e;
          }
        }, sb = {};
        sb.Grid = ul;
        var ib = {};
        ib.isAutoHideable = Ra;
        var Jm = class {
          constructor(e) {
            this.workspace = e, this.layers = /* @__PURE__ */ new Map(), (e = e.getInjectionDiv()) && (this.dragLayer = this.createDragLayer(e), this.animationLayer = this.createAnimationLayer(e)), e = this.createLayer(co), I(e, "blocklyBlockCanvas"), e = this.createLayer(Kn), I(e, "blocklyBubbleCanvas");
          }
          createDragLayer(e) {
            let t = b($.SVG, { class: "blocklyBlockDragSurface", xmlns: Oi, "xmlns:html": Po, "xmlns:xlink": He, version: "1.1" });
            return e.append(t), b($.G, {}, t);
          }
          createAnimationLayer(e) {
            let t = b($.SVG, { class: "blocklyAnimationLayer", xmlns: Oi, "xmlns:html": Po, "xmlns:xlink": He, version: "1.1" });
            return e.append(t), b($.G, {}, t);
          }
          appendToAnimationLayer(e) {
            let t, o = (t = this.dragLayer) == null ? void 0 : t.getAttribute("transform");
            if (o) {
              let i;
              (i = this.animationLayer) == null || i.setAttribute("transform", o);
            }
            let s;
            (s = this.animationLayer) == null || s.appendChild(e.getSvgRoot());
          }
          translateLayers(e, t) {
            e = `translate(${e.x}, ${e.y}) scale(${t})`;
            let o;
            (o = this.dragLayer) == null || o.setAttribute("transform", e);
            for (let [, s] of this.layers) s.setAttribute("transform", e);
          }
          moveToDragLayer(e) {
            let t;
            (t = this.dragLayer) == null || t.appendChild(e.getSvgRoot()), e.canBeFocused() && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e);
          }
          moveOffDragLayer(e, t) {
            this.append(e, t), e.canBeFocused() && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e);
          }
          append(e, t) {
            this.layers.has(t) || this.createLayer(t), e = e.getSvgRoot();
            let o;
            if (((o = this.layers.get(t)) == null ? void 0 : o.lastChild) !== e) {
              let s;
              (s = this.layers.get(t)) == null || s.appendChild(e);
            }
          }
          createLayer(e) {
            let t = this.workspace.getSvgGroup(), o = b($.G, {}), s = false, i = [...this.layers].sort((n, l) => n[0] - l[0]);
            for (let [n, l] of i) if (e < n) {
              t.insertBefore(o, l), s = true;
              break;
            }
            return s || t.appendChild(o), this.layers.set(e, o), o;
          }
          hasLayer(e) {
            return e === this.dragLayer || new Set(this.layers.values()).has(e);
          }
          getBlockLayer() {
            return this.layers.get(co);
          }
          getBubbleLayer() {
            return this.layers.get(Kn);
          }
        }, rb = {};
        rb.LayerManager = Jm;
        var Oh = class {
          constructor() {
            this.curNode = this.colour = null, this.type = "marker";
          }
          getCurNode() {
            return this.curNode;
          }
          setCurNode(e) {
            this.curNode = e;
          }
          dispose() {
            this.curNode = null;
          }
          getSourceBlockFromNode(e) {
            return e instanceof z ? e : e instanceof F || e instanceof pe ? e.getSourceBlock() : null;
          }
          getSourceBlock() {
            return this.getSourceBlockFromNode(this.getCurNode());
          }
        }, nb = {};
        nb.Marker = Oh;
        var hl = class extends Oh {
          constructor(e) {
            super(), this.workspace = e, this.type = "cursor", this.potentialNodes = null;
          }
          next() {
            var e = this.getCurNode();
            return e ? ((e = this.getNextNode(e, (t) => {
              let o;
              return t instanceof z && !((o = t.outputConnection) != null && o.targetBlock()) || t instanceof It;
            }, true)) && this.setCurNode(e), e) : null;
          }
          in() {
            var e = this.getCurNode();
            return e ? ((e = this.getNextNode(e, () => true, true)) && this.setCurNode(e), e) : null;
          }
          prev() {
            var e = this.getCurNode();
            return e ? ((e = this.getPreviousNode(e, (t) => {
              let o;
              return t instanceof z && !((o = t.outputConnection) != null && o.targetBlock()) || t instanceof It;
            }, true)) && this.setCurNode(e), e) : null;
          }
          out() {
            var e = this.getCurNode();
            return e ? ((e = this.getPreviousNode(e, () => true, true)) && this.setCurNode(e), e) : null;
          }
          atEndOfLine() {
            var e = this.getCurNode();
            if (!e) return false;
            let t = this.getNextNode(e, () => true, true);
            return e = this.getNextNode(e, (o) => {
              let s;
              return o instanceof z && !((s = o.outputConnection) != null && s.targetBlock());
            }, true), t === e;
          }
          getNextNodeImpl(e, t, o = /* @__PURE__ */ new Set()) {
            if (!e || o.has(e)) return null;
            let s = this.workspace.getNavigator().getFirstChild(e) || this.workspace.getNavigator().getNextSibling(e);
            for (var i = e; i && !s && (i = this.workspace.getNavigator().getParent(i), !!i); ) s = this.workspace.getNavigator().getNextSibling(i);
            return t(s) ? s : s ? (o.add(e), this.getNextNodeImpl(s, t, o)) : null;
          }
          getNextNode(e, t, o) {
            return !e || !o && this.getLastNode() === e ? null : this.getNextNodeImpl(e, t);
          }
          getPreviousNodeImpl(e, t, o = /* @__PURE__ */ new Set()) {
            if (!e || o.has(e)) return null;
            let s = this.getRightMostChild(this.workspace.getNavigator().getPreviousSibling(e), e) || this.workspace.getNavigator().getParent(e);
            return t(s) ? s : s ? (o.add(e), this.getPreviousNodeImpl(s, t, o)) : null;
          }
          getPreviousNode(e, t, o) {
            return !e || !o && this.getFirstNode() === e ? null : this.getPreviousNodeImpl(e, t);
          }
          getRightMostChild(e, t) {
            if (!e) return e;
            let o = this.workspace.getNavigator().getFirstChild(e);
            if (!o || o === t) return e;
            for (e = o; e && e !== t; e = this.workspace.getNavigator().getNextSibling(o)) o = e;
            return this.getRightMostChild(o, t);
          }
          preDelete(e) {
            var t = this.getCurNode();
            t = t ? [t] : [];
            var o;
            let s, i, n = (i = (o = e.previousConnection) == null ? void 0 : o.targetConnection) != null ? i : (s = e.outputConnection) == null ? void 0 : s.targetConnection;
            n && t.push(n), (o = e.getNextBlock()) && t.push(o), (e = e.getParent()) && t.push(e), t.push(this.workspace), this.potentialNodes = t;
          }
          postDelete() {
            let e = this.potentialNodes;
            if (this.potentialNodes = null, !e) throw Error("must call preDelete first");
            for (let t of e) {
              let o;
              if ((o = this.getSourceBlockFromNode(t)) == null || !o.disposed) {
                this.setCurNode(t);
                return;
              }
            }
            throw Error("no valid nodes in this.potentialNodes");
          }
          getCurNode() {
            return r.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode();
          }
          setCurNode(e) {
            r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e);
          }
          getFirstNode() {
            return this.workspace.getNavigator().getFirstChild(this.workspace);
          }
          getLastNode() {
            let e = this.getFirstNode();
            return this.getPreviousNode(e, () => true, true);
          }
        };
        c(E.CURSOR, Fe, hl);
        var lb = {};
        lb.LineCursor = hl;
        var dl = class {
          constructor(e) {
            this.workspace = e, this.markers = /* @__PURE__ */ new Map(), this.cursor = new hl(this.workspace);
          }
          registerMarker(e, t) {
            this.markers.has(e) && this.unregisterMarker(e), this.markers.set(e, t);
          }
          unregisterMarker(e) {
            let t = this.markers.get(e);
            if (t) t.dispose(), this.markers.delete(e);
            else throw Error("Marker with ID " + e + " does not exist. Can only unregister markers that exist.");
          }
          getCursor() {
            return this.cursor;
          }
          getMarker(e) {
            return this.markers.get(e) || null;
          }
          setCursor(e) {
            this.cursor = e;
          }
          dispose() {
            let e = Object.keys(this.markers);
            for (let t = 0, o; o = e[t]; t++) this.unregisterMarker(o);
            this.markers.clear(), this.cursor.dispose();
          }
        };
        dl.LOCAL_MARKER = "local_marker_1";
        var cb = {};
        cb.MarkerManager = dl;
        var ho = {};
        ho.CommentIcon = qe, ho.Icon = As, ho.IconType = ue, ho.MutatorIcon = r.MutatorIcon$$module$build$src$core$icons$mutator_icon, ho.WarningIcon = nt, ho.exceptions = Bm, ho.registry = Ih;
        var ab = {};
        ab.isProcedureBlock = Nt, r.Names$$module$build$src$core$names = class {
          constructor(e, t) {
            this.db = /* @__PURE__ */ new Map(), this.dbReverse = /* @__PURE__ */ new Set(), this.variableMap = null, this.variablePrefix = t || "", this.reservedWords = new Set(e ? e.split(",") : []);
          }
          reset() {
            this.db.clear(), this.dbReverse.clear(), this.variableMap = null;
          }
          setVariableMap(e) {
            this.variableMap = e;
          }
          getNameForUserVariable(e) {
            return this.variableMap ? (e = this.variableMap.getVariableById(e)) ? e.getName() : null : (console.warn(`Deprecated call to Names.prototype.getName without defining a variable map. To fix, add the following code in your generator's init() function:
Blockly.YourGeneratorName.nameDB_.setVariableMap(workspace.getVariableMap());`), null);
          }
          populateVariables(e) {
            e = r.allUsedVarModels$$module$build$src$core$variables(e);
            for (let t = 0; t < e.length; t++) this.getName(e[t].getId(), r.NameType$$module$build$src$core$names.VARIABLE);
          }
          populateProcedures(e) {
            throw Error("The implementation of populateProcedures should be monkey-patched in by blockly.ts");
          }
          getName(e, t) {
            let o = e;
            t === r.NameType$$module$build$src$core$names.VARIABLE && (e = this.getNameForUserVariable(e)) && (o = e), e = o.toLowerCase();
            let s = t === r.NameType$$module$build$src$core$names.VARIABLE || t === r.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "";
            this.db.has(t) || this.db.set(t, /* @__PURE__ */ new Map());
            let i = this.db.get(t);
            return i.has(e) ? s + i.get(e) : (t = this.getDistinctName(o, t), i.set(e, t.substr(s.length)), t);
          }
          getUserNames(e) {
            let t;
            return (e = (t = this.db.get(e)) == null ? void 0 : t.keys()) ? Array.from(e) : [];
          }
          getDistinctName(e, t) {
            e = this.safeName(e);
            let o = null, s, i;
            for (; this.dbReverse.has(e + ((s = o) != null ? s : "")) || this.reservedWords.has(e + ((i = o) != null ? i : "")); ) o = o ? o + 1 : 2;
            let n;
            return e += (n = o) != null ? n : "", this.dbReverse.add(e), (t === r.NameType$$module$build$src$core$names.VARIABLE || t === r.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "") + e;
          }
          safeName(e) {
            return e ? (e = encodeURI(e.replace(/ /g, "_")).replace(/[^\w]/g, "_"), "0123456789".includes(e[0]) && (e = "my_" + e)) : e = r.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed", e;
          }
          static equals(e, t) {
            return e.toLowerCase() === t.toLowerCase();
          }
        }, (function(e) {
          e = e.NameType || (e.NameType = {}), e.DEVELOPER_VARIABLE = "DEVELOPER_VARIABLE", e.VARIABLE = "VARIABLE", e.PROCEDURE = "PROCEDURE";
        })(r.Names$$module$build$src$core$names || (r.Names$$module$build$src$core$names = {})), r.NameType$$module$build$src$core$names = r.Names$$module$build$src$core$names.NameType, r.Names$$module$build$src$core$names.DEVELOPER_VARIABLE_TYPE = r.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE;
        var ub = { NameType: r.NameType$$module$build$src$core$names };
        ub.Names = r.Names$$module$build$src$core$names;
        var hb = {};
        hb.isObservable = bi;
        var wh = class extends Map {
          constructor() {
            super();
          }
          set(e, t) {
            return this.get(e) === t ? this : (super.set(e, t), bi(t) && t.startPublishing(), this);
          }
          delete(e) {
            let t = this.get(e);
            return e = super.delete(e), e && (bi(t) && t.stopPublishing(), e);
          }
          clear() {
            if (this.size) for (let e of this.keys()) this.delete(e);
          }
          add(e) {
            return this.set(e.getId(), e);
          }
          getProcedures() {
            return [...this.values()];
          }
        }, db = {};
        db.ObservableProcedureMap = wh;
        var lr, Se;
        lr = "PROCEDURE", r.DEFAULT_ARG$$module$build$src$core$procedures = "x", Se = { CATEGORY_NAME: lr, DEFAULT_ARG: r.DEFAULT_ARG$$module$build$src$core$procedures }, Se.ObservableProcedureMap = wh, Se.allProcedures = fi, Se.findLegalName = r.findLegalName$$module$build$src$core$procedures, Se.flyoutCategory = wa, Se.getCallers = Aa, Se.getDefinition = r.getDefinition$$module$build$src$core$procedures, Se.internalFlyoutCategory = pn, Se.isNameUsed = Oa, Se.isProcedureBlock = Nt, Se.mutateCallers = r.mutateCallers$$module$build$src$core$procedures, Se.mutatorOpenListener = Na, Se.rename = r.rename$$module$build$src$core$procedures;
        var $b = class {
          constructor() {
            this.NONE = 0, this.FIELD = 1, this.HAT = 2, this.ICON = 4, this.SPACER = 8, this.BETWEEN_ROW_SPACER = 16, this.IN_ROW_SPACER = 32, this.EXTERNAL_VALUE_INPUT = 64, this.INPUT = 128, this.INLINE_INPUT = 256, this.STATEMENT_INPUT = 512, this.CONNECTION = 1024, this.PREVIOUS_CONNECTION = 2048, this.NEXT_CONNECTION = 4096, this.OUTPUT_CONNECTION = 8192, this.CORNER = 16384, this.LEFT_SQUARE_CORNER = 32768, this.LEFT_ROUND_CORNER = 65536, this.RIGHT_SQUARE_CORNER = 131072, this.RIGHT_ROUND_CORNER = 262144, this.JAGGED_EDGE = 524288, this.ROW = 1048576, this.TOP_ROW = 2097152, this.BOTTOM_ROW = 4194304, this.INPUT_ROW = 8388608, this.LEFT_CORNER = this.LEFT_SQUARE_CORNER | this.LEFT_ROUND_CORNER, this.RIGHT_CORNER = this.RIGHT_SQUARE_CORNER | this.RIGHT_ROUND_CORNER, this.nextTypeValue_ = 16777216;
          }
          getType(e) {
            return Object.prototype.hasOwnProperty.call(this, e) || (this[e] = this.nextTypeValue_, this.nextTypeValue_ <<= 1), this[e];
          }
          isField(e) {
            return (e.type & this.FIELD) >= 1;
          }
          isHat(e) {
            return (e.type & this.HAT) >= 1;
          }
          isIcon(e) {
            return (e.type & this.ICON) >= 1;
          }
          isSpacer(e) {
            return (e.type & this.SPACER) >= 1;
          }
          isInRowSpacer(e) {
            return (e.type & this.IN_ROW_SPACER) >= 1;
          }
          isSpacerRow(e) {
            return (e.type & this.BETWEEN_ROW_SPACER) >= 1;
          }
          isInput(e) {
            return (e.type & this.INPUT) >= 1;
          }
          isExternalInput(e) {
            return (e.type & this.EXTERNAL_VALUE_INPUT) >= 1;
          }
          isInlineInput(e) {
            return (e.type & this.INLINE_INPUT) >= 1;
          }
          isStatementInput(e) {
            return (e.type & this.STATEMENT_INPUT) >= 1;
          }
          isPreviousConnection(e) {
            return (e.type & this.PREVIOUS_CONNECTION) >= 1;
          }
          isNextConnection(e) {
            return (e.type & this.NEXT_CONNECTION) >= 1;
          }
          isPreviousOrNextConnection(e) {
            return this.isPreviousConnection(e) || this.isNextConnection(e);
          }
          isRoundCorner(e) {
            return (e.type & this.LEFT_ROUND_CORNER) >= 1 || (e.type & this.RIGHT_ROUND_CORNER) >= 1;
          }
          isLeftRoundedCorner(e) {
            return this.isRoundCorner(e) && (e.type & this.LEFT_ROUND_CORNER) >= 1;
          }
          isRightRoundedCorner(e) {
            return this.isRoundCorner(e) && (e.type & this.RIGHT_ROUND_CORNER) >= 1;
          }
          isLeftSquareCorner(e) {
            return (e.type & this.LEFT_SQUARE_CORNER) >= 1;
          }
          isRightSquareCorner(e) {
            return (e.type & this.RIGHT_SQUARE_CORNER) >= 1;
          }
          isCorner(e) {
            return (e.type & this.CORNER) >= 1;
          }
          isJaggedEdge(e) {
            return (e.type & this.JAGGED_EDGE) >= 1;
          }
          isRow(e) {
            return (e.type & this.ROW) >= 1;
          }
          isBetweenRowSpacer(e) {
            return (e.type & this.BETWEEN_ROW_SPACER) >= 1;
          }
          isTopRow(e) {
            return (e.type & this.TOP_ROW) >= 1;
          }
          isBottomRow(e) {
            return (e.type & this.BOTTOM_ROW) >= 1;
          }
          isTopOrBottomRow(e) {
            return this.isTopRow(e) || this.isBottomRow(e);
          }
          isInputRow(e) {
            return (e.type & this.INPUT_ROW) >= 1;
          }
        }, h = new $b(), gL = { Types: h }, lt = class {
          constructor(e) {
            this.centerline = this.xPos = this.height = this.width = 0, this.constants_ = e, this.type = h.NONE, this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;
          }
        }, pb = {};
        pb.Measurable = lt;
        var Ps = class {
          constructor(e) {
            this.elements = [], this.xPos = this.yPos = this.widthWithConnectedBlocks = this.minWidth = this.minHeight = this.width = this.height = 0, this.hasStatement = this.hasExternalInput = false, this.statementEdge = 0, this.hasJaggedEdge = this.hasDummyInput = this.hasInlineInput = false, this.align = null, this.constants_ = e, this.type = h.ROW, this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;
          }
          getLastInput() {
            for (let e = this.elements.length - 1; e >= 0; e--) {
              let t = this.elements[e];
              if (h.isInput(t)) return t;
            }
            return null;
          }
          measure() {
            throw Error("Unexpected attempt to measure a base Row.");
          }
          startsWithElemSpacer() {
            return true;
          }
          endsWithElemSpacer() {
            return true;
          }
          getFirstSpacer() {
            for (let e = 0; e < this.elements.length; e++) {
              let t = this.elements[e];
              if (h.isInRowSpacer(t)) return t;
            }
            return null;
          }
          getLastSpacer() {
            for (let e = this.elements.length - 1; e >= 0; e--) {
              let t = this.elements[e];
              if (h.isInRowSpacer(t)) return t;
            }
            return null;
          }
        }, gb = {};
        gb.Row = Ps;
        var $l = class extends Ps {
          constructor(e) {
            super(e), this.hasNextConnection = false, this.connection = null, this.baseline = this.descenderHeight = 0, this.type |= h.BOTTOM_ROW;
          }
          hasLeftSquareCorner(e) {
            return !!e.outputConnection || !!e.getNextBlock();
          }
          hasRightSquareCorner(e) {
            return true;
          }
          measure() {
            let e = 0, t = 0, o = 0;
            for (let s = 0; s < this.elements.length; s++) {
              let i = this.elements[s];
              t += i.width, h.isSpacer(i) || (h.isNextConnection(i) ? o = Math.max(o, i.height) : e = Math.max(e, i.height));
            }
            this.width = Math.max(this.minWidth, t), this.height = Math.max(this.minHeight, e) + o, this.descenderHeight = o, this.widthWithConnectedBlocks = this.width;
          }
          startsWithElemSpacer() {
            return false;
          }
          endsWithElemSpacer() {
            return false;
          }
        }, mb = {};
        mb.BottomRow = $l;
        var $o = class extends lt {
          constructor(e, t) {
            super(e), this.connectionModel = t, this.type |= h.CONNECTION, this.shape = this.constants_.shapeFor(t), this.isDynamicShape = "isDynamic" in this.shape && this.shape.isDynamic, this.highlighted = t.isHighlighted();
          }
        }, _b = {};
        _b.Connection = $o;
        var cr = class extends $o {
          constructor(e, t) {
            super(e, t.connection), this.input = t, this.connectionOffsetY = this.connectionOffsetX = 0, this.type |= h.INPUT, this.align = t.align, (this.connectedBlock = t.connection && t.connection.targetBlock() ? t.connection.targetBlock() : null) ? (e = this.connectedBlock.getHeightWidth(), this.connectedBlockWidth = e.width, this.connectedBlockHeight = e.height) : this.connectedBlockHeight = this.connectedBlockWidth = 0;
          }
        }, Tb = {};
        Tb.InputConnection = cr;
        var pl = class extends cr {
          constructor(e, t) {
            super(e, t), this.height = 0, this.type |= h.EXTERNAL_VALUE_INPUT, this.height = this.connectedBlock ? this.connectedBlockHeight - this.constants_.TAB_OFFSET_FROM_TOP - this.constants_.MEDIUM_PADDING : this.shape.height, this.width = this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING, this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP, this.connectionHeight = this.shape.height, this.connectionWidth = this.shape.width;
          }
        }, Eb = {};
        Eb.ExternalValueInput = pl;
        var gl = class extends lt {
          constructor(e, t, o) {
            super(e), this.field = t, this.parentInput = o, this.isEditable = t.EDITABLE, this.flipRtl = t.getFlipRtl(), this.type |= h.FIELD, e = this.field.getSize(), this.height = e.height, this.width = e.width;
          }
        }, bb = {};
        bb.Field = gl;
        var Lh = class extends lt {
          constructor(e) {
            super(e), this.type |= h.HAT, this.height = this.constants_.START_HAT.height, this.width = this.constants_.START_HAT.width, this.ascenderHeight = this.height;
          }
        }, fb = {};
        fb.Hat = Lh;
        var Nh = class extends lt {
          constructor(e, t) {
            super(e), this.icon = t, this.flipRtl = false, this.type |= h.ICON, e = t.getSize(), this.height = e.height, this.width = e.width;
          }
        }, Ib = {};
        Ib.Icon = Nh;
        var Me = class extends lt {
          constructor(e, t) {
            super(e), this.type |= h.SPACER | h.IN_ROW_SPACER, this.width = t, this.height = this.constants_.SPACER_DEFAULT_HEIGHT;
          }
        }, yb = {};
        yb.InRowSpacer = Me;
        var ml = class extends cr {
          constructor(e, t) {
            super(e, t), this.type |= h.INLINE_INPUT, this.connectedBlock ? (this.width = this.connectedBlockWidth, this.height = this.connectedBlockHeight) : (this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT, this.width = this.constants_.EMPTY_INLINE_INPUT_PADDING), this.connectionHeight = this.isDynamicShape ? this.shape.height(this.height) : this.shape.height, this.connectionWidth = this.isDynamicShape ? this.shape.width(this.height) : this.shape.width, this.connectedBlock || (this.width += this.connectionWidth * (this.isDynamicShape ? 2 : 1)), this.connectionOffsetY = "connectionOffsetY" in this.shape ? this.shape.connectionOffsetY(this.connectionHeight) : this.constants_.TAB_OFFSET_FROM_TOP, this.connectionOffsetX = "connectionOffsetX" in this.shape ? this.shape.connectionOffsetX(this.connectionWidth) : 0;
          }
        }, Cb = {};
        Cb.InlineInput = ml;
        var _l = class extends Ps {
          constructor(e) {
            super(e), this.connectedBlockWidths = 0, this.type |= h.INPUT_ROW;
          }
          measure() {
            this.width = this.minWidth, this.height = this.minHeight;
            let e = 0;
            for (let t = 0; t < this.elements.length; t++) {
              let o = this.elements[t];
              this.width += o.width, h.isInput(o) && (h.isStatementInput(o) ? e += o.connectedBlockWidth : h.isExternalInput(o) && o.connectedBlockWidth !== 0 && (e += o.connectedBlockWidth - o.connectionWidth)), h.isSpacer(o) || (this.height = Math.max(this.height, o.height));
            }
            this.connectedBlockWidths = e, this.widthWithConnectedBlocks = this.width + e;
          }
          endsWithElemSpacer() {
            return !this.hasExternalInput && !this.hasStatement;
          }
        }, vb = {};
        vb.InputRow = _l;
        var Ah = class extends lt {
          constructor(e) {
            super(e), this.type |= h.JAGGED_EDGE, this.height = this.constants_.JAGGED_TEETH.height, this.width = this.constants_.JAGGED_TEETH.width;
          }
        }, kb = {};
        kb.JaggedEdge = Ah;
        var Mh = class extends $o {
          constructor(e, t) {
            super(e, t), this.type |= h.NEXT_CONNECTION, this.height = this.shape.height, this.width = this.shape.width;
          }
        }, Rb = {};
        Rb.NextConnection = Mh;
        var Dh = class extends $o {
          constructor(e, t) {
            super(e, t), this.connectionOffsetX = 0, this.type |= h.OUTPUT_CONNECTION, this.height = this.isDynamicShape ? 0 : this.shape.height, this.startX = this.width = this.isDynamicShape ? 0 : this.shape.width, this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
          }
        }, Sb = {};
        Sb.OutputConnection = Dh;
        var Ph = class extends $o {
          constructor(e, t) {
            super(e, t), this.type |= h.PREVIOUS_CONNECTION, this.height = this.shape.height, this.width = this.shape.width;
          }
        }, Ob = {};
        Ob.PreviousConnection = Ph;
        var Bs = class extends lt {
          constructor(e, t) {
            super(e), this.type = (t && t !== "left" ? h.RIGHT_ROUND_CORNER : h.LEFT_ROUND_CORNER) | h.CORNER, this.width = this.constants_.CORNER_RADIUS, this.height = this.constants_.CORNER_RADIUS / 2;
          }
        }, wb = {};
        wb.RoundCorner = Bs;
        var Tl = class extends Ps {
          constructor(e, t, o) {
            super(e), this.height = t, this.width = o, this.precedesStatement = this.followsStatement = false, this.widthWithConnectedBlocks = 0, this.type |= h.SPACER | h.BETWEEN_ROW_SPACER, this.elements = [new Me(this.constants_, o)];
          }
          measure() {
          }
        }, Lb = {};
        Lb.SpacerRow = Tl;
        var xs = class extends lt {
          constructor(e, t) {
            super(e), this.type = (t && t !== "left" ? h.RIGHT_SQUARE_CORNER : h.LEFT_SQUARE_CORNER) | h.CORNER, this.width = this.height = this.constants_.NO_PADDING;
          }
        }, Nb = {};
        Nb.SquareCorner = xs;
        var ar = class extends cr {
          constructor(e, t) {
            super(e, t), this.type |= h.STATEMENT_INPUT, this.height = this.connectedBlock ? this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER : this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT, this.width = this.constants_.STATEMENT_INPUT_NOTCH_OFFSET + this.shape.width;
          }
        }, Ab = {};
        Ab.StatementInput = ar;
        var El = class extends Ps {
          constructor(e) {
            super(e), this.ascenderHeight = this.capline = 0, this.hasPreviousConnection = false, this.connection = null, this.type |= h.TOP_ROW;
          }
          hasLeftSquareCorner(e) {
            let t = (e.hat ? e.hat === "cap" : this.constants_.ADD_START_HATS) && !e.outputConnection && !e.previousConnection, o = e.getPreviousBlock();
            return !!e.outputConnection || t || (o ? o.getNextBlock() === e : false);
          }
          hasRightSquareCorner(e) {
            return true;
          }
          measure() {
            let e = 0, t = 0, o = 0;
            for (let s = 0; s < this.elements.length; s++) {
              let i = this.elements[s];
              t += i.width, h.isSpacer(i) || (h.isHat(i) ? o = Math.max(o, i.ascenderHeight) : e = Math.max(e, i.height));
            }
            this.width = Math.max(this.minWidth, t), this.height = Math.max(this.minHeight, e) + o, this.capline = this.ascenderHeight = o, this.widthWithConnectedBlocks = this.width;
          }
          startsWithElemSpacer() {
            return false;
          }
          endsWithElemSpacer() {
            return false;
          }
        }, Mb = {};
        Mb.TopRow = El;
        var ur = class {
          constructor() {
            this.NO_PADDING = 0, this.SMALL_PADDING = 3, this.MEDIUM_PADDING = 5, this.MEDIUM_LARGE_PADDING = 8, this.LARGE_PADDING = 10, this.TAB_HEIGHT = 15, this.TAB_OFFSET_FROM_TOP = 5, this.TAB_VERTICAL_OVERLAP = 2.5, this.TAB_WIDTH = 8, this.NOTCH_WIDTH = 15, this.NOTCH_HEIGHT = 4, this.MIN_BLOCK_WIDTH = 12, this.EMPTY_BLOCK_SPACER_HEIGHT = 16, this.CORNER_RADIUS = 8, this.NOTCH_OFFSET_LEFT = 15, this.STATEMENT_BOTTOM_SPACER = 0, this.STATEMENT_INPUT_PADDING_LEFT = 20, this.BETWEEN_STATEMENT_PADDING_Y = 4, this.ADD_START_HATS = false, this.START_HAT_HEIGHT = 15, this.START_HAT_WIDTH = 100, this.SPACER_DEFAULT_HEIGHT = 15, this.MIN_BLOCK_HEIGHT = 24, this.EMPTY_INLINE_INPUT_PADDING = 14.5, this.EXTERNAL_VALUE_INPUT_PADDING = 2, this.JAGGED_TEETH_HEIGHT = 12, this.JAGGED_TEETH_WIDTH = 6, this.FIELD_TEXT_FONTSIZE = 11, this.FIELD_TEXT_FONTWEIGHT = "normal", this.FIELD_TEXT_FONTFAMILY = "sans-serif", this.FIELD_TEXT_BASELINE = this.FIELD_TEXT_HEIGHT = -1, this.FIELD_BORDER_RECT_RADIUS = 4, this.FIELD_BORDER_RECT_HEIGHT = 16, this.FIELD_BORDER_RECT_X_PADDING = 5, this.FIELD_BORDER_RECT_Y_PADDING = 3, this.FIELD_BORDER_RECT_COLOUR = "#fff", this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = false, this.FIELD_DROPDOWN_SVG_ARROW_SIZE = 12, this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = false, this.FIELD_COLOUR_DEFAULT_WIDTH = 26, this.defs = null, this.embossFilterId = "", this.embossFilter = null, this.disabledPatternId = "", this.disabledPattern = null, this.debugFilterId = "", this.cssNode = this.debugFilter = null, this.CURSOR_COLOUR = "#cc0a0a", this.MARKER_COLOUR = "#4286f4", this.CURSOR_WS_WIDTH = 100, this.WS_CURSOR_HEIGHT = 5, this.CURSOR_STACK_PADDING = 10, this.CURSOR_BLOCK_PADDING = 2, this.CURSOR_STROKE_WIDTH = 4, this.FULL_BLOCK_FIELDS = false, this.INSERTION_MARKER_COLOUR = "#000000", this.INSERTION_MARKER_OPACITY = 0.2, this.SHAPES = { PUZZLE: 1, NOTCH: 2 }, this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING, this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT, this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT, this.TOP_ROW_MIN_HEIGHT = this.MEDIUM_PADDING, this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING, this.BOTTOM_ROW_MIN_HEIGHT = this.MEDIUM_PADDING, this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING, this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11, this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT, this.START_POINT = ee(0, 0), this.FIELD_TEXT_BASELINE_CENTER = true, this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT, this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING, this.FIELD_DROPDOWN_SVG_ARROW_DATAURI = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=", this.FIELD_COLOUR_DEFAULT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT, this.FIELD_CHECKBOX_X_OFFSET = this.FIELD_BORDER_RECT_X_PADDING - 3, this.randomIdentifier = String(Math.random()).substring(2);
          }
          init() {
            this.JAGGED_TEETH = this.makeJaggedTeeth(), this.NOTCH = this.makeNotch(), this.START_HAT = this.makeStartHat(), this.PUZZLE_TAB = this.makePuzzleTab(), this.INSIDE_CORNERS = this.makeInsideCorners(), this.OUTSIDE_CORNERS = this.makeOutsideCorners();
          }
          setTheme(e) {
            this.blockStyles = /* @__PURE__ */ Object.create(null);
            let t = e.blockStyles;
            for (let o in t) this.blockStyles[o] = this.validatedBlockStyle_(t[o]);
            this.setDynamicProperties_(e);
          }
          setDynamicProperties_(e) {
            this.setFontConstants_(e), this.setComponentConstants_(e), this.ADD_START_HATS = e.startHats !== void 0 ? e.startHats : this.ADD_START_HATS;
          }
          setFontConstants_(e) {
            e.fontStyle && e.fontStyle.family && (this.FIELD_TEXT_FONTFAMILY = e.fontStyle.family), e.fontStyle && e.fontStyle.weight && (this.FIELD_TEXT_FONTWEIGHT = e.fontStyle.weight), e.fontStyle && e.fontStyle.size && (this.FIELD_TEXT_FONTSIZE = e.fontStyle.size), e = Sr("Hg", this.FIELD_TEXT_FONTSIZE + "pt", this.FIELD_TEXT_FONTWEIGHT, this.FIELD_TEXT_FONTFAMILY), this.FIELD_TEXT_HEIGHT = e.height, this.FIELD_TEXT_BASELINE = e.baseline;
          }
          setComponentConstants_(e) {
            this.CURSOR_COLOUR = e.getComponentStyle("cursorColour") || this.CURSOR_COLOUR, this.MARKER_COLOUR = e.getComponentStyle("markerColour") || this.MARKER_COLOUR, this.INSERTION_MARKER_COLOUR = e.getComponentStyle("insertionMarkerColour") || this.INSERTION_MARKER_COLOUR, this.INSERTION_MARKER_OPACITY = Number(e.getComponentStyle("insertionMarkerOpacity")) || this.INSERTION_MARKER_OPACITY;
          }
          getBlockStyleForColour(e) {
            let t = "auto_" + e;
            return this.blockStyles[t] || (this.blockStyles[t] = this.createBlockStyle_(e)), { style: this.blockStyles[t], name: t };
          }
          getBlockStyle(e) {
            return this.blockStyles[e || ""] || (e && e.startsWith("auto_") ? this.getBlockStyleForColour(e.substring(5)).style : this.createBlockStyle_("#000000"));
          }
          createBlockStyle_(e) {
            return this.validatedBlockStyle_({ colourPrimary: e });
          }
          validatedBlockStyle_(e) {
            let t = {};
            return e && Object.assign(t, e), e = ps(t.colourPrimary || "#000"), t.colourPrimary = e.hex, t.colourSecondary = t.colourSecondary ? ps(t.colourSecondary).hex : this.generateSecondaryColour_(t.colourPrimary), t.colourTertiary = t.colourTertiary ? ps(t.colourTertiary).hex : this.generateTertiaryColour_(t.colourPrimary), t.hat = t.hat || "", t;
          }
          generateSecondaryColour_(e) {
            return So("#fff", e, 0.6) || e;
          }
          generateTertiaryColour_(e) {
            return So("#fff", e, 0.3) || e;
          }
          dispose() {
            this.embossFilter && V(this.embossFilter), this.disabledPattern && V(this.disabledPattern), this.debugFilter && V(this.debugFilter), this.cssNode = null;
          }
          makeJaggedTeeth() {
            let e = this.JAGGED_TEETH_HEIGHT, t = this.JAGGED_TEETH_WIDTH, o = Es([k(t, e / 4), k(-t * 2, e / 2), k(t, e / 4)]);
            return { height: e, width: t, path: o };
          }
          makeStartHat() {
            let e = this.START_HAT_HEIGHT, t = this.START_HAT_WIDTH, o = Le("c", [k(30, -e), k(70, -e), k(t, 0)]);
            return { height: e * 0.75, width: t, path: o };
          }
          makePuzzleTab() {
            function e(n) {
              n = n ? -1 : 1;
              let l = -n;
              var a = o / 2;
              let _ = a + 2.5, v = a + 0.5, Q = k(-t, n * a);
              return a = k(t, n * a), Le("c", [k(0, n * _), k(-t, l * v), Q]) + Le("s", [k(t, l * 2.5), a]);
            }
            let t = this.TAB_WIDTH, o = this.TAB_HEIGHT, s = e(true), i = e(false);
            return { type: this.SHAPES.PUZZLE, width: t, height: o, pathDown: i, pathUp: s };
          }
          makeNotch() {
            function e(l) {
              return Es([k(l * s, o), k(l * 3, 0), k(l * s, -o)]);
            }
            let t = this.NOTCH_WIDTH, o = this.NOTCH_HEIGHT, s = (t - 3) / 2, i = e(1), n = e(-1);
            return { type: this.SHAPES.NOTCH, width: t, height: o, pathLeft: i, pathRight: n };
          }
          makeInsideCorners() {
            let e = this.CORNER_RADIUS, t = re("a", "0 0,0", e, k(-e, e)), o = re("a", "0 0,0", e, k(e, e));
            return { width: e, height: e, pathTop: t, pathBottom: o };
          }
          makeOutsideCorners() {
            let e = this.CORNER_RADIUS, t = ee(0, e) + re("a", "0 0,1", e, k(e, -e)), o = re("a", "0 0,1", e, k(e, e)), s = re("a", "0 0,1", e, k(-e, -e)), i = re("a", "0 0,1", e, k(-e, e));
            return { topLeft: t, topRight: o, bottomRight: i, bottomLeft: s, rightHeight: e };
          }
          shapeFor(e) {
            switch (e.type) {
              case C.INPUT_VALUE:
              case C.OUTPUT_VALUE:
                return this.PUZZLE_TAB;
              case C.PREVIOUS_STATEMENT:
              case C.NEXT_STATEMENT:
                return this.NOTCH;
              default:
                throw Error("Unknown connection type");
            }
          }
          createDom(e, t, o, s) {
            this.injectCSS_(t, o), this.defs = b($.DEFS, {}, e), e = b($.FILTER, { id: "blocklyEmbossFilter" + this.randomIdentifier }, this.defs), b($.FEGAUSSIANBLUR, { in: "SourceAlpha", stdDeviation: 1, result: "blur" }, e), t = b($.FESPECULARLIGHTING, { in: "blur", surfaceScale: 1, specularConstant: 0.5, specularExponent: 10, "lighting-color": "white", result: "specOut" }, e), b($.FEPOINTLIGHT, { x: -5e3, y: -1e4, z: 2e4 }, t), b($.FECOMPOSITE, { in: "specOut", in2: "SourceAlpha", operator: "in", result: "specOut" }, e), b($.FECOMPOSITE, { in: "SourceGraphic", in2: "specOut", operator: "arithmetic", k1: 0, k2: 1, k3: 1, k4: 0 }, e), this.embossFilterId = e.id, this.embossFilter = e, e = b($.PATTERN, { id: "blocklyDisabledPattern" + this.randomIdentifier, patternUnits: "userSpaceOnUse", width: 10, height: 10 }, this.defs), b($.RECT, { width: 10, height: 10, fill: "#aaa" }, e), b($.PATH, { d: "M 0 0 L 10 10 M 10 0 L 0 10", stroke: "#cc0" }, e), this.disabledPatternId = e.id, this.disabledPattern = e, this.createDebugFilter(), s && (s.style.setProperty("--blocklyEmbossFilter", `url(#${this.embossFilterId})`), s.style.setProperty("--blocklyDisabledPattern", `url(#${this.disabledPatternId})`), s.style.setProperty("--blocklyDebugFilter", `url(#${this.debugFilterId})`));
          }
          createDebugFilter() {
            if (!this.debugFilter) {
              let e = b($.FILTER, { id: "blocklyDebugFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" }, this.defs), t = b($.FECOMPONENTTRANSFER, { result: "outBlur" }, e);
              b($.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, t), b($.FEFLOOD, { "flood-color": "#ff0000", "flood-opacity": 0.5, result: "outColor" }, e), b($.FECOMPOSITE, { in: "outColor", in2: "outBlur", operator: "in", result: "outGlow" }, e), this.debugFilterId = e.id, this.debugFilter = e;
            }
          }
          injectCSS_(e, t) {
            t = this.getCSS_(t), e = "blockly-renderer-style-" + e, this.cssNode = document.getElementById(e);
            let o = t.join(`
`);
            this.cssNode ? this.cssNode.firstChild.textContent = o : (t = document.createElement("style"), t.id = e, e = document.createTextNode(o), t.appendChild(e), document.head.insertBefore(t, document.head.firstChild), this.cssNode = t);
          }
          getCSS_(e) {
            return [`${e} .blocklyText, `, `${e} .blocklyFlyoutLabelText {`, `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${e} .blocklyText {`, "fill: #fff;", "}", `${e} .blocklyNonEditableField>rect,`, `${e} .blocklyEditableField>rect {`, `fill: ${this.FIELD_BORDER_RECT_COLOUR};`, "fill-opacity: .6;", "stroke: none;", "}", `${e} .blocklyNonEditableField>text,`, `${e} .blocklyEditableField>text {`, "fill: #000;", "}", `${e} .blocklyFlyoutLabelText {`, "fill: #000;", "}", `${e} .blocklyText.blocklyBubbleText {`, "fill: #000;", "}", `${e} .blocklyEditableField:not(.blocklyEditing):hover>rect {`, "stroke: #fff;", "stroke-width: 2;", "}", `${e} .blocklyHtmlInput {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`, "}", `${e} .blocklySelected>.blocklyPath {`, "stroke: #fc3;", "stroke-width: 3px;", "}", `${e} .blocklyHighlightedConnectionPath {`, "stroke: #fc3;", "}", `${e} .blocklyReplaceable .blocklyPath {`, "fill-opacity: .5;", "}", `${e} .blocklyReplaceable .blocklyPathLight,`, `${e} .blocklyReplaceable .blocklyPathDark {`, "display: none;", "}", `${e} .blocklyInsertionMarker>.blocklyPath {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}"];
          }
        }, bl = {};
        bl.ConstantProvider = ur, bl.isDynamicShape = Ii, bl.isNotch = Da, bl.isPuzzleTab = Ma;
        var hr = class {
          constructor(e, t) {
            this.inlinePath_ = this.outlinePath_ = "", this.block_ = e, this.info_ = t, this.topLeft_ = e.getRelativeToSurfaceXY(), this.constants_ = t.getRenderer().getConstants();
          }
          draw() {
            this.drawOutline_(), this.drawInternals_(), this.updateConnectionHighlights(), this.block_.pathObject.setPath(this.outlinePath_ + `
` + this.inlinePath_), this.info_.RTL && this.block_.pathObject.flipRTL(), this.recordSizeOnBlock_();
          }
          recordSizeOnBlock_() {
            this.block_.height = this.info_.height, this.block_.width = this.info_.widthWithChildren, this.block_.childlessWidth = this.info_.width;
          }
          drawOutline_() {
            this.drawTop_();
            for (let e = 1; e < this.info_.rows.length - 1; e++) {
              let t = this.info_.rows[e];
              t.hasJaggedEdge ? this.drawJaggedEdge_(t) : t.hasStatement ? this.drawStatementInput_(t) : t.hasExternalInput ? this.drawValueInput_(t) : this.drawRightSideRow_(t);
            }
            this.drawBottom_(), this.drawLeft_();
          }
          drawTop_() {
            let e = this.info_.topRow, t = e.elements;
            this.positionPreviousConnection_(), this.outlinePath_ += ee(e.xPos, this.info_.startY);
            for (let o = 0, s; s = t[o]; o++) h.isLeftRoundedCorner(s) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft : h.isRightRoundedCorner(s) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topRight : h.isPreviousConnection(s) ? this.outlinePath_ += s.shape.pathLeft : h.isHat(s) ? this.outlinePath_ += this.constants_.START_HAT.path : h.isSpacer(s) && (this.outlinePath_ += O("h", s.width));
            this.outlinePath_ += O("v", e.height - e.ascenderHeight);
          }
          drawJaggedEdge_(e) {
            this.outlinePath_ += this.constants_.JAGGED_TEETH.path + O("v", e.height - this.constants_.JAGGED_TEETH.height);
          }
          drawValueInput_(e) {
            let t = e.getLastInput();
            this.positionExternalValueConnection_(e);
            let o = Ii(t.shape) ? t.shape.pathDown(t.height) : t.shape.pathDown;
            this.outlinePath_ += O("H", t.xPos + t.width) + o + O("v", e.height - t.connectionHeight);
          }
          drawStatementInput_(e) {
            var t = e.getLastInput();
            if (t) {
              var o = t.xPos + t.notchOffset + t.shape.width;
              t = t.shape.pathRight + O("h", -(t.notchOffset - this.constants_.INSIDE_CORNERS.width)) + this.constants_.INSIDE_CORNERS.pathTop;
              var s = e.height - 2 * this.constants_.INSIDE_CORNERS.height;
              this.outlinePath_ += O("H", o) + t + O("v", s) + this.constants_.INSIDE_CORNERS.pathBottom + O("H", e.xPos + e.width), this.positionStatementInputConnection_(e);
            }
          }
          drawRightSideRow_(e) {
            this.outlinePath_ += O("V", e.yPos + e.height);
          }
          drawBottom_() {
            let e = this.info_.bottomRow, t = e.elements;
            this.positionNextConnection_();
            let o = 0, s = "";
            for (let i = t.length - 1, n; n = t[i]; i--) h.isNextConnection(n) ? s += n.shape.pathRight : h.isLeftSquareCorner(n) ? s += O("H", e.xPos) : h.isLeftRoundedCorner(n) ? s += this.constants_.OUTSIDE_CORNERS.bottomLeft : h.isRightRoundedCorner(n) ? (s += this.constants_.OUTSIDE_CORNERS.bottomRight, o = this.constants_.OUTSIDE_CORNERS.rightHeight) : h.isSpacer(n) && (s += O("h", n.width * -1));
            this.outlinePath_ += O("V", e.baseline - o), this.outlinePath_ += s;
          }
          drawLeft_() {
            var e = this.info_.outputConnection;
            if (this.positionOutputConnection_(), e) {
              let t = e.connectionOffsetY + e.height;
              e = Ii(e.shape) ? e.shape.pathUp(e.height) : e.shape.pathUp, this.outlinePath_ += O("V", t) + e;
            }
            this.outlinePath_ += "z";
          }
          drawInternals_() {
            for (let e = 0, t; t = this.info_.rows[e]; e++) for (let o = 0, s; s = t.elements[o]; o++) h.isInlineInput(s) ? this.drawInlineInput_(s) : (h.isIcon(s) || h.isField(s)) && this.layoutField_(s);
          }
          layoutField_(e) {
            let t = e.centerline - e.height / 2, o = e.xPos;
            var s = "";
            this.info_.RTL && (o = -(o + e.width), e.flipRtl && (o += e.width, s = "scale(-1 1)")), h.isIcon(e) ? (s = e.icon, s.setOffsetInBlock(new f(o, t)), this.info_.isInsertionMarker && s.hideForInsertionMarker()) : (e = e.field.getSvgRoot(), e.setAttribute("transform", "translate(" + o + "," + t + ")" + s), this.info_.isInsertionMarker && e.setAttribute("display", "none"));
          }
          drawInlineInput_(e) {
            let t = e.width, o = e.height, s = e.connectionOffsetY, i = e.connectionHeight + s;
            this.inlinePath_ += _e(e.xPos + e.connectionWidth, e.centerline - o / 2) + O("v", s) + e.shape.pathDown + O("v", o - i) + O("h", t - e.connectionWidth) + O("v", -o) + "z", this.positionInlineInputConnection_(e);
          }
          positionInlineInputConnection_(e) {
            let t = e.centerline - e.height / 2;
            if (e.connectionModel) {
              let o = e.xPos + e.connectionWidth + e.connectionOffsetX;
              this.info_.RTL && (o *= -1), e.connectionModel.setOffsetInBlock(o, t + e.connectionOffsetY);
            }
          }
          positionStatementInputConnection_(e) {
            let t = e.getLastInput();
            if (t != null && t.connectionModel) {
              let o = e.xPos + e.statementEdge + t.notchOffset;
              this.info_.RTL && (o *= -1), t.connectionModel.setOffsetInBlock(o, e.yPos);
            }
          }
          positionExternalValueConnection_(e) {
            let t = e.getLastInput();
            if (t && t.connectionModel) {
              let o = e.xPos + e.width;
              this.info_.RTL && (o *= -1), t.connectionModel.setOffsetInBlock(o, e.yPos);
            }
          }
          positionPreviousConnection_() {
            let e = this.info_.topRow;
            if (e.connection) {
              let t = e.xPos + e.notchOffset;
              e.connection.connectionModel.setOffsetInBlock(this.info_.RTL ? -t : t, 0);
            }
          }
          positionNextConnection_() {
            let e = this.info_.bottomRow;
            if (e.connection) {
              let t = e.connection, o = t.xPos;
              t.connectionModel.setOffsetInBlock(this.info_.RTL ? -o : o, e.baseline);
            }
          }
          positionOutputConnection_() {
            if (this.info_.outputConnection) {
              let e = this.info_.startX + this.info_.outputConnection.connectionOffsetX;
              this.block_.outputConnection.setOffsetInBlock(this.info_.RTL ? -e : e, this.info_.outputConnection.connectionOffsetY);
            }
          }
          updateConnectionHighlights() {
            for (let e of this.info_.rows) for (let t of e.elements) {
              if (!(t instanceof $o)) continue;
              let o = this.drawConnectionHighlightPath(t);
              o && (o.style.display = t.highlighted ? "" : "none");
            }
          }
          drawConnectionHighlightPath(e) {
            let t = e.connectionModel;
            e = t.type === C.INPUT_VALUE || t.type === C.OUTPUT_VALUE ? this.getExpressionConnectionHighlightPath(e) : this.getStatementConnectionHighlightPath(e);
            let o = t.getSourceBlock(), s, i;
            return (i = (s = o.pathObject).addConnectionHighlight) == null ? void 0 : i.call(s, t, e, t.getOffsetInBlock(), o.RTL);
          }
          getExpressionConnectionHighlightPath(e) {
            let t = "";
            return Ii(e.shape) ? t = e.shape.pathDown(e.height) : Ma(e.shape) && (t = e.shape.pathDown), e = this.constants_.TAB_OFFSET_FROM_TOP, ee(0, -e) + O("v", e) + t + O("v", e);
          }
          getStatementConnectionHighlightPath(e) {
            if (!Da(e.shape)) throw Error("Statement connections should have notch shapes");
            let t = this.constants_.NOTCH_OFFSET_LEFT - this.constants_.CORNER_RADIUS;
            return ee(-t, 0) + O("h", t) + e.shape.pathLeft + O("h", t);
          }
        }, Db = {};
        Db.Drawer = hr;
        var Fs = class {
          constructor(e, t) {
            this.statementEdge = this.width = this.widthWithChildren = this.height = 0, this.rows = [], this.inputRows = [], this.startY = this.startX = 0, this.renderer_ = e, this.block_ = t, this.constants_ = this.renderer_.getConstants(), this.outputConnection = t.outputConnection ? new Dh(this.constants_, t.outputConnection) : null, this.isInline = t.getInputsInline() && !t.isCollapsed(), this.isCollapsed = t.isCollapsed(), this.isInsertionMarker = t.isInsertionMarker(), this.RTL = t.RTL, this.topRow = new El(this.constants_), this.bottomRow = new $l(this.constants_);
          }
          getRenderer() {
            return this.renderer_;
          }
          measure() {
            this.createRows_(), this.addElemSpacing_(), this.addRowSpacing_(), this.computeBounds_(), this.alignRowElements_(), this.finalize_();
          }
          createRows_() {
            this.populateTopRow_(), this.rows.push(this.topRow);
            let e = new _l(this.constants_);
            this.inputRows.push(e);
            var t = this.block_.getIcons();
            for (let o = 0, s; s = t[o]; o++) {
              let i = new Nh(this.constants_, s);
              this.isCollapsed && !s.isShownWhenCollapsed() || e.elements.push(i);
            }
            t = void 0;
            for (let o = 0, s; s = this.block_.inputList[o]; o++) if (s.isVisible()) {
              this.shouldStartNewRow_(s, t) && (this.rows.push(e), e = new _l(this.constants_), this.inputRows.push(e));
              for (let i = 0, n; n = s.fieldRow[i]; i++) e.elements.push(new gl(this.constants_, n, s));
              this.addInput_(s, e), t = s;
            }
            this.isCollapsed && (e.hasJaggedEdge = true, e.elements.push(new Ah(this.constants_))), (e.elements.length || e.hasDummyInput) && this.rows.push(e), this.populateBottomRow_(), this.rows.push(this.bottomRow);
          }
          populateTopRow_() {
            var e = !!this.block_.previousConnection;
            let t = (this.block_.hat ? this.block_.hat === "cap" : this.constants_.ADD_START_HATS) && !this.outputConnection && !e, o = this.topRow.hasLeftSquareCorner(this.block_) ? xs : Bs;
            this.topRow.elements.push(new o(this.constants_)), t ? (e = new Lh(this.constants_), this.topRow.elements.push(e)) : e && (this.topRow.hasPreviousConnection = true, this.topRow.connection = new Ph(this.constants_, this.block_.previousConnection), this.topRow.elements.push(this.topRow.connection)), this.block_.inputList.length && this.block_.inputList[0] instanceof Ae && !this.block_.isCollapsed() ? this.topRow.minHeight = this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT : this.topRow.minHeight = this.constants_.TOP_ROW_MIN_HEIGHT, o = this.topRow.hasRightSquareCorner(this.block_) ? xs : Bs, this.topRow.elements.push(new o(this.constants_, "right"));
          }
          populateBottomRow_() {
            this.bottomRow.hasNextConnection = !!this.block_.nextConnection, this.bottomRow.minHeight = this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1] instanceof Ae ? this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT : this.constants_.BOTTOM_ROW_MIN_HEIGHT, this.bottomRow.hasLeftSquareCorner(this.block_) ? this.bottomRow.elements.push(new xs(this.constants_)) : this.bottomRow.elements.push(new Bs(this.constants_)), this.bottomRow.hasNextConnection && (this.bottomRow.connection = new Mh(this.constants_, this.block_.nextConnection), this.bottomRow.elements.push(this.bottomRow.connection)), this.bottomRow.hasRightSquareCorner(this.block_) ? this.bottomRow.elements.push(new xs(this.constants_, "right")) : this.bottomRow.elements.push(new Bs(this.constants_, "right"));
          }
          addInput_(e, t) {
            this.isInline && e instanceof r.ValueInput$$module$build$src$core$inputs$value_input ? (t.elements.push(new ml(this.constants_, e)), t.hasInlineInput = true) : e instanceof Ae ? (t.elements.push(new ar(this.constants_, e)), t.hasStatement = true) : e instanceof r.ValueInput$$module$build$src$core$inputs$value_input ? (t.elements.push(new pl(this.constants_, e)), t.hasExternalInput = true) : (e instanceof rt || e instanceof Ct) && (t.minHeight = Math.max(t.minHeight, e.getSourceBlock() && e.getSourceBlock().isShadow() ? this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT : this.constants_.DUMMY_INPUT_MIN_HEIGHT), t.hasDummyInput = true), t.align === null && (t.align = e.align);
          }
          shouldStartNewRow_(e, t) {
            return t ? t instanceof Ct || e instanceof Ae || t instanceof Ae ? true : e instanceof r.ValueInput$$module$build$src$core$inputs$value_input || e instanceof rt || t instanceof r.ValueInput$$module$build$src$core$inputs$value_input ? !this.isInline : false : false;
          }
          addElemSpacing_() {
            for (let e = 0, t; t = this.rows[e]; e++) {
              let o = t.elements;
              if (t.elements = [], t.startsWithElemSpacer() && t.elements.push(new Me(this.constants_, this.getInRowSpacing_(null, o[0]))), o.length) {
                for (let s = 0; s < o.length - 1; s++) {
                  t.elements.push(o[s]);
                  let i = this.getInRowSpacing_(o[s], o[s + 1]);
                  t.elements.push(new Me(this.constants_, i));
                }
                t.elements.push(o[o.length - 1]), t.endsWithElemSpacer() && t.elements.push(new Me(this.constants_, this.getInRowSpacing_(o[o.length - 1], null)));
              }
            }
          }
          getInRowSpacing_(e, t) {
            if (!e && t && h.isStatementInput(t)) return this.constants_.STATEMENT_INPUT_PADDING_LEFT;
            if (e && h.isInput(e) && !t) {
              if (h.isExternalInput(e)) return this.constants_.NO_PADDING;
              if (h.isInlineInput(e)) return this.constants_.LARGE_PADDING;
              if (h.isStatementInput(e)) return this.constants_.NO_PADDING;
            }
            return e && h.isLeftSquareCorner(e) && t && (h.isPreviousConnection(t) || h.isNextConnection(t)) ? t.notchOffset : e && h.isLeftRoundedCorner(e) && t && (h.isPreviousConnection(t) || h.isNextConnection(t)) ? t.notchOffset - this.constants_.CORNER_RADIUS : e && h.isField(e) && e.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING;
          }
          computeBounds_() {
            let e = 0, t = 0, o = 0;
            for (let i = 0, n; n = this.rows[i]; i++) {
              if (n.measure(), t = Math.max(t, n.width), n.hasStatement) {
                var s = n.getLastInput();
                let l, a;
                s = n.width - ((a = (l = s) == null ? void 0 : l.width) != null ? a : 0), e = Math.max(e, s);
              }
              o = Math.max(o, n.widthWithConnectedBlocks);
            }
            this.statementEdge = e, this.width = t;
            for (let i = 0, n; n = this.rows[i]; i++) n.hasStatement && (n.statementEdge = this.statementEdge);
            this.widthWithChildren = Math.max(t, o), this.outputConnection && (this.startX = this.outputConnection.width, this.width += this.outputConnection.width, this.widthWithChildren += this.outputConnection.width);
          }
          alignRowElements_() {
            for (let t = 0, o; o = this.rows[t]; t++) if (o.hasStatement) this.alignStatementRow_(o);
            else {
              var e = o.width;
              e = this.getDesiredRowWidth_(o) - e, e > 0 && this.addAlignmentPadding_(o, e), h.isTopOrBottomRow(o) && (o.widthWithConnectedBlocks = o.width);
            }
          }
          getDesiredRowWidth_(e) {
            return this.width - this.startX;
          }
          addAlignmentPadding_(e, t) {
            let o = e.getFirstSpacer(), s = e.getLastSpacer();
            if ((e.hasExternalInput || e.hasStatement) && (e.widthWithConnectedBlocks += t), e.align === r.Align$$module$build$src$core$inputs$align.LEFT && s) s.width += t;
            else if (e.align === r.Align$$module$build$src$core$inputs$align.CENTRE && o && s) o.width += t / 2, s.width += t / 2;
            else if (e.align === r.Align$$module$build$src$core$inputs$align.RIGHT && o) o.width += t;
            else if (s) s.width += t;
            else return;
            e.width += t;
          }
          alignStatementRow_(e) {
            let t = e.getLastInput();
            if (t) {
              var o = e.width - t.width, s = this.statementEdge;
              o = s - o, o > 0 && this.addAlignmentPadding_(e, o), o = e.width, s = this.getDesiredRowWidth_(e), t.width += s - o, t.height = Math.max(t.height, e.height), e.width += s - o, e.widthWithConnectedBlocks = Math.max(e.width, this.statementEdge + e.connectedBlockWidths);
            }
          }
          addRowSpacing_() {
            let e = this.rows;
            this.rows = [];
            for (let t = 0; t < e.length; t++) this.rows.push(e[t]), t !== e.length - 1 && this.rows.push(this.makeSpacerRow_(e[t], e[t + 1]));
          }
          makeSpacerRow_(e, t) {
            var o = this.getSpacerRowHeight_(e, t);
            let s = this.getSpacerRowWidth_(e, t);
            return o = new Tl(this.constants_, o, s), e.hasStatement && (o.followsStatement = true), t.hasStatement && (o.precedesStatement = true), o;
          }
          getSpacerRowWidth_(e, t) {
            return this.width - this.startX;
          }
          getSpacerRowHeight_(e, t) {
            return this.constants_.MEDIUM_PADDING;
          }
          getElemCenterline_(e, t) {
            return h.isSpacer(t) ? e.yPos + t.height / 2 : h.isBottomRow(e) ? (e = e.yPos + e.height - e.descenderHeight, h.isNextConnection(t) ? e + t.height / 2 : e - t.height / 2) : h.isTopRow(e) ? h.isHat(t) ? e.capline - t.height / 2 : e.capline + t.height / 2 : e.yPos + e.height / 2;
          }
          recordElemPositions_(e) {
            let t = e.xPos;
            for (let o = 0, s; s = e.elements[o]; o++) h.isSpacer(s) && (s.height = e.height), s.xPos = t, s.centerline = this.getElemCenterline_(e, s), t += s.width;
          }
          finalize_() {
            let e = 0, t = 0;
            for (let o = 0, s; s = this.rows[o]; o++) s.yPos = t, s.xPos = this.startX, t += s.height, e = Math.max(e, s.widthWithConnectedBlocks), this.recordElemPositions_(s);
            if (this.outputConnection && this.block_.nextConnection) {
              let o = this.block_.nextConnection.targetBlock();
              o && (e = Math.max(e, o.getHeightWidth().width));
            }
            this.widthWithChildren = e + this.startX, this.height = t, this.startY = this.topRow.capline, this.bottomRow.baseline = t - this.bottomRow.descenderHeight;
          }
          getMeasureableForConnection(e) {
            let t;
            if (((t = this.outputConnection) == null ? void 0 : t.connectionModel) === e) return this.outputConnection;
            for (let o of this.rows) for (let s of o.elements) if (s instanceof $o && s.connectionModel === e) return s;
            return null;
          }
        }, Pb = {};
        Pb.RenderInfo = Fs;
        var dr = class {
          constructor(e, t, o) {
            this.connectionHighlights = /* @__PURE__ */ new WeakMap(), this.highlightOffsets = /* @__PURE__ */ new WeakMap(), this.constants = o, this.style = t, this.svgRoot = e, this.svgPath = b($.PATH, { class: "blocklyPath" }, this.svgRoot), this.setClass_("blocklyBlock", true);
          }
          setPath(e) {
            this.svgPath.setAttribute("d", e);
          }
          flipRTL() {
            this.svgPath.setAttribute("transform", "scale(-1 1)");
          }
          applyColour(e) {
            this.svgPath.setAttribute("stroke", this.style.colourTertiary), this.svgPath.setAttribute("fill", this.style.colourPrimary), this.updateShadow_(e.isShadow()), this.updateDisabled_(!e.isEnabled() || e.getInheritedDisabled());
          }
          setStyle(e) {
            this.style = e;
          }
          setClass_(e, t) {
            e && (t ? I(this.svgRoot, e) : P(this.svgRoot, e));
          }
          updateHighlighted(e) {
            e ? this.setClass_("blocklyHighlighted", true) : this.setClass_("blocklyHighlighted", false);
          }
          updateShadow_(e) {
            e ? (this.setClass_("blocklyShadow", true), this.svgPath.setAttribute("stroke", "none"), this.svgPath.setAttribute("fill", this.style.colourSecondary)) : this.setClass_("blocklyShadow", false);
          }
          updateDisabled_(e) {
            this.setClass_("blocklyDisabled", e), this.setClass_("blocklyDisabledPattern", e);
          }
          updateSelected(e) {
            this.setClass_("blocklySelected", e);
          }
          updateDraggingDelete(e) {
            this.setClass_("blocklyDraggingDelete", e);
          }
          updateInsertionMarker(e) {
            this.setClass_("blocklyInsertionMarker", e);
          }
          updateMovable(e) {
            this.setClass_("blocklyDraggable", e);
          }
          updateReplacementFade(e) {
            this.setClass_("blocklyReplaceable", e);
          }
          updateShapeForInputHighlight(e, t) {
          }
          addConnectionHighlight(e, t, o, s) {
            return o = `translate(${o.x}, ${o.y})` + (s ? " scale(-1 1)" : ""), (s = this.connectionHighlights.get(e)) ? (s.setAttribute("d", t), s.setAttribute("transform", o), s) : (t = b($.PATH, { id: e.id, class: "blocklyHighlightedConnectionPath", style: "display: none;", d: t, transform: o }, this.svgRoot), this.connectionHighlights.set(e, t), t);
          }
          removeConnectionHighlight(e) {
            let t = this.connectionHighlights.get(e);
            t && (V(t), this.connectionHighlights.delete(e));
          }
        }, Bb = {};
        Bb.PathObject = dr;
        var $r = class {
          constructor(e) {
            this.overrides = null, this.name = e;
          }
          getClassName() {
            return this.name + "-renderer";
          }
          init(e, t) {
            this.constants_ = this.makeConstants_(), t && (this.overrides = t, Object.assign(this.constants_, t)), this.constants_.setTheme(e), this.constants_.init();
          }
          createDom(e, t, o) {
            this.constants_.createDom(e, this.name + "-" + t.name, "." + this.getClassName() + "." + t.getClassName(), o);
          }
          refreshDom(e, t, o) {
            let s = this.getConstants();
            s.dispose(), this.constants_ = this.makeConstants_(), this.overrides && Object.assign(this.constants_, this.overrides), this.constants_.randomIdentifier = s.randomIdentifier, this.constants_.setTheme(t), this.constants_.init(), this.createDom(e, t, o);
          }
          dispose() {
            this.constants_ && this.constants_.dispose();
          }
          makeConstants_() {
            return new ur();
          }
          makeRenderInfo_(e) {
            return new Fs(this, e);
          }
          makeDrawer_(e, t) {
            return new hr(e, t);
          }
          makePathObject(e, t) {
            return new dr(e, t, this.constants_);
          }
          getConstants() {
            return this.constants_;
          }
          shouldHighlightConnection(e) {
            return true;
          }
          orphanCanConnectAtEnd(e, t, o) {
            return !!D.getConnectionForOrphanedConnection(e, o === C.OUTPUT_VALUE ? t.outputConnection : t.previousConnection);
          }
          render(e) {
            let t = this.makeRenderInfo_(e);
            t.measure(), this.makeDrawer_(e, t).draw();
          }
        }, xb = {};
        xb.Renderer = $r;
        var U = {};
        U.BottomRow = $l, U.Connection = $o, U.ConstantProvider = ur, U.Drawer = hr, U.ExternalValueInput = pl, U.Field = gl, U.Hat = Lh, U.Icon = Nh, U.InRowSpacer = Me, U.InlineInput = ml, U.InputConnection = cr, U.InputRow = _l, U.JaggedEdge = Ah, U.Measurable = lt, U.NextConnection = Mh, U.OutputConnection = Dh, U.PathObject = dr, U.PreviousConnection = Ph, U.RenderInfo = Fs, U.Renderer = $r, U.RoundCorner = Bs, U.Row = Ps, U.SpacerRow = Tl, U.SquareCorner = xs, U.StatementInput = ar, U.TopRow = El, U.Types = h, U.init = Pa, U.register = yi, U.unregister = eg;
        var Bh = class {
          constructor(e, t) {
            this.workspace = e, this.theme = t, this.subscribedWorkspaces = [], this.componentDB = /* @__PURE__ */ new Map();
          }
          getTheme() {
            return this.theme;
          }
          setTheme(e) {
            var t = this.theme;
            this.theme = e, (e = this.workspace.getInjectionDiv()) && (t && (t = t.getClassName()) && P(e, t), (t = this.theme.getClassName()) && I(e, t));
            for (let o = 0, s; s = this.subscribedWorkspaces[o]; o++) s.refreshTheme();
            for (let [o, s] of this.componentDB) for (let i of s) {
              e = i.element, t = i.propertyName;
              let n = this.theme && this.theme.getComponentStyle(o);
              e.style.setProperty(t, n || "");
            }
            for (let o of this.subscribedWorkspaces) o.hideChaff();
          }
          subscribeWorkspace(e) {
            this.subscribedWorkspaces.push(e);
          }
          unsubscribeWorkspace(e) {
            if (!Pe(this.subscribedWorkspaces, e)) throw Error("Cannot unsubscribe a workspace that hasn't been subscribed.");
          }
          subscribe(e, t, o) {
            this.componentDB.has(t) || this.componentDB.set(t, []), this.componentDB.get(t).push({ element: e, propertyName: o }), t = this.theme && this.theme.getComponentStyle(t), e.style.setProperty(o, t || "");
          }
          unsubscribe(e) {
            if (e) for (let [t, o] of this.componentDB) {
              for (let s = o.length - 1; s >= 0; s--) o[s].element === e && o.splice(s, 1);
              o.length || this.componentDB.delete(t);
            }
          }
          dispose() {
            this.subscribedWorkspaces.length = 0, this.componentDB.clear();
          }
        }, Fb = {};
        Fb.ThemeManager = Bh;
        var fl = "VARIABLE_DYNAMIC", mL = Ci, _L = vi, TL = ki, po = { CATEGORY_NAME: fl };
        po.flyoutCategory = Ba, po.flyoutCategoryBlocks = xa, po.internalFlyoutCategory = gn, po.onCreateVariableButtonClick_Colour = ki, po.onCreateVariableButtonClick_Number = vi, po.onCreateVariableButtonClick_String = Ci;
        var xh = class {
          canConnect(e, t, o, s) {
            return this.canConnectWithReason(e, t, o, s) === D.CAN_CONNECT;
          }
          canConnectWithReason(e, t, o, s) {
            let i = this.doSafetyChecks(e, t);
            return i !== D.CAN_CONNECT ? i : this.doTypeChecks(e, t) ? o && !this.doDragChecks(e, t, s || 0) ? D.REASON_DRAG_CHECKS_FAILED : D.CAN_CONNECT : D.REASON_CHECKS_FAILED;
          }
          getErrorMessage(e, t, o) {
            switch (e) {
              case D.REASON_SELF_CONNECTION:
                return "Attempted to connect a block to itself.";
              case D.REASON_DIFFERENT_WORKSPACES:
                return "Blocks not on same workspace.";
              case D.REASON_WRONG_TYPE:
                return "Attempt to connect incompatible types.";
              case D.REASON_TARGET_NULL:
                return "Target connection is null.";
              case D.REASON_CHECKS_FAILED:
                return "Connection checks failed. " + (t + " expected " + t.getCheck() + ", found " + o.getCheck());
              case D.REASON_SHADOW_PARENT:
                return "Connecting non-shadow to shadow block.";
              case D.REASON_DRAG_CHECKS_FAILED:
                return "Drag checks failed.";
              case D.REASON_PREVIOUS_AND_OUTPUT:
                return "Block would have an output and a previous connection.";
              default:
                return "Unknown connection failure: this should never happen!";
            }
          }
          doSafetyChecks(e, t) {
            if (!e || !t) return D.REASON_TARGET_NULL;
            let o, s, i;
            return e.isSuperior() ? (o = e.getSourceBlock(), s = t.getSourceBlock(), i = t) : (s = e.getSourceBlock(), o = t.getSourceBlock(), i = e, e = t), o === s ? D.REASON_SELF_CONNECTION : i.type !== Ut[e.type] ? D.REASON_WRONG_TYPE : o.workspace !== s.workspace ? D.REASON_DIFFERENT_WORKSPACES : o.isShadow() && !s.isShadow() ? D.REASON_SHADOW_PARENT : i.type === C.OUTPUT_VALUE && s.previousConnection && s.previousConnection.isConnected() || i.type === C.PREVIOUS_STATEMENT && s.outputConnection && s.outputConnection.isConnected() ? D.REASON_PREVIOUS_AND_OUTPUT : D.CAN_CONNECT;
          }
          doTypeChecks(e, t) {
            if (e = e.getCheck(), t = t.getCheck(), !e || !t) return true;
            for (let o = 0; o < e.length; o++) if (t.includes(e[o])) return true;
            return false;
          }
          doDragChecks(e, t, o) {
            if (e.distanceFrom(t) > o || t.getSourceBlock().isInsertionMarker()) return false;
            switch (t.type) {
              case C.PREVIOUS_STATEMENT:
                return this.canConnectToPrevious_(e, t);
              case C.OUTPUT_VALUE:
                if (t.isConnected() && !t.targetBlock().isInsertionMarker() || e.isConnected()) return false;
                break;
              case C.INPUT_VALUE:
                if (t.isConnected() && !t.targetBlock().isMovable() && !t.targetBlock().isShadow()) return false;
                break;
              case C.NEXT_STATEMENT:
                if (t.isConnected() && !e.getSourceBlock().nextConnection && !t.targetBlock().isShadow() && t.targetBlock().nextConnection || t.targetBlock() && !t.targetBlock().isMovable() && !t.targetBlock().isShadow()) return false;
                break;
              default:
                return false;
            }
            return !Ni.includes(t);
          }
          canConnectToPrevious_(e, t) {
            return e.targetConnection || Ni.includes(t) ? false : t.targetConnection ? (e = t.targetBlock(), e.isInsertionMarker() ? !e.getPreviousBlock() : false) : true;
          }
        };
        c(E.CONNECTION_CHECKER, Fe, xh);
        var Hb = {};
        Hb.ConnectionChecker = xh;
        var Jo = class {
          get isFlyout() {
            return this.internalIsFlyout;
          }
          get isMutator() {
            return this.internalIsMutator;
          }
          constructor(e) {
            this.isClearing = this.internalIsMutator = this.internalIsFlyout = this.rendered = false, this.MAX_UNDO = 1024, this.connectionDBList = [], this.topBlocks = [], this.topComments = [], this.commentDB = /* @__PURE__ */ new Map(), this.listeners = [], this.undoStack_ = [], this.redoStack_ = [], this.blockDB = /* @__PURE__ */ new Map(), this.typedBlocksDB = /* @__PURE__ */ new Map(), this.procedureMap = new wh(), this.readOnly = false, this.potentialVariableMap = null, this.id = wt(), sc(this), this.options = e || new st({}), this.RTL = !!this.options.RTL, this.horizontalLayout = !!this.options.horizontalLayout, this.toolboxPosition = this.options.toolboxPosition, this.connectionChecker = new (Ce(E.CONNECTION_CHECKER, this.options, true))(this), this.variableMap = new (this.getVariableMapClass())(this), this.setIsReadOnly(this.options.readOnly);
          }
          dispose() {
            this.listeners.length = 0, this.clear(), ic(this);
          }
          sortObjects(e, t) {
            let o = (s) => ({ getBoundingRectangle: () => {
              let i = s.getRelativeToSurfaceXY();
              return new L(i.y, i.y, i.x, i.x);
            }, moveBy: () => {
            } });
            return this.sortByOrigin(o(e), o(t));
          }
          sortByOrigin(e, t) {
            let o = Math.sin(jr(Jo.SCAN_ANGLE)) * (this.RTL ? -1 : 1);
            return e = e.getBoundingRectangle().getOrigin(), t = t.getBoundingRectangle().getOrigin(), e.y + o * e.x - (t.y + o * t.x);
          }
          addTopBlock(e) {
            this.topBlocks.push(e);
          }
          removeTopBlock(e) {
            if (!Pe(this.topBlocks, e)) throw Error("Block not present in workspace's list of top-most blocks.");
          }
          getTopBlocks(e = false) {
            let t = [].concat(this.topBlocks);
            return e && t.length > 1 && t.sort(this.sortObjects.bind(this)), t;
          }
          addTypedBlock(e) {
            this.typedBlocksDB.has(e.type) || this.typedBlocksDB.set(e.type, []), this.typedBlocksDB.get(e.type).push(e);
          }
          removeTypedBlock(e) {
            Pe(this.typedBlocksDB.get(e.type), e), this.typedBlocksDB.get(e.type).length || this.typedBlocksDB.delete(e.type);
          }
          getBlocksByType(e, t = false) {
            return this.typedBlocksDB.has(e) ? (e = this.typedBlocksDB.get(e).slice(0), t && e && e.length > 1 && e.sort(this.sortObjects.bind(this)), e.filter((o) => !o.isInsertionMarker())) : [];
          }
          addTopComment(e) {
            this.topComments.push(e), this.commentDB.has(e.id) && console.warn('Overriding an existing comment on this workspace, with id "' + e.id + '"'), this.commentDB.set(e.id, e);
          }
          removeTopComment(e) {
            if (!Pe(this.topComments, e)) throw Error("Comment not present in workspace's list of top-most comments.");
            this.commentDB.delete(e.id);
          }
          getTopComments(e = false) {
            let t = [].concat(this.topComments);
            return e && t.length > 1 && t.sort(this.sortObjects.bind(this)), t;
          }
          getAllBlocks(e = false) {
            if (e) {
              var t = this.getTopBlocks(true);
              e = [];
              for (let o = 0; o < t.length; o++) e.push(...t[o].getDescendants(true));
            } else for (e = this.getTopBlocks(false), t = 0; t < e.length; t++) e.push(...e[t].getChildren(false));
            return e.filter((o) => !o.isInsertionMarker());
          }
          clear() {
            this.isClearing = true;
            try {
              let e = r.getGroup$$module$build$src$core$events$utils();
              for (e || r.setGroup$$module$build$src$core$events$utils(true); this.topBlocks.length; ) this.topBlocks[0].dispose(false);
              for (; this.topComments.length; ) this.topComments[this.topComments.length - 1].dispose();
              r.setGroup$$module$build$src$core$events$utils(e), this.isFlyout || this.variableMap.clear(), this.potentialVariableMap && this.potentialVariableMap.clear();
            } finally {
              this.isClearing = false;
            }
          }
          renameVariableById(e, t) {
            me("Blockly.Workspace.renameVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().renameVariable"), (e = this.variableMap.getVariableById(e)) && this.variableMap.renameVariable(e, t);
          }
          createVariable(e, t, o) {
            return me("Blockly.Workspace.createVariable", "v12", "v13", "Blockly.Workspace.getVariableMap().createVariable"), this.variableMap.createVariable(e, t ?? void 0, o ?? void 0);
          }
          getVariableUsesById(e) {
            return me("Blockly.Workspace.getVariableUsesById", "v12", "v13", "Blockly.Variables.getVariableUsesById"), us(this, e);
          }
          deleteVariableById(e) {
            me("Blockly.Workspace.deleteVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().deleteVariable");
            let t = this.variableMap.getVariableById(e);
            t ? r.deleteVariable$$module$build$src$core$variables(this, t) : console.warn(`Can't delete non-existent variable: ${e}`);
          }
          getVariable(e, t) {
            return me("Blockly.Workspace.getVariable", "v12", "v13", "Blockly.Workspace.getVariableMap().getVariable"), this.variableMap.getVariable(e, t);
          }
          getVariableById(e) {
            return me("Blockly.Workspace.getVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().getVariableById"), this.variableMap.getVariableById(e);
          }
          getVariablesOfType(e) {
            return me("Blockly.Workspace.getVariablesOfType", "v12", "v13", "Blockly.Workspace.getVariableMap().getVariablesOfType"), this.variableMap.getVariablesOfType(e ?? "");
          }
          getAllVariables() {
            return me("Blockly.Workspace.getAllVariables", "v12", "v13", "Blockly.Workspace.getVariableMap().getAllVariables"), this.variableMap.getAllVariables();
          }
          getAllVariableNames() {
            return me("Blockly.Workspace.getAllVariableNames", "v12", "v13", "Blockly.Workspace.getVariableMap().getAllVariables"), this.variableMap.getAllVariables().map((e) => e.getName());
          }
          getWidth() {
            return 0;
          }
          newBlock(e, t) {
            throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts");
          }
          newComment(e) {
            throw Error("The implementation of newComment should be monkey-patched in by blockly.ts");
          }
          remainingCapacity() {
            return isNaN(this.options.maxBlocks) ? 1 / 0 : this.options.maxBlocks - this.getAllBlocks(false).length;
          }
          remainingCapacityOfType(e) {
            return this.options.maxInstances ? (this.options.maxInstances[e] !== void 0 ? this.options.maxInstances[e] : 1 / 0) - this.getBlocksByType(e, false).length : 1 / 0;
          }
          isCapacityAvailable(e) {
            if (!this.hasBlockLimits()) return true;
            let t = 0;
            for (let o in e) {
              if (e[o] > this.remainingCapacityOfType(o)) return false;
              t += e[o];
            }
            return !(t > this.remainingCapacity());
          }
          hasBlockLimits() {
            return this.options.maxBlocks !== 1 / 0 || !!this.options.maxInstances;
          }
          getUndoStack() {
            return this.undoStack_;
          }
          getRedoStack() {
            return this.redoStack_;
          }
          undo(e) {
            var t = e ? this.redoStack_ : this.undoStack_, o = e ? this.undoStack_ : this.redoStack_;
            let s = t.pop();
            if (s) {
              for (var i = [s]; t.length && s.group && s.group === t[t.length - 1].group; ) {
                let n = t.pop();
                n && i.push(n);
              }
              for (t = 0; t < i.length; t++) o.push(i[t]);
              r.setRecordUndo$$module$build$src$core$events$utils(false);
              try {
                for (o = 0; o < i.length; o++) i[o].run(e);
              } finally {
                r.setRecordUndo$$module$build$src$core$events$utils(true);
              }
            }
          }
          clearUndo() {
            this.undoStack_.length = 0, this.redoStack_.length = 0, Cr();
          }
          addChangeListener(e) {
            return this.listeners.push(e), e;
          }
          removeChangeListener(e) {
            Pe(this.listeners, e);
          }
          fireChangeListener(e) {
            if (e.recordUndo) for (this.undoStack_.push(e), this.redoStack_.length = 0; this.undoStack_.length > this.MAX_UNDO && this.MAX_UNDO >= 0; ) this.undoStack_.shift();
            for (let t = 0; t < this.listeners.length; t++) (0, this.listeners[t])(e);
          }
          getBlockById(e) {
            return this.blockDB.get(e) || null;
          }
          setBlockById(e, t) {
            this.blockDB.set(e, t);
          }
          removeBlockById(e) {
            this.blockDB.delete(e);
          }
          getCommentById(e) {
            let t;
            return (t = this.commentDB.get(e)) != null ? t : null;
          }
          allInputsFilled(e) {
            let t = this.getTopBlocks(false);
            for (let o = 0; o < t.length; o++) if (!t[o].allInputsFilled(e)) return false;
            return true;
          }
          getPotentialVariableMap() {
            return this.potentialVariableMap;
          }
          createPotentialVariableMap() {
            this.potentialVariableMap = new (this.getVariableMapClass())(this, true);
          }
          getVariableMap() {
            return this.variableMap;
          }
          setVariableMap(e) {
            this.variableMap = e;
          }
          getProcedureMap() {
            return this.procedureMap;
          }
          getRootWorkspace() {
            let e = null, t = this.options.parentWorkspace;
            return this.isFlyout ? t && t.options && (e = t.options.parentWorkspace) : t && (e = t), e;
          }
          static getById(e) {
            return zt(e);
          }
          static getAll() {
            return is();
          }
          getVariableMapClass() {
            let e = Ce(E.VARIABLE_MAP, this.options, true);
            if (!e) throw Error("No variable map is registered.");
            return e;
          }
          isReadOnly() {
            return this.readOnly;
          }
          setIsReadOnly(e) {
            this.readOnly = e, this.options.readOnly = e;
          }
        };
        Jo.SCAN_ANGLE = 3;
        var Ub = {};
        Ub.Workspace = Jo;
        var Gb = 100, Fh = class {
          constructor(e) {
            this.parentWorkspace = e, this.sounds = /* @__PURE__ */ new Map(), this.lastSound = null, this.muted = false;
          }
          dispose() {
            this.sounds.clear();
          }
          load(e, t) {
            if (e.length) {
              try {
                var o = new globalThis.Audio();
              } catch {
                return;
              }
              for (let i = 0; i < e.length; i++) {
                let n = e[i], l = n.match(/\.(\w+)$/);
                if (l && o.canPlayType("audio/" + l[1])) {
                  var s = new globalThis.Audio(n);
                  break;
                }
              }
              s && this.sounds.set(t, s);
            }
          }
          preload() {
            for (let e of this.sounds.values()) {
              e.volume = 0.01;
              let t = e.play();
              if (t !== void 0 ? t.then(e.pause).catch(function() {
              }) : e.pause(), kn || Sg) break;
            }
          }
          play(e, t) {
            if (!this.muted) {
              var o = this.sounds.get(e);
              o ? (e = /* @__PURE__ */ new Date(), this.lastSound !== null && e.getTime() - this.lastSound.getTime() < Gb || (this.lastSound = e, o = kn || yu ? o : o.cloneNode(), o.volume = t === void 0 ? 1 : t, o.play())) : this.parentWorkspace && this.parentWorkspace.getAudioManager().play(e, t);
            }
          }
          setMuted(e) {
            this.muted = e;
          }
          getMuted() {
            return this.muted;
          }
        }, Vb = {};
        Vb.WorkspaceAudio = Fh;
        var Wb = 20, Ie = class extends Jo {
          constructor(e) {
            super(e), this.resizeHandlerWrapper = null, this.resizesEnabled = this.visible = this.rendered = true, this.startScrollY = this.startScrollX = this.scrollY = this.scrollX = 0, this.oldScale = this.scale = 1, this.oldLeft = this.oldTop = 0, this.inverseScreenCTM = this.targetWorkspace = this.dummyWheelListener = this.configureContextMenu = this.lastRecordedPageScroll = this.injectionDiv = this.currentGesture_ = this.toolbox = this.flyout = this.scrollbar = this.trashcan = null, this.inverseScreenCTMDirty = true, this.highlightedBlocks = [], this.toolboxCategoryCallbacks = /* @__PURE__ */ new Map(), this.flyoutButtonCallbacks = /* @__PURE__ */ new Map(), this.cachedParentSvg = null, this.keyboardMoveInProgress = this.keyboardAccessibilityMode = false, this.topBoundedElements = [], this.dragTargetAreas = [], this.zoomControls_ = this.layerManager = null, this.navigator = new cl(), this.metricsManager = new (Ce(E.METRICS_MANAGER, e, true))(this), this.getMetrics = e.getMetrics || this.metricsManager.getMetrics.bind(this.metricsManager), this.setMetrics = e.setMetrics || Ie.setTopLevelWorkspaceMetrics, this.componentManager = new j(), this.connectionDBList = zo.init(this.connectionChecker), this.audioManager = new Fh(e.parentWorkspace), this.grid = this.options.gridPattern ? new ul(this.options.gridPattern, e.gridOptions) : null, this.markerManager = new dl(this), le && Wr && this.registerToolboxCategoryCallback(Dn, Wr), po && gn && this.registerToolboxCategoryCallback(fl, gn), Se && pn && (this.registerToolboxCategoryCallback(lr, pn), this.addChangeListener(Na)), this.addChangeListener(this.variableChangeCallback.bind(this)), this.themeManager_ = this.options.parentWorkspace ? this.options.parentWorkspace.getThemeManager() : new Bh(this, this.options.theme || Ji), this.themeManager_.subscribeWorkspace(this);
            let t;
            this.renderer = Pa(this.options.renderer || "geras", this.getTheme(), (t = this.options.rendererOverrides) != null ? t : void 0), this.cachedParentSvgSize = new N(0, 0);
          }
          getMarkerManager() {
            return this.markerManager;
          }
          getMetricsManager() {
            return this.metricsManager;
          }
          setMetricsManager(e) {
            this.metricsManager = e, this.getMetrics = this.metricsManager.getMetrics.bind(this.metricsManager);
          }
          getComponentManager() {
            return this.componentManager;
          }
          getMarker(e) {
            return this.markerManager.getMarker(e);
          }
          getCursor() {
            return this.markerManager.getCursor();
          }
          getRenderer() {
            return this.renderer;
          }
          getThemeManager() {
            return this.themeManager_;
          }
          getTheme() {
            return this.themeManager_.getTheme();
          }
          setTheme(e) {
            e || (e = Ji), this.themeManager_.setTheme(e);
          }
          refreshTheme() {
            if (this.svgGroup_) {
              var e = this.options.parentWorkspace === null;
              this.renderer.refreshDom(this.svgGroup_, this.getTheme(), e ? this.getInjectionDiv() : void 0);
            }
            this.updateBlockStyles(this.getAllBlocks(false).filter((t) => !!t.getStyleName())), this.refreshToolboxSelection(), this.toolbox && this.toolbox.refreshTheme(), this.isVisible() && this.setVisible(true), e = new (S(d.THEME_CHANGE))(this.getTheme().name, this.id), R(e);
          }
          updateBlockStyles(e) {
            for (let t = 0, o; o = e[t]; t++) {
              let s = o.getStyleName();
              s && o.setStyle(s);
            }
          }
          getInverseScreenCTM() {
            if (this.inverseScreenCTMDirty) {
              let e = this.getParentSvg().getScreenCTM();
              e && (this.inverseScreenCTM = e.inverse(), this.inverseScreenCTMDirty = false);
            }
            return this.inverseScreenCTM;
          }
          updateInverseScreenCTM() {
            this.inverseScreenCTMDirty = true;
          }
          isVisible() {
            return this.visible;
          }
          getSvgXY(e) {
            let t = 0, o = 0, s = 1;
            (this.getCanvas().contains(e) || this.getBubbleCanvas().contains(e)) && (s = this.scale);
            do {
              let i = si(e);
              (e === this.getCanvas() || e === this.getBubbleCanvas()) && (s = 1), t += i.x * s, o += i.y * s, e = e.parentNode;
            } while (e && e !== this.getParentSvg() && e !== this.getInjectionDiv());
            return new f(t, o);
          }
          getCachedParentSvgSize() {
            let e = this.cachedParentSvgSize;
            return new N(e.width, e.height);
          }
          getOriginOffsetInPixels() {
            return Lr(this.getCanvas());
          }
          getInjectionDiv() {
            if (!this.injectionDiv) {
              let e = this.svgGroup_;
              for (; e; ) {
                if ((" " + (e.getAttribute("class") || "") + " ").includes(" injectionDiv ")) {
                  this.injectionDiv = e;
                  break;
                }
                e = e.parentNode;
              }
            }
            return this.injectionDiv;
          }
          getSvgGroup() {
            return this.svgGroup_;
          }
          getBlockCanvas() {
            return this.getCanvas();
          }
          setResizeHandlerWrapper(e) {
            this.resizeHandlerWrapper = e;
          }
          createDom(e, t) {
            return this.injectionDiv || (this.injectionDiv = t ?? null), this.svgGroup_ = b($.G, { class: "blocklyWorkspace", id: this.id }), t && ae(this.svgGroup_, ne.LABEL, r.Msg$$module$build$src$core$msg.WORKSPACE_ARIA_LABEL), e && (this.svgBackground_ = b($.RECT, { height: "100%", width: "100%", class: e }, this.svgGroup_), e === "blocklyMainBackground" && this.grid ? this.svgBackground_.style.fill = "var(--blocklyGridPattern)" : this.themeManager_.subscribe(this.svgBackground_, "workspaceBackgroundColour", "fill")), this.layerManager = new Jm(this), this.svgBlockCanvas_ = this.layerManager.getBlockLayer(), this.svgBubbleCanvas_ = this.layerManager.getBubbleLayer(), this.isFlyout || (w(this.svgGroup_, "pointerdown", this, this.onMouseDown, false), this.dummyWheelListener = () => {
            }, document.body.addEventListener("wheel", this.dummyWheelListener), w(this.svgGroup_, "wheel", this, this.onMouseWheel)), this.options.hasCategories && (this.toolbox = new (Ce(E.TOOLBOX, this.options, true))(this)), this.grid && this.grid.update(this.scale), this.recordDragTargets(), (e = Ce(E.CURSOR, this.options)) && this.markerManager.setCursor(new e(this)), e = this.options.parentWorkspace === null, this.renderer.createDom(this.svgGroup_, this.getTheme(), e ? this.getInjectionDiv() : void 0), r.getFocusManager$$module$build$src$core$focus_manager().registerTree(this, !!this.injectionDiv || this.isFlyout), this.svgGroup_;
          }
          dispose() {
            if (this.rendered = false, this.currentGesture_ && this.currentGesture_.cancel(), this.svgGroup_ && V(this.svgGroup_), this.toolbox && (this.toolbox.dispose(), this.toolbox = null), this.flyout && (this.flyout.dispose(), this.flyout = null), this.trashcan && (this.trashcan.dispose(), this.trashcan = null), this.scrollbar && (this.scrollbar.dispose(), this.scrollbar = null), this.zoomControls_ && this.zoomControls_.dispose(), this.audioManager && this.audioManager.dispose(), this.grid && (this.grid = null), this.renderer.dispose(), this.markerManager.dispose(), super.dispose(), this.themeManager_ && (this.themeManager_.unsubscribeWorkspace(this), this.themeManager_.unsubscribe(this.svgBackground_), this.options.parentWorkspace || this.themeManager_.dispose()), this.connectionDBList.length = 0, this.toolboxCategoryCallbacks.clear(), this.flyoutButtonCallbacks.clear(), !this.options.parentWorkspace) {
              let e = this.getParentSvg();
              e && e.parentNode && V(e.parentNode);
            }
            this.resizeHandlerWrapper && (x(this.resizeHandlerWrapper), this.resizeHandlerWrapper = null), this.dummyWheelListener && (document.body.removeEventListener("wheel", this.dummyWheelListener), this.dummyWheelListener = null), r.getFocusManager$$module$build$src$core$focus_manager().isRegistered(this) && r.getFocusManager$$module$build$src$core$focus_manager().unregisterTree(this);
          }
          addTrashcan() {
            this.trashcan = Ie.newTrashcan(this);
            let e = this.trashcan.createDom();
            this.svgGroup_.insertBefore(e, this.getCanvas());
          }
          static newTrashcan(e) {
            throw Error("The implementation of newTrashcan should be monkey-patched in by blockly.ts");
          }
          addZoomControls() {
            this.zoomControls_ = new Bu(this);
            let e = this.zoomControls_.createDom();
            this.svgGroup_.appendChild(e);
          }
          copyOptionsForFlyout() {
            return new st({ parentWorkspace: this, rtl: this.RTL, oneBasedIndex: this.options.oneBasedIndex, horizontalLayout: this.horizontalLayout, renderer: this.options.renderer, rendererOverrides: this.options.rendererOverrides, plugins: this.options.plugins, modalInputs: this.options.modalInputs, move: { scrollbars: true } });
          }
          addFlyout(e) {
            let t = this.copyOptionsForFlyout();
            return t.toolboxPosition = this.options.toolboxPosition, this.flyout = this.horizontalLayout ? new (Ce(E.FLYOUTS_HORIZONTAL_TOOLBOX, this.options, true))(t) : new (Ce(E.FLYOUTS_VERTICAL_TOOLBOX, this.options, true))(t), this.flyout.autoClose = false, this.flyout.getWorkspace().setVisible(true), this.flyout.createDom(e);
          }
          getFlyout(e) {
            return this.flyout || e ? this.flyout : this.toolbox ? this.toolbox.getFlyout() : null;
          }
          getToolbox() {
            return this.toolbox;
          }
          updateScreenCalculations() {
            this.updateInverseScreenCTM(), this.recordDragTargets();
          }
          resizeContents() {
            this.resizesEnabled && this.rendered && (this.scrollbar && this.scrollbar.resize(), this.updateInverseScreenCTM());
          }
          resize() {
            this.toolbox ? this.toolbox.position() : this.flyout && this.flyout.position();
            let e = this.componentManager.getComponents(j.Capability.POSITIONABLE, true), t = this.getMetricsManager().getUiMetrics(), o = [];
            for (let s = 0, i; i = e[s]; s++) {
              i.position(t, o);
              let n = i.getBoundingRectangle();
              n && o.push(n);
            }
            this.scrollbar && this.scrollbar.resize(), this.updateScreenCalculations();
          }
          updateScreenCalculationsIfScrolled() {
            let e = dc();
            f.equals(this.lastRecordedPageScroll, e) || (this.lastRecordedPageScroll = e, this.updateScreenCalculations());
          }
          getLayerManager() {
            return this.layerManager;
          }
          getCanvas() {
            return this.layerManager.getBlockLayer();
          }
          setCachedParentSvgSize(e, t) {
            let o = this.getParentSvg();
            e != null && (this.cachedParentSvgSize.width = e, o.setAttribute("data-cached-width", `${e}`)), t != null && (this.cachedParentSvgSize.height = t, o.setAttribute("data-cached-height", `${t}`));
          }
          getBubbleCanvas() {
            return this.layerManager.getBubbleLayer();
          }
          getParentSvg() {
            if (!this.cachedParentSvg) {
              let e = this.svgGroup_;
              for (; e; ) {
                if (e.tagName === "svg") {
                  this.cachedParentSvg = e;
                  break;
                }
                e = e.parentNode;
              }
            }
            return this.cachedParentSvg;
          }
          maybeFireViewportChangeEvent() {
            if (J()) {
              var e = this.scale, t = -this.scrollY, o = -this.scrollX;
              if (!(e === this.oldScale && Math.abs(t - this.oldTop) < 1 && Math.abs(o - this.oldLeft) < 1)) {
                var s = new (S(d.VIEWPORT_CHANGE))(t, o, e, this.id, this.oldScale);
                this.oldScale = e, this.oldTop = t, this.oldLeft = o, R(s);
              }
            }
          }
          translate(e, t) {
            let o;
            (o = this.layerManager) == null || o.translateLayers(new f(e, t), this.scale);
            let s;
            (s = this.grid) == null || s.moveTo(e, t), this.maybeFireViewportChangeEvent();
          }
          getWidth() {
            let e = this.getMetrics();
            return e ? e.viewWidth / this.scale : 0;
          }
          setVisible(e) {
            this.visible = e, this.svgGroup_ && (this.scrollbar && this.scrollbar.setContainerVisible(e), this.getFlyout() && this.getFlyout().setContainerVisible(e), this.getParentSvg().style.display = e ? "block" : "none", this.toolbox && this.toolbox.setVisible(e), e || this.hideChaff(true));
          }
          render() {
            let e = this.getAllBlocks(false);
            for (let t = e.length - 1; t >= 0; t--) e[t].queueRender();
            this.getTopBlocks().flatMap((t) => t.getDescendants(false)).filter((t) => t.isInsertionMarker()).forEach((t) => t.queueRender());
          }
          highlightBlock(e, t) {
            if (t === void 0) {
              for (let o = 0, s; s = this.highlightedBlocks[o]; o++) s.setHighlighted(false);
              this.highlightedBlocks.length = 0;
            }
            (e = e ? this.getBlockById(e) : null) && ((t = t === void 0 || t) ? this.highlightedBlocks.includes(e) || this.highlightedBlocks.push(e) : Pe(this.highlightedBlocks, e), e.setHighlighted(t));
          }
          variableChangeCallback(e) {
            switch (e.type) {
              case d.VAR_CREATE:
              case d.VAR_DELETE:
              case d.VAR_RENAME:
              case d.VAR_TYPE_CHANGE:
                this.refreshToolboxSelection();
            }
          }
          refreshToolboxSelection() {
            let e = this.isFlyout ? this.targetWorkspace : this;
            e && !e.currentGesture_ && e.toolbox && e.toolbox.getFlyout() && e.toolbox.refreshSelection();
          }
          recordDragTargets() {
            let e = this.componentManager.getComponents(j.Capability.DRAG_TARGET, true);
            this.dragTargetAreas = [];
            for (let t = 0, o; o = e[t]; t++) {
              let s = o.getClientRect();
              s && this.dragTargetAreas.push({ component: o, clientRect: s });
            }
          }
          newBlock(e, t) {
            throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts");
          }
          newComment(e) {
            throw Error("The implementation of newComment should be monkey-patched in by blockly.ts");
          }
          getDragTarget(e) {
            for (let t = 0, o; o = this.dragTargetAreas[t]; t++) if (o.clientRect.contains(e.clientX, e.clientY)) return o.component;
            return null;
          }
          onMouseDown(e) {
            let t = this.getGesture(e);
            t && t.handleWsStart(e, this);
          }
          startDrag(e, t) {
            mi(this, e, t);
          }
          moveDrag(e) {
            return _i(this, e);
          }
          setKeyboardMoveInProgress(e) {
            this.keyboardMoveInProgress = e;
          }
          isDragging() {
            return this.keyboardMoveInProgress || this.currentGesture_ !== null && this.currentGesture_.isDragging();
          }
          isDraggable() {
            return this.options.moveOptions && this.options.moveOptions.drag;
          }
          isMovable() {
            return this.options.moveOptions && !!this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.wheel || this.options.zoomOptions && this.options.zoomOptions.pinch;
          }
          isMovableHorizontally() {
            let e = !!this.scrollbar;
            return this.isMovable() && (!e || e && this.scrollbar.canScrollHorizontally());
          }
          isMovableVertically() {
            let e = !!this.scrollbar;
            return this.isMovable() && (!e || e && this.scrollbar.canScrollVertically());
          }
          onMouseWheel(e) {
            if (nr.inProgress()) e.preventDefault(), e.stopPropagation();
            else {
              var t = this.options.zoomOptions && this.options.zoomOptions.wheel, o = this.options.moveOptions && this.options.moveOptions.wheel;
              if (t || o) {
                var s = Xs(e);
                if (Cu) var i = e.metaKey;
                t && (e.ctrlKey || i || !o) ? (s = -s.y / 50, t = ts(e, this.getParentSvg(), this.getInverseScreenCTM()), this.zoom(t.x, t.y, s)) : (t = this.scrollX - s.x, o = this.scrollY - s.y, e.shiftKey && !s.x && (t = this.scrollX - s.y, o = this.scrollY), this.scroll(t, o)), e.preventDefault();
              }
            }
          }
          getBlocksBoundingBox() {
            let e = this.getTopBoundedElements();
            if (!e.length) return new L(0, 0, 0, 0);
            let t = e[0].getBoundingRectangle();
            for (let s = 1; s < e.length; s++) {
              var o = e[s];
              o.isInsertionMarker && o.isInsertionMarker() || (o = o.getBoundingRectangle(), o.top < t.top && (t.top = o.top), o.bottom > t.bottom && (t.bottom = o.bottom), o.left < t.left && (t.left = o.left), o.right > t.right && (t.right = o.right));
            }
            return t;
          }
          cleanUp() {
            this.setResizesEnabled(false);
            let e = r.getGroup$$module$build$src$core$events$utils();
            e || r.setGroup$$module$build$src$core$events$utils(true);
            var t = this.getTopBlocks(true), o = t.filter((l) => l.isMovable());
            let s = t.filter((l) => !l.isMovable()).map((l) => l.getBoundingRectangle());
            t = function(l) {
              for (let a of s) if (l.intersects(a)) return a;
              return null;
            };
            var i = 0;
            let n = this.renderer.getConstants().MIN_BLOCK_HEIGHT;
            for (let l of o) {
              for (o = l.getBoundingRectangle(), l.moveBy(-o.left, i - o.top, ["cleanup"]), l.snapToGrid(), o = l.getBoundingRectangle(), i = t(o); i != null; ) i = i.top + i.getHeight() + n, l.moveBy(0, i - o.top, ["cleanup"]), l.snapToGrid(), o = l.getBoundingRectangle(), i = t(o);
              i = l.getRelativeToSurfaceXY().y + l.getHeightWidth().height + n;
            }
            r.setGroup$$module$build$src$core$events$utils(e), this.setResizesEnabled(true);
          }
          showContextMenu(e) {
            if (!this.isReadOnly() && !this.isFlyout) {
              var t = M.registry.getContextMenuOptions({ workspace: this, focusedNode: this }, e);
              this.configureContextMenu && this.configureContextMenu(t, e);
              var o = e instanceof PointerEvent ? new f(e.clientX, e.clientY) : ns(this, new f(5, 5));
              _s(e, t, this.RTL, this, o);
            }
          }
          updateToolbox(e) {
            if (e = Nr(e)) {
              if (!this.options.languageTree) throw Error("Existing toolbox is null.  Can't create new toolbox.");
              if (Ar(e)) {
                if (!this.toolbox) throw Error("Existing toolbox has no categories.  Can't change mode.");
                this.options.languageTree = e, this.toolbox.render(e);
              } else {
                if (!this.flyout) throw Error("Existing toolbox has categories.  Can't change mode.");
                this.options.languageTree = e, this.flyout.show(e);
              }
            } else if (this.options.languageTree) throw Error("Can't nullify an existing toolbox.");
          }
          markFocused() {
            this.options.parentWorkspace ? this.options.parentWorkspace.markFocused() : (Zs(this), this.getParentSvg().focus({ preventScroll: true }));
          }
          zoom(e, t, o) {
            o = Math.pow(this.options.zoomOptions.scaleSpeed, o);
            let s = this.scale * o;
            if (this.scale !== s) {
              s > this.options.zoomOptions.maxScale ? o = this.options.zoomOptions.maxScale / this.scale : s < this.options.zoomOptions.minScale && (o = this.options.zoomOptions.minScale / this.scale);
              var i = this.getCanvas().getCTM(), n = this.getParentSvg().createSVGPoint();
              n.x = e, n.y = t, n = n.matrixTransform(i.inverse()), e = n.x, t = n.y, i = i.translate(e * (1 - o), t * (1 - o)).scale(o), this.scrollX = i.e, this.scrollY = i.f, this.setScale(s);
            }
          }
          zoomCenter(e) {
            var t = this.getMetrics();
            let o;
            this.flyout ? (o = t.svgWidth ? t.svgWidth / 2 : 0, t = t.svgHeight ? t.svgHeight / 2 : 0) : (o = t.viewWidth / 2 + t.absoluteLeft, t = t.viewHeight / 2 + t.absoluteTop), this.zoom(o, t, e);
          }
          zoomToFit() {
            if (this.isMovable()) {
              var e = this.getMetrics(), t = e.viewWidth;
              e = e.viewHeight;
              var o = this.getBlocksBoundingBox(), s = Wb * 2, i = o.right - o.left + s;
              if (o = o.bottom - o.top + s, i) {
                this.flyout && (this.horizontalLayout ? (e += this.flyout.getHeight(), o += this.flyout.getHeight() / this.scale) : (t += this.flyout.getWidth(), i += this.flyout.getWidth() / this.scale)), t /= i, e /= o, r.disable$$module$build$src$core$events$utils();
                try {
                  this.setScale(Math.min(t, e)), this.scrollCenter();
                } finally {
                  r.enable$$module$build$src$core$events$utils();
                }
                this.maybeFireViewportChangeEvent();
              }
            } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
          }
          beginCanvasTransition() {
            I(this.getCanvas(), "blocklyCanvasTransitioning"), I(this.getBubbleCanvas(), "blocklyCanvasTransitioning");
          }
          endCanvasTransition() {
            P(this.getCanvas(), "blocklyCanvasTransitioning"), P(this.getBubbleCanvas(), "blocklyCanvasTransitioning");
          }
          scrollCenter() {
            if (this.isMovable()) {
              var e = this.getMetrics(), t = (e.scrollWidth - e.viewWidth) / 2, o = (e.scrollHeight - e.viewHeight) / 2;
              t = -t - e.scrollLeft, o = -o - e.scrollTop, this.scroll(t, o);
            } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
          }
          centerOnBlock(e, t) {
            if (this.isMovable()) {
              var o = e ? this.getBlockById(e) : null;
              if (o) {
                e = o.getRelativeToSurfaceXY(), o = t ? { height: o.height, width: o.width } : o.getHeightWidth();
                var s = this.scale;
                t = (e.x + (this.RTL ? -1 : 1) * o.width / 2) * s, e = (e.y + o.height / 2) * s, o = this.getMetrics(), this.scroll(-(t - o.viewWidth / 2), -(e - o.viewHeight / 2));
              }
            } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
          }
          setScale(e) {
            this.options.zoomOptions.maxScale && e > this.options.zoomOptions.maxScale ? e = this.options.zoomOptions.maxScale : this.options.zoomOptions.minScale && e < this.options.zoomOptions.minScale && (e = this.options.zoomOptions.minScale), this.scale = e, this.hideChaff(false), (e = this.getFlyout(false)) && e.isVisible() && (e.reflow(), this.recordDragTargets()), this.grid && this.grid.update(this.scale), e = this.getMetrics(), this.scrollX -= e.absoluteLeft, this.scrollY -= e.absoluteTop, e.viewLeft += e.absoluteLeft, e.viewTop += e.absoluteTop, this.scroll(this.scrollX, this.scrollY), this.scrollbar && (this.flyout ? this.scrollbar.resizeView(e) : this.scrollbar.resizeContent(e));
          }
          getScale() {
            return this.scale;
          }
          getAbsoluteScale() {
            let e = (o) => {
              if (o.isFlyout) {
                let s, i = (s = o.targetWorkspace) == null ? void 0 : s.getFlyout();
                if (i instanceof ir) return i.getFlyoutScale();
              }
              return o.getScale();
            }, t = (o, s) => o.options.parentWorkspace && o.options.parentWorkspace.getSvgGroup().contains(o.getSvgGroup()) ? t(o.options.parentWorkspace, s * e(o)) : s * e(o);
            return t(this, 1);
          }
          scroll(e, t) {
            this.hideChaff(true);
            let o = this.getMetrics();
            e = Math.min(e, -o.scrollLeft), t = Math.min(t, -o.scrollTop);
            let s = o.scrollTop + Math.max(0, o.scrollHeight - o.viewHeight);
            e = Math.max(e, -(o.scrollLeft + Math.max(0, o.scrollWidth - o.viewWidth))), t = Math.max(t, -s), this.scrollX = e, this.scrollY = t, this.scrollbar && this.scrollbar.set(-(e + o.scrollLeft), -(t + o.scrollTop), false), e += o.absoluteLeft, t += o.absoluteTop, this.translate(e, t);
          }
          getBlockById(e) {
            return super.getBlockById(e);
          }
          getAllBlocks(e = false) {
            return super.getAllBlocks(e);
          }
          getTopBlocks(e = false) {
            return super.getTopBlocks(e);
          }
          addTopBlock(e) {
            this.addTopBoundedElement(e), super.addTopBlock(e);
          }
          removeTopBlock(e) {
            this.removeTopBoundedElement(e), super.removeTopBlock(e);
          }
          addTopComment(e) {
            this.addTopBoundedElement(e), super.addTopComment(e);
          }
          removeTopComment(e) {
            this.removeTopBoundedElement(e), super.removeTopComment(e);
          }
          getTopComments(e = false) {
            return super.getTopComments(e);
          }
          getCommentById(e) {
            return super.getCommentById(e);
          }
          getRootWorkspace() {
            return super.getRootWorkspace();
          }
          addTopBoundedElement(e) {
            this.topBoundedElements.push(e);
          }
          removeTopBoundedElement(e) {
            Pe(this.topBoundedElements, e);
          }
          getTopBoundedElements(e = false) {
            let t = [].concat(this.topBoundedElements);
            return e && t.sort(this.sortByOrigin.bind(this)), t;
          }
          setResizesEnabled(e) {
            let t = !this.resizesEnabled && e;
            this.resizesEnabled = e, t && this.resizeContents();
          }
          clear() {
            this.setResizesEnabled(false), super.clear(), this.topBoundedElements = [], this.setResizesEnabled(true);
          }
          registerButtonCallback(e, t) {
            if (typeof t != "function") throw TypeError("Button callbacks must be functions.");
            this.flyoutButtonCallbacks.set(e, t);
          }
          getButtonCallback(e) {
            let t;
            return (t = this.flyoutButtonCallbacks.get(e)) != null ? t : null;
          }
          removeButtonCallback(e) {
            this.flyoutButtonCallbacks.delete(e);
          }
          registerToolboxCategoryCallback(e, t) {
            if (typeof t != "function") throw TypeError("Toolbox category callbacks must be functions.");
            this.toolboxCategoryCallbacks.set(e, t);
          }
          getToolboxCategoryCallback(e) {
            return this.toolboxCategoryCallbacks.get(e) || null;
          }
          removeToolboxCategoryCallback(e) {
            this.toolboxCategoryCallbacks.delete(e);
          }
          getGesture(e) {
            if (this.keyboardMoveInProgress) return e.preventDefault(), e.stopPropagation(), null;
            let t = e.type === "pointerdown", o;
            return t && ((o = this.currentGesture_) != null && o.hasStarted()) && (console.warn("Tried to start the same gesture twice."), this.currentGesture_.cancel()), !this.currentGesture_ && t && (this.currentGesture_ = new nr(e, this)), this.currentGesture_;
          }
          clearGesture() {
            this.currentGesture_ = null;
          }
          cancelCurrentGesture() {
            this.currentGesture_ && this.currentGesture_.cancel();
          }
          getAudioManager() {
            return this.audioManager;
          }
          getGrid() {
            return this.grid;
          }
          hideChaff(e = false) {
            Lt(), pi(this), Tt(), this.hideComponents(e);
          }
          hideComponents(e = false) {
            this.getComponentManager().getComponents(j.Capability.AUTOHIDEABLE, true).forEach((t) => t.autoHide(e));
          }
          static setTopLevelWorkspaceMetrics(e) {
            let t = this.getMetrics();
            typeof e.x == "number" && (this.scrollX = -(t.scrollLeft + (t.scrollWidth - t.viewWidth) * e.x)), typeof e.y == "number" && (this.scrollY = -(t.scrollTop + (t.scrollHeight - t.viewHeight) * e.y)), this.translate(this.scrollX + t.absoluteLeft, this.scrollY + t.absoluteTop);
          }
          addClass(e) {
            this.injectionDiv && I(this.injectionDiv, e);
          }
          removeClass(e) {
            this.injectionDiv && P(this.injectionDiv, e);
          }
          setIsReadOnly(e) {
            super.setIsReadOnly(e), e ? this.addClass("blocklyReadOnly") : this.removeClass("blocklyReadOnly");
          }
          scrollBoundsIntoView(e, t = 10) {
            if (!nr.inProgress()) {
              var o = this.getScale(), s = this.getMetricsManager().getViewMetrics(true);
              if (s = new L(s.top, s.top + s.height, s.left, s.left + s.width), !(e.left >= s.left && e.top >= s.top && e.right <= s.right && e.bottom <= s.bottom)) {
                e = e.clone(), e.top -= t, e.bottom += t, e.left -= t, e.right += t;
                var i = t = 0;
                e.left < s.left ? t = this.RTL ? Math.min(s.left - e.left, s.right - e.right) : s.left - e.left : e.right > s.right && (t = this.RTL ? s.right - e.right : Math.max(s.right - e.right, s.left - e.left)), e.top < s.top ? i = s.top - e.top : e.bottom > s.bottom && (i = Math.max(s.bottom - e.bottom, s.top - e.top)), this.scroll(this.scrollX + t * o, this.scrollY + i * o);
              }
            }
          }
          getFocusableElement() {
            return this.svgGroup_;
          }
          getFocusableTree() {
            return this.isMutator && this.options.parentWorkspace || this;
          }
          onNodeFocus() {
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
          getRootFocusableNode() {
            return this;
          }
          getRestoredFocusableNode(e) {
            if (e) return null;
            let t;
            if (e = (t = this.targetWorkspace) == null ? void 0 : t.getFlyout(), this.isFlyout && e) {
              let s, i;
              return (i = (s = e.getContents().find((n) => (n = n.getElement(), Wt(n) && n.canBeFocused()))) == null ? void 0 : s.getElement()) != null ? i : null;
            }
            let o;
            return (o = this.getTopBlocks(true)[0]) != null ? o : null;
          }
          getNestedTrees() {
            let e = this.getAllBlocks().map((o) => o.getIcons()).flat().filter((o) => o instanceof r.MutatorIcon$$module$build$src$core$icons$mutator_icon && o.bubbleIsVisible()).map((o) => {
              let s;
              return (s = o.getBubble()) == null ? void 0 : s.getWorkspace();
            }).filter((o) => !!o), t = this.getFlyout(true);
            return t && e.push(t.getWorkspace()), e;
          }
          searchForWorkspaceComment(e) {
            for (let t of this.getTopComments()) if (t instanceof It && t.canBeFocused() && t.getFocusableElement().id === e) return t;
          }
          lookUpFocusableNode(e) {
            var t;
            let o = (t = this.targetWorkspace) == null ? void 0 : t.getFlyout();
            if (this.isFlyout && o) {
              for (var s of o.getContents()) if (t = s.getElement(), Wt(t) && t.canBeFocused() && t.getFocusableElement().id === e) return t;
            }
            if (s = e.indexOf("_field_"), t = e.indexOf("_connection_"), s !== -1) {
              var i = e.substring(0, s);
              if (i = this.getBlockById(i)) {
                for (var n of i.getFields()) if (n.canBeFocused() && n.getFocusableElement().id === e) return n;
              }
              return null;
            }
            if (t !== -1) {
              if (i = e.substring(0, t), i = this.getBlockById(i)) {
                for (let a of i.getConnections_(true)) if (a.id === e) return a;
              }
              return null;
            }
            if (n = Math.max(e.indexOf(jn), e.indexOf(rh), e.indexOf(lh)), n !== -1 && (n = e.substring(0, n), n = this.searchForWorkspaceComment(n))) {
              if (e.indexOf(jn) > -1) return n.getEditorFocusableNode();
              var l;
              return (l = n.view.getCommentBarButtons().find((a) => a.getFocusableElement().id.includes(e))) != null ? l : null;
            }
            if ((l = this.getAllBlocks(false).find((a) => a.getFocusableElement().id === e)) || (l = this.searchForWorkspaceComment(e))) return l;
            l = this.getAllBlocks().map((a) => a.getIcons()).flat();
            for (i of l) {
              if (i.canBeFocused() && i.getFocusableElement().id === e) return i;
              if (qt(i)) {
                if ((l = i.getBubble()) && l.canBeFocused() && l.getFocusableElement().id === e) return l;
                if (l instanceof qi && l.getEditor().getFocusableElement().id === e) return l.getEditor();
              }
            }
            return null;
          }
          onTreeFocus(e, t) {
          }
          onTreeBlur(e) {
            if (this.isFlyout && this.targetWorkspace && !r.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken()) {
              var t = this.targetWorkspace.getToolbox();
              t && e === t || Ra(t) && t.autoHide(false);
            }
          }
          getNavigator() {
            return this.navigator;
          }
          setNavigator(e) {
            this.navigator = e;
          }
        }, qm = {};
        qm.WorkspaceSvg = Ie, qm.resizeSvgContents = og;
        var qo = class extends Bo {
          constructor(e) {
            super(), this.isBlank = typeof e > "u", e && (this.varId = e.getId(), this.workspaceId = e.getWorkspace().id);
          }
          toJson() {
            let e = super.toJson();
            if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
            return e.varId = this.varId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new qo()), t.varId = e.varId, t;
          }
        }, zb = {};
        zb.VarBase = qo;
        var Il = class extends qo {
          constructor(e) {
            super(e), this.type = d.VAR_CREATE, e && (this.varType = e.getType(), this.varName = e.getName());
          }
          toJson() {
            let e = super.toJson();
            if (this.varType === void 0) throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
            return e.varType = this.varType, e.varName = this.varName, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Il()), t.varType = e.varType, t.varName = e.varName, t;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
            t = t.getVariableMap(), e ? t.createVariable(this.varName, this.varType, this.varId) : (e = t.getVariableById(this.varId)) && t.deleteVariable(e);
          }
        };
        c(E.EVENT, d.VAR_CREATE, Il);
        var Xb = {};
        Xb.VarCreate = Il;
        var Hh = class {
          constructor(e, t, o, s) {
            this.workspace = e, this.name = t, this.type = o || "", this.id = s || wt();
          }
          getId() {
            return this.id;
          }
          getName() {
            return this.name;
          }
          setName(e) {
            return this.name = e, this;
          }
          getType() {
            return this.type;
          }
          setType(e) {
            return this.type = e, this;
          }
          getWorkspace() {
            return this.workspace;
          }
          save() {
            let e = { name: this.getName(), id: this.getId() }, t = this.getType();
            return t && (e.type = t), e;
          }
          static load(e, t) {
            e = new this(t, e.name, e.type, e.id), t.getVariableMap().addVariable(e), R(new (S(d.VAR_CREATE))(e));
          }
        };
        c(E.VARIABLE_MODEL, Fe, Hh);
        var Yb = {};
        Yb.VariableModel = Hh;
        var yl = class extends qo {
          constructor(e) {
            super(e), this.type = d.VAR_DELETE, e && (this.varType = e.getType(), this.varName = e.getName());
          }
          toJson() {
            let e = super.toJson();
            if (this.varType === void 0) throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
            return e.varType = this.varType, e.varName = this.varName, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new yl()), t.varType = e.varType, t.varName = e.varName, t;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
            t = t.getVariableMap(), e ? (e = t.getVariableById(this.varId)) && t.deleteVariable(e) : t.createVariable(this.varName, this.varType, this.varId);
          }
        };
        c(E.EVENT, d.VAR_DELETE, yl);
        var Kb = {};
        Kb.VarDelete = yl;
        var Cl = class extends qo {
          constructor(e, t) {
            super(e), this.type = d.VAR_RENAME, e && (this.oldName = e.getName(), this.newName = typeof t > "u" ? "" : t);
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldName) throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.newName) throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
            return e.oldName = this.oldName, e.newName = this.newName, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Cl()), t.oldName = e.oldName, t.newName = e.newName, t;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.oldName) throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.newName) throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
            t = t.getVariableMap();
            let o = t.getVariableById(this.varId);
            e ? o && t.renameVariable(o, this.newName) : o && t.renameVariable(o, this.oldName);
          }
        };
        c(E.EVENT, d.VAR_RENAME, Cl);
        var jb = {};
        jb.VarRename = Cl;
        var Uh = class {
          constructor(e, t = false) {
            this.workspace = e, this.potentialMap = t, this.variableMap = /* @__PURE__ */ new Map();
          }
          clear() {
            for (let e of this.variableMap.values()) for (let t of e.values()) this.deleteVariable(t);
            if (this.variableMap.size !== 0) throw Error("Non-empty variable map");
          }
          renameVariable(e, t) {
            if (e.getName() === t) return e;
            var o = e.getType();
            o = this.getVariable(t, o);
            let s = this.workspace.getAllBlocks(false), i = "";
            this.potentialMap || (i = r.getGroup$$module$build$src$core$events$utils()) || r.setGroup$$module$build$src$core$events$utils(true);
            try {
              o && o.getId() !== e.getId() ? this.renameVariableWithConflict(e, t, o, s) : this.renameVariableAndUses(e, t, s);
            } finally {
              this.potentialMap || r.setGroup$$module$build$src$core$events$utils(i);
            }
            return e;
          }
          changeVariableType(e, t) {
            let o = e.getType();
            if (o === t) return e;
            var s = this.variableMap.get(o);
            s?.delete(e.getId()), s?.size === 0 && this.variableMap.delete(o), e.setType(t);
            let i;
            return s = (i = this.variableMap.get(t)) != null ? i : /* @__PURE__ */ new Map(), s.set(e.getId(), e), this.variableMap.has(t) || this.variableMap.set(t, s), R(new (S(d.VAR_TYPE_CHANGE))(e, o, t)), e;
          }
          renameVariableById(e, t) {
            me("VariableMap.renameVariableById", "v12", "v13", "VariableMap.renameVariable");
            let o = this.getVariableById(e);
            if (!o) throw Error("Tried to rename a variable that didn't exist. ID: " + e);
            this.renameVariable(o, t);
          }
          renameVariableAndUses(e, t, o) {
            for (this.potentialMap || R(new (S(d.VAR_RENAME))(e, t)), e.setName(t), t = 0; t < o.length; t++) o[t].updateVarName(e);
          }
          renameVariableWithConflict(e, t, o, s) {
            let i = e.getType(), n = o.getName();
            for (t !== n && this.renameVariableAndUses(o, t, s), t = 0; t < s.length; t++) s[t].renameVarById(e.getId(), o.getId());
            this.potentialMap || R(new (S(d.VAR_DELETE))(e));
            let l;
            (l = this.variableMap.get(i)) == null || l.delete(e.getId());
          }
          createVariable(e, t, o) {
            var s = this.getVariable(e, t);
            if (s) {
              if (o && s.getId() !== o) throw Error('Variable "' + e + '" is already in use and its id is "' + s.getId() + '" which conflicts with the passed in id, "' + o + '".');
              return s;
            }
            if (o && this.getVariableById(o)) throw Error('Variable id, "' + o + '", is already in use.');
            if (s = o || wt(), t = t || "", o = Ce(E.VARIABLE_MODEL, this.workspace.options, true), !o) throw Error("No variable model is registered.");
            s = new o(this.workspace, e, t, s);
            let i;
            return e = (i = this.variableMap.get(t)) != null ? i : /* @__PURE__ */ new Map(), e.set(s.getId(), s), this.variableMap.has(t) || this.variableMap.set(t, e), this.potentialMap || R(new (S(d.VAR_CREATE))(s)), s;
          }
          addVariable(e) {
            let t = e.getType();
            this.variableMap.has(t) || this.variableMap.set(t, /* @__PURE__ */ new Map());
            let o;
            (o = this.variableMap.get(t)) == null || o.set(e.getId(), e);
          }
          deleteVariable(e) {
            let t = us(this.workspace, e.getId()), o = "";
            this.potentialMap || (o = r.getGroup$$module$build$src$core$events$utils()) || r.setGroup$$module$build$src$core$events$utils(true);
            try {
              for (let i = 0; i < t.length; i++) t[i].dispose(true);
              let s = this.variableMap.get(e.getType());
              s && s.has(e.getId()) && (s.delete(e.getId()), this.potentialMap || R(new (S(d.VAR_DELETE))(e)), s.size === 0 && this.variableMap.delete(e.getType()));
            } finally {
              this.potentialMap || r.setGroup$$module$build$src$core$events$utils(o);
            }
          }
          deleteVariableById(e) {
            me("VariableMap.deleteVariableById", "v12", "v13", "Blockly.Variables.deleteVariable"), (e = this.getVariableById(e)) && r.deleteVariable$$module$build$src$core$variables(this.workspace, e);
          }
          getVariable(e, t) {
            if (t = this.variableMap.get(t || ""), !t) return null;
            let o;
            return (o = [...t.values()].find((s) => r.Names$$module$build$src$core$names.equals(s.getName(), e))) != null ? o : null;
          }
          getVariableById(e) {
            for (let t of this.variableMap.values()) if (t.has(e)) {
              let o;
              return (o = t.get(e)) != null ? o : null;
            }
            return null;
          }
          getVariablesOfType(e) {
            return (e = this.variableMap.get(e || "")) ? [...e.values()] : [];
          }
          getTypes() {
            return [...this.variableMap.keys()];
          }
          getAllVariables() {
            let e = [];
            for (let t of this.variableMap.values()) e = e.concat(...t.values());
            return e;
          }
          getAllVariableNames() {
            me("VariableMap.getAllVariableNames", "v12", "v13", "Blockly.Variables.getAllVariables");
            let e = [];
            for (let t of this.variableMap.values()) for (let o of t.values()) e.push(o.getName());
            return e;
          }
          getVariableUsesById(e) {
            return me("VariableMap.getVariableUsesById", "v12", "v13", "Blockly.Variables.getVariableUsesById"), us(this.workspace, e);
          }
        };
        c(E.VARIABLE_MAP, Fe, Uh);
        var Jb = {};
        Jb.VariableMap = Uh;
        var vl = class extends tt {
          constructor(e, t) {
            super(t), this.type = d.TRASHCAN_OPEN, this.isOpen = e;
          }
          toJson() {
            let e = super.toJson();
            if (this.isOpen === void 0) throw Error("Whether this is already open or not is undefined. Either pass a value to the constructor, or call fromJson");
            return e.isOpen = this.isOpen, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new vl()), t.isOpen = e.isOpen, t;
          }
        };
        c(E.EVENT, d.TRASHCAN_OPEN, vl);
        var qb = {};
        qb.TrashcanOpen = vl;
        var Gh = class extends or {
          constructor(e) {
            super(), this.workspace = e, this.id = "trashcan", this.contents = [], this.flyout = null, this.isLidOpen = false, this.minOpenness = 0, this.lidTask = this.svgLid = this.svgGroup = null, this.top = this.left = this.lidOpen = 0, this.initialized = false, this.workspace.options.maxTrashcanContents <= 0 || (e = this.workspace.copyOptionsForFlyout(), this.workspace.horizontalLayout ? (e.toolboxPosition = this.workspace.toolboxPosition === A.TOP ? A.BOTTOM : A.TOP, this.flyout = new (Ce(E.FLYOUTS_HORIZONTAL_TOOLBOX, this.workspace.options, true))(e)) : (e.toolboxPosition = this.workspace.toolboxPosition === A.RIGHT ? A.LEFT : A.RIGHT, this.flyout = new (Ce(E.FLYOUTS_VERTICAL_TOOLBOX, this.workspace.options, true))(e)), this.workspace.addChangeListener(this.onDelete.bind(this)));
          }
          createDom() {
            this.svgGroup = b($.G, { class: "blocklyTrash" });
            let e, t = String(Math.random()).substring(2);
            e = b($.CLIPPATH, { id: "blocklyTrashBodyClipPath" + t }, this.svgGroup), b($.RECT, { width: Hs, height: kl, y: Us }, e);
            let o = b($.IMAGE, { width: ve.width, x: -Vh, height: ve.height, y: -Wh, "clip-path": "url(#blocklyTrashBodyClipPath" + t + ")" }, this.svgGroup);
            return o.setAttributeNS(He, "xlink:href", this.workspace.options.pathToMedia + ve.url), e = b($.CLIPPATH, { id: "blocklyTrashLidClipPath" + t }, this.svgGroup), b($.RECT, { width: Hs, height: Us }, e), this.svgLid = b($.IMAGE, { width: ve.width, x: -Vh, height: ve.height, y: -Wh, "clip-path": "url(#blocklyTrashLidClipPath" + t + ")" }, this.svgGroup), this.svgLid.setAttributeNS(He, "xlink:href", this.workspace.options.pathToMedia + ve.url), ze(this.svgGroup, "pointerdown", this, this.blockMouseDownWhenOpenable), ze(this.svgGroup, "pointerup", this, this.click), ze(o, "pointerover", this, this.mouseOver), ze(o, "pointerout", this, this.mouseOut), this.animateLid(), this.svgGroup;
          }
          init() {
            if (this.workspace.options.maxTrashcanContents > 0) {
              let e = this.flyout.createDom($.SVG);
              I(e, "blocklyTrashcanFlyout"), bo(e, this.workspace.getParentSvg()), this.flyout.init(this.workspace);
            }
            this.workspace.getComponentManager().addComponent({ component: this, weight: j.ComponentWeight.TRASHCAN_WEIGHT, capabilities: [j.Capability.AUTOHIDEABLE, j.Capability.DELETE_AREA, j.Capability.DRAG_TARGET, j.Capability.POSITIONABLE] }), this.initialized = true, this.setLidOpen(false);
          }
          dispose() {
            this.workspace.getComponentManager().removeComponent("trashcan"), this.svgGroup && V(this.svgGroup), this.lidTask && clearTimeout(this.lidTask);
          }
          hasContents() {
            return !!this.contents.length;
          }
          contentsIsOpen() {
            return !!this.flyout && this.flyout.isVisible();
          }
          openFlyout() {
            if (!this.contentsIsOpen()) {
              var e = this.contents.map(function(o) {
                return JSON.parse(o);
              }), t = this.workspace.getParentSvg().style;
              t.cursor = "wait", setTimeout(() => {
                let o;
                (o = this.flyout) == null || o.show(e), t.cursor = "";
                let s;
                (s = this.workspace.scrollbar) == null || s.setVisible(false);
              }, 10), this.fireUiEvent(true);
            }
          }
          closeFlyout() {
            if (this.contentsIsOpen()) {
              var e;
              (e = this.flyout) == null || e.hide();
              var t;
              (t = this.workspace.scrollbar) == null || t.setVisible(true), this.fireUiEvent(false), this.workspace.recordDragTargets();
            }
          }
          autoHide(e) {
            !e && this.flyout && this.closeFlyout();
          }
          emptyContents() {
            this.hasContents() && (this.contents.length = 0, this.setMinOpenness(0), this.closeFlyout());
          }
          position(e, t) {
            if (this.initialized) {
              var o = Br(this.workspace, e);
              e = Pr(o, new N(Hs, kl + Us), Zb, Zm, e, this.workspace), t = xr(e, Zm, o.vertical === xt.TOP ? so.DOWN : so.UP, t), this.top = t.top, this.left = t.left;
              var s;
              (s = this.svgGroup) == null || s.setAttribute("transform", "translate(" + this.left + "," + this.top + ")");
              var i;
              (i = this.flyout) == null || i.position();
            }
          }
          getBoundingRectangle() {
            return new L(this.top, this.top + kl + Us, this.left, this.left + Hs);
          }
          getClientRect() {
            if (!this.svgGroup) return null;
            var e = this.svgGroup.getBoundingClientRect();
            let t = e.top + Wh - Rl;
            return e = e.left + Vh - Rl, new L(t, t + Us + kl + 2 * Rl, e, e + Hs + 2 * Rl);
          }
          onDragOver(e) {
            this.setLidOpen(this.wouldDelete_);
          }
          onDragExit(e) {
            this.setLidOpen(false);
          }
          onDrop(e) {
            setTimeout(this.setLidOpen.bind(this, false), 100);
          }
          setLidOpen(e) {
            this.isLidOpen !== e && (this.lidTask && clearTimeout(this.lidTask), this.isLidOpen = e, this.animateLid());
          }
          animateLid() {
            let e = tf;
            var t = 1 / (e + 1);
            this.lidOpen += this.isLidOpen ? t : -t, this.lidOpen = Math.min(Math.max(this.lidOpen, this.minOpenness), 1), this.setLidAngle(this.lidOpen * e_), t = Qm + this.lidOpen * (of - Qm), this.svgGroup && (this.svgGroup.style.opacity = `${t}`), this.lidOpen > this.minOpenness && this.lidOpen < 1 && (this.lidTask = setTimeout(this.animateLid.bind(this), ef / e));
          }
          setLidAngle(e) {
            let t = this.workspace.toolboxPosition === A.RIGHT || this.workspace.horizontalLayout && this.workspace.RTL, o;
            (o = this.svgLid) == null || o.setAttribute("transform", "rotate(" + (t ? -e : e) + "," + (t ? 4 : Hs - 4) + "," + (Us - 2) + ")");
          }
          setMinOpenness(e) {
            this.minOpenness = e, this.isLidOpen || this.setLidAngle(e * e_);
          }
          closeLid() {
            this.setLidOpen(false);
          }
          click() {
            this.hasContents() && !this.workspace.isDragging() && this.openFlyout();
          }
          fireUiEvent(e) {
            e = new (S(d.TRASHCAN_OPEN))(e, this.workspace.id), R(e);
          }
          blockMouseDownWhenOpenable(e) {
            !this.contentsIsOpen() && this.hasContents() && e.stopPropagation();
          }
          mouseOver() {
            this.hasContents() && this.setLidOpen(true);
          }
          mouseOut() {
            this.setLidOpen(false);
          }
          onDelete(e) {
            if (!(this.workspace.options.maxTrashcanContents <= 0 || !br(e) || e.wasShadow)) {
              if (!e.oldJson) throw Error("Encountered a delete event without proper oldJson");
              if (e = JSON.stringify(this.cleanBlockJson(e.oldJson)), !this.contents.includes(e)) {
                for (this.contents.unshift(e); this.contents.length > this.workspace.options.maxTrashcanContents; ) this.contents.pop();
                this.setMinOpenness(Qb);
              }
            }
          }
          cleanBlockJson(e) {
            function t(o) {
              if (o) {
                if (delete o.id, delete o.x, delete o.y, delete o.enabled, delete o.disabledReasons, o.icons && o.icons.comment) {
                  var s = o.icons.comment;
                  delete s.height, delete s.width, delete s.pinned;
                }
                s = o.inputs;
                for (var i in s) {
                  var n = s[i];
                  let l = n.block;
                  n = n.shadow, l && t(l), n && t(n);
                }
                o.next && (i = o.next, o = i.block, i = i.shadow, o && t(o), i && t(i));
              }
            }
            return e = JSON.parse(JSON.stringify(e)), t(e), Object.assign({}, { kind: "BLOCK" }, e);
          }
        }, Hs = 47, kl = 44, Us = 16, Zm = 20, Zb = 20, Rl = 10, Vh = 0, Wh = 32, Qb = 0.1, ef = 80, tf = 4, Qm = 0.4, of = 0.8, e_ = 45, sf = {};
        sf.Trashcan = Gh;
        var pr = null, gr = null, Sl = void 0, ct = {};
        ct.BlockPaster = Ds, ct.copy = mn, ct.getLastCopiedData = _n, ct.getLastCopiedLocation = Fa, ct.getLastCopiedWorkspace = Tn, ct.paste = Qt, ct.registry = Fu, ct.setLastCopiedData = sg, ct.setLastCopiedLocation = rg, ct.setLastCopiedWorkspace = ig;
        var go = {};
        go.CollapseCommentBarButton = nh, go.CommentBarButton = Yi, go.CommentEditor = Ki, go.CommentView = Ns, go.DeleteCommentBarButton = ch, go.RenderedWorkspaceComment = It, go.WorkspaceComment = ji;
        var rf = {};
        rf.isCopyable = fs;
        var vt;
        (function(e) {
          e.ESCAPE = "escape", e.DELETE = "delete", e.COPY = "copy", e.CUT = "cut", e.PASTE = "paste", e.UNDO = "undo", e.REDO = "redo";
        })(vt || (vt = {})), ja();
        var kt = {};
        kt.names = vt, kt.registerCopy = Wa, kt.registerCut = za, kt.registerDefaultShortcuts = ja, kt.registerDelete = Ga, kt.registerEscape = Ua, kt.registerPaste = Xa, kt.registerRedo = Ka, kt.registerUndo = Ya;
        var nf = class {
          constructor(e, t) {
            this.procedureModelClass = e, this.parameterModelClass = t, this.priority = jg;
          }
          save(e) {
            return e = e.getProcedureMap().getProcedures().map((t) => Ja(t)), e.length ? e : null;
          }
          load(e, t) {
            let o = t.getProcedureMap();
            for (let s of e) o.add(qa(this.procedureModelClass, this.parameterModelClass, s, t));
          }
          clear(e) {
            e.getProcedureMap().clear();
          }
        }, Ol = {};
        Ol.ProcedureSerializer = nf, Ol.loadProcedure = qa, Ol.saveProcedure = Ja;
        var t_ = class {
          constructor() {
            this.priority = Kg;
          }
          save(e) {
            return e = e.getAllVariables().map((t) => t.save()), e.length ? e : null;
          }
          load(e, t) {
            let o = ht(E.VARIABLE_MODEL, Fe);
            e.forEach((s) => {
              o?.load(s, t);
            });
          }
          clear(e) {
            e.getVariableMap().clear();
          }
        };
        ni("variables", new t_());
        var o_ = {};
        o_.VariableSerializer = t_;
        var zh = {};
        zh.load = lg, zh.save = ng;
        var lf = { blocks: Ui, exceptions: Ho, priorities: ET, procedures: Ol, registry: xu, variables: o_, workspaceComments: Ln, workspaces: zh };
        "Blockly" in globalThis || (globalThis.Blockly = { Msg: em });
        var EL = {}, Xh = "label", Yh = class {
          load(e, t) {
            return e = new Re(t.getWorkspace(), t.targetWorkspace, e, true), e.show(), new Ko(e, Xh);
          }
          gapForItem(e, t) {
            return t;
          }
          disposeItem(e) {
            e = e.getElement(), e instanceof Re && e.dispose();
          }
          getType() {
            return Xh;
          }
        };
        c(E.FLYOUT_INFLATER, Xh, Yh);
        var cf = {};
        cf.LabelFlyoutInflater = Yh;
        var Kh = class extends ur {
          constructor(e) {
            super(), this.GRID_UNIT = 4, this.CURSOR_COLOUR = "#ffa200", this.CURSOR_RADIUS = 5, this.JAGGED_TEETH_WIDTH = this.JAGGED_TEETH_HEIGHT = 0, this.START_HAT_HEIGHT = 22, this.START_HAT_WIDTH = 96, this.SHAPES = { HEXAGONAL: 1, ROUND: 2, SQUARE: 3, PUZZLE: 4, NOTCH: 5 }, this.SHAPE_IN_SHAPE_PADDING = { 1: { 0: 5 * this.GRID_UNIT, 1: 2 * this.GRID_UNIT, 2: 5 * this.GRID_UNIT, 3: 5 * this.GRID_UNIT }, 2: { 0: 3 * this.GRID_UNIT, 1: 3 * this.GRID_UNIT, 2: 1 * this.GRID_UNIT, 3: 2 * this.GRID_UNIT }, 3: { 0: 2 * this.GRID_UNIT, 1: 2 * this.GRID_UNIT, 2: 2 * this.GRID_UNIT, 3: 2 * this.GRID_UNIT } }, this.FULL_BLOCK_FIELDS = true, this.FIELD_TEXT_FONTWEIGHT = "bold", this.FIELD_TEXT_FONTFAMILY = '"Helvetica Neue", "Segoe UI", Helvetica, sans-serif', this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = true, this.SELECTED_GLOW_COLOUR = "#fff200", this.SELECTED_GLOW_SIZE = 0.5, this.REPLACEMENT_GLOW_COLOUR = "#fff200", this.REPLACEMENT_GLOW_SIZE = 2, this.selectedGlowFilterId = "", this.selectedGlowFilter = null, this.replacementGlowFilterId = "", this.SQUARED = this.ROUNDED = this.HEXAGONAL = this.replacementGlowFilter = null, e && (this.GRID_UNIT = e), this.SMALL_PADDING = this.GRID_UNIT, this.MEDIUM_PADDING = 2 * this.GRID_UNIT, this.MEDIUM_LARGE_PADDING = 3 * this.GRID_UNIT, this.LARGE_PADDING = 4 * this.GRID_UNIT, this.CORNER_RADIUS = 1 * this.GRID_UNIT, this.NOTCH_WIDTH = 9 * this.GRID_UNIT, this.NOTCH_HEIGHT = 2 * this.GRID_UNIT, this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT = 3 * this.GRID_UNIT, this.MIN_BLOCK_WIDTH = 2 * this.GRID_UNIT, this.MIN_BLOCK_HEIGHT = 12 * this.GRID_UNIT, this.EMPTY_STATEMENT_INPUT_HEIGHT = 6 * this.GRID_UNIT, this.TOP_ROW_MIN_HEIGHT = this.CORNER_RADIUS, this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING, this.BOTTOM_ROW_MIN_HEIGHT = this.CORNER_RADIUS, this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = 6 * this.GRID_UNIT, this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT, this.STATEMENT_INPUT_SPACER_MIN_WIDTH = 40 * this.GRID_UNIT, this.STATEMENT_INPUT_PADDING_LEFT = 4 * this.GRID_UNIT, this.EMPTY_INLINE_INPUT_PADDING = 4 * this.GRID_UNIT, this.EMPTY_INLINE_INPUT_HEIGHT = 8 * this.GRID_UNIT, this.DUMMY_INPUT_MIN_HEIGHT = 8 * this.GRID_UNIT, this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 6 * this.GRID_UNIT, this.CURSOR_WS_WIDTH = 20 * this.GRID_UNIT, this.FIELD_TEXT_FONTSIZE = 3 * this.GRID_UNIT, this.FIELD_BORDER_RECT_RADIUS = this.CORNER_RADIUS, this.FIELD_BORDER_RECT_X_PADDING = 2 * this.GRID_UNIT, this.FIELD_BORDER_RECT_Y_PADDING = 1.625 * this.GRID_UNIT, this.FIELD_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT, this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT, this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING, this.FIELD_COLOUR_DEFAULT_WIDTH = 6 * this.GRID_UNIT, this.FIELD_COLOUR_DEFAULT_HEIGHT = 8 * this.GRID_UNIT, this.FIELD_CHECKBOX_X_OFFSET = 1 * this.GRID_UNIT, this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH = 12 * this.GRID_UNIT;
          }
          setFontConstants_(e) {
            super.setFontConstants_(e), this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT = this.FIELD_TEXT_HEIGHT + this.FIELD_BORDER_RECT_Y_PADDING * 2;
          }
          init() {
            super.init(), this.HEXAGONAL = this.makeHexagonal(), this.ROUNDED = this.makeRounded(), this.SQUARED = this.makeSquared(), this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT + this.INSIDE_CORNERS.rightWidth;
          }
          setDynamicProperties_(e) {
            super.setDynamicProperties_(e), this.SELECTED_GLOW_COLOUR = e.getComponentStyle("selectedGlowColour") || this.SELECTED_GLOW_COLOUR;
            let t = Number(e.getComponentStyle("selectedGlowSize"));
            this.SELECTED_GLOW_SIZE = t && !isNaN(t) ? t : this.SELECTED_GLOW_SIZE, this.REPLACEMENT_GLOW_COLOUR = e.getComponentStyle("replacementGlowColour") || this.REPLACEMENT_GLOW_COLOUR, this.REPLACEMENT_GLOW_SIZE = (e = Number(e.getComponentStyle("replacementGlowSize"))) && !isNaN(e) ? e : this.REPLACEMENT_GLOW_SIZE;
          }
          dispose() {
            super.dispose(), this.selectedGlowFilter && V(this.selectedGlowFilter), this.replacementGlowFilter && V(this.replacementGlowFilter);
          }
          makeStartHat() {
            let e = this.START_HAT_HEIGHT, t = this.START_HAT_WIDTH, o = Le("c", [k(25, -e), k(71, -e), k(t, 0)]);
            return { height: e * 0.75, width: t, path: o };
          }
          makeHexagonal() {
            function e(o, s, i) {
              var n = o / 2;
              return n = n > t ? t : n, i = i ? -1 : 1, o = (s ? -1 : 1) * o / 2, ft(-i * n, o) + ft(i * n, o);
            }
            let t = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;
            return { type: this.SHAPES.HEXAGONAL, isDynamic: true, width(o) {
              return o /= 2, o > t ? t : o;
            }, height(o) {
              return o;
            }, connectionOffsetY(o) {
              return o / 2;
            }, connectionOffsetX(o) {
              return -o;
            }, pathDown(o) {
              return e(o, false, false);
            }, pathUp(o) {
              return e(o, true, false);
            }, pathRightDown(o) {
              return e(o, false, true);
            }, pathRightUp(o) {
              return e(o, false, true);
            } };
          }
          makeRounded() {
            function e(s, i, n) {
              let l = s > o ? s - o : 0;
              s = (s > o ? o : s) / 2;
              let a = n === i ? "0" : "1";
              return re("a", "0 0," + a, s, k((n ? 1 : -1) * s, (i ? -1 : 1) * s)) + O("v", (i ? -1 : 1) * l) + re("a", "0 0," + a, s, k((n ? -1 : 1) * s, (i ? -1 : 1) * s));
            }
            let t = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH, o = t * 2;
            return { type: this.SHAPES.ROUND, isDynamic: true, width(s) {
              return s /= 2, s > t ? t : s;
            }, height(s) {
              return s;
            }, connectionOffsetY(s) {
              return s / 2;
            }, connectionOffsetX(s) {
              return -s;
            }, pathDown(s) {
              return e(s, false, false);
            }, pathUp(s) {
              return e(s, true, false);
            }, pathRightDown(s) {
              return e(s, false, true);
            }, pathRightUp(s) {
              return e(s, false, true);
            } };
          }
          makeSquared() {
            function e(o, s, i) {
              o -= t * 2;
              let n = i === s ? "0" : "1";
              return re("a", "0 0," + n, t, k((i ? 1 : -1) * t, (s ? -1 : 1) * t)) + O("v", (s ? -1 : 1) * o) + re("a", "0 0," + n, t, k((i ? -1 : 1) * t, (s ? -1 : 1) * t));
            }
            let t = this.CORNER_RADIUS;
            return { type: this.SHAPES.SQUARE, isDynamic: true, width(o) {
              return t;
            }, height(o) {
              return o;
            }, connectionOffsetY(o) {
              return o / 2;
            }, connectionOffsetX(o) {
              return -o;
            }, pathDown(o) {
              return e(o, false, false);
            }, pathUp(o) {
              return e(o, true, false);
            }, pathRightDown(o) {
              return e(o, false, true);
            }, pathRightUp(o) {
              return e(o, false, true);
            } };
          }
          shapeFor(e) {
            let t = e.getCheck();
            switch (!t && e.targetConnection && (t = e.targetConnection.getCheck()), e.type) {
              case C.INPUT_VALUE:
              case C.OUTPUT_VALUE:
                if (e = e.getSourceBlock().getOutputShape(), e !== null) switch (e) {
                  case this.SHAPES.HEXAGONAL:
                    return this.HEXAGONAL;
                  case this.SHAPES.ROUND:
                    return this.ROUNDED;
                  case this.SHAPES.SQUARE:
                    return this.SQUARED;
                }
                return t && t.includes("Boolean") ? this.HEXAGONAL : t && t.includes("Number") ? this.ROUNDED : (t && t.includes("String"), this.ROUNDED);
              case C.PREVIOUS_STATEMENT:
              case C.NEXT_STATEMENT:
                return this.NOTCH;
              default:
                throw Error("Unknown type");
            }
          }
          makeNotch() {
            function e(v) {
              return Le("c", [k(v * i / 2, 0), k(v * i * 3 / 4, l / 2), k(v * i, l)]) + Es([k(v * i, n)]) + Le("c", [k(v * i / 4, l / 2), k(v * i / 2, l), k(v * i, l)]) + O("h", v * s) + Le("c", [k(v * i / 2, 0), k(v * i * 3 / 4, -(l / 2)), k(v * i, -l)]) + Es([k(v * i, -n)]) + Le("c", [k(v * i / 4, -(l / 2)), k(v * i / 2, -l), k(v * i, -l)]);
            }
            let t = this.NOTCH_WIDTH, o = this.NOTCH_HEIGHT, s = t / 3, i = s / 3, n = o / 2, l = n / 2, a = e(1), _ = e(-1);
            return { type: this.SHAPES.NOTCH, width: t, height: o, pathLeft: a, pathRight: _ };
          }
          makeInsideCorners() {
            let e = this.CORNER_RADIUS, t = re("a", "0 0,0", e, k(-e, e)), o = re("a", "0 0,1", e, k(-e, e)), s = re("a", "0 0,0", e, k(e, e)), i = re("a", "0 0,1", e, k(e, e));
            return { width: e, height: e, pathTop: t, pathBottom: s, rightWidth: e, rightHeight: e, pathTopRight: o, pathBottomRight: i };
          }
          generateSecondaryColour_(e) {
            return So("#000", e, 0.15) || e;
          }
          generateTertiaryColour_(e) {
            return So("#000", e, 0.25) || e;
          }
          createDom(e, t, o, s) {
            super.createDom(e, t, o, s), e = b($.DEFS, {}, e), t = b($.FILTER, { id: "blocklySelectedGlowFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" }, e), b($.FEGAUSSIANBLUR, { in: "SourceGraphic", stdDeviation: this.SELECTED_GLOW_SIZE }, t), o = b($.FECOMPONENTTRANSFER, { result: "outBlur" }, t), b($.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, o), b($.FEFLOOD, { "flood-color": this.SELECTED_GLOW_COLOUR, "flood-opacity": 1, result: "outColor" }, t), b($.FECOMPOSITE, { in: "outColor", in2: "outBlur", operator: "in", result: "outGlow" }, t), this.selectedGlowFilterId = t.id, this.selectedGlowFilter = t, e = b($.FILTER, { id: "blocklyReplacementGlowFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" }, e), b($.FEGAUSSIANBLUR, { in: "SourceGraphic", stdDeviation: this.REPLACEMENT_GLOW_SIZE }, e), t = b($.FECOMPONENTTRANSFER, { result: "outBlur" }, e), b($.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, t), b($.FEFLOOD, { "flood-color": this.REPLACEMENT_GLOW_COLOUR, "flood-opacity": 1, result: "outColor" }, e), b($.FECOMPOSITE, { in: "outColor", in2: "outBlur", operator: "in", result: "outGlow" }, e), b($.FECOMPOSITE, { in: "SourceGraphic", in2: "outGlow", operator: "over" }, e), this.replacementGlowFilterId = e.id, this.replacementGlowFilter = e, s && (s.style.setProperty("--blocklySelectedGlowFilter", `url(#${this.selectedGlowFilterId})`), s.style.setProperty("--blocklyReplacementGlowFilter", `url(#${this.replacementGlowFilterId})`));
          }
          getCSS_(e) {
            return [`${e} .blocklyText,`, `${e} .blocklyFlyoutLabelText {`, `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${e} .blocklyTextInputBubble textarea {`, "font-weight: normal;", "}", `${e} .blocklyText {`, "fill: #fff;", "}", `${e} .blocklyNonEditableField>rect:not(.blocklyDropdownRect),`, `${e} .blocklyEditableField>rect:not(.blocklyDropdownRect) {`, `fill: ${this.FIELD_BORDER_RECT_COLOUR};`, "}", `${e} .blocklyNonEditableField>text,`, `${e} .blocklyEditableField>text,`, `${e} .blocklyNonEditableField>g>text,`, `${e} .blocklyEditableField>g>text {`, "fill: #575E75;", "}", `${e} .blocklyFlyoutLabelText {`, "fill: #575E75;", "}", `${e} .blocklyText.blocklyBubbleText {`, "fill: #575E75;", "}", `${e} .blocklyDraggable:not(.blocklyDisabled)`, " .blocklyEditableField:not(.blocklyEditing):hover>rect,", `${e} .blocklyDraggable:not(.blocklyDisabled)`, " .blocklyEditableField:not(.blocklyEditing):hover>.blocklyPath {", "stroke: #fff;", "stroke-width: 2;", "}", `${e} .blocklyHtmlInput {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`, "color: #575E75;", "}", `${e} .blocklyDropdownText {`, "fill: #fff !important;", "}", `${e}.blocklyWidgetDiv .blocklyMenuItem,`, `${e}.blocklyDropDownDiv .blocklyMenuItem {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${e}.blocklyDropDownDiv .blocklyMenuItemContent {`, "color: #fff;", "}", `${e} .blocklyHighlightedConnectionPath {`, `stroke: ${this.SELECTED_GLOW_COLOUR};`, "}", `${e} .blocklyDisabledPattern > .blocklyOutlinePath {`, "fill: var(--blocklyDisabledPattern)", "}", `${e} .blocklyInsertionMarker>.blocklyPath {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}", `${e} .blocklySelected>.blocklyPath.blocklyPathSelected {`, "fill: none;", "filter: var(--blocklySelectedGlowFilter);", "}", `${e} .blocklyReplaceable>.blocklyPath {`, "filter: var(--blocklyReplacementGlowFilter);", "}"];
          }
        }, af = {};
        af.ConstantProvider = Kh;
        var jh = class extends hr {
          constructor(e, t) {
            super(e, t);
          }
          draw() {
            let e = this.block_.pathObject;
            e.beginDrawing(), this.drawOutline_(), this.drawInternals_(), this.updateConnectionHighlights(), e.setPath(this.outlinePath_ + `
` + this.inlinePath_), this.info_.RTL && e.flipRTL(), this.recordSizeOnBlock_(), this.info_.outputConnection && (e.outputShapeType = this.info_.outputConnection.shape.type), e.endDrawing();
          }
          drawOutline_() {
            this.info_.outputConnection && this.info_.outputConnection.isDynamicShape && !this.info_.hasStatementInput && !this.info_.bottomRow.hasNextConnection ? (this.drawFlatTop_(), this.drawRightDynamicConnection_(), this.drawFlatBottom_(), this.drawLeftDynamicConnection_()) : super.drawOutline_();
          }
          drawLeft_() {
            this.info_.outputConnection && this.info_.outputConnection.isDynamicShape ? this.drawLeftDynamicConnection_() : super.drawLeft_();
          }
          drawRightSideRow_(e) {
            if (!(e.height <= 0)) {
              if (h.isSpacer(e)) {
                let s = e.precedesStatement;
                var t = e.followsStatement;
                if (s || t) {
                  let i = this.constants_.INSIDE_CORNERS;
                  var o = i.rightHeight;
                  o = e.height - (s ? o : 0), t = t ? i.pathBottomRight : "", e = o > 0 ? O("V", e.yPos + o) : "", this.outlinePath_ += t + e + (s ? i.pathTopRight : "");
                  return;
                }
              }
              this.outlinePath_ += O("V", e.yPos + e.height);
            }
          }
          drawRightDynamicConnection_() {
            if (!this.info_.outputConnection) throw Error("Cannot draw the output connection of a block that doesn't have one");
            this.outlinePath_ += this.info_.outputConnection.shape.pathRightDown(this.info_.outputConnection.height);
          }
          drawLeftDynamicConnection_() {
            if (!this.info_.outputConnection) throw Error("Cannot draw the output connection of a block that doesn't have one");
            this.positionOutputConnection_(), this.outlinePath_ += this.info_.outputConnection.shape.pathUp(this.info_.outputConnection.height), this.outlinePath_ += "z";
          }
          drawFlatTop_() {
            let e = this.info_.topRow;
            this.positionPreviousConnection_(), this.outlinePath_ += ee(e.xPos, this.info_.startY), this.outlinePath_ += O("h", e.width);
          }
          drawFlatBottom_() {
            let e = this.info_.bottomRow;
            this.positionNextConnection_(), this.outlinePath_ += O("V", e.baseline), this.outlinePath_ += O("h", -e.width);
          }
          drawInlineInput_(e) {
            this.positionInlineInputConnection_(e);
            let t = e.input.name;
            e.connectedBlock || this.info_.isInsertionMarker || (e = _e(e.xPos + e.connectionWidth, e.centerline - e.height / 2) + this.getInlineInputPath(e), this.block_.pathObject.setOutlinePath(t, e));
          }
          getInlineInputPath(e) {
            let t = e.width - e.connectionWidth * 2, o = e.height;
            return O("h", t) + e.shape.pathRightDown(o) + O("h", -t) + e.shape.pathUp(o) + "z";
          }
          drawStatementInput_(e) {
            var t = e.getLastInput();
            let o = t.xPos + t.notchOffset + t.shape.width, s = this.constants_.INSIDE_CORNERS, i = t.shape.pathRight + O("h", -(t.notchOffset - s.width)) + s.pathTop, n = e.height - 2 * s.height;
            t = s.pathBottom + O("h", t.notchOffset - s.width) + (t.connectedBottomNextConnection ? "" : t.shape.pathLeft), this.outlinePath_ += O("H", o) + i + O("v", n) + t + O("H", e.xPos + e.width), this.positionStatementInputConnection_(e);
          }
          drawConnectionHighlightPath(e) {
            let t = e.connectionModel;
            if (t.type === C.NEXT_STATEMENT || t.type === C.PREVIOUS_STATEMENT || t.type === C.OUTPUT_VALUE && !e.isDynamicShape) return super.drawConnectionHighlightPath(e);
            e = t.type === C.INPUT_VALUE ? _e(e.connectionWidth, -e.height / 2) + this.getInlineInputPath(e) : _e(e.width, -e.height / 2) + e.shape.pathDown(e.height);
            let o = t.getSourceBlock(), s, i;
            return (i = (s = o.pathObject).addConnectionHighlight) == null ? void 0 : i.call(s, t, e, t.getOffsetInBlock(), o.RTL);
          }
        }, uf = {};
        uf.Drawer = jh;
        var mo = class extends F {
          constructor(e, t, o, s, i, n, l) {
            if (super(F.SKIP_SETUP), this.imageElement = this.clickHandler = null, this.flipRtl = this.isDirty_ = this.EDITABLE = false, this.altText = "", o = Number(ie(o)), t = Number(ie(t)), isNaN(o) || isNaN(t)) throw Error("Height and width values of an image field must cast to numbers.");
            if (o <= 0 || t <= 0) throw Error("Height and width values of an image field must be greater than 0.");
            this.size_ = new N(t, o + mo.Y_PADDING), this.imageHeight = o, typeof i == "function" && (this.clickHandler = i), e !== F.SKIP_SETUP && (l ? this.configure_(l) : (this.flipRtl = !!n, this.altText = ie(s) || ""), this.setValue(ie(e)));
          }
          configure_(e) {
            super.configure_(e), e.flipRtl && (this.flipRtl = e.flipRtl), e.alt && (this.altText = ie(e.alt));
          }
          initView() {
            this.imageElement = b($.IMAGE, { height: this.imageHeight + "px", width: this.size_.width + "px", alt: this.altText }, this.fieldGroup_), this.imageElement.setAttributeNS(He, "xlink:href", this.value_), this.fieldGroup_ && I(this.fieldGroup_, "blocklyImageField"), this.clickHandler && (this.imageElement.style.cursor = "pointer");
          }
          updateSize_() {
          }
          doClassValidation_(e) {
            return typeof e != "string" ? null : e;
          }
          doValueUpdate_(e) {
            this.value_ = e, this.imageElement && this.imageElement.setAttributeNS(He, "xlink:href", this.value_);
          }
          getFlipRtl() {
            return this.flipRtl;
          }
          setAlt(e) {
            e !== this.altText && (this.altText = e || "", this.imageElement && this.imageElement.setAttribute("alt", this.altText));
          }
          isClickable() {
            return super.isClickable() && !!this.clickHandler;
          }
          showEditor_() {
            this.clickHandler && this.clickHandler(this);
          }
          setOnClickHandler(e) {
            this.clickHandler = e;
          }
          getText_() {
            return this.altText;
          }
          static fromJson(e) {
            if (!e.src || !e.width || !e.height) throw Error("src, width, and height values for an image field arerequired. The width and height must be non-zero.");
            return new this(e.src, e.width, e.height, void 0, void 0, void 0, e);
          }
        };
        mo.Y_PADDING = 1, bt("field_image", mo), mo.prototype.DEFAULT_VALUE = "";
        var hf = {};
        hf.FieldImage = mo;
        var wl = 14, Zo = class extends F {
          set size_(e) {
            super.size_ = e;
          }
          get size_() {
            let e = super.size_;
            return e.width < wl && (e.width = wl), e;
          }
          constructor(e, t, o) {
            super(F.SKIP_SETUP), this.spellcheck_ = true, this.htmlInput_ = null, this.isTextValid_ = this.isBeingEdited_ = false, this.onInputWrapper = this.onKeyDownWrapper = this.valueWhenEditorWasOpened_ = null, this.fullBlockClickTarget_ = false, this.workspace_ = null, this.SERIALIZABLE = true, e !== F.SKIP_SETUP && (o && this.configure_(o), this.setValue(e), t && this.setValidator(t));
          }
          configure_(e) {
            super.configure_(e), e.spellcheck !== void 0 && (this.spellcheck_ = e.spellcheck);
          }
          initView() {
            if (!this.getSourceBlock()) throw new se();
            super.initView(), this.isFullBlockField() && (this.clickTarget_ = this.sourceBlock_.getSvgRoot()), this.fieldGroup_ && I(this.fieldGroup_, "blocklyInputField");
          }
          isFullBlockField() {
            let e = this.getSourceBlock();
            if (!e) throw new se();
            let t;
            return this.fullBlockClickTarget_ = !((t = this.getConstants()) == null || !t.FULL_BLOCK_FIELDS) && e.isSimpleReporter();
          }
          doValueInvalid_(e, t = true) {
            this.isBeingEdited_ && (this.isDirty_ = true, this.isTextValid_ = false, e = this.value_, this.value_ = this.valueWhenEditorWasOpened_, this.sourceBlock_ && J() && this.value_ !== e && t && R(new (S(d.BLOCK_CHANGE))(this.sourceBlock_, "field", this.name || null, e, this.value_)));
          }
          doValueUpdate_(e) {
            this.isTextValid_ = this.isDirty_ = true, this.value_ = e;
          }
          applyColour() {
            let e = this.getSourceBlock();
            if (!e) throw new se();
            this.getConstants().FULL_BLOCK_FIELDS && this.fieldGroup_ && (!this.isFullBlockField() && this.borderRect_ ? (this.borderRect_.style.display = "block", this.borderRect_.setAttribute("stroke", e.getColourTertiary())) : (this.borderRect_.style.display = "none", e.pathObject.svgPath.setAttribute("fill", this.getConstants().FIELD_BORDER_RECT_COLOUR)));
          }
          getSize() {
            let e;
            return (e = this.getConstants()) != null && e.FULL_BLOCK_FIELDS && (this.render_(), this.isDirty_ = false), super.getSize();
          }
          onLocationChange() {
            this.isBeingEdited_ && this.resizeEditor_();
          }
          render_() {
            if (super.render_(), this.isBeingEdited_) {
              var e = this.htmlInput_;
              this.isTextValid_ ? (P(e, "blocklyInvalidInput"), ae(e, ne.INVALID, false)) : (I(e, "blocklyInvalidInput"), ae(e, ne.INVALID, true));
            }
            if (e = this.getSourceBlock(), !e) throw new se();
            this.getConstants().FULL_BLOCK_FIELDS && e.applyColour();
          }
          setSpellcheck(e) {
            e !== this.spellcheck_ && (this.spellcheck_ = e, this.htmlInput_ && this.htmlInput_.setAttribute("spellcheck", this.spellcheck_));
          }
          showEditor_(e, t = false, o = true) {
            this.workspace_ = this.sourceBlock_.workspace, !t && this.workspace_.options.modalInputs && (Og || yu || kn) ? this.showPromptEditor() : this.showInlineEditor(t, o);
          }
          showPromptEditor() {
            Gr(r.Msg$$module$build$src$core$msg.CHANGE_VALUE_TITLE, this.getText(), (e) => {
              e !== null && this.setValue(this.getValueFromEditorText_(e)), this.onFinishEditing_(this.value_);
            });
          }
          showInlineEditor(e, t) {
            let o = this.getSourceBlock();
            if (!o) throw new se();
            nn(this, o.RTL, this.widgetDispose_.bind(this), this.workspace_, t), this.htmlInput_ = this.widgetCreate_(), this.isBeingEdited_ = true, this.valueWhenEditorWasOpened_ = this.value_, e || (this.htmlInput_.focus({ preventScroll: true }), this.htmlInput_.select());
          }
          widgetCreate_() {
            var e = this.getSourceBlock();
            if (!e) throw new se();
            r.setGroup$$module$build$src$core$events$utils(true);
            let t = gs();
            var o = this.getClickTarget_();
            if (!o) throw Error("A click target has not been set.");
            I(o, "blocklyEditing"), o = document.createElement("input"), o.className = "blocklyHtmlInput", o.setAttribute("spellcheck", this.spellcheck_);
            let s = this.workspace_.getAbsoluteScale();
            var i = this.getConstants().FIELD_TEXT_FONTSIZE * s + "pt";
            return t.style.fontSize = i, o.style.fontSize = i, i = Zo.BORDERRADIUS * s + "px", this.isFullBlockField() && (i = this.getScaledBBox(), i = (i.bottom - i.top) / 2 + "px", e = e.getParent() ? e.getParent().getColourTertiary() : this.sourceBlock_.getColourTertiary(), o.style.border = 1 * s + "px solid " + e, t.style.borderRadius = i, t.style.transition = "box-shadow 0.25s ease 0s", this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW && (t.style.boxShadow = "rgba(255, 255, 255, 0.3) 0 0 0 " + 4 * s + "px")), o.style.borderRadius = i, t.appendChild(o), o.value = o.defaultValue = this.getEditorText_(this.value_), o.setAttribute("data-untyped-default-value", String(this.value_)), this.resizeEditor_(), this.bindInputEvents_(o), o;
          }
          widgetDispose_() {
            this.isBeingEdited_ = false, this.isTextValid_ = true, this.forceRerender(), this.onFinishEditing_(this.value_), this.sourceBlock_ && J() && this.valueWhenEditorWasOpened_ !== null && this.valueWhenEditorWasOpened_ !== this.value_ && (R(new (S(d.BLOCK_CHANGE))(this.sourceBlock_, "field", this.name || null, this.valueWhenEditorWasOpened_, this.value_)), this.valueWhenEditorWasOpened_ = null), r.setGroup$$module$build$src$core$events$utils(false), this.unbindInputEvents_();
            var e = gs().style;
            if (e.width = "auto", e.height = "auto", e.fontSize = "", e.transition = "", e.boxShadow = "", this.htmlInput_ = null, e = this.getClickTarget_(), !e) throw Error("A click target has not been set.");
            P(e, "blocklyEditing");
          }
          onFinishEditing_(e) {
          }
          bindInputEvents_(e) {
            this.onKeyDownWrapper = w(e, "keydown", this, this.onHtmlInputKeyDown_), this.onInputWrapper = w(e, "input", this, this.onHtmlInputChange);
          }
          unbindInputEvents_() {
            this.onKeyDownWrapper && (x(this.onKeyDownWrapper), this.onKeyDownWrapper = null), this.onInputWrapper && (x(this.onInputWrapper), this.onInputWrapper = null);
          }
          onHtmlInputKeyDown_(e) {
            if (e.key === "Enter") Oo(this), Tt();
            else if (e.key === "Escape") this.setValue(this.htmlInput_.getAttribute("data-untyped-default-value"), false), Oo(this), Tt();
            else if (e.key === "Tab") {
              e.preventDefault();
              var t, o = (t = this.workspace_) == null ? void 0 : t.getCursor();
              t = (s) => (s instanceof Zo || s instanceof z && s.isSimpleReporter()) && s !== this.getSourceBlock(), e = e.shiftKey ? o?.getPreviousNode(this, t, false) : o?.getNextNode(this, t, false), e = e instanceof z && e.isSimpleReporter() ? e.getFields().next().value : e, e instanceof Zo && (Oo(this), Tt(), o = e.getSourceBlock(), e.isFullBlockField() && o && o instanceof z ? r.getFocusManager$$module$build$src$core$focus_manager().focusNode(o) : r.getFocusManager$$module$build$src$core$focus_manager().focusNode(e), e.showEditor());
            }
          }
          onHtmlInputChange(e) {
            e = this.value_, this.setValue(this.getValueFromEditorText_(this.htmlInput_.value), false), this.sourceBlock_ && J() && this.value_ !== e && R(new (S(d.BLOCK_FIELD_INTERMEDIATE_CHANGE))(this.sourceBlock_, this.name || null, e, this.value_));
          }
          setEditorValue_(e, t = true) {
            this.isDirty_ = true, this.isBeingEdited_ && (this.htmlInput_.value = this.getEditorText_(e)), this.setValue(e, t);
          }
          resizeEditor_() {
            _t().then(() => {
              let e = this.getSourceBlock();
              if (!e) throw new se();
              let t = gs(), o = this.getScaledBBox();
              t.style.width = o.right - o.left + "px", t.style.height = o.bottom - o.top + "px";
              let s = o.top;
              t.style.left = `${e.RTL ? o.right - t.offsetWidth : o.left}px`, t.style.top = `${s}px`;
            });
          }
          repositionForWindowResize() {
            let e, t = (e = this.getSourceBlock()) == null ? void 0 : e.getRootBlock();
            return t instanceof z ? (Lo(this.workspace_, this.workspace_.getMetricsManager().getViewMetrics(true), t) || this.resizeEditor_(), true) : false;
          }
          positionTextElement_(e, t) {
            let o = e * 2 + t;
            super.positionTextElement_(e + (o < wl ? (wl - o) / 2 : 0), t);
          }
          getText_() {
            return this.isBeingEdited_ && this.htmlInput_ ? this.htmlInput_.value : null;
          }
          getEditorText_(e) {
            return `${e}`;
          }
          getValueFromEditorText_(e) {
            return e;
          }
        };
        Zo.BORDERRADIUS = 4;
        var df = {};
        df.FieldInput = Zo, r.FieldTextInput$$module$build$src$core$field_textinput = class extends Zo {
          constructor(e, t, o) {
            super(e, t, o);
          }
          initView() {
            super.initView(), this.fieldGroup_ && I(this.fieldGroup_, "blocklyTextInputField");
          }
          doClassValidation_(e) {
            return e === void 0 ? null : `${e}`;
          }
          static fromJson(e) {
            return new this(ie(e.text), void 0, e);
          }
        }, bt("field_input", r.FieldTextInput$$module$build$src$core$field_textinput), r.FieldTextInput$$module$build$src$core$field_textinput.prototype.DEFAULT_VALUE = "";
        var $f = {};
        $f.FieldTextInput = r.FieldTextInput$$module$build$src$core$field_textinput;
        var Jh = class extends $l {
          constructor(e) {
            super(e);
          }
          endsWithElemSpacer() {
            return false;
          }
          hasLeftSquareCorner(e) {
            return !!e.outputConnection;
          }
          hasRightSquareCorner(e) {
            return !!e.outputConnection && !e.statementInputCount && !e.nextConnection;
          }
        }, pf = {};
        pf.BottomRow = Jh;
        var mr = class extends ar {
          constructor(e, t) {
            if (super(e, t), this.connectedBottomNextConnection = false, this.connectedBlock) {
              for (e = this.connectedBlock; t = e.getNextBlock(); ) e = t;
              e.nextConnection || (this.height = this.connectedBlockHeight, this.connectedBottomNextConnection = true);
            }
          }
        }, gf = {};
        gf.StatementInput = mr;
        var qh = class extends lt {
          constructor(e) {
            super(e), this.width = this.height = 0, this.type |= h.getType("RIGHT_CONNECTION");
          }
        }, mf = {};
        mf.RightConnectionShape = qh;
        var Zh = class extends El {
          constructor(e) {
            super(e);
          }
          endsWithElemSpacer() {
            return false;
          }
          hasLeftSquareCorner(e) {
            let t = (e.hat ? e.hat === "cap" : this.constants_.ADD_START_HATS) && !e.outputConnection && !e.previousConnection;
            return !!e.outputConnection || t;
          }
          hasRightSquareCorner(e) {
            return !!e.outputConnection && !e.statementInputCount && !e.nextConnection;
          }
        }, _f = {};
        _f.TopRow = Zh;
        var Qh = class extends Fs {
          constructor(e, t) {
            super(e, t), this.isInline = true, this.renderer_ = e, this.constants_ = this.renderer_.getConstants(), this.topRow = new Zh(this.constants_), this.bottomRow = new Jh(this.constants_), this.isMultiRow = !t.getInputsInline() || t.isCollapsed(), this.hasStatementInput = t.statementInputCount > 0, this.rightSide = this.outputConnection ? new qh(this.constants_) : null, this.rightAlignedDummyInputs = /* @__PURE__ */ new WeakMap();
          }
          getRenderer() {
            return this.renderer_;
          }
          measure() {
            this.createRows_(), this.addElemSpacing_(), this.addRowSpacing_(), this.adjustXPosition_(), this.computeBounds_(), this.alignRowElements_(), this.finalize_();
          }
          shouldStartNewRow_(e, t) {
            return t ? t instanceof Ct || e instanceof Ae || t instanceof Ae ? true : e instanceof r.ValueInput$$module$build$src$core$inputs$value_input || e instanceof rt || e instanceof Ct ? !this.isInline || this.isMultiRow : false : false;
          }
          getDesiredRowWidth_(e) {
            return e.hasStatement ? this.width - this.startX - (this.constants_.INSIDE_CORNERS.rightWidth || 0) : super.getDesiredRowWidth_(e);
          }
          getInRowSpacing_(e, t) {
            return e && t || !this.outputConnection || !this.outputConnection.isDynamicShape || this.hasStatementInput || this.bottomRow.hasNextConnection ? !e && t && h.isStatementInput(t) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : e && h.isLeftRoundedCorner(e) && t && (h.isPreviousConnection(t) || h.isNextConnection(t)) ? t.notchOffset - this.constants_.CORNER_RADIUS : e && h.isLeftSquareCorner(e) && t && h.isHat(t) || e && h.isField(e) && e.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : this.constants_.NO_PADDING;
          }
          getSpacerRowHeight_(e, t) {
            if (h.isTopRow(e) && h.isBottomRow(t)) return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;
            let o = h.isInputRow(e) && e.hasStatement, s = h.isInputRow(t) && t.hasStatement;
            return s || o ? (e = Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.INSIDE_CORNERS.rightHeight || 0), s && o ? Math.max(e, this.constants_.DUMMY_INPUT_MIN_HEIGHT) : e) : h.isTopRow(e) ? e.hasPreviousConnection || this.outputConnection && !this.hasStatementInput ? this.constants_.NO_PADDING : Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : h.isBottomRow(t) ? this.outputConnection ? !t.hasNextConnection && this.hasStatementInput ? Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : this.constants_.NO_PADDING : Math.max(this.topRow.minHeight, Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.CORNER_RADIUS)) - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING;
          }
          getSpacerRowWidth_(e, t) {
            let o = this.width - this.startX;
            return h.isInputRow(e) && e.hasStatement || h.isInputRow(t) && t.hasStatement ? Math.max(o, this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH) : o;
          }
          getElemCenterline_(e, t) {
            if (e.hasStatement && !h.isSpacer(t) && !h.isStatementInput(t)) return e.yPos + this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT / 2;
            if (h.isInlineInput(t)) {
              let o = t.connectedBlock;
              if (o && o.outputConnection && o.nextConnection) return e.yPos + o.height / 2;
            }
            return super.getElemCenterline_(e, t);
          }
          addInput_(e, t) {
            if ((e instanceof rt || e instanceof Ct) && t.hasDummyInput && t.align === r.Align$$module$build$src$core$inputs$align.LEFT && e.align === r.Align$$module$build$src$core$inputs$align.RIGHT) this.rightAlignedDummyInputs.set(t, e);
            else if (e instanceof Ae) {
              t.elements.push(new mr(this.constants_, e)), t.hasStatement = true, t.align === null && (t.align = e.align);
              return;
            }
            super.addInput_(e, t);
          }
          addAlignmentPadding_(e, t) {
            if (this.rightAlignedDummyInputs.get(e)) {
              let o;
              for (let s = 0; s < e.elements.length; s++) {
                let i = e.elements[s];
                if (h.isSpacer(i) && (o = i), h.isField(i) && i.parentInput === this.rightAlignedDummyInputs.get(e)) break;
              }
              if (o) {
                o.width += t, e.width += t;
                return;
              }
            }
            super.addAlignmentPadding_(e, t);
          }
          adjustXPosition_() {
            let e = this.constants_.NOTCH_OFFSET_LEFT + this.constants_.NOTCH_WIDTH, t = e;
            for (let i = 2; i < this.rows.length - 1; i += 2) {
              var o = this.rows[i - 1];
              let n = this.rows[i];
              var s = this.rows[i + 1];
              if (o = i === 2 ? !!this.topRow.hasPreviousConnection : !!o.followsStatement, s = i + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!s.precedesStatement, h.isInputRow(n) && n.hasStatement) {
                n.measure();
                let l, a;
                t = n.width - ((a = (l = n.getLastInput()) == null ? void 0 : l.width) != null ? a : 0) + e;
              } else if (o && (i === 2 || s) && h.isInputRow(n) && !n.hasStatement) {
                s = n.xPos, o = null;
                for (let l = 0; l < n.elements.length; l++) {
                  let a = n.elements[l];
                  h.isSpacer(a) && (o = a), !(o && (h.isField(a) || h.isInput(a)) && s < t) || h.isField(a) && (a.field instanceof uo || a.field instanceof mo) || (o.width += t - s), s += a.width;
                }
              }
            }
          }
          finalizeOutputConnection_() {
            if (this.outputConnection && this.outputConnection.isDynamicShape) {
              var e = this.outputConnection.shape;
              if ("isDynamic" in e && e.isDynamic) {
                for (var t = 0, o = 0; o < this.rows.length; o++) {
                  let s = this.rows[o];
                  s.yPos = t, t += s.height;
                }
                this.height = t, o = this.bottomRow.hasNextConnection ? this.height - this.bottomRow.descenderHeight : this.height, t = e.height(o), o = e.width(o), this.outputConnection.height = t, this.outputConnection.width = o, this.outputConnection.startX = o, this.outputConnection.connectionOffsetY = e.connectionOffsetY(t), this.outputConnection.connectionOffsetX = e.connectionOffsetX(o), e = 0, this.hasStatementInput || this.bottomRow.hasNextConnection || (e = o, this.rightSide.height = t, this.rightSide.width = e, this.rightSide.centerline = t / 2, this.rightSide.xPos = this.width + e), this.startX = o, this.width += o + e, this.widthWithChildren += o + e;
              }
            }
          }
          finalizeHorizontalAlignment_() {
            if (this.outputConnection && !this.hasStatementInput && !this.bottomRow.hasNextConnection) {
              for (var e = 0, t = 0; t < this.rows.length; t++) {
                var o = this.rows[t];
                if (!h.isInputRow(o)) continue;
                e = o.elements[o.elements.length - 2];
                let s = this.getNegativeSpacing_(o.elements[1]), i = this.getNegativeSpacing_(e);
                e = s + i;
                let n = this.constants_.MIN_BLOCK_WIDTH + this.outputConnection.width * 2;
                this.width - e < n && (e = this.width - n, s = e / 2, i = e / 2), o.elements.unshift(new Me(this.constants_, -s)), o.elements.push(new Me(this.constants_, -i));
              }
              if (e) for (this.width -= e, this.widthWithChildren -= e, this.rightSide.xPos -= e, t = 0; t < this.rows.length; t++) o = this.rows[t], h.isTopOrBottomRow(o) && (o.elements[1].width -= e), o.width -= e, o.widthWithConnectedBlocks -= e;
            }
          }
          getNegativeSpacing_(e) {
            if (!e || !this.outputConnection) return 0;
            let t = this.outputConnection.width;
            var o = this.outputConnection.shape.type;
            let s = this.constants_;
            if (this.inputRows.length > 1) switch (o) {
              case s.SHAPES.ROUND:
                return o = this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH, o = this.height / 2 > o ? o : this.height / 2, t - o * (1 - Math.sin(Math.acos((o - this.constants_.SMALL_PADDING) / o)));
              default:
                return 0;
            }
            if (h.isInlineInput(e)) {
              let i = e.connectedBlock;
              return e = i ? i.pathObject.outputShapeType : e.shape.type, e == null || i && i.outputConnection && (i.statementInputCount || i.nextConnection) || o === s.SHAPES.HEXAGONAL && o !== e ? 0 : t - this.constants_.SHAPE_IN_SHAPE_PADDING[o][e];
            }
            return h.isField(e) ? o === s.SHAPES.ROUND && e.field instanceof r.FieldTextInput$$module$build$src$core$field_textinput ? t - 2.75 * s.GRID_UNIT : t - this.constants_.SHAPE_IN_SHAPE_PADDING[o][0] : h.isIcon(e) ? this.constants_.SMALL_PADDING : 0;
          }
          finalizeVerticalAlignment_() {
            if (!this.outputConnection) for (let s = 2; s < this.rows.length - 1; s += 2) {
              let i = this.rows[s - 1], n = this.rows[s], l = this.rows[s + 1];
              var e = s === 2, t = s + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!l.precedesStatement;
              if (e ? this.topRow.hasPreviousConnection : i.followsStatement) {
                var o = n.elements[1];
                if (o = n.elements.length === 3 && o instanceof gl && (o.field instanceof uo || o.field instanceof mo), !e && o) i.height -= this.constants_.SMALL_PADDING, l.height -= this.constants_.SMALL_PADDING, n.height -= this.constants_.MEDIUM_PADDING;
                else if (!e && !t) i.height += this.constants_.SMALL_PADDING;
                else if (t) {
                  for (e = false, t = 0; t < n.elements.length; t++) if (o = n.elements[t], h.isInlineInput(o) && o.connectedBlock && !o.connectedBlock.isShadow() && o.connectedBlock.getHeightWidth().height >= 40) {
                    e = true;
                    break;
                  }
                  e && (i.height -= this.constants_.SMALL_PADDING, l.height -= this.constants_.SMALL_PADDING);
                }
              }
            }
          }
          finalize_() {
            this.finalizeOutputConnection_(), this.finalizeHorizontalAlignment_(), this.finalizeVerticalAlignment_(), super.finalize_(), this.rightSide && (this.widthWithChildren += this.rightSide.width);
          }
        }, Tf = {};
        Tf.RenderInfo = Qh;
        var ed = class extends dr {
          constructor(e, t, o) {
            super(e, t, o), this.svgPathSelected = null, this.outlines = /* @__PURE__ */ new Map(), this.remainingOutlines = /* @__PURE__ */ new Set(), this.outputShapeType = null, this.constants = o;
          }
          setPath(e) {
            super.setPath(e), this.svgPathSelected && this.svgPathSelected.setAttribute("d", e);
          }
          applyColour(e) {
            super.applyColour(e);
            let t = e.getParent();
            e.isShadow() && t && this.svgPath.setAttribute("stroke", t.getColourTertiary());
            for (let o of this.outlines.values()) o.setAttribute("fill", this.style.colourTertiary);
          }
          flipRTL() {
            super.flipRTL();
            for (let e of this.outlines.values()) e.setAttribute("transform", "scale(-1 1)");
          }
          updateSelected(e) {
            this.setClass_("blocklySelected", e), e ? this.svgPathSelected || (this.svgPathSelected = this.svgPath.cloneNode(true), this.svgPathSelected.classList.add("blocklyPathSelected"), P(this.svgPathSelected, Ee.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME), P(this.svgPathSelected, Ee.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME), this.svgPathSelected.removeAttribute("tabindex"), this.svgPathSelected.removeAttribute("id"), this.svgRoot.appendChild(this.svgPathSelected)) : this.svgPathSelected && (this.svgRoot.removeChild(this.svgPathSelected), this.svgPathSelected = null);
          }
          updateReplacementFade(e) {
            this.setClass_("blocklyReplaceable", e);
          }
          updateShapeForInputHighlight(e, t) {
            e = e.getParentInput().name, (e = this.getOutlinePath(e)) && (t ? e.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : e.removeAttribute("filter"));
          }
          beginDrawing() {
            this.remainingOutlines.clear();
            for (let e of this.outlines.keys()) this.remainingOutlines.add(e);
          }
          endDrawing() {
            if (this.remainingOutlines.size) for (let e of this.remainingOutlines) this.removeOutlinePath(e);
            this.remainingOutlines.clear();
          }
          setOutlinePath(e, t) {
            e = this.getOutlinePath(e), e.setAttribute("d", t), e.setAttribute("fill", this.style.colourTertiary);
          }
          getOutlinePath(e) {
            return this.outlines.has(e) || this.outlines.set(e, b($.PATH, { class: "blocklyOutlinePath", d: "" }, this.svgRoot)), this.remainingOutlines.delete(e), this.outlines.get(e);
          }
          removeOutlinePath(e) {
            let t, o;
            (t = this.outlines.get(e)) == null || (o = t.parentNode) == null || o.removeChild(this.outlines.get(e)), this.outlines.delete(e);
          }
        }, Ef = {};
        Ef.PathObject = ed;
        var Ll = class extends $r {
          constructor(e) {
            super(e);
          }
          makeConstants_() {
            return new Kh();
          }
          makeRenderInfo_(e) {
            return new Qh(this, e);
          }
          makeDrawer_(e, t) {
            return new jh(e, t);
          }
          makePathObject(e, t) {
            return new ed(e, t, this.getConstants());
          }
          getConstants() {
            return this.constants_;
          }
        };
        yi("zelos", Ll);
        var bf = {};
        bf.Renderer = Ll;
        var td = class {
          constructor(e) {
            this.staticConn = this.draggedConn = this.markerConn = this.fadedBlock = null, this.workspace = e.workspace;
          }
          previewReplacement(e, t, o) {
            r.disable$$module$build$src$core$events$utils();
            try {
              this.hidePreview(), this.fadedBlock = o, o.fadeForReplacement(true), this.workspace.getRenderer().shouldHighlightConnection(t) && (t.highlight(), this.staticConn = t);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
          }
          previewConnection(e, t) {
            if (e !== this.draggedConn || t !== this.staticConn) {
              r.disable$$module$build$src$core$events$utils();
              try {
                this.hidePreview(), this.shouldUseMarkerPreview(e, t) && (this.markerConn = this.previewMarker(e, t)), this.workspace.getRenderer().shouldHighlightConnection(t) && t.highlight(), this.draggedConn = e, this.staticConn = t;
              } finally {
                r.enable$$module$build$src$core$events$utils();
              }
            }
          }
          shouldUseMarkerPreview(e, t) {
            return t.type === C.PREVIOUS_STATEMENT || t.type === C.NEXT_STATEMENT || !(this.workspace.getRenderer() instanceof Ll);
          }
          previewMarker(e, t) {
            let o = e.getSourceBlock(), s = this.createInsertionMarker(o), i = this.getMatchingConnection(o, s, e);
            if (!i) return null;
            s.queueRender(), jt(), i.connect(t);
            let n = { x: t.x - i.x, y: t.y - i.y }, l = i.getOffsetInBlock().clone();
            return _t().then(() => {
              if (!s.isDeadOrDying()) {
                r.disable$$module$build$src$core$events$utils();
                try {
                  s?.positionNearConnection(i, n, l), s?.getSvgRoot().setAttribute("visibility", "visible");
                } finally {
                  r.enable$$module$build$src$core$events$utils();
                }
              }
            }), i;
          }
          serializeBlockToInsertionMarker(e) {
            let t = Be(e, { addCoordinates: false, addInputBlocks: false, addNextBlocks: false, doFullSerialization: false });
            if (!t) throw Error(`Failed to serialize source block. ${e.toDevString()}`);
            return t;
          }
          createInsertionMarker(e) {
            e = this.serializeBlockToInsertionMarker(e), e = Jt(e, this.workspace);
            for (let t of e.getDescendants(false)) t.setInsertionMarker(true);
            return e.initSvg(), e.getSvgRoot().setAttribute("visibility", "hidden"), e;
          }
          getMatchingConnection(e, t, o) {
            if (e = e.getConnections_(true), t = t.getConnections_(true), e.length !== t.length) return null;
            for (let s = 0; s < e.length; s++) if (e[s] === o) return t[s];
            return null;
          }
          hidePreview() {
            r.disable$$module$build$src$core$events$utils();
            try {
              this.staticConn && (this.staticConn.unhighlight(), this.staticConn = null), this.fadedBlock && (this.fadedBlock.fadeForReplacement(false), this.fadedBlock = null), this.markerConn && (this.hideInsertionMarker(this.markerConn), this.draggedConn = this.markerConn = null);
            } finally {
              r.enable$$module$build$src$core$events$utils();
            }
          }
          hideInsertionMarker(e) {
            let t = e.getSourceBlock(), o = t.outputConnection, s;
            if ((s = t.previousConnection) != null && s.targetConnection || o != null && o.targetConnection) t.unplug(true);
            else {
              let i;
              (i = e.targetBlock()) == null || i.unplug(false);
            }
            t.dispose();
          }
          dispose() {
            this.hidePreview();
          }
        };
        c(E.CONNECTION_PREVIEWER, Fe, td);
        var ff = {};
        ff.InsertionMarkerPreviewer = td;
        var _o = {};
        _o.Align = r.Align$$module$build$src$core$inputs$align, _o.DummyInput = rt, _o.EndRowInput = Ct, _o.Input = Xo, _o.StatementInput = Ae, _o.ValueInput = r.ValueInput$$module$build$src$core$inputs$value_input, _o.inputTypes = r.inputTypes$$module$build$src$core$inputs$input_types;
        var s_ = false, If = {};
        If.inject = Za;
        var i_;
        r.CodeGenerator$$module$build$src$core$generator = class {
          constructor(e) {
            this.forBlock = /* @__PURE__ */ Object.create(null), this.FUNCTION_NAME_PLACEHOLDER_ = "{leCUI8hutHZI4480Dc}", this.STATEMENT_SUFFIX = this.STATEMENT_PREFIX = this.INFINITE_LOOP_TRAP = null, this.INDENT = "  ", this.COMMENT_WRAP = 60, this.ORDER_OVERRIDES = [], this.isInitialized = null, this.RESERVED_WORDS_ = "", this.definitions_ = /* @__PURE__ */ Object.create(null), this.functionNames_ = /* @__PURE__ */ Object.create(null), this.nameDB_ = void 0, this.name_ = e, this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ = new RegExp(this.FUNCTION_NAME_PLACEHOLDER_, "g");
          }
          workspaceToCode(e) {
            e || (console.warn("No workspace specified in workspaceToCode call.  Guessing."), e = De());
            var t = [];
            this.init(e), e = e.getTopBlocks(true);
            for (let o = 0, s; s = e[o]; o++) {
              let i = this.blockToCode(s);
              Array.isArray(i) && (i = i[0]), i && (s.outputConnection && (i = this.scrubNakedValue(i), this.STATEMENT_PREFIX && !s.suppressPrefixSuffix && (i = this.injectId(this.STATEMENT_PREFIX, s) + i), this.STATEMENT_SUFFIX && !s.suppressPrefixSuffix && (i += this.injectId(this.STATEMENT_SUFFIX, s))), t.push(i));
            }
            return t = t.join(`
`), t = this.finish(t), t = t.replace(/^\s+\n/, ""), t = t.replace(/\n\s+$/, `
`), t = t.replace(/[ \t]+\n/g, `
`);
          }
          prefixLines(e, t) {
            return t + e.replace(/(?!\n$)\n/g, `
` + t);
          }
          allNestedComments(e) {
            let t = [];
            e = e.getDescendants(true);
            for (let o = 0; o < e.length; o++) {
              let s = e[o].getCommentText();
              s && t.push(s);
            }
            return t.length && t.push(""), t.join(`
`);
          }
          blockToCode(e, t) {
            if (this.isInitialized === false && console.warn("CodeGenerator init was not called before blockToCode was called."), !e) return "";
            if (!e.isEnabled()) return t ? "" : this.blockToCode(e.getNextBlock());
            if (e.isInsertionMarker()) return t ? "" : this.blockToCode(e.getChildren(false)[0]);
            var o = this.forBlock[e.type];
            if (typeof o != "function") throw Error(`${this.name_} generator does not know how to generate code for block type "${e.type}".`);
            if (o = o.call(e, e, this), Array.isArray(o)) {
              if (!e.outputConnection) throw TypeError("Expecting string from statement block: " + e.type);
              return [this.scrub_(e, o[0], t), o[1]];
            }
            if (typeof o == "string") return this.STATEMENT_PREFIX && !e.suppressPrefixSuffix && (o = this.injectId(this.STATEMENT_PREFIX, e) + o), this.STATEMENT_SUFFIX && !e.suppressPrefixSuffix && (o += this.injectId(this.STATEMENT_SUFFIX, e)), this.scrub_(e, o, t);
            if (o === null) return "";
            throw SyntaxError("Invalid code generated: " + o);
          }
          valueToCode(e, t, o) {
            if (isNaN(o)) throw TypeError("Expecting valid order from block: " + e.type);
            var s = e.getInputTargetBlock(t);
            if (!s && !e.getInput(t)) throw ReferenceError(`Input "${t}" doesn't exist on "${e.type}"`);
            if (!s || (t = this.blockToCode(s), t === "")) return "";
            if (!Array.isArray(t)) throw TypeError(`Expecting tuple from value block: ${s.type} See developers.google.com/blockly/guides/create-custom-blocks/generating-code for more information`);
            if (e = t[0], t = t[1], isNaN(t)) throw TypeError("Expecting valid order from value block: " + s.type);
            if (!e) return "";
            s = false;
            var i = Math.floor(o);
            let n = Math.floor(t);
            if (i <= n && (i !== n || i !== 0 && i !== 99)) {
              for (s = true, i = 0; i < this.ORDER_OVERRIDES.length; i++) if (this.ORDER_OVERRIDES[i][0] === o && this.ORDER_OVERRIDES[i][1] === t) {
                s = false;
                break;
              }
            }
            return s && (e = "(" + e + ")"), e;
          }
          statementToCode(e, t) {
            let o = e.getInputTargetBlock(t);
            if (!o && !e.getInput(t)) throw ReferenceError(`Input "${t}" doesn't exist on "${e.type}"`);
            if (e = this.blockToCode(o), typeof e != "string") throw TypeError("Expecting code from statement block: " + (o && o.type));
            return e && (e = this.prefixLines(e, this.INDENT)), e;
          }
          addLoopTrap(e, t) {
            return this.INFINITE_LOOP_TRAP && (e = this.prefixLines(this.injectId(this.INFINITE_LOOP_TRAP, t), this.INDENT) + e), this.STATEMENT_SUFFIX && !t.suppressPrefixSuffix && (e = this.prefixLines(this.injectId(this.STATEMENT_SUFFIX, t), this.INDENT) + e), this.STATEMENT_PREFIX && !t.suppressPrefixSuffix && (e += this.prefixLines(this.injectId(this.STATEMENT_PREFIX, t), this.INDENT)), e;
          }
          injectId(e, t) {
            return t = t.id.replace(/\$/g, "$$$$"), e.replace(/%1/g, "'" + t + "'");
          }
          addReservedWords(e) {
            this.RESERVED_WORDS_ += e + ",";
          }
          provideFunction_(e, t) {
            if (!this.definitions_[e]) {
              let o = this.nameDB_.getDistinctName(e, r.NameType$$module$build$src$core$names.PROCEDURE);
              this.functionNames_[e] = o, Array.isArray(t) && (t = t.join(`
`)), t = t.trim().replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, o);
              let s;
              for (; s !== t; ) s = t, t = t.replace(/^(( {2})*) {2}/gm, "$1\0");
              t = t.replace(/\0/g, this.INDENT), this.definitions_[e] = t;
            }
            return this.functionNames_[e];
          }
          getVariableName(e) {
            return this.getName(e, r.NameType$$module$build$src$core$names.VARIABLE);
          }
          getProcedureName(e) {
            return this.getName(e, r.NameType$$module$build$src$core$names.PROCEDURE);
          }
          getName(e, t) {
            if (!this.nameDB_) throw Error("Name database is not defined. You must initialize `nameDB_` in your generator class and call `init` first.");
            return this.nameDB_.getName(e, t);
          }
          init(e) {
            this.definitions_ = /* @__PURE__ */ Object.create(null), this.functionNames_ = /* @__PURE__ */ Object.create(null);
          }
          scrub_(e, t, o) {
            return t;
          }
          finish(e) {
            return this.definitions_ = /* @__PURE__ */ Object.create(null), this.functionNames_ = /* @__PURE__ */ Object.create(null), e;
          }
          scrubNakedValue(e) {
            return e;
          }
        }, i_ = {}, i_.CodeGenerator = r.CodeGenerator$$module$build$src$core$generator;
        var Nl = class extends ir {
          constructor(e) {
            super(e);
          }
          setMetrics_(e) {
            if (this.isVisible()) {
              var t = this.workspace_.getMetricsManager(), o = t.getScrollMetrics(), s = t.getViewMetrics();
              t = t.getAbsoluteMetrics(), typeof e.y == "number" && (this.workspace_.scrollY = -(o.top + (o.height - s.height) * e.y)), this.workspace_.translate(this.workspace_.scrollX + t.left, this.workspace_.scrollY + t.top);
            }
          }
          getX() {
            if (!this.isVisible()) return 0;
            var e = this.targetWorkspace.getMetricsManager();
            let t = e.getAbsoluteMetrics(), o = e.getViewMetrics();
            return e = e.getToolboxMetrics(), this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? this.toolboxPosition_ === A.LEFT ? e.width : o.width - this.getWidth() : this.toolboxPosition_ === A.LEFT ? 0 : o.width : this.toolboxPosition_ === A.LEFT ? 0 : o.width + t.left - this.getWidth();
          }
          getY() {
            return 0;
          }
          position() {
            if (this.isVisible() && this.targetWorkspace.isVisible()) {
              var e = this.targetWorkspace.getMetricsManager().getViewMetrics();
              this.height_ = e.height;
              var t = this.getWidth() - this.CORNER_RADIUS;
              this.setBackgroundPath(t, e.height - 2 * this.CORNER_RADIUS), e = this.getX(), t = this.getY(), this.positionAt_(this.getWidth(), this.getHeight(), e, t);
            }
          }
          setBackgroundPath(e, t) {
            let o = this.toolboxPosition_ === A.RIGHT;
            var s = e + this.CORNER_RADIUS;
            s = ["M " + (o ? s : 0) + ",0"], s.push("h", o ? -e : e), s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, o ? 0 : 1, o ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS), s.push("v", Math.max(0, t)), s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, o ? 0 : 1, o ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS), s.push("h", o ? e : -e), s.push("z"), this.svgBackground_.setAttribute("d", s.join(" "));
          }
          scrollToStart() {
            let e;
            (e = this.workspace_.scrollbar) == null || e.setY(0);
          }
          wheel_(e) {
            var t = Xs(e);
            if (t.y) {
              let o = this.workspace_.getMetricsManager(), s = o.getScrollMetrics();
              t = o.getViewMetrics().top - s.top + t.y;
              let i;
              (i = this.workspace_.scrollbar) == null || i.setY(t), pi(this.workspace_), Tt();
            }
            e.preventDefault(), e.stopPropagation();
          }
          layout_(e) {
            this.workspace_.scale = this.targetWorkspace.scale;
            var t = this.MARGIN;
            let o = this.RTL ? t : t + this.tabWidth_;
            for (let s of e) s.getElement().moveBy(o, t), t += s.getElement().getBoundingRectangle().getHeight();
          }
          isDragTowardWorkspace(e) {
            e = Math.atan2(e.y, e.x) / Math.PI * 180;
            let t = this.dragAngleRange_;
            return e < t && e > -t || e < -180 + t || e > 180 - t;
          }
          getClientRect() {
            if (!this.svgGroup_ || this.autoClose || !this.isVisible()) return null;
            let e = this.svgGroup_.getBoundingClientRect(), t = e.left;
            return this.toolboxPosition_ === A.LEFT ? new L(-1e9, 1e9, -1e9, t + e.width) : new L(-1e9, 1e9, t, 1e9);
          }
          reflowInternal_() {
            this.workspace_.scale = this.getFlyoutScale();
            let e = this.getContents().reduce((t, o) => Math.max(t, o.getElement().getBoundingRectangle().getWidth()), 0);
            if (e += this.MARGIN * 1.5 + this.tabWidth_, e *= this.workspace_.scale, e += te.scrollbarThickness, this.getWidth() !== e) {
              if (this.RTL) for (let t of this.getContents()) {
                let o = t.getElement().getBoundingRectangle().left, s = e / this.workspace_.scale - t.getElement().getBoundingRectangle().getWidth() - this.MARGIN - this.tabWidth_;
                t.getElement().moveBy(s - o, 0);
              }
              this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== A.LEFT || this.targetWorkspace.translate(this.targetWorkspace.scrollX + e, this.targetWorkspace.scrollY), this.width_ = e, this.position(), this.targetWorkspace.resizeContents(), this.targetWorkspace.recordDragTargets();
            }
          }
        };
        Nl.registryName = "verticalFlyout", c(E.FLYOUTS_VERTICAL_TOOLBOX, Fe, Nl);
        var yf = {};
        yf.VerticalFlyout = Nl;
        var od = class extends ir {
          constructor(e) {
            super(e), this.horizontalLayout = true;
          }
          setMetrics_(e) {
            if (this.isVisible()) {
              var t = this.workspace_.getMetricsManager(), o = t.getScrollMetrics(), s = t.getViewMetrics();
              t = t.getAbsoluteMetrics(), typeof e.x == "number" && (this.workspace_.scrollX = -(o.left + (o.width - s.width) * e.x)), this.workspace_.translate(this.workspace_.scrollX + t.left, this.workspace_.scrollY + t.top);
            }
          }
          getX() {
            return 0;
          }
          getY() {
            if (!this.isVisible()) return 0;
            var e = this.targetWorkspace.getMetricsManager();
            let t = e.getAbsoluteMetrics(), o = e.getViewMetrics();
            e = e.getToolboxMetrics();
            let s = this.toolboxPosition_ === A.TOP;
            return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? s ? e.height : o.height - this.getHeight() : s ? 0 : o.height : s ? 0 : o.height + t.top - this.getHeight();
          }
          position() {
            if (this.isVisible() && this.targetWorkspace.isVisible()) {
              var e = this.targetWorkspace.getMetricsManager().getViewMetrics();
              this.width_ = e.width, e = e.width - 2 * this.CORNER_RADIUS;
              var t = this.getHeight() - this.CORNER_RADIUS;
              this.setBackgroundPath(e, t), e = this.getX(), t = this.getY(), this.positionAt_(this.getWidth(), this.getHeight(), e, t);
            }
          }
          setBackgroundPath(e, t) {
            let o = this.toolboxPosition_ === A.TOP, s = ["M 0," + (o ? 0 : this.CORNER_RADIUS)];
            o ? (s.push("h", e + 2 * this.CORNER_RADIUS), s.push("v", t), s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, this.CORNER_RADIUS), s.push("h", -e), s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, -this.CORNER_RADIUS)) : (s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, -this.CORNER_RADIUS), s.push("h", e), s.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, this.CORNER_RADIUS), s.push("v", t), s.push("h", -e - 2 * this.CORNER_RADIUS)), s.push("z"), this.svgBackground_.setAttribute("d", s.join(" "));
          }
          scrollToStart() {
            let e;
            (e = this.workspace_.scrollbar) == null || e.setX(this.RTL ? 1 / 0 : 0);
          }
          wheel_(e) {
            var t = Xs(e);
            if (t = t.x || t.y) {
              let o = this.workspace_.getMetricsManager(), s = o.getScrollMetrics();
              t = o.getViewMetrics().left - s.left + t;
              let i;
              (i = this.workspace_.scrollbar) == null || i.setX(t), pi(this.workspace_), Tt();
            }
            e.preventDefault(), e.stopPropagation();
          }
          layout_(e) {
            this.workspace_.scale = this.targetWorkspace.scale;
            let t = this.MARGIN, o = t + this.tabWidth_;
            this.RTL && (e = e.reverse());
            for (let s of e) e = s.getElement().getBoundingRectangle(), e = this.RTL ? o + e.getWidth() : o, s.getElement().moveBy(e, t), o += s.getElement().getBoundingRectangle().getWidth();
          }
          isDragTowardWorkspace(e) {
            e = Math.atan2(e.y, e.x) / Math.PI * 180;
            let t = this.dragAngleRange_;
            return e < 90 + t && e > 90 - t || e > -90 - t && e < -90 + t;
          }
          getClientRect() {
            if (!this.svgGroup_ || this.autoClose || !this.isVisible()) return null;
            let e = this.svgGroup_.getBoundingClientRect(), t = e.top;
            return this.toolboxPosition_ === A.TOP ? new L(-1e9, t + e.height, -1e9, 1e9) : new L(t, 1e9, -1e9, 1e9);
          }
          reflowInternal_() {
            this.workspace_.scale = this.getFlyoutScale();
            let e = this.getContents().reduce((t, o) => Math.max(t, o.getElement().getBoundingRectangle().getHeight()), 0);
            e += this.MARGIN * 1.5, e *= this.workspace_.scale, e += te.scrollbarThickness, this.getHeight() !== e && (this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== A.TOP || this.targetWorkspace.translate(this.targetWorkspace.scrollX, this.targetWorkspace.scrollY + e), this.height_ = e, this.position(), this.targetWorkspace.resizeContents(), this.targetWorkspace.recordDragTargets());
          }
        };
        c(E.FLYOUTS_HORIZONTAL_TOOLBOX, Fe, od);
        var Cf = {};
        Cf.HorizontalFlyout = od;
        var Gs = class extends be {
          constructor(e, t, o, s, i) {
            super(F.SKIP_SETUP), this.defaultType = "", this.variableTypes = [], this.variable = null, this.SERIALIZABLE = true, this.menuGenerator_ = Gs.dropdownCreate, this.defaultVariableName = typeof e == "string" ? e : "", this.size_ = new N(0, 0), e !== F.SKIP_SETUP && (i ? this.configure_(i) : this.setTypes(o, s), t && this.setValidator(t));
          }
          configure_(e) {
            super.configure_(e), this.setTypes(e.variableTypes, e.defaultType);
          }
          initModel() {
            var e = this.getSourceBlock();
            if (!e) throw new se();
            this.variable || (e = r.getOrCreateVariablePackage$$module$build$src$core$variables(e.workspace, null, this.defaultVariableName, this.defaultType), this.doValueUpdate_(e.getId()));
          }
          initView() {
            super.initView(), I(this.fieldGroup_, "blocklyVariableField");
          }
          shouldAddBorderRect_() {
            let e = this.getSourceBlock();
            if (!e) throw new se();
            return super.shouldAddBorderRect_() && (!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || e.type !== "variables_get");
          }
          fromXml(e) {
            var t = this.getSourceBlock();
            if (!t) throw new se();
            let o = e.getAttribute("id"), s = e.textContent, i = e.getAttribute("variabletype") || e.getAttribute("variableType") || "";
            if (t = r.getOrCreateVariablePackage$$module$build$src$core$variables(t.workspace, o, s, i), i !== null && i !== t.getType()) throw Error("Serialized variable type with id '" + t.getId() + "' had type " + t.getType() + ", and does not match variable field that references it: " + Et(e) + ".");
            this.setValue(t.getId());
          }
          toXml(e) {
            return this.initModel(), e.id = this.variable.getId(), e.textContent = this.variable.getName(), this.variable.getType() && e.setAttribute("variabletype", this.variable.getType()), e;
          }
          saveState(e) {
            var t = this.saveLegacyState(Gs);
            return t !== null || (this.initModel(), t = { id: this.variable.getId() }, e && (t.name = this.variable.getName(), t.type = this.variable.getType())), t;
          }
          loadState(e) {
            let t = this.getSourceBlock();
            if (!t) throw new se();
            this.loadLegacyState(Gs, e) || (e = r.getOrCreateVariablePackage$$module$build$src$core$variables(t.workspace, e.id || null, e.name, e.type || ""), this.setValue(e.getId()));
          }
          setSourceBlock(e) {
            if (e.isShadow()) throw Error("Variable fields are not allowed to exist on shadow blocks.");
            super.setSourceBlock(e);
          }
          getValue() {
            return this.variable ? this.variable.getId() : null;
          }
          getText() {
            return this.variable ? this.variable.getName() : "";
          }
          getVariable() {
            return this.variable;
          }
          getDefaultType() {
            return this.defaultType;
          }
          getValidator() {
            return this.variable ? this.validator_ : null;
          }
          doClassValidation_(e) {
            if (e === null) return null;
            var t = this.getSourceBlock();
            if (!t) throw new se();
            return t = r.getVariable$$module$build$src$core$variables(t.workspace, e), t ? (t = t.getType(), this.typeIsAllowed(t) ? e : (console.warn("Variable type doesn't match this field!  Type was " + t), null)) : (console.warn("Variable id doesn't point to a real variable! ID was " + e), null);
          }
          doValueUpdate_(e) {
            let t = this.getSourceBlock();
            if (!t) throw new se();
            this.variable = r.getVariable$$module$build$src$core$variables(t.workspace, e), super.doValueUpdate_(e);
          }
          typeIsAllowed(e) {
            let t = this.getVariableTypes();
            if (!t) return true;
            for (let o = 0; o < t.length; o++) if (e === t[o]) return true;
            return false;
          }
          getVariableTypes() {
            if (this.variableTypes) return this.variableTypes;
            if (!this.sourceBlock_ || this.sourceBlock_.isDeadOrDying()) return [""];
            let e = this.sourceBlock_.workspace.getVariableMap().getTypes();
            if (this.sourceBlock_.isInFlyout) {
              let t = this.sourceBlock_.workspace.getPotentialVariableMap();
              if (!t) return e;
              e = Array.from(/* @__PURE__ */ new Set([...e, ...t.getTypes()]));
            }
            return e;
          }
          setTypes(e = null, t = "") {
            var o = this.getText();
            if (Array.isArray(e)) {
              if (e.length === 0) throw Error(`'variableTypes' of field variable ${o} was an empty list. If you want to include all variable types, pass 'null' instead.`);
              o = false;
              for (let s = 0; s < e.length; s++) e[s] === t && (o = true);
              if (!o) throw Error("Invalid default type '" + t + "' in the definition of a FieldVariable");
            } else if (e !== null) throw Error(`'variableTypes' was not an array or null in the definition of FieldVariable ${o}`);
            this.defaultType = t, this.variableTypes = e;
          }
          refreshVariableName() {
            this.forceRerender();
          }
          onItemSelected_(e, t) {
            if (e = t.getValue(), this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying()) {
              if (e === Zi && this.variable) {
                r.renameVariable$$module$build$src$core$variables(this.sourceBlock_.workspace, this.variable);
                return;
              }
              if (e === Qi && this.variable) {
                e = this.variable.getWorkspace(), r.deleteVariable$$module$build$src$core$variables(e, this.variable, this.sourceBlock_);
                return;
              }
            }
            this.setValue(e);
          }
          referencesVariables() {
            return true;
          }
          static fromJson(e) {
            return new this(ie(e.variable), void 0, void 0, void 0, e);
          }
          static dropdownCreate() {
            if (!this.variable) throw Error("Tried to call dropdownCreate on a variable field with no variable selected.");
            let e = this.getText(), t = [];
            var o = this.getSourceBlock();
            if (o && !o.isDeadOrDying()) {
              o = o.workspace;
              let n = this.getVariableTypes();
              for (let l = 0; l < n.length; l++) {
                let a = n[l], _ = o.getVariableMap().getVariablesOfType(a);
                if (t = t.concat(_), o.isFlyout) {
                  var s = void 0, i = void 0;
                  t = t.concat((i = (s = o.getPotentialVariableMap()) == null ? void 0 : s.getVariablesOfType(a)) != null ? i : []);
                }
              }
            }
            for (t.sort(as), s = [], i = 0; i < t.length; i++) s[i] = [t[i].getName(), t[i].getId()];
            return s.push([r.Msg$$module$build$src$core$msg.RENAME_VARIABLE, Zi]), r.Msg$$module$build$src$core$msg.DELETE_VARIABLE && s.push([r.Msg$$module$build$src$core$msg.DELETE_VARIABLE.replace("%1", e), Qi]), s;
          }
        };
        bt("field_variable", Gs);
        var vf = {};
        vf.FieldVariable = Gs;
        var Al = class extends Zo {
          constructor(e, t, o, s, i, n) {
            super(F.SKIP_SETUP), this.min_ = -1 / 0, this.max_ = 1 / 0, this.precision_ = 0, this.decimalPlaces = null, this.spellcheck_ = false, e !== F.SKIP_SETUP && (n ? this.configure_(n) : this.setConstraints(t, o, s), this.setValue(e), i && this.setValidator(i));
          }
          configure_(e) {
            super.configure_(e), this.setMinInternal(e.min), this.setMaxInternal(e.max), this.setPrecisionInternal(e.precision);
          }
          setConstraints(e, t, o) {
            this.setMinInternal(e), this.setMaxInternal(t), this.setPrecisionInternal(o), this.setValue(this.getValue());
          }
          setMin(e) {
            this.setMinInternal(e), this.setValue(this.getValue());
          }
          setMinInternal(e) {
            e == null ? this.min_ = -1 / 0 : (e = Number(e), isNaN(e) || (this.min_ = e));
          }
          getMin() {
            return this.min_;
          }
          setMax(e) {
            this.setMaxInternal(e), this.setValue(this.getValue());
          }
          setMaxInternal(e) {
            e == null ? this.max_ = 1 / 0 : (e = Number(e), isNaN(e) || (this.max_ = e));
          }
          getMax() {
            return this.max_;
          }
          setPrecision(e) {
            this.setPrecisionInternal(e), this.setValue(this.getValue());
          }
          setPrecisionInternal(e) {
            this.precision_ = Number(e) || 0;
            let t = String(this.precision_);
            t.includes("e") && (t = this.precision_.toLocaleString("en-US", { maximumFractionDigits: 20 }));
            let o = t.indexOf(".");
            this.decimalPlaces = o === -1 ? e ? 0 : null : t.length - o - 1;
          }
          getPrecision() {
            return this.precision_;
          }
          doClassValidation_(e) {
            return e === null || (e = `${e}`.replace(/O/gi, "0"), e = e.replace(/,/g, ""), e = e.replace(/infinity/i, "Infinity"), e = Number(e || 0), isNaN(e)) ? null : (e = Math.min(Math.max(e, this.min_), this.max_), this.precision_ && isFinite(e) && (e = Math.round(e / this.precision_) * this.precision_), this.decimalPlaces !== null && (e = Number(e.toFixed(this.decimalPlaces))), e);
          }
          widgetCreate_() {
            let e = super.widgetCreate_();
            return this.min_ > -1 / 0 && (e.min = `${this.min_}`, ae(e, ne.VALUEMIN, this.min_)), this.max_ < 1 / 0 && (e.max = `${this.max_}`, ae(e, ne.VALUEMAX, this.max_)), e;
          }
          initView() {
            super.initView(), this.fieldGroup_ && I(this.fieldGroup_, "blocklyNumberField");
          }
          static fromJson(e) {
            return new this(e.value, void 0, void 0, void 0, void 0, e);
          }
        };
        bt("field_number", Al), Al.prototype.DEFAULT_VALUE = 0;
        var kf = {};
        kf.FieldNumber = Al;
        var sd = class extends uo {
          constructor(e, t, o) {
            super(String(e ?? ""), t, o), this.EDITABLE = false, this.SERIALIZABLE = true;
          }
          static fromJson(e) {
            return new this(ie(e.text), void 0, e);
          }
        };
        bt("field_label_serializable", sd);
        var Rf = {};
        Rf.FieldLabelSerializable = sd;
        var To = class extends F {
          constructor(e, t, o) {
            super(F.SKIP_SETUP), this.SERIALIZABLE = true, this.value_ = this.value_, this.checkChar = To.CHECK_CHAR, e !== F.SKIP_SETUP && (o && this.configure_(o), this.setValue(e), t && this.setValidator(t));
          }
          configure_(e) {
            super.configure_(e), e.checkCharacter && (this.checkChar = e.checkCharacter);
          }
          saveState() {
            let e = this.saveLegacyState(To);
            return e !== null ? e : this.getValueBoolean();
          }
          initView() {
            super.initView();
            let e = this.getTextElement();
            I(this.fieldGroup_, "blocklyCheckboxField"), e.style.display = this.value_ ? "block" : "none";
          }
          render_() {
            this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_()), this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET);
          }
          getDisplayText_() {
            return this.checkChar;
          }
          setCheckCharacter(e) {
            this.checkChar = e || To.CHECK_CHAR, this.forceRerender();
          }
          showEditor_() {
            this.setValue(!this.value_);
          }
          doClassValidation_(e) {
            return e === true || e === "TRUE" ? "TRUE" : e === false || e === "FALSE" ? "FALSE" : null;
          }
          doValueUpdate_(e) {
            this.value_ = this.convertValueToBool(e), this.textElement_ && (this.textElement_.style.display = this.value_ ? "block" : "none");
          }
          getValue() {
            return this.value_ ? "TRUE" : "FALSE";
          }
          getValueBoolean() {
            return this.value_;
          }
          getText() {
            return String(this.convertValueToBool(this.value_));
          }
          convertValueToBool(e) {
            return typeof e == "string" ? e === "TRUE" : !!e;
          }
          static fromJson(e) {
            return new this(e.checked, void 0, e);
          }
        };
        To.CHECK_CHAR = "\u2713", bt("field_checkbox", To), To.prototype.DEFAULT_VALUE = false;
        var Sf = {};
        Sf.FieldCheckbox = To;
        var id = class {
          constructor(e, t) {
            this.draggable = e, this.workspace = t, this.dragTarget = null, this.startLoc = e.getRelativeToSurfaceXY();
          }
          onDragStart(e) {
            r.getGroup$$module$build$src$core$events$utils() || r.setGroup$$module$build$src$core$events$utils(true), this.draggable.startDrag(e);
          }
          onDrag(e, t) {
            this.moveDraggable(e, t), t = this.getRoot(this.draggable), xe(t) && t.setDeleteStyle(this.wouldDeleteDraggable(e, t)), this.updateDragTarget(e);
          }
          updateDragTarget(e) {
            e = this.workspace.getDragTarget(e);
            let t = this.getRoot(this.draggable);
            if (this.dragTarget !== e) {
              let o;
              (o = this.dragTarget) == null || o.onDragExit(t), e?.onDragEnter(t);
            }
            e?.onDragOver(t), this.dragTarget = e;
          }
          moveDraggable(e, t) {
            t = this.pixelsToWorkspaceUnits(t), t = f.sum(this.startLoc, t), this.draggable.drag(t, e);
          }
          wouldDeleteDraggable(e, t) {
            return (e = this.workspace.getDragTarget(e)) && this.workspace.getComponentManager().hasCapability(e.id, j.Capability.DELETE_AREA) ? e.wouldDelete(t) : false;
          }
          onDragEnd(e) {
            let t = r.getGroup$$module$build$src$core$events$utils();
            var o = this.workspace.getDragTarget(e);
            let s = this.getRoot(this.draggable);
            if (o) {
              let i;
              (i = this.dragTarget) == null || i.onDrop(s);
            }
            this.shouldReturnToStart(e, s) && this.draggable.revertDrag(), (o = xe(s) && this.wouldDeleteDraggable(e, s)) && this.draggable instanceof z && dn(this.draggable.getRootBlock()), this.draggable.endDrag(e), o && xe(s) && (r.setGroup$$module$build$src$core$events$utils(t), s.dispose()), r.setGroup$$module$build$src$core$events$utils(false), !o && Wt(this.draggable) && r.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.draggable);
          }
          getRoot(e) {
            return e instanceof z ? e.getRootBlock() : e;
          }
          shouldReturnToStart(e, t) {
            return (e = this.workspace.getDragTarget(e)) ? e.shouldPreventMove(t) : false;
          }
          pixelsToWorkspaceUnits(e) {
            return e = new f(e.x / this.workspace.scale, e.y / this.workspace.scale), this.workspace.isMutator && e.scale(1 / this.workspace.options.parentWorkspace.scale), e;
          }
        };
        c(E.BLOCK_DRAGGER, Fe, id);
        var Of = {};
        Of.Dragger = id;
        var _r = {};
        _r.BlockDragStrategy = uh, _r.BubbleDragStrategy = ah, _r.CommentDragStrategy = ih, _r.Dragger = id;
        var Ml = class extends tt {
          constructor(e, t, o) {
            super(e ? e.workspace.id : void 0), this.type = d.BLOCK_DRAG, e && (this.blockId = e.id, this.isStart = t, this.blocks = o);
          }
          toJson() {
            let e = super.toJson();
            if (this.isStart === void 0) throw Error("Whether this event is the start of a drag is undefined. Either pass the value to the constructor, or call fromJson");
            if (this.blockId === void 0) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            return e.isStart = this.isStart, e.blockId = this.blockId, e.blocks = this.blocks, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Ml()), t.isStart = e.isStart, t.blockId = e.blockId, t.blocks = e.blocks, t;
          }
        };
        c(E.EVENT, d.BLOCK_DRAG, Ml);
        var wf = {};
        wf.BlockDrag = Ml;
        var Dl = class extends ro {
          constructor(e, t, o, s) {
            super(e), this.type = d.BLOCK_FIELD_INTERMEDIATE_CHANGE, this.recordUndo = false, e && (this.name = t, this.oldValue = o, this.newValue = s);
          }
          toJson() {
            let e = super.toJson();
            if (!this.name) throw Error("The changed field name is undefined. Either pass a name to the constructor, or call fromJson.");
            return e.name = this.name, e.oldValue = this.oldValue, e.newValue = this.newValue, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Dl()), t.name = e.name, t.oldValue = e.oldValue, t.newValue = e.newValue, t;
          }
          isNull() {
            return this.oldValue === this.newValue;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            if (t = t.getBlockById(this.blockId), !t) throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
            e = e ? this.newValue : this.oldValue, (t = t.getField(this.name)) ? t.setValue(e) : console.warn("Can't set non-existent field: " + this.name);
          }
        };
        c(E.EVENT, d.BLOCK_FIELD_INTERMEDIATE_CHANGE, Dl);
        var Lf = {};
        Lf.BlockFieldIntermediateChange = Dl;
        var Pl = class extends ro {
          constructor(e) {
            super(e), this.type = d.BLOCK_MOVE, e && (e.isShadow() && (this.recordUndo = false), e = this.currentLocation(), this.oldParentId = e.parentId, this.oldInputName = e.inputName, this.oldCoordinate = e.coordinate);
          }
          toJson() {
            let e = super.toJson();
            return e.oldParentId = this.oldParentId, e.oldInputName = this.oldInputName, this.oldCoordinate && (e.oldCoordinate = `${Math.round(this.oldCoordinate.x)}, ${Math.round(this.oldCoordinate.y)}`), e.newParentId = this.newParentId, e.newInputName = this.newInputName, this.newCoordinate && (e.newCoordinate = `${Math.round(this.newCoordinate.x)}, ${Math.round(this.newCoordinate.y)}`), this.reason && (e.reason = this.reason), this.recordUndo || (e.recordUndo = this.recordUndo), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Pl()), t.oldParentId = e.oldParentId, t.oldInputName = e.oldInputName, e.oldCoordinate && (o = e.oldCoordinate.split(","), t.oldCoordinate = new f(Number(o[0]), Number(o[1]))), t.newParentId = e.newParentId, t.newInputName = e.newInputName, e.newCoordinate && (o = e.newCoordinate.split(","), t.newCoordinate = new f(Number(o[0]), Number(o[1]))), e.reason !== void 0 && (t.reason = e.reason), e.recordUndo !== void 0 && (t.recordUndo = e.recordUndo), t;
          }
          recordNew() {
            let e = this.currentLocation();
            this.newParentId = e.parentId, this.newInputName = e.inputName, this.newCoordinate = e.coordinate;
          }
          setReason(e) {
            this.reason = e;
          }
          currentLocation() {
            var e = this.getEventWorkspace_();
            if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            var t = e.getBlockById(this.blockId);
            if (!t) throw Error("The block associated with the block move event could not be found");
            e = {};
            let o = t.getParent();
            return o ? (e.parentId = o.id, (t = o.getInputWithBlock(t)) && (e.inputName = t.name)) : e.coordinate = t.getRelativeToSurfaceXY(), e;
          }
          isNull() {
            return this.oldParentId === this.newParentId && this.oldInputName === this.newInputName && f.equals(this.oldCoordinate, this.newCoordinate);
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
            var o = t.getBlockById(this.blockId);
            if (o) {
              var s = e ? this.newParentId : this.oldParentId, i = e ? this.newInputName : this.oldInputName;
              if (e = e ? this.newCoordinate : this.oldCoordinate, s) {
                var n = t.getBlockById(s);
                if (!n) {
                  console.warn("Can't connect to non-existent block: " + s);
                  return;
                }
              }
              if (o.getParent() && o.unplug(), e) i = o.getRelativeToSurfaceXY(), o.moveBy(e.x - i.x, e.y - i.y, this.reason);
              else {
                t = o.outputConnection, (!t || o.previousConnection && o.previousConnection.isConnected()) && (t = o.previousConnection);
                let l, a;
                o = (a = t) == null ? void 0 : a.type, i ? (o = n.getInput(i)) && (l = o.connection) : o === C.PREVIOUS_STATEMENT && (l = n.nextConnection), l && t ? t.connect(l) : console.warn("Can't connect to non-existent input: " + i);
              }
            } else console.warn("Can't move non-existent block: " + this.blockId);
          }
        };
        c(E.EVENT, d.BLOCK_MOVE, Pl);
        var Nf = {};
        Nf.BlockMove = Pl;
        var Bl = class extends tt {
          constructor(e, t, o) {
            super(e ? e.workspace.id : void 0), this.type = d.BUBBLE_OPEN, e && (this.blockId = e.id, this.isOpen = t, this.bubbleType = o);
          }
          toJson() {
            let e = super.toJson();
            if (this.isOpen === void 0) throw Error("Whether this event is for opening the bubble is undefined. Either pass the value to the constructor, or call fromJson");
            if (!this.bubbleType) throw Error("The type of bubble is undefined. Either pass the value to the constructor, or call fromJson");
            return e.isOpen = this.isOpen, e.bubbleType = this.bubbleType, e.blockId = this.blockId || "", e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Bl()), t.isOpen = e.isOpen, t.bubbleType = e.bubbleType, t.blockId = e.blockId, t;
          }
        }, xl;
        (function(e) {
          e.MUTATOR = "mutator", e.COMMENT = "comment", e.WARNING = "warning";
        })(xl || (xl = {})), c(E.EVENT, d.BUBBLE_OPEN, Bl);
        var r_ = {};
        r_.BubbleOpen = Bl, r_.BubbleType = xl;
        var at = class extends Bo {
          constructor(e) {
            super(), this.isBlank = !e, e && (this.commentId = e.id, this.workspaceId = e.workspace.id, this.group = r.getGroup$$module$build$src$core$events$utils(), this.recordUndo = we());
          }
          toJson() {
            let e = super.toJson();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            return e.commentId = this.commentId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new at()), t.commentId = e.commentId, t;
          }
          static CommentCreateDeleteHelper(e, t) {
            let o = e.getEventWorkspace_();
            if (t) {
              if (!e.json) throw Error("Encountered a comment event without proper json");
              li(e.json, o);
            } else {
              if (!e.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              (t = o.getCommentById(e.commentId)) ? t.dispose() : console.warn("Can't delete non-existent comment: " + e.commentId);
            }
          }
        }, Af = {};
        Af.CommentBase = at;
        var Fl = class extends at {
          constructor(e, t, o) {
            super(e), this.type = d.COMMENT_CHANGE, e && (this.oldContents_ = typeof t > "u" ? "" : t, this.newContents_ = typeof o > "u" ? "" : o);
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldContents_) throw Error("The old contents is undefined. Either pass a value to the constructor, or call fromJson");
            if (!this.newContents_) throw Error("The new contents is undefined. Either pass a value to the constructor, or call fromJson");
            return e.oldContents = this.oldContents_, e.newContents = this.newContents_, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Fl()), t.oldContents_ = e.oldContents, t.newContents_ = e.newContents, t;
          }
          isNull() {
            return this.oldContents_ === this.newContents_;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            if (t = t.getCommentById(this.commentId)) {
              var o = e ? this.newContents_ : this.oldContents_;
              if (o === void 0) throw Error(e ? "The new contents is undefined. Either pass a value to the constructor, or call fromJson" : "The old contents is undefined. Either pass a value to the constructor, or call fromJson");
              t.setText(o);
            } else console.warn("Can't change non-existent comment: " + this.commentId);
          }
        };
        c(E.EVENT, d.COMMENT_CHANGE, Fl);
        var Mf = {};
        Mf.CommentChange = Fl;
        var Hl = class extends at {
          constructor(e, t) {
            super(e), this.newCollapsed = t, this.type = d.COMMENT_COLLAPSE;
          }
          toJson() {
            let e = super.toJson();
            if (this.newCollapsed === void 0) throw Error("The new collapse value undefined. Either call recordNew, or call fromJson");
            return e.newCollapsed = this.newCollapsed, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Hl()), t.newCollapsed = e.newCollapsed, t;
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            (t = t.getCommentById(this.commentId)) ? t.setCollapsed(e ? !!this.newCollapsed : !this.newCollapsed) : console.warn("Can't collapse or uncollapse non-existent comment: " + this.commentId);
          }
        };
        c(E.EVENT, d.COMMENT_COLLAPSE, Hl);
        var Df = {};
        Df.CommentCollapse = Hl;
        var Ul = class extends at {
          constructor(e) {
            super(e), this.type = d.COMMENT_CREATE, e && (this.xml = Ti(e), this.json = yo(e, { addCoordinates: true }));
          }
          toJson() {
            let e = super.toJson();
            if (!this.xml) throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
            if (!this.json) throw Error("The comment JSON is undefined. Either pass a block to the constructor, or call fromJson");
            return e.xml = Et(this.xml), e.json = this.json, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Ul()), t.xml = r.textToDom$$module$build$src$core$utils$xml(e.xml), t.json = e.json, t;
          }
          run(e) {
            at.CommentCreateDeleteHelper(this, e);
          }
        };
        c(E.EVENT, d.COMMENT_CREATE, Ul);
        var Pf = {};
        Pf.CommentCreate = Ul;
        var Gl = class extends at {
          constructor(e) {
            super(e), this.type = d.COMMENT_DELETE, e && (this.xml = Ti(e), this.json = yo(e, { addCoordinates: true }));
          }
          run(e) {
            at.CommentCreateDeleteHelper(this, !e);
          }
          toJson() {
            let e = super.toJson();
            if (!this.xml) throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
            if (!this.json) throw Error("The comment JSON is undefined. Either pass a block to the constructor, or call fromJson");
            return e.xml = Et(this.xml), e.json = this.json, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Gl()), t.xml = r.textToDom$$module$build$src$core$utils$xml(e.xml), t.json = e.json, t;
          }
        };
        c(E.EVENT, d.COMMENT_DELETE, Gl);
        var Bf = {};
        Bf.CommentDelete = Gl;
        var Vl = class extends tt {
          constructor(e, t) {
            super(e ? e.workspace.id : void 0), this.type = d.COMMENT_DRAG, e && (this.commentId = e.id, this.isStart = t);
          }
          toJson() {
            let e = super.toJson();
            if (this.isStart === void 0) throw Error("Whether this event is the start of a drag is undefined. Either pass the value to the constructor, or call fromJson");
            if (this.commentId === void 0) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            return e.isStart = this.isStart, e.commentId = this.commentId, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Vl()), t.isStart = e.isStart, t.commentId = e.commentId, t;
          }
        };
        c(E.EVENT, d.COMMENT_DRAG, Vl);
        var xf = {};
        xf.CommentDrag = Vl;
        var Wl = class extends at {
          constructor(e) {
            super(e), this.type = d.COMMENT_MOVE, e && (this.comment_ = e, this.oldCoordinate_ = e.getRelativeToSurfaceXY());
          }
          recordNew() {
            if (this.newCoordinate_) throw Error("Tried to record the new position of a comment on the same event twice.");
            if (!this.comment_) throw Error("The comment is undefined. Pass a comment to the constructor if you want to use the record functionality");
            this.newCoordinate_ = this.comment_.getRelativeToSurfaceXY();
          }
          setReason(e) {
            this.reason = e;
          }
          setOldCoordinate(e) {
            this.oldCoordinate_ = e;
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldCoordinate_) throw Error("The old comment position is undefined. Either pass a comment to the constructor, or call fromJson");
            if (!this.newCoordinate_) throw Error("The new comment position is undefined. Either call recordNew, or call fromJson");
            return e.oldCoordinate = `${Math.round(this.oldCoordinate_.x)}, ${Math.round(this.oldCoordinate_.y)}`, e.newCoordinate = Math.round(this.newCoordinate_.x) + "," + Math.round(this.newCoordinate_.y), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Wl()), o = e.oldCoordinate.split(","), t.oldCoordinate_ = new f(Number(o[0]), Number(o[1])), o = e.newCoordinate.split(","), t.newCoordinate_ = new f(Number(o[0]), Number(o[1])), t;
          }
          isNull() {
            return f.equals(this.oldCoordinate_, this.newCoordinate_);
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            if (t = t.getCommentById(this.commentId)) {
              if (e = e ? this.newCoordinate_ : this.oldCoordinate_, !e) throw Error("Either oldCoordinate_ or newCoordinate_ is undefined. Either pass a comment to the constructor and call recordNew, or call fromJson");
              t.moveTo(e);
            } else console.warn("Can't move non-existent comment: " + this.commentId);
          }
        };
        c(E.EVENT, d.COMMENT_MOVE, Wl);
        var Ff = {};
        Ff.CommentMove = Wl;
        var zl = class extends at {
          constructor(e) {
            super(e), this.type = d.COMMENT_RESIZE, e && (this.oldSize = e.getSize());
          }
          recordCurrentSizeAsNewSize() {
            if (this.newSize) throw Error("Tried to record the new size of a comment on the same event twice.");
            var e = this.getEventWorkspace_();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            if (e = e.getCommentById(this.commentId), !e) throw Error("The comment associated with the comment resize event could not be found");
            this.newSize = e.getSize();
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldSize) throw Error("The old comment size is undefined. Either pass a comment to the constructor, or call fromJson");
            if (!this.newSize) throw Error("The new comment size is undefined. Either call recordCurrentSizeAsNewSize, or call fromJson");
            return e.oldWidth = Math.round(this.oldSize.width), e.oldHeight = Math.round(this.oldSize.height), e.newWidth = Math.round(this.newSize.width), e.newHeight = Math.round(this.newSize.height), e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new zl()), t.oldSize = new N(e.oldWidth, e.oldHeight), t.newSize = new N(e.newWidth, e.newHeight), t;
          }
          isNull() {
            return N.equals(this.oldSize, this.newSize);
          }
          run(e) {
            var t = this.getEventWorkspace_();
            if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
            if (t = t.getCommentById(this.commentId)) {
              if (e = e ? this.newSize : this.oldSize, !e) throw Error("Either oldSize or newSize is undefined. Either pass a comment to the constructor and call recordCurrentSizeAsNewSize, or call fromJson");
              t.setSize(e);
            } else console.warn("Can't resize non-existent comment: " + this.commentId);
          }
        };
        c(E.EVENT, d.COMMENT_RESIZE, zl);
        var Hf = {};
        Hf.CommentResize = zl;
        var Xl = class extends tt {
          constructor(e, t, o) {
            super(o), this.type = d.TOOLBOX_ITEM_SELECT, this.oldItem = e ?? void 0, this.newItem = t ?? void 0;
          }
          toJson() {
            let e = super.toJson();
            return e.oldItem = this.oldItem, e.newItem = this.newItem, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Xl()), t.oldItem = e.oldItem, t.newItem = e.newItem, t;
          }
        };
        c(E.EVENT, d.TOOLBOX_ITEM_SELECT, Xl);
        var Uf = {};
        Uf.ToolboxItemSelect = Xl;
        var Yl = class extends qo {
          constructor(e, t, o) {
            super(e), this.oldType = t, this.newType = o, this.type = d.VAR_TYPE_CHANGE;
          }
          toJson() {
            let e = super.toJson();
            if (!this.oldType || !this.newType) throw Error("The variable's types are undefined. Either pass them to the constructor, or call fromJson");
            return e.oldType = this.oldType, e.newType = this.newType, e;
          }
          static fromJson(e, t, o) {
            return t = super.fromJson(e, t, o ?? new Yl()), t.oldType = e.oldType, t.newType = e.newType, t;
          }
          run(e) {
            let t = this.getEventWorkspace_();
            if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
            if (!this.oldType || !this.newType) throw Error("The variable's types are undefined. Either pass them to the constructor, or call fromJson");
            let o = t.getVariableMap().getVariableById(this.varId);
            o && (e ? t.getVariableMap().changeVariableType(o, this.newType) : t.getVariableMap().changeVariableType(o, this.oldType));
          }
        };
        c(E.EVENT, d.VAR_TYPE_CHANGE, Yl);
        var Gf = {};
        Gf.VarTypeChange = Yl;
        var rd = class extends Bo {
          constructor(e) {
            super(), this.isBlank = true, this.recordUndo = false, this.type = d.FINISHED_LOADING, this.isBlank = !!e, e && (this.workspaceId = e.id);
          }
        };
        c(E.EVENT, d.FINISHED_LOADING, rd);
        var Vf = {};
        Vf.FinishedLoading = rd;
        var n_, l_, c_, a_, u_, h_, d_, $_, p_, g_, m_, __, T_, E_, b_, f_, I_, y_, C_, v_, k_, R_, S_, O_, y;
        r.BLOCK_CHANGE$$module$build$src$core$events$events = d.BLOCK_CHANGE, r.BLOCK_CREATE$$module$build$src$core$events$events = d.BLOCK_CREATE, r.BLOCK_DELETE$$module$build$src$core$events$events = d.BLOCK_DELETE, n_ = d.BLOCK_DRAG, r.BLOCK_MOVE$$module$build$src$core$events$events = d.BLOCK_MOVE, l_ = d.BLOCK_FIELD_INTERMEDIATE_CHANGE, c_ = d.BUBBLE_OPEN, a_ = d.BLOCK_CHANGE, u_ = d.CLICK, h_ = d.COMMENT_CHANGE, d_ = d.COMMENT_CREATE, $_ = d.COMMENT_DELETE, p_ = d.COMMENT_MOVE, g_ = d.COMMENT_RESIZE, m_ = d.COMMENT_DRAG, __ = d.BLOCK_CREATE, T_ = d.BLOCK_DELETE, E_ = d.FINISHED_LOADING, b_ = d.BLOCK_MOVE, f_ = d.SELECTED, I_ = d.THEME_CHANGE, y_ = d.TOOLBOX_ITEM_SELECT, C_ = d.TRASHCAN_OPEN, v_ = d.UI, k_ = d.VAR_CREATE, R_ = d.VAR_DELETE, S_ = d.VAR_RENAME, O_ = d.VIEWPORT_CHANGE, y = {}, y.Abstract = Bo, y.BLOCK_CHANGE = r.BLOCK_CHANGE$$module$build$src$core$events$events, y.BLOCK_CREATE = r.BLOCK_CREATE$$module$build$src$core$events$events, y.BLOCK_DELETE = r.BLOCK_DELETE$$module$build$src$core$events$events, y.BLOCK_DRAG = n_, y.BLOCK_FIELD_INTERMEDIATE_CHANGE = l_, y.BLOCK_MOVE = r.BLOCK_MOVE$$module$build$src$core$events$events, y.BUBBLE_OPEN = c_, y.BUMP_EVENTS = vu, y.BlockBase = ro, y.BlockChange = no, y.BlockCreate = Jn, y.BlockDelete = sl, y.BlockDrag = Ml, y.BlockFieldIntermediateChange = Dl, y.BlockMove = Pl, y.BubbleOpen = Bl, y.BubbleType = xl, y.CHANGE = a_, y.CLICK = u_, y.COMMENT_CHANGE = h_, y.COMMENT_CREATE = d_, y.COMMENT_DELETE = $_, y.COMMENT_DRAG = m_, y.COMMENT_MOVE = p_, y.COMMENT_RESIZE = g_, y.CREATE = __, y.Click = Rn, y.ClickTarget = Sn, y.CommentBase = at, y.CommentChange = Fl, y.CommentCollapse = Hl, y.CommentCreate = Ul, y.CommentDelete = Gl, y.CommentDrag = Vl, y.CommentMove = Wl, y.CommentResize = zl, y.DELETE = T_, y.FINISHED_LOADING = E_, y.FinishedLoading = rd, y.MOVE = b_, y.SELECTED = f_, y.Selected = ol, y.THEME_CHANGE = I_, y.TOOLBOX_ITEM_SELECT = y_, y.TRASHCAN_OPEN = C_, y.ThemeChange = qn, y.ToolboxItemSelect = Xl, y.TrashcanOpen = vl, y.UI = v_, y.UiBase = tt, y.VAR_CREATE = k_, y.VAR_DELETE = R_, y.VAR_RENAME = S_, y.VIEWPORT_CHANGE = O_, y.VarBase = qo, y.VarCreate = Il, y.VarDelete = yl, y.VarRename = Cl, y.VarTypeChange = Yl, y.ViewportChange = Zn, y.clearPendingUndo = Cr, y.disable = r.disable$$module$build$src$core$events$utils, y.disableOrphans = oc, y.enable = r.enable$$module$build$src$core$events$utils, y.filter = yr, y.fire = R, y.fromJson = tc, y.get = S, y.getDescendantIds = js, y.getGroup = r.getGroup$$module$build$src$core$events$utils, y.getRecordUndo = we, y.isEnabled = J, y.setGroup = r.setGroup$$module$build$src$core$events$utils, y.setRecordUndo = r.setRecordUndo$$module$build$src$core$events$utils;
        var Rt = {};
        Rt.BottomRow = Jh, Rt.ConstantProvider = Kh, Rt.Drawer = jh, Rt.PathObject = ed, Rt.RenderInfo = Qh, Rt.Renderer = Ll, Rt.RightConnectionShape = qh, Rt.StatementInput = mr, Rt.TopRow = Zh, _u();
        var ge = {};
        ge.registerCleanup = tu, ge.registerCollapse = su, ge.registerCollapseExpandBlock = uu, ge.registerComment = cu, ge.registerCommentCreate = mu, ge.registerCommentDelete = pu, ge.registerCommentDuplicate = gu, ge.registerCommentOptions = mg, ge.registerDefaultOptions = _u, ge.registerDelete = du, ge.registerDeleteAll = nu, ge.registerDisable = hu, ge.registerDuplicate = lu, ge.registerExpand = iu, ge.registerHelp = $u, ge.registerInline = au, ge.registerRedo = eu, ge.registerUndo = Qa;
        var nd = "button", ld = class {
          load(e, t) {
            return e = new Re(t.getWorkspace(), t.targetWorkspace, e, false), e.show(), new Ko(e, nd);
          }
          gapForItem(e, t) {
            return t;
          }
          disposeItem(e) {
            e = e.getElement(), e instanceof Re && e.dispose();
          }
          getType() {
            return nd;
          }
        };
        c(E.FLYOUT_INFLATER, nd, ld);
        var Wf = {};
        Wf.ButtonFlyoutInflater = ld;
        var Tr = {};
        Tr.Bubble = B, Tr.MiniWorkspaceBubble = yt, Tr.TextBubble = hh, Tr.TextInputBubble = qi;
        var bL = {}, zf = "WORKSPACE_AT_BLOCK_CAPACITY", cd = "block", ad = class {
          constructor() {
            this.permanentlyDisabledBlocks = /* @__PURE__ */ new Set(), this.listeners = /* @__PURE__ */ new Map(), this.capacityWrapper = this.filterFlyoutBasedOnCapacity.bind(this);
          }
          load(e, t) {
            return this.setFlyout(t), e = this.createBlock(e, t.getWorkspace()), e.isEnabled() ? this.updateStateBasedOnCapacity(e) : this.permanentlyDisabledBlocks.add(e), e.getDescendants(false).forEach((o) => o.isInFlyout = true), this.addBlockListeners(e), new Ko(e, cd);
          }
          createBlock(e, t) {
            return e.blockxml ? (e = typeof e.blockxml == "string" ? r.textToDom$$module$build$src$core$utils$xml(e.blockxml) : e.blockxml, t = wo(e, t)) : (e.enabled === void 0 && (e.enabled = e.disabled !== "true" && e.disabled !== true), e.disabledReasons === void 0 && e.enabled === false && (e.disabledReasons = [Ke]), "x" in e && delete e.x, "y" in e && delete e.y, t = hs(e, t)), t;
          }
          gapForItem(e, t) {
            let o;
            return e.gap ? o = parseInt(String(e.gap)) : e.blockxml && (e = typeof e.blockxml == "string" ? r.textToDom$$module$build$src$core$utils$xml(e.blockxml) : e.blockxml, o = parseInt(e.getAttribute("gap"))), !o || isNaN(o) ? t : o;
          }
          disposeItem(e) {
            e = e.getElement(), e instanceof z && (this.removeListeners(e.id), e.dispose(false, false));
          }
          removeListeners(e) {
            let t;
            ((t = this.listeners.get(e)) != null ? t : []).forEach((o) => x(o)), this.listeners.delete(e);
          }
          setFlyout(e) {
            if (this.flyout !== e) {
              if (this.flyout) {
                let o;
                (o = this.flyout.targetWorkspace) == null || o.removeChangeListener(this.capacityWrapper);
              }
              this.flyout = e;
              var t;
              (t = this.flyout.targetWorkspace) == null || t.addChangeListener(this.capacityWrapper);
            }
          }
          updateStateBasedOnCapacity(e) {
            let t, o, s = (t = this.flyout) == null || (o = t.targetWorkspace) == null ? void 0 : o.isCapacityAvailable(ei(e));
            for (; e; ) e.setDisabledReason(!s, zf), e = e.getNextBlock();
          }
          addBlockListeners(e) {
            let t = [];
            t.push(w(e.getSvgRoot(), "pointerdown", e, (o) => {
              let s, i, n = (s = this.flyout) == null || (i = s.targetWorkspace) == null ? void 0 : i.getGesture(o);
              n && this.flyout && (n.setStartBlock(e), n.handleFlyoutStart(o, this.flyout));
            })), t.push(ze(e.getSvgRoot(), "pointermove", null, () => {
              let o, s;
              !((o = this.flyout) == null || (s = o.targetWorkspace) == null) && s.isDragging() || e.addSelect();
            })), t.push(ze(e.getSvgRoot(), "pointerleave", null, () => {
              let o, s;
              !((o = this.flyout) == null || (s = o.targetWorkspace) == null) && s.isDragging() || e.removeSelect();
            })), this.listeners.set(e.id, t);
          }
          filterFlyoutBasedOnCapacity(e) {
            !this.flyout || e && e.type !== d.BLOCK_CREATE && e.type !== d.BLOCK_DELETE || this.flyout.getWorkspace().getTopBlocks(false).forEach((t) => {
              this.permanentlyDisabledBlocks.has(t) || this.updateStateBasedOnCapacity(t);
            });
          }
          getType() {
            return cd;
          }
        };
        c(E.FLYOUT_INFLATER, cd, ad);
        var Xf = {};
        Xf.BlockFlyoutInflater = ad;
        var Yf = {};
        Yf.isPaster = Tu;
        var Kf = {};
        Kf.isRenderedElement = Eu;
        var ud = class extends ur {
          constructor() {
            super(), this.FIELD_TEXT_BASELINE_CENTER = false, this.DARK_PATH_OFFSET = 1, this.MAX_BOTTOM_WIDTH = 30, this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT / 2;
          }
          getCSS_(e) {
            return super.getCSS_(e).concat([`${e} .blocklyInsertionMarker>.blocklyPathLight,`, `${e} .blocklyInsertionMarker>.blocklyPathDark {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}"]);
          }
        }, jf = {};
        jf.ConstantProvider = ud;
        var hd = class {
          constructor(e) {
            this.inlineSteps_ = this.steps_ = "", this.info_ = e, this.RTL_ = this.info_.RTL, e = e.getRenderer(), this.constants_ = e.getConstants(), this.highlightConstants_ = e.getHighlightConstants(), this.highlightOffset = this.highlightConstants_.OFFSET, this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER, this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER, this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB, this.notchPaths_ = this.highlightConstants_.NOTCH, this.startPaths_ = this.highlightConstants_.START_HAT, this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH;
          }
          getPath() {
            return this.steps_ + `
` + this.inlineSteps_;
          }
          drawTopCorner(e) {
            this.steps_ += ee(e.xPos, this.info_.startY);
            for (let t = 0, o; o = e.elements[t]; t++) h.isLeftSquareCorner(o) ? this.steps_ += this.highlightConstants_.START_POINT : h.isLeftRoundedCorner(o) ? this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_) : h.isPreviousConnection(o) ? this.steps_ += this.notchPaths_.pathLeft : h.isHat(o) ? this.steps_ += this.startPaths_.path(this.RTL_) : h.isSpacer(o) && o.width !== 0 && (this.steps_ += O("H", o.xPos + o.width - this.highlightOffset));
            this.steps_ += O("H", e.xPos + e.width - this.highlightOffset);
          }
          drawJaggedEdge_(e) {
            this.info_.RTL && (this.steps_ += this.jaggedTeethPaths_.pathLeft + O("v", e.height - this.jaggedTeethPaths_.height - this.highlightOffset));
          }
          drawValueInput(e) {
            let t = e.getLastInput();
            if (this.RTL_) {
              let o = e.height - t.connectionHeight;
              this.steps_ += _e(t.xPos + t.width - this.highlightOffset, e.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_) + O("v", o);
            } else this.steps_ += _e(t.xPos + t.width, e.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_);
          }
          drawStatementInput(e) {
            let t = e.getLastInput();
            if (t) if (this.RTL_) {
              let o = e.height - 2 * this.insideCornerPaths_.height;
              this.steps_ += _e(t.xPos, e.yPos) + this.insideCornerPaths_.pathTop(this.RTL_) + O("v", o) + this.insideCornerPaths_.pathBottom(this.RTL_) + ft(e.width - t.xPos - this.insideCornerPaths_.width, 0);
            } else this.steps_ += _e(t.xPos, e.yPos + e.height) + this.insideCornerPaths_.pathBottom(this.RTL_) + ft(e.width - t.xPos - this.insideCornerPaths_.width, 0);
          }
          drawRightSideRow(e) {
            let t = e.xPos + e.width - this.highlightOffset;
            e instanceof Tl && e.followsStatement && (this.steps_ += O("H", t)), this.RTL_ && (this.steps_ += O("H", t), e.height > this.highlightOffset && (this.steps_ += O("V", e.yPos + e.height - this.highlightOffset)));
          }
          drawBottomRow(e) {
            if (this.RTL_) this.steps_ += O("V", e.baseline - this.highlightOffset);
            else {
              let t = this.info_.bottomRow.elements[0];
              h.isLeftSquareCorner(t) ? this.steps_ += _e(e.xPos + this.highlightOffset, e.baseline - this.highlightOffset) : h.isLeftRoundedCorner(t) && (this.steps_ += _e(e.xPos, e.baseline), this.steps_ += this.outsideCornerPaths_.bottomLeft());
            }
          }
          drawLeft() {
            var e = this.info_.outputConnection;
            e && (e = e.connectionOffsetY + e.height, this.RTL_ ? this.steps_ += _e(this.info_.startX, e) : (this.steps_ += _e(this.info_.startX + this.highlightOffset, this.info_.bottomRow.baseline - this.highlightOffset), this.steps_ += O("V", e)), this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_)), this.RTL_ || (e = this.info_.topRow, h.isLeftRoundedCorner(e.elements[0]) ? this.steps_ += O("V", this.outsideCornerPaths_.height) : this.steps_ += O("V", e.capline + this.highlightOffset));
          }
          drawInlineInput(e) {
            let t = this.highlightOffset, o = e.xPos + e.connectionWidth;
            var s = e.centerline - e.height / 2;
            let i = e.width - e.connectionWidth, n = s + t;
            this.RTL_ ? (s = e.connectionOffsetY - t, e = e.height - (e.connectionOffsetY + e.connectionHeight) + t, this.inlineSteps_ += _e(o - t, n) + O("v", s) + this.puzzleTabPaths_.pathDown(this.RTL_) + O("v", e) + O("h", i)) : this.inlineSteps_ += _e(e.xPos + e.width + t, n) + O("v", e.height) + O("h", -i) + _e(o, s + e.connectionOffsetY) + this.puzzleTabPaths_.pathDown(this.RTL_);
          }
        }, Jf = {};
        Jf.Highlighter = hd;
        var dd = class extends hr {
          constructor(e, t) {
            super(e, t), this.highlighter_ = new hd(t);
          }
          draw() {
            this.drawOutline_(), this.drawInternals_(), this.updateConnectionHighlights();
            let e = this.block_.pathObject;
            e.setPath(this.outlinePath_ + `
` + this.inlinePath_), e.setHighlightPath(this.highlighter_.getPath()), this.info_.RTL && e.flipRTL(), this.recordSizeOnBlock_();
          }
          drawTop_() {
            this.highlighter_.drawTopCorner(this.info_.topRow), this.highlighter_.drawRightSideRow(this.info_.topRow), super.drawTop_();
          }
          drawJaggedEdge_(e) {
            this.highlighter_.drawJaggedEdge_(e), super.drawJaggedEdge_(e);
          }
          drawValueInput_(e) {
            this.highlighter_.drawValueInput(e), super.drawValueInput_(e);
          }
          drawStatementInput_(e) {
            this.highlighter_.drawStatementInput(e), super.drawStatementInput_(e);
          }
          drawRightSideRow_(e) {
            this.highlighter_.drawRightSideRow(e), this.outlinePath_ += O("H", e.xPos + e.width) + O("V", e.yPos + e.height);
          }
          drawBottom_() {
            this.highlighter_.drawBottomRow(this.info_.bottomRow), super.drawBottom_();
          }
          drawLeft_() {
            this.highlighter_.drawLeft(), super.drawLeft_();
          }
          drawInlineInput_(e) {
            this.highlighter_.drawInlineInput(e), super.drawInlineInput_(e);
          }
          positionInlineInputConnection_(e) {
            let t = e.centerline - e.height / 2;
            if (e.connectionModel) {
              let o = e.xPos + e.connectionWidth + this.constants_.DARK_PATH_OFFSET;
              this.info_.RTL && (o *= -1), e.connectionModel.setOffsetInBlock(o, t + e.connectionOffsetY + this.constants_.DARK_PATH_OFFSET);
            }
          }
          positionStatementInputConnection_(e) {
            let t = e.getLastInput();
            if (t != null && t.connectionModel) {
              let o = e.xPos + e.statementEdge + t.notchOffset;
              o = this.info_.RTL ? o * -1 : o + this.constants_.DARK_PATH_OFFSET, t.connectionModel.setOffsetInBlock(o, e.yPos + this.constants_.DARK_PATH_OFFSET);
            }
          }
          positionExternalValueConnection_(e) {
            let t = e.getLastInput();
            if (t && t.connectionModel) {
              let o = e.xPos + e.width + this.constants_.DARK_PATH_OFFSET;
              this.info_.RTL && (o *= -1), t.connectionModel.setOffsetInBlock(o, e.yPos);
            }
          }
          positionNextConnection_() {
            let e = this.info_.bottomRow;
            if (e.connection) {
              let t = e.connection, o = t.xPos;
              t.connectionModel.setOffsetInBlock((this.info_.RTL ? -o : o) + this.constants_.DARK_PATH_OFFSET / 2, e.baseline + this.constants_.DARK_PATH_OFFSET);
            }
          }
        }, qf = {};
        qf.Drawer = dd;
        var $d = class {
          constructor(e) {
            this.OFFSET = 0.5, this.constantProvider = e, this.START_POINT = ee(this.OFFSET, this.OFFSET);
          }
          init() {
            this.INSIDE_CORNER = this.makeInsideCorner(), this.OUTSIDE_CORNER = this.makeOutsideCorner(), this.PUZZLE_TAB = this.makePuzzleTab(), this.NOTCH = this.makeNotch(), this.JAGGED_TEETH = this.makeJaggedTeeth(), this.START_HAT = this.makeStartHat();
          }
          makeInsideCorner() {
            let e = this.constantProvider.CORNER_RADIUS, t = this.OFFSET, o = (1 - Math.SQRT1_2) * (e + t) - t, s = ee(o, o) + re("a", "0 0,0", e, k(-o - t, e - o)), i = re("a", "0 0,0", e + t, k(e + t, e + t)), n = ee(o, -o) + re("a", "0 0,0", e + t, k(e - o, o + t));
            return { width: e + t, height: e, pathTop(l) {
              return l ? s : "";
            }, pathBottom(l) {
              return l ? i : n;
            } };
          }
          makeOutsideCorner() {
            let e = this.constantProvider.CORNER_RADIUS, t = this.OFFSET, o = (1 - Math.SQRT1_2) * (e - t) + t, s = ee(o, o) + re("a", "0 0,1", e - t, k(e - o, -o + t)), i = ee(t, e) + re("a", "0 0,1", e - t, k(e, -e + t)), n = -o, l = ee(o, n) + re("a", "0 0,1", e - t, k(-o + t, -n - e));
            return { height: e, topLeft(a) {
              return a ? s : i;
            }, bottomLeft() {
              return l;
            } };
          }
          makePuzzleTab() {
            let e = this.constantProvider.TAB_WIDTH, t = this.constantProvider.TAB_HEIGHT, o = ee(-2, -t + 2.5 + 0.9) + ft(e * -0.45, -2.1), s = O("v", 2.5) + ee(-e * 0.97, 2.5) + Le("q", [k(-e * 0.05, 10), k(e * 0.3, 9.5)]) + ee(e * 0.67, -1.9) + O("v", 2.5), i = O("v", -1.5) + ee(e * -0.92, -0.5) + Le("q", [k(e * -0.19, -5.5), k(0, -11)]) + ee(e * 0.92, 1), n = ee(-5, t - 0.7) + ft(e * 0.46, -2.1);
            return { width: e, height: t, pathUp(l) {
              return l ? o : i;
            }, pathDown(l) {
              return l ? s : n;
            } };
          }
          makeNotch() {
            return { pathLeft: O("h", this.OFFSET) + this.constantProvider.NOTCH.pathLeft };
          }
          makeJaggedTeeth() {
            return { pathLeft: ft(5.1, 2.6) + ee(-10.2, 6.8) + ft(5.1, 2.6), height: 12, width: 10.2 };
          }
          makeStartHat() {
            let e = this.constantProvider.START_HAT.height, t = ee(25, -8.7) + Le("c", [k(29.7, -6.2), k(57.2, -0.5), k(75, 8.7)]), o = Le("c", [k(17.8, -9.2), k(45.3, -14.9), k(75, -8.7)]) + _e(100.5, e + 0.5);
            return { path(s) {
              return s ? t : o;
            } };
          }
        }, Zf = {};
        Zf.HighlightConstantProvider = $d;
        var pd = class extends ml {
          constructor(e, t) {
            super(e, t), this.constants_ = e, this.connectedBlock && (this.width += this.constants_.DARK_PATH_OFFSET, this.height += this.constants_.DARK_PATH_OFFSET);
          }
        }, Qf = {};
        Qf.InlineInput = pd;
        var gd = class extends ar {
          constructor(e, t) {
            super(e, t), this.constants_ = e, this.connectedBlock && (this.height += this.constants_.DARK_PATH_OFFSET);
          }
        }, eI = {};
        eI.StatementInput = gd;
        var md = class extends Fs {
          constructor(e, t) {
            super(e, t), this.renderer_ = e;
          }
          getRenderer() {
            return this.renderer_;
          }
          populateBottomRow_() {
            super.populateBottomRow_(), this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1] instanceof Ae || (this.bottomRow.minHeight = this.constants_.MEDIUM_PADDING - this.constants_.DARK_PATH_OFFSET);
          }
          addInput_(e, t) {
            this.isInline && e instanceof r.ValueInput$$module$build$src$core$inputs$value_input ? (t.elements.push(new pd(this.constants_, e)), t.hasInlineInput = true) : e instanceof Ae ? (t.elements.push(new gd(this.constants_, e)), t.hasStatement = true) : e instanceof r.ValueInput$$module$build$src$core$inputs$value_input ? (t.elements.push(new pl(this.constants_, e)), t.hasExternalInput = true) : (e instanceof rt || e instanceof Ct) && (t.minHeight = Math.max(t.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT), t.hasDummyInput = true), this.isInline || t.align !== null || (t.align = e.align);
          }
          addElemSpacing_() {
            let e = false;
            for (let o = 0, s; s = this.rows[o]; o++) s.hasExternalInput && (e = true);
            for (let o = 0, s; s = this.rows[o]; o++) {
              var t = s.elements;
              if (s.elements = [], s.startsWithElemSpacer() && s.elements.push(new Me(this.constants_, this.getInRowSpacing_(null, t[0]))), t.length) {
                for (let i = 0; i < t.length - 1; i++) {
                  s.elements.push(t[i]);
                  let n = this.getInRowSpacing_(t[i], t[i + 1]);
                  s.elements.push(new Me(this.constants_, n));
                }
                s.elements.push(t[t.length - 1]), s.endsWithElemSpacer() && (t = this.getInRowSpacing_(t[t.length - 1], null), e && s.hasDummyInput && (t += this.constants_.TAB_WIDTH), s.elements.push(new Me(this.constants_, t)));
              }
            }
          }
          getInRowSpacing_(e, t) {
            if (!e) return t && h.isField(t) && t.isEditable ? this.constants_.MEDIUM_PADDING : t && h.isInlineInput(t) ? this.constants_.MEDIUM_LARGE_PADDING : t && h.isStatementInput(t) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
            if (!h.isInput(e) && (!t || h.isStatementInput(t))) return h.isField(e) && e.isEditable ? e.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : h.isIcon(e) ? this.constants_.LARGE_PADDING * 2 + 1 : h.isHat(e) ? this.constants_.NO_PADDING : h.isPreviousOrNextConnection(e) ? this.constants_.LARGE_PADDING : h.isLeftRoundedCorner(e) ? this.constants_.MIN_BLOCK_WIDTH : h.isJaggedEdge(e) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
            if (h.isInput(e) && !t) {
              if (h.isExternalInput(e)) return this.constants_.NO_PADDING;
              if (h.isInlineInput(e)) return this.constants_.LARGE_PADDING;
              if (h.isStatementInput(e)) return this.constants_.NO_PADDING;
            }
            if (!h.isInput(e) && t && h.isInput(t)) {
              if (h.isField(e) && e.isEditable) {
                if (h.isInlineInput(t) || h.isExternalInput(t)) return this.constants_.SMALL_PADDING;
              } else {
                if (h.isInlineInput(t) || h.isExternalInput(t)) return this.constants_.MEDIUM_LARGE_PADDING;
                if (h.isStatementInput(t)) return this.constants_.LARGE_PADDING;
              }
              return this.constants_.LARGE_PADDING - 1;
            }
            if (h.isIcon(e) && t && !h.isInput(t)) return this.constants_.LARGE_PADDING;
            if (h.isInlineInput(e) && t && h.isField(t)) return t.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
            if (h.isLeftSquareCorner(e) && t) {
              if (h.isHat(t)) return this.constants_.NO_PADDING;
              if (h.isPreviousConnection(t)) return t.notchOffset;
              if (h.isNextConnection(t)) return t.notchOffset + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;
            }
            if (h.isLeftRoundedCorner(e) && t) {
              if (h.isPreviousConnection(t)) return t.notchOffset - this.constants_.CORNER_RADIUS;
              if (h.isNextConnection(t)) return t.notchOffset - this.constants_.CORNER_RADIUS + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;
            }
            return h.isField(e) && t && h.isField(t) && e.isEditable === t.isEditable ? e.width === 0 ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING : t && h.isJaggedEdge(t) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
          }
          getSpacerRowHeight_(e, t) {
            return h.isTopRow(e) && h.isBottomRow(t) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : h.isTopRow(e) || h.isBottomRow(t) ? this.constants_.NO_PADDING : e.hasExternalInput && t.hasExternalInput ? this.constants_.LARGE_PADDING : !e.hasStatement && t.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : e.hasStatement && t.hasStatement || !e.hasStatement && t.hasDummyInput || e.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
          }
          getElemCenterline_(e, t) {
            if (h.isSpacer(t)) return e.yPos + t.height / 2;
            if (h.isBottomRow(e)) return e = e.yPos + e.height - e.descenderHeight, h.isNextConnection(t) ? e + t.height / 2 : e - t.height / 2;
            if (h.isTopRow(e)) return h.isHat(t) ? e.capline - t.height / 2 : e.capline + t.height / 2;
            let o = e.yPos;
            return h.isField(t) || h.isIcon(t) ? (o += t.height / 2, (e.hasInlineInput || e.hasStatement) && t.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <= e.height && (o += this.constants_.TALL_INPUT_FIELD_OFFSET_Y)) : o = h.isInlineInput(t) ? o + t.height / 2 : o + e.height / 2, o;
          }
          alignRowElements_() {
            if (this.isInline) {
              var e = 0, t = /* @__PURE__ */ new WeakMap(), o = null;
              for (let s = this.rows.length - 1, i; i = this.rows[s]; s--) t.set(i, e), h.isInputRow(i) && (i.hasStatement && this.alignStatementRow_(i), o && o.hasStatement && i.width < o.width ? t.set(i, o.width) : e = i.hasStatement ? i.width : Math.max(e, i.width), o = i);
              e = 0;
              for (let s = 0, i; i = this.rows[s]; s++) i.hasStatement ? e = this.getDesiredRowWidth_(i) : h.isSpacer(i) ? i.width = Math.max(e, t.get(i)) : (o = i.width, e = Math.max(e, t.get(i)) - o, e > 0 && this.addAlignmentPadding_(i, e), e = i.width);
            } else super.alignRowElements_();
          }
          getDesiredRowWidth_(e) {
            return this.isInline && e.hasStatement ? this.statementEdge + this.constants_.MAX_BOTTOM_WIDTH + this.startX : super.getDesiredRowWidth_(e);
          }
          finalize_() {
            let e = 0, t = 0;
            for (let s = 0, i; i = this.rows[s]; s++) {
              i.yPos = t, i.xPos = this.startX, t += i.height, e = Math.max(e, i.widthWithConnectedBlocks);
              var o = t - this.topRow.ascenderHeight;
              i === this.bottomRow && o < this.constants_.MIN_BLOCK_HEIGHT && (o = this.constants_.MIN_BLOCK_HEIGHT - o, this.bottomRow.height += o, t += o), this.recordElemPositions_(i);
            }
            this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (o = this.block_.nextConnection.targetBlock()) && (e = Math.max(e, o.getHeightWidth().width - this.constants_.DARK_PATH_OFFSET)), this.bottomRow.baseline = t - this.bottomRow.descenderHeight, this.widthWithChildren = e + this.startX + this.constants_.DARK_PATH_OFFSET, this.width += this.constants_.DARK_PATH_OFFSET, this.height = t + this.constants_.DARK_PATH_OFFSET, this.startY = this.topRow.capline;
          }
        }, tI = {};
        tI.RenderInfo = md;
        var _d = class extends dr {
          constructor(e, t, o) {
            super(e, t, o), this.constants = o, this.colourDark = "#000000", this.svgPathDark = b($.PATH, { class: "blocklyPathDark", transform: "translate(1,1)" }), this.svgRoot.insertBefore(this.svgPathDark, this.svgPath), this.svgPathLight = b($.PATH, { class: "blocklyPathLight" }, this.svgRoot);
          }
          setPath(e) {
            this.svgPath.setAttribute("d", e), this.svgPathDark.setAttribute("d", e);
          }
          setHighlightPath(e) {
            this.svgPathLight.setAttribute("d", e);
          }
          flipRTL() {
            this.svgPath.setAttribute("transform", "scale(-1 1)"), this.svgPathLight.setAttribute("transform", "scale(-1 1)"), this.svgPathDark.setAttribute("transform", "translate(1,1) scale(-1 1)");
          }
          applyColour(e) {
            if (this.svgPathLight.style.display = "", this.svgPathDark.style.display = "", !this.style.colourTertiary) throw Error("The renderer did not properly initialize the tertiary colour of the block style");
            this.svgPathLight.setAttribute("stroke", this.style.colourTertiary), this.svgPathDark.setAttribute("fill", this.colourDark), super.applyColour(e), this.svgPath.setAttribute("stroke", "none");
          }
          setStyle(e) {
            this.style = e, this.colourDark = So("#000", this.style.colourPrimary, 0.2) || this.colourDark;
          }
          updateHighlighted(e) {
            super.updateHighlighted(e), this.svgPathLight.style.display = e ? "none" : "inline";
          }
          updateShadow_(e) {
            if (e) {
              if (this.svgPathLight.style.display = "none", !this.style.colourSecondary) throw Error("The renderer did not properly initialize the secondary colour of the block style block style");
              this.svgPathDark.setAttribute("fill", this.style.colourSecondary), this.svgPath.setAttribute("stroke", "none"), this.svgPath.setAttribute("fill", this.style.colourSecondary);
            }
          }
          updateDisabled_(e) {
            super.updateDisabled_(e), e && this.svgPath.setAttribute("stroke", "none");
          }
        }, oI = {};
        oI.PathObject = _d;
        var Td = class extends $r {
          constructor(e) {
            super(e), this.highlightConstants = null;
          }
          init(e, t) {
            super.init(e, t), this.highlightConstants = this.makeHighlightConstants_(), this.highlightConstants.init();
          }
          refreshDom(e, t, o) {
            super.refreshDom(e, t, o), this.getHighlightConstants().init();
          }
          makeConstants_() {
            return new ud();
          }
          makeRenderInfo_(e) {
            return new md(this, e);
          }
          makeDrawer_(e, t) {
            return new dd(e, t);
          }
          makePathObject(e, t) {
            return new _d(e, t, this.getConstants());
          }
          makeHighlightConstants_() {
            return new $d(this.getConstants());
          }
          getHighlightConstants() {
            if (!this.highlightConstants) throw Error("Cannot access the highlight constants because init has not been called");
            return this.highlightConstants;
          }
        };
        yi("geras", Td);
        var sI = {};
        sI.Renderer = Td;
        var St = {};
        St.ConstantProvider = ud, St.Drawer = dd, St.HighlightConstantProvider = $d, St.Highlighter = hd, St.InlineInput = pd, St.PathObject = _d, St.RenderInfo = md, St.Renderer = Td, St.StatementInput = gd;
        var Ed = class extends Fs {
          constructor(e, t) {
            super(e, t);
          }
          getRenderer() {
            return this.renderer_;
          }
          addElemSpacing_() {
            let e = false;
            for (var t = 0; t < this.rows.length; t++) if (this.rows[t].hasExternalInput) {
              e = true;
              break;
            }
            for (t = 0; t < this.rows.length; t++) {
              let s = this.rows[t];
              var o = s.elements;
              if (s.elements = [], s.startsWithElemSpacer() && s.elements.push(new Me(this.constants_, this.getInRowSpacing_(null, o[0]))), o.length) {
                for (let i = 0; i < o.length - 1; i++) {
                  s.elements.push(o[i]);
                  let n = this.getInRowSpacing_(o[i], o[i + 1]);
                  s.elements.push(new Me(this.constants_, n));
                }
                s.elements.push(o[o.length - 1]), s.endsWithElemSpacer() && (o = this.getInRowSpacing_(o[o.length - 1], null), e && s.hasDummyInput && (o += this.constants_.TAB_WIDTH), s.elements.push(new Me(this.constants_, o)));
              }
            }
          }
          getInRowSpacing_(e, t) {
            if (!e) return t && h.isField(t) && t.isEditable ? this.constants_.MEDIUM_PADDING : t && h.isInlineInput(t) ? this.constants_.MEDIUM_LARGE_PADDING : t && h.isStatementInput(t) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
            if (!h.isInput(e) && !t) return h.isField(e) && e.isEditable ? e.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : h.isIcon(e) ? this.constants_.LARGE_PADDING * 2 + 1 : h.isHat(e) ? this.constants_.NO_PADDING : h.isPreviousOrNextConnection(e) ? this.constants_.LARGE_PADDING : h.isLeftRoundedCorner(e) ? this.constants_.MIN_BLOCK_WIDTH : h.isJaggedEdge(e) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
            if (h.isInput(e) && !t) {
              if (h.isExternalInput(e)) return this.constants_.NO_PADDING;
              if (h.isInlineInput(e)) return this.constants_.LARGE_PADDING;
              if (h.isStatementInput(e)) return this.constants_.NO_PADDING;
            }
            if (!h.isInput(e) && t && h.isInput(t)) {
              if (h.isField(e) && e.isEditable) {
                if (h.isInlineInput(t) || h.isExternalInput(t)) return this.constants_.SMALL_PADDING;
              } else {
                if (h.isInlineInput(t) || h.isExternalInput(t)) return this.constants_.MEDIUM_LARGE_PADDING;
                if (h.isStatementInput(t)) return this.constants_.LARGE_PADDING;
              }
              return this.constants_.LARGE_PADDING - 1;
            }
            if (h.isIcon(e) && t && !h.isInput(t)) return this.constants_.LARGE_PADDING;
            if (h.isInlineInput(e) && t && h.isField(t)) return t.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
            if (h.isLeftSquareCorner(e) && t) {
              if (h.isHat(t)) return this.constants_.NO_PADDING;
              if (h.isPreviousConnection(t) || h.isNextConnection(t)) return t.notchOffset;
            }
            return h.isLeftRoundedCorner(e) && t ? t.notchOffset - this.constants_.CORNER_RADIUS : h.isField(e) && t && h.isField(t) && e.isEditable === t.isEditable ? e.width === 0 ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING : t && h.isJaggedEdge(t) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
          }
          getSpacerRowHeight_(e, t) {
            return h.isTopRow(e) && h.isBottomRow(t) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : h.isTopRow(e) || h.isBottomRow(t) ? this.constants_.NO_PADDING : e.hasExternalInput && t.hasExternalInput ? this.constants_.LARGE_PADDING : !e.hasStatement && t.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : e.hasStatement && t.hasStatement || e.hasDummyInput || t.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
          }
          getElemCenterline_(e, t) {
            if (h.isSpacer(t)) return e.yPos + t.height / 2;
            if (h.isBottomRow(e)) return e = e.yPos + e.height - e.descenderHeight, h.isNextConnection(t) ? e + t.height / 2 : e - t.height / 2;
            if (h.isTopRow(e)) return h.isHat(t) ? e.capline - t.height / 2 : e.capline + t.height / 2;
            let o = e.yPos;
            return o = h.isField(t) && e.hasStatement ? o + (this.constants_.TALL_INPUT_FIELD_OFFSET_Y + t.height / 2) : o + e.height / 2;
          }
          finalize_() {
            let e = 0, t = 0;
            for (var o = 0; o < this.rows.length; o++) {
              let i = this.rows[o];
              i.yPos = t, i.xPos = this.startX, t += i.height, e = Math.max(e, i.widthWithConnectedBlocks);
              var s = t - this.topRow.ascenderHeight;
              i === this.bottomRow && s < this.constants_.MIN_BLOCK_HEIGHT && (s = this.constants_.MIN_BLOCK_HEIGHT - s, this.bottomRow.height += s, t += s), this.recordElemPositions_(i);
            }
            this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (o = this.block_.nextConnection.targetBlock()) && (e = Math.max(e, o.getHeightWidth().width)), this.bottomRow.baseline = t - this.bottomRow.descenderHeight, this.widthWithChildren = e + this.startX, this.height = t, this.startY = this.topRow.capline;
          }
        }, iI = {};
        iI.RenderInfo = Ed;
        var bd = class extends $r {
          constructor(e) {
            super(e);
          }
          makeRenderInfo_(e) {
            return new Ed(this, e);
          }
        };
        yi("thrasos", bd);
        var rI = {};
        rI.Renderer = bd;
        var fd = {};
        fd.RenderInfo = Ed, fd.Renderer = bd;
        var nI = { colour_blocks: { colourPrimary: "#CF63CF", colourSecondary: "#C94FC9", colourTertiary: "#BD42BD" }, list_blocks: { colourPrimary: "#9966FF", colourSecondary: "#855CD6", colourTertiary: "#774DCB" }, logic_blocks: { colourPrimary: "#4C97FF", colourSecondary: "#4280D7", colourTertiary: "#3373CC" }, loop_blocks: { colourPrimary: "#0fBD8C", colourSecondary: "#0DA57A", colourTertiary: "#0B8E69" }, math_blocks: { colourPrimary: "#59C059", colourSecondary: "#46B946", colourTertiary: "#389438" }, procedure_blocks: { colourPrimary: "#FF6680", colourSecondary: "#FF4D6A", colourTertiary: "#FF3355" }, text_blocks: { colourPrimary: "#FFBF00", colourSecondary: "#E6AC00", colourTertiary: "#CC9900" }, variable_blocks: { colourPrimary: "#FF8C1A", colourSecondary: "#FF8000", colourTertiary: "#DB6E00" }, variable_dynamic_blocks: { colourPrimary: "#FF8C1A", colourSecondary: "#FF8000", colourTertiary: "#DB6E00" }, hat_blocks: { colourPrimary: "#4C97FF", colourSecondary: "#4280D7", colourTertiary: "#3373CC", hat: "cap" } }, lI = { colour_category: { colour: "#CF63CF" }, list_category: { colour: "#9966FF" }, logic_category: { colour: "#4C97FF" }, loop_category: { colour: "#0fBD8C" }, math_category: { colour: "#59C059" }, procedure_category: { colour: "#FF6680" }, text_category: { colour: "#FFBF00" }, variable_category: { colour: "#FF8C1A" }, variable_dynamic_category: { colour: "#FF8C1A" } }, w_ = new ao("zelos", nI, lI), fL = { Zelos: w_ }, cI = { Classic: Ji, Zelos: w_ }, Kl = class {
          constructor(e, t, o) {
            this.id_ = e.toolboxitemid || Xe(), this.level_ = (this.parent_ = o || null) ? this.parent_.getLevel() + 1 : 0, this.toolboxItemDef_ = e, this.parentToolbox_ = t, this.workspace_ = this.parentToolbox_.getWorkspace();
          }
          init() {
          }
          getDiv() {
            return null;
          }
          getClickTarget() {
            return null;
          }
          getId() {
            return this.id_;
          }
          getParent() {
            return null;
          }
          getLevel() {
            return this.level_;
          }
          isSelectable() {
            return false;
          }
          isCollapsible() {
            return false;
          }
          dispose() {
          }
          setVisible_(e) {
          }
          getFocusableElement() {
            let e = this.getDiv();
            if (!e) throw Error("Trying to access toolbox item before DOM is initialized.");
            if (!(e instanceof HTMLElement)) throw Error("Toolbox item div is unexpectedly not an HTML element.");
            return e;
          }
          getFocusableTree() {
            return this.parentToolbox_;
          }
          onNodeFocus() {
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
        }, aI = {};
        aI.ToolboxItem = Kl;
        var Ze = class extends Kl {
          constructor(e, t, o) {
            super(e, t, o), this.colour_ = this.name_ = "", this.labelDom_ = this.iconDom_ = this.rowContents_ = this.rowDiv_ = this.htmlDiv_ = null, this.isDisabled_ = this.isHidden_ = false, this.flyoutItems_ = [], this.cssConfig_ = this.makeDefaultCssConfig_();
          }
          init() {
            this.parseCategoryDef_(this.toolboxItemDef_), this.parseContents_(this.toolboxItemDef_), this.createDom_(), this.toolboxItemDef_.hidden === "true" && this.hide();
          }
          makeDefaultCssConfig_() {
            return { container: "blocklyToolboxCategoryContainer", row: "blocklyToolboxCategory", rowcontentcontainer: "blocklyTreeRowContentContainer", icon: "blocklyToolboxCategoryIcon", label: "blocklyToolboxCategoryLabel", contents: "blocklyToolboxCategoryGroup", selected: "blocklyToolboxSelected", openicon: "blocklyToolboxCategoryIconOpen", closedicon: "blocklyToolboxCategoryIconClosed" };
          }
          parseContents_(e) {
            if ("custom" in e) this.flyoutItems_ = e.custom;
            else if (e = e.contents) for (let t = 0; t < e.length; t++) {
              let o = e[t];
              Array.isArray(this.flyoutItems_) && this.flyoutItems_.push(o);
            }
          }
          parseCategoryDef_(e) {
            this.name_ = "name" in e ? ie(e.name) : "", this.colour_ = this.getColour_(e), Object.assign(this.cssConfig_, e.cssconfig || e.cssConfig);
          }
          createDom_() {
            this.htmlDiv_ = this.createContainer_(), mt(this.htmlDiv_, Ue.TREEITEM), ae(this.htmlDiv_, ne.SELECTED, false), ae(this.htmlDiv_, ne.LEVEL, this.level_ + 1), this.rowDiv_ = this.createRowContainer_(), this.rowDiv_.style.pointerEvents = "auto", this.htmlDiv_.appendChild(this.rowDiv_), this.rowContents_ = this.createRowContentsContainer_(), this.rowContents_.style.pointerEvents = "none", this.rowDiv_.appendChild(this.rowContents_), this.iconDom_ = this.createIconDom_(), mt(this.iconDom_, Ue.PRESENTATION), this.rowContents_.appendChild(this.iconDom_), this.labelDom_ = this.createLabelDom_(this.name_), this.rowContents_.appendChild(this.labelDom_);
            let e = this.labelDom_.getAttribute("id");
            return e && ae(this.htmlDiv_, ne.LABELLEDBY, e), this.addColourBorder_(this.colour_), this.htmlDiv_;
          }
          createContainer_() {
            let e = document.createElement("div");
            e.tabIndex = -1, e.id = this.getId();
            let t = this.cssConfig_.container;
            return t && I(e, t), e;
          }
          createRowContainer_() {
            let e = document.createElement("div");
            var t = this.cssConfig_.row;
            return t && I(e, t), t = `${Ze.nestedPadding * this.getLevel()}px`, this.workspace_.RTL ? e.style.paddingRight = t : e.style.paddingLeft = t, e;
          }
          createRowContentsContainer_() {
            let e = document.createElement("div"), t = this.cssConfig_.rowcontentcontainer;
            return t && I(e, t), e;
          }
          createIconDom_() {
            let e = document.createElement("span");
            if (!this.parentToolbox_.isHorizontal()) {
              let t = this.cssConfig_.icon;
              t && I(e, t);
            }
            return e.style.display = "inline-block", e;
          }
          createLabelDom_(e) {
            let t = document.createElement("span");
            return t.setAttribute("id", this.getId() + ".label"), t.textContent = e, (e = this.cssConfig_.label) && I(t, e), t;
          }
          refreshTheme() {
            this.colour_ = this.getColour_(this.toolboxItemDef_), this.addColourBorder_(this.colour_);
          }
          addColourBorder_(e) {
            e && (e = Ze.borderWidth + "px solid " + (e || "#ddd"), this.workspace_.RTL ? this.rowDiv_.style.borderRight = e : this.rowDiv_.style.borderLeft = e);
          }
          getColour_(e) {
            let t = e.categorystyle || e.categoryStyle;
            if ((e = e.colour) && t) console.warn('Toolbox category "' + this.name_ + '" must not have both a style and a colour');
            else {
              if (t) return this.getColourfromStyle(t);
              if (e) return this.parseColour(e);
            }
            return "";
          }
          getColourfromStyle(e) {
            var t = this.workspace_.getTheme();
            if (e && t) {
              if ((t = t.categoryStyles[e]) && t.colour) return this.parseColour(t.colour);
              console.warn('Style "' + e + '" must exist and contain a colour value');
            }
            return "";
          }
          getClickTarget() {
            return this.rowDiv_;
          }
          parseColour(e) {
            if (e = ie(e), e == null || e === "") return "";
            var t = Number(e);
            return isNaN(t) ? (t = Ro(e)) ? t : (console.warn('Toolbox category "' + this.name_ + '" has unrecognized colour attribute: ' + e), "") : Qc(t);
          }
          openIcon_(e) {
            if (e) {
              var t = this.cssConfig_.closedicon;
              t && vr(e, t), (t = this.cssConfig_.openicon) && I(e, t);
            }
          }
          closeIcon_(e) {
            if (e) {
              var t = this.cssConfig_.openicon;
              t && vr(e, t), (t = this.cssConfig_.closedicon) && I(e, t);
            }
          }
          setVisible_(e) {
            this.htmlDiv_.style.display = e ? "block" : "none", this.isHidden_ = !e, this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection();
          }
          hide() {
            this.setVisible_(false);
          }
          show() {
            this.setVisible_(true);
          }
          isVisible() {
            return !this.isHidden_ && this.allAncestorsExpanded_();
          }
          allAncestorsExpanded_() {
            let e = this;
            for (; e.getParent(); ) if (e = e.getParent(), !e.isExpanded()) return false;
            return true;
          }
          isSelectable() {
            return this.isVisible() && !this.isDisabled_;
          }
          onClick(e) {
          }
          setSelected(e) {
            if (this.rowDiv_) {
              var t = this.cssConfig_.selected;
              if (e) {
                let o = this.parseColour(Ze.defaultBackgroundColour);
                this.rowDiv_.style.backgroundColor = this.colour_ || o, t && I(this.rowDiv_, t);
              } else this.rowDiv_.style.backgroundColor = "", t && P(this.rowDiv_, t);
              ae(this.htmlDiv_, ne.SELECTED, e);
            }
          }
          setDisabled(e) {
            this.isDisabled_ = e, this.getDiv().setAttribute("disabled", `${e}`), e ? this.getDiv().setAttribute("disabled", "true") : this.getDiv().removeAttribute("disabled");
          }
          getName() {
            return this.name_;
          }
          getParent() {
            return this.parent_;
          }
          getDiv() {
            return this.htmlDiv_;
          }
          getContents() {
            return this.flyoutItems_;
          }
          updateFlyoutContents(e) {
            this.flyoutItems_ = [], this.toolboxItemDef_ = typeof e == "string" ? { kind: this.toolboxItemDef_.kind, custom: e, id: this.toolboxItemDef_.id, categorystyle: this.toolboxItemDef_.categorystyle, colour: this.toolboxItemDef_.colour, cssconfig: this.toolboxItemDef_.cssconfig, hidden: this.toolboxItemDef_.hidden } : { kind: this.toolboxItemDef_.kind, name: "name" in this.toolboxItemDef_ ? this.toolboxItemDef_.name : "", contents: ri(e), id: this.toolboxItemDef_.id, categorystyle: this.toolboxItemDef_.categorystyle, colour: this.toolboxItemDef_.colour, cssconfig: this.toolboxItemDef_.cssconfig, hidden: this.toolboxItemDef_.hidden }, this.parseContents_(this.toolboxItemDef_);
          }
          dispose() {
            V(this.htmlDiv_);
          }
        };
        Ze.registrationName = "category", Ze.nestedPadding = 19, Ze.borderWidth = 8, Ze.defaultBackgroundColour = "#57e", pt(`
.blocklyToolboxCategory:not(.blocklyToolboxSelected):hover {
  background-color: rgba(255, 255, 255, .2);
}

.blocklyToolbox[layout="h"] .blocklyToolboxCategoryContainer {
  margin: 1px 5px 1px 0;
}

.blocklyToolbox[dir="RTL"][layout="h"] .blocklyToolboxCategoryContainer {
  margin: 1px 0 1px 5px;
}

.blocklyToolboxCategory {
  height: 22px;
  line-height: 22px;
  margin-bottom: 3px;
  padding-right: 8px;
  white-space: nowrap;
}

.blocklyToolbox[dir="RTL"] .blocklyToolboxCategory {
  margin-left: 8px;
  padding-right: 0;
}

.blocklyToolboxCategoryIcon {
  background-image: url(<<<PATH>>>/sprites.png);
  height: 16px;
  vertical-align: middle;
  visibility: hidden;
  width: 16px;
}

.blocklyToolboxCategoryIconClosed {
  background-position: -32px -1px;
}

.blocklyToolbox[dir="RTL"] .blocklyToolboxCategoryIconClosed {
  background-position: 0 -1px;
}

.blocklyToolboxSelected>.blocklyToolboxCategoryIconClosed {
  background-position: -32px -17px;
}

.blocklyToolbox[dir="RTL"] .blocklyToolboxSelected>.blocklyToolboxCategoryIconClosed {
  background-position: 0 -17px;
}

.blocklyToolboxCategoryIconOpen {
  background-position: -16px -1px;
}

.blocklyToolboxSelected>.blocklyToolboxCategoryIconOpen {
  background-position: -16px -17px;
}

.blocklyToolboxCategoryLabel {
  cursor: default;
  font: 16px sans-serif;
  padding: 0 3px;
  vertical-align: middle;
}

.blocklyToolboxDelete .blocklyToolboxCategoryLabel {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyToolboxSelected .blocklyToolboxCategoryLabel {
  color: #fff;
}
`), c(E.TOOLBOX_ITEM, Ze.registrationName, Ze);
        var uI = {};
        uI.ToolboxCategory = Ze;
        var Vs = class extends Kl {
          constructor(e, t) {
            super(e, t), this.cssConfig_ = { container: "blocklyTreeSeparator" }, this.htmlDiv = null, Object.assign(this.cssConfig_, e.cssconfig || e.cssConfig);
          }
          init() {
            this.createDom_();
          }
          createDom_() {
            let e = document.createElement("div");
            e.tabIndex = -1, e.id = this.getId();
            let t = this.cssConfig_.container;
            return t && I(e, t), this.htmlDiv = e;
          }
          getDiv() {
            return this.htmlDiv;
          }
          dispose() {
            V(this.htmlDiv);
          }
        };
        Vs.registrationName = "sep", pt(`
.blocklyTreeSeparator {
  border-bottom: solid #e5e5e5 1px;
  height: 0;
  margin: 5px 0;
}

.blocklyToolbox[layout="h"] .blocklyTreeSeparator {
  border-right: solid #e5e5e5 1px;
  border-bottom: none;
  height: auto;
  margin: 0 5px 0 5px;
  padding: 5px 0;
  width: 0;
}
`), c(E.TOOLBOX_ITEM, Vs.registrationName, Vs);
        var hI = {};
        hI.ToolboxSeparator = Vs;
        var Qo = class extends Ze {
          constructor(e, t, o) {
            super(e, t, o), this.subcategoriesDiv_ = null, this.expanded_ = false, this.toolboxItems_ = [];
          }
          makeDefaultCssConfig_() {
            let e = super.makeDefaultCssConfig_();
            return e.contents = "blocklyToolboxCategoryGroup", e;
          }
          parseContents_(e) {
            if ("custom" in e) this.flyoutItems_ = e.custom;
            else {
              let t = e.contents;
              if (t) {
                this.flyoutItems_ = [], e = true;
                for (let o = 0; o < t.length; o++) {
                  let s = t[o];
                  !G(E.TOOLBOX_ITEM, s.kind) || s.kind.toLowerCase() === Vs.registrationName && e ? (this.flyoutItems_.push(s), e = true) : (this.createToolboxItem(s), e = false);
                }
              }
            }
          }
          createToolboxItem(e) {
            let t = e.kind;
            t.toUpperCase() === "CATEGORY" && Mr(e) && (t = Qo.registrationName), e = new (Y(E.TOOLBOX_ITEM, t))(e, this.parentToolbox_, this), this.toolboxItems_.push(e);
          }
          init() {
            super.init(), this.setExpanded(this.toolboxItemDef_.expanded === "true" || this.toolboxItemDef_.expanded === true);
          }
          createDom_() {
            super.createDom_();
            let e = this.getChildToolboxItems();
            return this.subcategoriesDiv_ = this.createSubCategoriesDom_(e), mt(this.subcategoriesDiv_, Ue.GROUP), this.htmlDiv_.appendChild(this.subcategoriesDiv_), this.closeIcon_(this.iconDom_), ae(this.htmlDiv_, ne.EXPANDED, false), this.htmlDiv_;
          }
          createIconDom_() {
            let e = document.createElement("span");
            if (!this.parentToolbox_.isHorizontal()) {
              let t = this.cssConfig_.icon;
              t && I(e, t), e.style.visibility = "visible";
            }
            return e.style.display = "inline-block", e;
          }
          createSubCategoriesDom_(e) {
            let t = document.createElement("div");
            t.style.display = "none";
            var o = this.cssConfig_.contents;
            for (o && I(t, o), o = 0; o < e.length; o++) {
              let s = e[o];
              s.init();
              let i = s.getDiv();
              if (t.appendChild(i), s.getClickTarget) {
                let n;
                (n = s.getClickTarget()) == null || n.setAttribute("id", s.getId());
              }
            }
            return t;
          }
          setExpanded(e) {
            if (this.expanded_ !== e) {
              if (this.expanded_ = e) this.subcategoriesDiv_.style.display = "block", this.openIcon_(this.iconDom_);
              else {
                let t;
                (t = this.parentToolbox_.getFlyout()) == null || t.setVisible(false), this.subcategoriesDiv_.style.display = "none", this.closeIcon_(this.iconDom_);
              }
              ae(this.htmlDiv_, ne.EXPANDED, e), this.parentToolbox_.handleToolboxItemResize();
            }
          }
          setVisible_(e) {
            this.htmlDiv_.style.display = e ? "block" : "none";
            let t = this.getChildToolboxItems();
            for (let o = 0; o < t.length; o++) t[o].setVisible_(e);
            this.isHidden_ = !e, this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection();
          }
          isExpanded() {
            return this.expanded_;
          }
          isCollapsible() {
            return true;
          }
          onClick(e) {
            this.toggleExpanded();
          }
          toggleExpanded() {
            this.setExpanded(!this.expanded_);
          }
          getDiv() {
            return this.htmlDiv_;
          }
          getChildToolboxItems() {
            return this.toolboxItems_;
          }
        };
        Qo.registrationName = "collapsibleCategory", c(E.TOOLBOX_ITEM, Qo.registrationName, Qo);
        var dI = {};
        dI.CollapsibleToolboxCategory = Qo;
        var $I = {};
        $I.isSelectableToolboxItem = bu;
        var Id = class extends or {
          constructor(e) {
            super(), this.id = "toolbox", this.contentsDiv_ = this.HtmlDiv = null, this.isVisible_ = false, this.height_ = this.width_ = 0, this.flyout = null, this.contents = /* @__PURE__ */ new Map(), this.previouslySelectedItem_ = this.selectedItem_ = null, this.boundEvents_ = [], this.workspace_ = e, this.toolboxDef_ = e.options.languageTree || { contents: [] }, this.horizontalLayout = e.options.horizontalLayout, this.RTL = e.options.RTL, this.toolboxPosition = e.options.toolboxPosition;
          }
          onShortcut(e) {
            return false;
          }
          init() {
            var e = this.workspace_;
            let t = e.getParentSvg();
            this.flyout = this.createFlyout_(), this.HtmlDiv = this.createDom_(this.workspace_);
            let o = this.flyout.createDom("svg");
            I(o, "blocklyToolboxFlyout"), bo(o, t), this.setVisible(true), this.flyout.init(e), this.render(this.toolboxDef_), e = e.getThemeManager(), e.subscribe(this.HtmlDiv, "toolboxBackgroundColour", "background-color"), e.subscribe(this.HtmlDiv, "toolboxForegroundColour", "color"), this.workspace_.getComponentManager().addComponent({ component: this, weight: j.ComponentWeight.TOOLBOX_WEIGHT, capabilities: [j.Capability.AUTOHIDEABLE, j.Capability.DELETE_AREA, j.Capability.DRAG_TARGET] }), r.getFocusManager$$module$build$src$core$focus_manager().registerTree(this, true);
          }
          createDom_(e) {
            e = e.getParentSvg();
            let t = this.createContainer_();
            return t.id = Xe(), this.contentsDiv_ = this.createContentsContainer_(), mt(this.contentsDiv_, Ue.TREE), t.appendChild(this.contentsDiv_), e.parentNode.insertBefore(t, e), this.attachEvents_(t, this.contentsDiv_), t;
          }
          createContainer_() {
            let e = document.createElement("div");
            return e.setAttribute("layout", this.isHorizontal() ? "h" : "v"), I(e, "blocklyToolbox"), e.setAttribute("dir", this.RTL ? "RTL" : "LTR"), e;
          }
          createContentsContainer_() {
            let e = document.createElement("div");
            return I(e, "blocklyToolboxCategoryGroup"), this.isHorizontal() && (e.style.flexDirection = "row"), e;
          }
          attachEvents_(e, t) {
            e = w(e, "pointerdown", this, this.onClick_, false), this.boundEvents_.push(e), t = w(t, "keydown", this, this.onKeyDown_, false), this.boundEvents_.push(t);
          }
          onClick_(e) {
            if (Qe(e) || e.target === this.HtmlDiv) De().hideChaff(false);
            else {
              var t = e.target.getAttribute("id");
              t && (t = this.getToolboxItemById(t), t.isSelectable() && (this.setSelectedItem(t), t.onClick(e))), De().hideChaff(true);
            }
            Oe();
          }
          onKeyDown_(e) {
            let t = false;
            switch (e.key) {
              case "ArrowDown":
                t = this.selectNext();
                break;
              case "ArrowUp":
                t = this.selectPrevious();
                break;
              case "ArrowLeft":
                t = this.selectParent();
                break;
              case "ArrowRight":
                t = this.selectChild();
                break;
              case "Enter":
              case " ":
                this.selectedItem_ && this.selectedItem_.isCollapsible() && (this.selectedItem_.toggleExpanded(), t = true);
                break;
              default:
                t = false;
            }
            !t && this.selectedItem_ && this.selectedItem_.onKeyDown && (t = this.selectedItem_.onKeyDown(e)), t && e.preventDefault();
          }
          createFlyout_() {
            let e = this.workspace_, t = e.copyOptionsForFlyout();
            return t.toolboxPosition = e.options.toolboxPosition, new (e.horizontalLayout ? Ce(E.FLYOUTS_HORIZONTAL_TOOLBOX, e.options, true) : Ce(E.FLYOUTS_VERTICAL_TOOLBOX, e.options, true))(t);
          }
          render(e) {
            this.toolboxDef_ = e, this.contents.forEach((t) => t.dispose()), this.contents.clear(), this.renderContents_(e.contents), this.position(), this.handleToolboxItemResize();
          }
          renderContents_(e) {
            let t = document.createDocumentFragment();
            for (let o = 0; o < e.length; o++) this.createToolboxItem(e[o], t);
            this.contentsDiv_.appendChild(t);
          }
          createToolboxItem(e, t) {
            var o = e.kind;
            o.toUpperCase() === "CATEGORY" && Mr(e) && (o = Qo.registrationName), (o = Y(E.TOOLBOX_ITEM, o.toLowerCase())) && (e = new o(e, this), e.init(), this.addToolboxItem_(e), (o = e.getDiv()) && t.appendChild(o), e.getClickTarget() && e.getClickTarget().setAttribute("id", e.getId()));
          }
          addToolboxItem_(e) {
            if (this.contents.set(e.getId(), e), e.isCollapsible()) {
              e = e.getChildToolboxItems();
              for (let t = 0; t < e.length; t++) this.addToolboxItem_(e[t]);
            }
          }
          getToolboxItems() {
            return [...this.contents.values()];
          }
          addStyle(e) {
            e && this.HtmlDiv && I(this.HtmlDiv, e);
          }
          removeStyle(e) {
            e && this.HtmlDiv && P(this.HtmlDiv, e);
          }
          getClientRect() {
            if (!this.HtmlDiv || !this.isVisible_) return null;
            var e = this.HtmlDiv.getBoundingClientRect();
            let t = e.top, o = t + e.height, s = e.left;
            return e = s + e.width, this.toolboxPosition === A.TOP ? new L(-1e7, o, -1e7, 1e7) : this.toolboxPosition === A.BOTTOM ? new L(t, 1e7, -1e7, 1e7) : this.toolboxPosition === A.LEFT ? new L(-1e7, 1e7, -1e7, e) : new L(-1e7, 1e7, s, 1e7);
          }
          wouldDelete(e) {
            return e instanceof z ? this.updateWouldDelete_(!e.getParent() && e.isDeletable()) : this.updateWouldDelete_(xe(e) && e.isDeletable()), this.wouldDelete_;
          }
          onDragEnter(e) {
            this.updateCursorDeleteStyle_(true);
          }
          onDragExit(e) {
            this.updateCursorDeleteStyle_(false);
          }
          onDrop(e) {
            this.updateCursorDeleteStyle_(false);
          }
          updateWouldDelete_(e) {
            e !== this.wouldDelete_ && (this.updateCursorDeleteStyle_(false), this.wouldDelete_ = e, this.updateCursorDeleteStyle_(true));
          }
          updateCursorDeleteStyle_(e) {
            let t = this.wouldDelete_ ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
            e ? this.addStyle(t) : this.removeStyle(t);
          }
          getToolboxItemById(e) {
            return this.contents.get(e) || null;
          }
          getWidth() {
            return this.width_;
          }
          getHeight() {
            return this.height_;
          }
          getFlyout() {
            return this.flyout;
          }
          getWorkspace() {
            return this.workspace_;
          }
          getSelectedItem() {
            return this.selectedItem_;
          }
          getPreviouslySelectedItem() {
            return this.previouslySelectedItem_;
          }
          isHorizontal() {
            return this.horizontalLayout;
          }
          position() {
            let e = this.workspace_.getMetrics(), t = this.HtmlDiv;
            t && (this.horizontalLayout ? (t.style.left = "0", t.style.height = "auto", t.style.width = "100%", this.height_ = t.offsetHeight, this.width_ = e.viewWidth, this.toolboxPosition === A.TOP ? t.style.top = "0" : t.style.bottom = "0") : (this.toolboxPosition === A.RIGHT ? t.style.right = "0" : t.style.left = "0", t.style.height = "100%", this.width_ = t.offsetWidth, this.height_ = e.viewHeight), this.flyout.position());
          }
          handleToolboxItemResize() {
            let e = this.workspace_;
            var t = this.HtmlDiv.getBoundingClientRect();
            let o = this.getFlyout(), s = this.toolboxPosition === A.LEFT ? e.scrollX + t.width + (o != null && o.isVisible() ? o.getWidth() : 0) : e.scrollX;
            t = this.toolboxPosition === A.TOP ? e.scrollY + t.height + (o != null && o.isVisible() ? o.getHeight() : 0) : e.scrollY, e.translate(s, t), Yt(e);
          }
          clearSelection() {
            this.setSelectedItem(null);
          }
          refreshTheme() {
            this.contents.forEach((e) => {
              e.refreshTheme && e.refreshTheme();
            });
          }
          refreshSelection() {
            this.selectedItem_ && this.selectedItem_.isSelectable() && this.selectedItem_.getContents().length && this.flyout.show(this.selectedItem_.getContents());
          }
          setVisible(e) {
            this.isVisible_ !== e && (this.HtmlDiv.style.display = e ? "block" : "none", this.isVisible_ = e, this.workspace_.recordDragTargets());
          }
          autoHide(e) {
            !e && this.flyout && this.flyout.autoClose && this.clearSelection();
          }
          setSelectedItem(e) {
            let t = this.selectedItem_;
            !e && !t || e && !bu(e) || (this.shouldDeselectItem_(t, e) && t !== null && this.deselectItem_(t), this.shouldSelectItem_(t, e) && e !== null && this.selectItem_(t, e), this.updateFlyout_(t, e), this.fireSelectEvent(t, e));
          }
          shouldDeselectItem_(e, t) {
            return e !== null && (!e.isCollapsible() || e !== t);
          }
          shouldSelectItem_(e, t) {
            return t !== null && t !== e;
          }
          deselectItem_(e) {
            this.selectedItem_ = null, this.previouslySelectedItem_ = e, e.setSelected(false), ae(this.contentsDiv_, ne.ACTIVEDESCENDANT, "");
          }
          selectItem_(e, t) {
            this.selectedItem_ = t, this.previouslySelectedItem_ = e, t.setSelected(true), ae(this.contentsDiv_, ne.ACTIVEDESCENDANT, t.getId());
          }
          selectItemByPosition(e) {
            (e = this.getToolboxItems()[e]) && this.setSelectedItem(e);
          }
          updateFlyout_(e, t) {
            t && (e !== t || t.isCollapsible()) && t.getContents().length ? (this.flyout.show(t.getContents()), this.flyout.scrollToStart()) : this.flyout.hide();
          }
          fireSelectEvent(e, t) {
            let o = e && e.getName(), s = t && t.getName();
            e === t && (s = null), e = new (S(d.TOOLBOX_ITEM_SELECT))(o, s, this.workspace_.id), R(e);
          }
          selectParent() {
            return this.selectedItem_ ? this.selectedItem_.isCollapsible() && this.selectedItem_.isExpanded() ? (this.selectedItem_.toggleExpanded(), true) : this.selectedItem_.getParent() && this.selectedItem_.getParent().isSelectable() ? (this.setSelectedItem(this.selectedItem_.getParent()), true) : false : false;
          }
          selectChild() {
            if (!this.selectedItem_ || !this.selectedItem_.isCollapsible()) return false;
            let e = this.selectedItem_;
            return e.isExpanded() ? this.selectNext() : e.toggleExpanded(), true;
          }
          selectNext() {
            if (!this.selectedItem_) return false;
            let e = [...this.contents.values()], t = e.indexOf(this.selectedItem_) + 1;
            if (t > -1 && t < e.length) {
              let o = e[t];
              for (; o && !o.isSelectable(); ) o = e[++t];
              if (o && o.isSelectable()) return this.setSelectedItem(o), true;
            }
            return false;
          }
          selectPrevious() {
            if (!this.selectedItem_) return false;
            let e = [...this.contents.values()], t = e.indexOf(this.selectedItem_) - 1;
            if (t > -1 && t < e.length) {
              let o = e[t];
              for (; o && !o.isSelectable(); ) o = e[--t];
              if (o && o.isSelectable()) return this.setSelectedItem(o), true;
            }
            return false;
          }
          dispose() {
            this.workspace_.getComponentManager().removeComponent("toolbox"), this.flyout.dispose(), this.contents.forEach((e) => e.dispose());
            for (let e = 0; e < this.boundEvents_.length; e++) x(this.boundEvents_[e]);
            this.boundEvents_ = [], this.contents.clear(), this.HtmlDiv && (this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv), V(this.HtmlDiv)), r.getFocusManager$$module$build$src$core$focus_manager().unregisterTree(this);
          }
          getFocusableElement() {
            if (!this.HtmlDiv) throw Error("Toolbox DOM has not yet been created.");
            return this.HtmlDiv;
          }
          getFocusableTree() {
            return this;
          }
          onNodeFocus() {
          }
          onNodeBlur() {
          }
          canBeFocused() {
            return true;
          }
          getRootFocusableNode() {
            return this;
          }
          getRestoredFocusableNode(e) {
            if (!e || e === this) {
              let t;
              return (t = this.getToolboxItems().find((o) => o.isSelectable())) != null ? t : null;
            }
            return null;
          }
          getNestedTrees() {
            return [];
          }
          lookUpFocusableNode(e) {
            return this.getToolboxItemById(e);
          }
          onTreeFocus(e, t) {
            e !== this ? this.getSelectedItem() !== e && this.setSelectedItem(e) : this.clearSelection();
          }
          onTreeBlur(e) {
            let t;
            e && e === ((t = this.flyout) == null ? void 0 : t.getWorkspace()) || this.autoHide(false);
          }
        };
        pt(`
.blocklyToolboxDelete {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyToolboxGrab {
  cursor: url("<<<PATH>>>/handclosed.cur"), auto;
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

/* Category tree in Toolbox. */
.blocklyToolbox {
  box-sizing: border-box;
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  background-color: #ddd;
  overflow-x: visible;
  overflow-y: auto;
  padding: 4px 0 4px 0;
  position: absolute;
  z-index: 70;  /* so blocks go under toolbox when dragging */
  -webkit-tap-highlight-color: transparent;  /* issue #1345 */
}

.blocklyToolboxCategoryGroup {
  display: flex;
  flex-wrap: wrap;
  flex-direction: column;
}

.blocklyToolboxCategoryGroup:focus {
  outline: none;
}
`), c(E.TOOLBOX, Fe, Id);
        var pI = {};
        pI.Toolbox = Id;
        var IL = {}, gI = "12.3.1", mI = C.INPUT_VALUE, _I = C.OUTPUT_VALUE, TI = C.NEXT_STATEMENT, EI = C.PREVIOUS_STATEMENT, bI = A.TOP, fI = A.BOTTOM, II = A.LEFT, yI = A.RIGHT, yL = Yt, CL = De, vL = rs, kL = wr, RL = Or, SL = il, OL = Ut, wL = Zi, LL = Qi, NL = Cs, AL = xi, ML = Dn, DL = fl, PL = lr;
        Jo.prototype.newBlock = function(e, t) {
          return new Yo(this, e, t);
        }, Ie.prototype.newBlock = function(e, t) {
          return new z(this, e, t);
        }, Jo.prototype.newComment = function(e) {
          return new ji(this, e);
        }, Ie.prototype.newComment = function(e) {
          return new It(this, e);
        }, Ie.newTrashcan = function(e) {
          return new Gh(e);
        }, yt.prototype.newWorkspaceSvg = function(e) {
          return new Ie(e);
        }, r.Names$$module$build$src$core$names.prototype.populateProcedures = function(e) {
          e = fi(e), e = e[0].concat(e[1]);
          for (let t = 0; t < e.length; t++) this.getName(e[t][0], r.Names$$module$build$src$core$names.NameType.PROCEDURE);
        };
        var BL = fe, g = {};
        g.Block = Yo, g.BlockFlyoutInflater = ad, g.BlockNavigationPolicy = Th, g.BlockSvg = z, g.Blocks = K, g.ButtonFlyoutInflater = ld, g.COLLAPSED_FIELD_NAME = xi, g.COLLAPSED_INPUT_NAME = Cs, g.COLLAPSE_CHARS = il, g.CodeGenerator = r.CodeGenerator$$module$build$src$core$generator, g.CollapsibleToolboxCategory = Qo, g.ComponentManager = j, g.Connection = D, g.ConnectionChecker = xh, g.ConnectionDB = zo, g.ConnectionNavigationPolicy = bh, g.ConnectionType = C, g.ContextMenu = Wo, g.ContextMenuItems = ge, g.ContextMenuRegistry = M, g.Css = Mu, g.DELETE_VARIABLE_ID = Qi, g.DeleteArea = or, g.DragTarget = $h, g.DropDownDiv = fe, g.Events = y, g.Extensions = it, g.Field = F, g.FieldCheckbox = To, g.FieldDropdown = be, g.FieldImage = mo, g.FieldLabel = uo, g.FieldLabelSerializable = sd, g.FieldNavigationPolicy = fh, g.FieldNumber = Al, g.FieldTextInput = r.FieldTextInput$$module$build$src$core$field_textinput, g.FieldVariable = Gs, g.Flyout = ir, g.FlyoutButton = Re, g.FlyoutButtonNavigationPolicy = gh, g.FlyoutItem = Ko, g.FlyoutMetricsManager = ph, g.FlyoutNavigationPolicy = mh, g.FlyoutNavigator = vh, g.FlyoutSeparator = sr, g.FlyoutSeparatorNavigationPolicy = _h, g.FocusManager = Ee, g.FocusableTreeTraverser = de, g.Generator = r.CodeGenerator$$module$build$src$core$generator, g.Gesture = nr, g.Grid = ul, g.HorizontalFlyout = od, g.INPUT_VALUE = mI, g.Input = Xo, g.InsertionMarkerPreviewer = td, g.KeyboardNavigationController = Rh, g.LabelFlyoutInflater = Yh, g.LineCursor = hl, g.Marker = Oh, g.MarkerManager = dl, g.Menu = Nn, g.MenuItem = Bi, g.MetricsManager = ll, g.Msg = r.Msg$$module$build$src$core$msg, g.NEXT_STATEMENT = TI, g.Names = r.Names$$module$build$src$core$names, g.Navigator = cl, g.OPPOSITE_TYPE = Ut, g.OUTPUT_VALUE = _I, g.Options = st, g.PREVIOUS_STATEMENT = EI, g.PROCEDURE_CATEGORY_NAME = lr, g.Procedures = Se, g.RENAME_VARIABLE_ID = Zi, g.RenderedConnection = pe, g.Scrollbar = te, g.ScrollbarPair = al, g.SeparatorFlyoutInflater = kh, g.ShortcutItems = kt, g.ShortcutRegistry = W, g.TOOLBOX_AT_BOTTOM = fI, g.TOOLBOX_AT_LEFT = II, g.TOOLBOX_AT_RIGHT = yI, g.TOOLBOX_AT_TOP = bI, g.Theme = ao, g.ThemeManager = Bh, g.Themes = cI, g.Toast = io, g.Toolbox = Id, g.ToolboxCategory = Ze, g.ToolboxItem = Kl, g.ToolboxSeparator = Vs, g.Tooltip = Ge, g.Touch = Do, g.Trashcan = Gh, g.UnattachedFieldError = se, g.VARIABLE_CATEGORY_NAME = Dn, g.VARIABLE_DYNAMIC_CATEGORY_NAME = fl, g.VERSION = gI, g.VariableMap = Uh, g.VariableModel = Hh, g.Variables = le, g.VariablesDynamic = po, g.VerticalFlyout = Nl, g.WidgetDiv = ot, g.Workspace = Jo, g.WorkspaceAudio = Fh, g.WorkspaceDragger = Sh, g.WorkspaceNavigationPolicy = Ch, g.WorkspaceSvg = Ie, g.Xml = ke, g.ZoomControls = Bu, g.blockAnimations = tr, g.blockRendering = U, g.browserEvents = Mt, g.bubbles = Tr, g.bumpObjects = nl, g.clipboard = ct, g.comments = go, g.common = $e, g.config = r.config$$module$build$src$core$config, g.constants = RT, g.defineBlocksWithJsonArray = wr, g.dialog = Ft, g.dragging = _r, g.fieldRegistry = Qn, g.geras = St, g.getFocusManager = r.getFocusManager$$module$build$src$core$focus_manager, g.getMainWorkspace = De, g.getSelected = rs, g.hasBubble = qt, g.hideChaff = _g, g.icons = ho, g.inject = Za, g.inputs = _o, g.isCopyable = fs, g.isDeletable = xe, g.isDraggable = Ao, g.isIcon = hn, g.isObservable = bi, g.isPaster = Tu, g.isRenderedElement = Eu, g.isSelectable = qs, g.isSerializable = cs, g.isVariableBackedParameterModel = Vr, g.keyboardNavigationController = rr, g.layers = PT, g.navigateBlock = Ye, g.navigateStacks = No, g.procedures = Se, g.registry = At, g.renderManagement = Mn, g.serialization = lf, g.setLocale = zu, g.setParentContainer = Or, g.svgResize = Yt, g.thrasos = fd, g.uiPosition = Fo, g.utils = Z, g.zelos = Rt;
        var xL = {}, FL = {}, HL = {}, UL = {}, GL = {}, VL = {}, WL = {}, zL = {}, XL = {}, YL = {}, KL = {}, jL = {}, JL = {}, qL = {}, ZL = {}, QL = {}, CI = {};
        CI.isFocusableTree = Tg;
        var eN = {}, tN = {}, oN = {}, sN = {}, iN = {}, rN = {}, nN = {}, lN = {}, cN = {}, aN = {}, uN = {}, hN = {};
        return g.__namespace__ = r, g;
      });
    });
    var z_ = D_((Rd, W_) => {
      (function(r, c) {
        if (typeof define == "function" && define.amd) define([], c);
        else if (typeof Rd == "object") W_.exports = c();
        else {
          var u = c();
          for (var p in u) r.Blockly.Msg[p] = u[p];
        }
      })(Rd, function() {
        "use strict";
        var r = r || { Msg: /* @__PURE__ */ Object.create(null) };
        return r.Msg.ADD_COMMENT = "Add Comment", r.Msg.ALT_KEY = "Alt", r.Msg.CANNOT_DELETE_VARIABLE_PROCEDURE = "Can't delete the variable '%1' because it's part of the definition of the function '%2'", r.Msg.CHANGE_VALUE_TITLE = "Change value:", r.Msg.CHROME_OS = "ChromeOS", r.Msg.CLEAN_UP = "Clean up Blocks", r.Msg.CLOSE = "Close", r.Msg.COLLAPSED_WARNINGS_WARNING = "Collapsed blocks contain warnings.", r.Msg.COLLAPSE_ALL = "Collapse Blocks", r.Msg.COLLAPSE_BLOCK = "Collapse Block", r.Msg.COLOUR_BLEND_COLOUR1 = "colour 1", r.Msg.COLOUR_BLEND_COLOUR2 = "colour 2", r.Msg.COLOUR_BLEND_HELPURL = "https://meyerweb.com/eric/tools/color-blend/#:::rgbp", r.Msg.COLOUR_BLEND_RATIO = "ratio", r.Msg.COLOUR_BLEND_TITLE = "blend", r.Msg.COLOUR_BLEND_TOOLTIP = "Blends two colours together with a given ratio (0.0 - 1.0).", r.Msg.COLOUR_PICKER_HELPURL = "https://en.wikipedia.org/wiki/Color", r.Msg.COLOUR_PICKER_TOOLTIP = "Choose a colour from the palette.", r.Msg.COLOUR_RANDOM_HELPURL = "http://randomcolour.com", r.Msg.COLOUR_RANDOM_TITLE = "random colour", r.Msg.COLOUR_RANDOM_TOOLTIP = "Choose a colour at random.", r.Msg.COLOUR_RGB_BLUE = "blue", r.Msg.COLOUR_RGB_GREEN = "green", r.Msg.COLOUR_RGB_HELPURL = "https://www.december.com/html/spec/colorpercompact.html", r.Msg.COLOUR_RGB_RED = "red", r.Msg.COLOUR_RGB_TITLE = "colour with", r.Msg.COLOUR_RGB_TOOLTIP = "Create a colour with the specified amount of red, green, and blue. All values must be between 0 and 100.", r.Msg.COMMAND_KEY = "\u2318 Command", r.Msg.CONTROLS_FLOW_STATEMENTS_HELPURL = "https://github.com/google/blockly/wiki/Loops#loop-termination-blocks", r.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK = "break out of loop", r.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE = "continue with next iteration of loop", r.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK = "Break out of the containing loop.", r.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE = "Skip the rest of this loop, and continue with the next iteration.", r.Msg.CONTROLS_FLOW_STATEMENTS_WARNING = "Warning: This block may only be used within a loop.", r.Msg.CONTROLS_FOREACH_HELPURL = "https://github.com/google/blockly/wiki/Loops#for-each", r.Msg.CONTROLS_FOREACH_TITLE = "for each item %1 in list %2", r.Msg.CONTROLS_FOREACH_TOOLTIP = "For each item in a list, set the variable '%1' to the item, and then do some statements.", r.Msg.CONTROLS_FOR_HELPURL = "https://github.com/google/blockly/wiki/Loops#count-with", r.Msg.CONTROLS_FOR_TITLE = "count with %1 from %2 to %3 by %4", r.Msg.CONTROLS_FOR_TOOLTIP = "Have the variable '%1' take on the values from the start number to the end number, counting by the specified interval, and do the specified blocks.", r.Msg.CONTROLS_IF_ELSEIF_TOOLTIP = "Add a condition to the if block.", r.Msg.CONTROLS_IF_ELSE_TOOLTIP = "Add a final, catch-all condition to the if block.", r.Msg.CONTROLS_IF_HELPURL = "https://github.com/google/blockly/wiki/IfElse", r.Msg.CONTROLS_IF_IF_TOOLTIP = "Add, remove, or reorder sections to reconfigure this if block.", r.Msg.CONTROLS_IF_MSG_ELSE = "else", r.Msg.CONTROLS_IF_MSG_ELSEIF = "else if", r.Msg.CONTROLS_IF_MSG_IF = "if", r.Msg.CONTROLS_IF_TOOLTIP_1 = "If a value is true, then do some statements.", r.Msg.CONTROLS_IF_TOOLTIP_2 = "If a value is true, then do the first block of statements. Otherwise, do the second block of statements.", r.Msg.CONTROLS_IF_TOOLTIP_3 = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements.", r.Msg.CONTROLS_IF_TOOLTIP_4 = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements. If none of the values are true, do the last block of statements.", r.Msg.CONTROLS_REPEAT_HELPURL = "https://en.wikipedia.org/wiki/For_loop", r.Msg.CONTROLS_REPEAT_INPUT_DO = "do", r.Msg.CONTROLS_REPEAT_TITLE = "repeat %1 times", r.Msg.CONTROLS_REPEAT_TOOLTIP = "Do some statements several times.", r.Msg.CONTROLS_WHILEUNTIL_HELPURL = "https://github.com/google/blockly/wiki/Loops#repeat", r.Msg.CONTROLS_WHILEUNTIL_OPERATOR_UNTIL = "repeat until", r.Msg.CONTROLS_WHILEUNTIL_OPERATOR_WHILE = "repeat while", r.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL = "While a value is false, then do some statements.", r.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_WHILE = "While a value is true, then do some statements.", r.Msg.CONTROL_KEY = "Ctrl", r.Msg.COPY_SHORTCUT = "Copy", r.Msg.CUT_SHORTCUT = "Cut", r.Msg.DELETE_ALL_BLOCKS = "Delete all %1 blocks?", r.Msg.DELETE_BLOCK = "Delete Block", r.Msg.DELETE_VARIABLE = "Delete the '%1' variable", r.Msg.DELETE_VARIABLE_CONFIRMATION = "Delete %1 uses of the '%2' variable?", r.Msg.DELETE_X_BLOCKS = "Delete %1 Blocks", r.Msg.DIALOG_CANCEL = "Cancel", r.Msg.DIALOG_OK = "OK", r.Msg.DISABLE_BLOCK = "Disable Block", r.Msg.DUPLICATE_BLOCK = "Duplicate", r.Msg.DUPLICATE_COMMENT = "Duplicate Comment", r.Msg.EDIT_BLOCK_CONTENTS = "Edit Block contents", r.Msg.ENABLE_BLOCK = "Enable Block", r.Msg.EXPAND_ALL = "Expand Blocks", r.Msg.EXPAND_BLOCK = "Expand Block", r.Msg.EXTERNAL_INPUTS = "External Inputs", r.Msg.HELP = "Help", r.Msg.HELP_PROMPT = "Press %1 for help on keyboard controls", r.Msg.INLINE_INPUTS = "Inline Inputs", r.Msg.KEYBOARD_NAV_CONSTRAINED_MOVE_HINT = "Use the arrow keys to move, then %1 to accept the position", r.Msg.KEYBOARD_NAV_COPIED_HINT = "Copied. Press %1 to paste.", r.Msg.KEYBOARD_NAV_CUT_HINT = "Cut. Press %1 to paste.", r.Msg.KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT = "Hold %1 and use arrow keys to move freely, then %2 to accept the position", r.Msg.LINUX = "Linux", r.Msg.LISTS_CREATE_EMPTY_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-empty-list", r.Msg.LISTS_CREATE_EMPTY_TITLE = "create empty list", r.Msg.LISTS_CREATE_EMPTY_TOOLTIP = "Returns a list, of length 0, containing no data records", r.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD = "list", r.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP = "Add, remove, or reorder sections to reconfigure this list block.", r.Msg.LISTS_CREATE_WITH_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-list-with", r.Msg.LISTS_CREATE_WITH_INPUT_WITH = "create list with", r.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP = "Add an item to the list.", r.Msg.LISTS_CREATE_WITH_TOOLTIP = "Create a list with any number of items.", r.Msg.LISTS_GET_INDEX_FIRST = "first", r.Msg.LISTS_GET_INDEX_FROM_END = "# from end", r.Msg.LISTS_GET_INDEX_FROM_START = "#", r.Msg.LISTS_GET_INDEX_GET = "get", r.Msg.LISTS_GET_INDEX_GET_REMOVE = "get and remove", r.Msg.LISTS_GET_INDEX_HELPURL = "https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list", r.Msg.LISTS_GET_INDEX_LAST = "last", r.Msg.LISTS_GET_INDEX_RANDOM = "random", r.Msg.LISTS_GET_INDEX_REMOVE = "remove", r.Msg.LISTS_GET_INDEX_TAIL = "", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST = "Returns the first item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM = "Returns the item at the specified position in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST = "Returns the last item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM = "Returns a random item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST = "Removes and returns the first item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM = "Removes and returns the item at the specified position in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST = "Removes and returns the last item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM = "Removes and returns a random item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST = "Removes the first item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM = "Removes the item at the specified position in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST = "Removes the last item in a list.", r.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM = "Removes a random item in a list.", r.Msg.LISTS_GET_SUBLIST_END_FROM_END = "to # from end", r.Msg.LISTS_GET_SUBLIST_END_FROM_START = "to #", r.Msg.LISTS_GET_SUBLIST_END_LAST = "to last", r.Msg.LISTS_GET_SUBLIST_HELPURL = "https://github.com/google/blockly/wiki/Lists#getting-a-sublist", r.Msg.LISTS_GET_SUBLIST_START_FIRST = "get sub-list from first", r.Msg.LISTS_GET_SUBLIST_START_FROM_END = "get sub-list from # from end", r.Msg.LISTS_GET_SUBLIST_START_FROM_START = "get sub-list from #", r.Msg.LISTS_GET_SUBLIST_TAIL = "", r.Msg.LISTS_GET_SUBLIST_TOOLTIP = "Creates a copy of the specified portion of a list.", r.Msg.LISTS_INDEX_FROM_END_TOOLTIP = "%1 is the last item.", r.Msg.LISTS_INDEX_FROM_START_TOOLTIP = "%1 is the first item.", r.Msg.LISTS_INDEX_OF_FIRST = "find first occurrence of item", r.Msg.LISTS_INDEX_OF_HELPURL = "https://github.com/google/blockly/wiki/Lists#finding-items-in-a-list", r.Msg.LISTS_INDEX_OF_LAST = "find last occurrence of item", r.Msg.LISTS_INDEX_OF_TOOLTIP = "Returns the index of the first/last occurrence of the item in the list. Returns %1 if item is not found.", r.Msg.LISTS_INLIST = "in list", r.Msg.LISTS_ISEMPTY_HELPURL = "https://github.com/google/blockly/wiki/Lists#is-empty", r.Msg.LISTS_ISEMPTY_TITLE = "%1 is empty", r.Msg.LISTS_ISEMPTY_TOOLTIP = "Returns true if the list is empty.", r.Msg.LISTS_LENGTH_HELPURL = "https://github.com/google/blockly/wiki/Lists#length-of", r.Msg.LISTS_LENGTH_TITLE = "length of %1", r.Msg.LISTS_LENGTH_TOOLTIP = "Returns the length of a list.", r.Msg.LISTS_REPEAT_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-list-with", r.Msg.LISTS_REPEAT_TITLE = "create list with item %1 repeated %2 times", r.Msg.LISTS_REPEAT_TOOLTIP = "Creates a list consisting of the given value repeated the specified number of times.", r.Msg.LISTS_REVERSE_HELPURL = "https://github.com/google/blockly/wiki/Lists#reversing-a-list", r.Msg.LISTS_REVERSE_MESSAGE0 = "reverse %1", r.Msg.LISTS_REVERSE_TOOLTIP = "Reverse a copy of a list.", r.Msg.LISTS_SET_INDEX_HELPURL = "https://github.com/google/blockly/wiki/Lists#in-list--set", r.Msg.LISTS_SET_INDEX_INPUT_TO = "as", r.Msg.LISTS_SET_INDEX_INSERT = "insert at", r.Msg.LISTS_SET_INDEX_SET = "set", r.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST = "Inserts the item at the start of a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM = "Inserts the item at the specified position in a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST = "Append the item to the end of a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM = "Inserts the item randomly in a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST = "Sets the first item in a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM = "Sets the item at the specified position in a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST = "Sets the last item in a list.", r.Msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM = "Sets a random item in a list.", r.Msg.LISTS_SORT_HELPURL = "https://github.com/google/blockly/wiki/Lists#sorting-a-list", r.Msg.LISTS_SORT_ORDER_ASCENDING = "ascending", r.Msg.LISTS_SORT_ORDER_DESCENDING = "descending", r.Msg.LISTS_SORT_TITLE = "sort %1 %2 %3", r.Msg.LISTS_SORT_TOOLTIP = "Sort a copy of a list.", r.Msg.LISTS_SORT_TYPE_IGNORECASE = "alphabetic, ignore case", r.Msg.LISTS_SORT_TYPE_NUMERIC = "numeric", r.Msg.LISTS_SORT_TYPE_TEXT = "alphabetic", r.Msg.LISTS_SPLIT_HELPURL = "https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists", r.Msg.LISTS_SPLIT_LIST_FROM_TEXT = "make list from text", r.Msg.LISTS_SPLIT_TEXT_FROM_LIST = "make text from list", r.Msg.LISTS_SPLIT_TOOLTIP_JOIN = "Join a list of texts into one text, separated by a delimiter.", r.Msg.LISTS_SPLIT_TOOLTIP_SPLIT = "Split text into a list of texts, breaking at each delimiter.", r.Msg.LISTS_SPLIT_WITH_DELIMITER = "with delimiter", r.Msg.LOGIC_BOOLEAN_FALSE = "false", r.Msg.LOGIC_BOOLEAN_HELPURL = "https://github.com/google/blockly/wiki/Logic#values", r.Msg.LOGIC_BOOLEAN_TOOLTIP = "Returns either true or false.", r.Msg.LOGIC_BOOLEAN_TRUE = "true", r.Msg.LOGIC_COMPARE_HELPURL = "https://en.wikipedia.org/wiki/Inequality_(mathematics)", r.Msg.LOGIC_COMPARE_TOOLTIP_EQ = "Return true if both inputs equal each other.", r.Msg.LOGIC_COMPARE_TOOLTIP_GT = "Return true if the first input is greater than the second input.", r.Msg.LOGIC_COMPARE_TOOLTIP_GTE = "Return true if the first input is greater than or equal to the second input.", r.Msg.LOGIC_COMPARE_TOOLTIP_LT = "Return true if the first input is smaller than the second input.", r.Msg.LOGIC_COMPARE_TOOLTIP_LTE = "Return true if the first input is smaller than or equal to the second input.", r.Msg.LOGIC_COMPARE_TOOLTIP_NEQ = "Return true if both inputs are not equal to each other.", r.Msg.LOGIC_NEGATE_HELPURL = "https://github.com/google/blockly/wiki/Logic#not", r.Msg.LOGIC_NEGATE_TITLE = "not %1", r.Msg.LOGIC_NEGATE_TOOLTIP = "Returns true if the input is false. Returns false if the input is true.", r.Msg.LOGIC_NULL = "null", r.Msg.LOGIC_NULL_HELPURL = "https://en.wikipedia.org/wiki/Nullable_type", r.Msg.LOGIC_NULL_TOOLTIP = "Returns null.", r.Msg.LOGIC_OPERATION_AND = "and", r.Msg.LOGIC_OPERATION_HELPURL = "https://github.com/google/blockly/wiki/Logic#logical-operations", r.Msg.LOGIC_OPERATION_OR = "or", r.Msg.LOGIC_OPERATION_TOOLTIP_AND = "Return true if both inputs are true.", r.Msg.LOGIC_OPERATION_TOOLTIP_OR = "Return true if at least one of the inputs is true.", r.Msg.LOGIC_TERNARY_CONDITION = "test", r.Msg.LOGIC_TERNARY_HELPURL = "https://en.wikipedia.org/wiki/%3F:", r.Msg.LOGIC_TERNARY_IF_FALSE = "if false", r.Msg.LOGIC_TERNARY_IF_TRUE = "if true", r.Msg.LOGIC_TERNARY_TOOLTIP = "Check the condition in 'test'. If the condition is true, returns the 'if true' value; otherwise returns the 'if false' value.", r.Msg.MAC_OS = "macOS", r.Msg.MATH_ADDITION_SYMBOL = "+", r.Msg.MATH_ARITHMETIC_HELPURL = "https://en.wikipedia.org/wiki/Arithmetic", r.Msg.MATH_ARITHMETIC_TOOLTIP_ADD = "Return the sum of the two numbers.", r.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE = "Return the quotient of the two numbers.", r.Msg.MATH_ARITHMETIC_TOOLTIP_MINUS = "Return the difference of the two numbers.", r.Msg.MATH_ARITHMETIC_TOOLTIP_MULTIPLY = "Return the product of the two numbers.", r.Msg.MATH_ARITHMETIC_TOOLTIP_POWER = "Return the first number raised to the power of the second number.", r.Msg.MATH_ATAN2_HELPURL = "https://en.wikipedia.org/wiki/Atan2", r.Msg.MATH_ATAN2_TITLE = "atan2 of X:%1 Y:%2", r.Msg.MATH_ATAN2_TOOLTIP = "Return the arctangent of point (X, Y) in degrees from -180 to 180.", r.Msg.MATH_CHANGE_HELPURL = "https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter", r.Msg.MATH_CHANGE_TITLE = "change %1 by %2", r.Msg.MATH_CHANGE_TOOLTIP = "Add a number to variable '%1'.", r.Msg.MATH_CONSTANT_HELPURL = "https://en.wikipedia.org/wiki/Mathematical_constant", r.Msg.MATH_CONSTANT_TOOLTIP = "Return one of the common constants: \u03C0 (3.141\u2026), e (2.718\u2026), \u03C6 (1.618\u2026), sqrt(2) (1.414\u2026), sqrt(\xBD) (0.707\u2026), or \u221E (infinity).", r.Msg.MATH_CONSTRAIN_HELPURL = "https://en.wikipedia.org/wiki/Clamping_(graphics)", r.Msg.MATH_CONSTRAIN_TITLE = "constrain %1 low %2 high %3", r.Msg.MATH_CONSTRAIN_TOOLTIP = "Constrain a number to be between the specified limits (inclusive).", r.Msg.MATH_DIVISION_SYMBOL = "\xF7", r.Msg.MATH_IS_DIVISIBLE_BY = "is divisible by", r.Msg.MATH_IS_EVEN = "is even", r.Msg.MATH_IS_NEGATIVE = "is negative", r.Msg.MATH_IS_ODD = "is odd", r.Msg.MATH_IS_POSITIVE = "is positive", r.Msg.MATH_IS_PRIME = "is prime", r.Msg.MATH_IS_TOOLTIP = "Check if a number is an even, odd, prime, whole, positive, negative, or if it is divisible by certain number. Returns true or false.", r.Msg.MATH_IS_WHOLE = "is whole", r.Msg.MATH_MODULO_HELPURL = "https://en.wikipedia.org/wiki/Modulo_operation", r.Msg.MATH_MODULO_TITLE = "remainder of %1 \xF7 %2", r.Msg.MATH_MODULO_TOOLTIP = "Return the remainder from dividing the two numbers.", r.Msg.MATH_MULTIPLICATION_SYMBOL = "\xD7", r.Msg.MATH_NUMBER_HELPURL = "https://en.wikipedia.org/wiki/Number", r.Msg.MATH_NUMBER_TOOLTIP = "A number.", r.Msg.MATH_ONLIST_HELPURL = "", r.Msg.MATH_ONLIST_OPERATOR_AVERAGE = "average of list", r.Msg.MATH_ONLIST_OPERATOR_MAX = "max of list", r.Msg.MATH_ONLIST_OPERATOR_MEDIAN = "median of list", r.Msg.MATH_ONLIST_OPERATOR_MIN = "min of list", r.Msg.MATH_ONLIST_OPERATOR_MODE = "modes of list", r.Msg.MATH_ONLIST_OPERATOR_RANDOM = "random item of list", r.Msg.MATH_ONLIST_OPERATOR_STD_DEV = "standard deviation of list", r.Msg.MATH_ONLIST_OPERATOR_SUM = "sum of list", r.Msg.MATH_ONLIST_TOOLTIP_AVERAGE = "Return the average (arithmetic mean) of the numeric values in the list.", r.Msg.MATH_ONLIST_TOOLTIP_MAX = "Return the largest number in the list.", r.Msg.MATH_ONLIST_TOOLTIP_MEDIAN = "Return the median number in the list.", r.Msg.MATH_ONLIST_TOOLTIP_MIN = "Return the smallest number in the list.", r.Msg.MATH_ONLIST_TOOLTIP_MODE = "Return a list of the most common item(s) in the list.", r.Msg.MATH_ONLIST_TOOLTIP_RANDOM = "Return a random element from the list.", r.Msg.MATH_ONLIST_TOOLTIP_STD_DEV = "Return the standard deviation of the list.", r.Msg.MATH_ONLIST_TOOLTIP_SUM = "Return the sum of all the numbers in the list.", r.Msg.MATH_POWER_SYMBOL = "^", r.Msg.MATH_RANDOM_FLOAT_HELPURL = "https://en.wikipedia.org/wiki/Random_number_generation", r.Msg.MATH_RANDOM_FLOAT_TITLE_RANDOM = "random fraction", r.Msg.MATH_RANDOM_FLOAT_TOOLTIP = "Return a random fraction between 0.0 (inclusive) and 1.0 (exclusive).", r.Msg.MATH_RANDOM_INT_HELPURL = "https://en.wikipedia.org/wiki/Random_number_generation", r.Msg.MATH_RANDOM_INT_TITLE = "random integer from %1 to %2", r.Msg.MATH_RANDOM_INT_TOOLTIP = "Return a random integer between the two specified limits, inclusive.", r.Msg.MATH_ROUND_HELPURL = "https://en.wikipedia.org/wiki/Rounding", r.Msg.MATH_ROUND_OPERATOR_ROUND = "round", r.Msg.MATH_ROUND_OPERATOR_ROUNDDOWN = "round down", r.Msg.MATH_ROUND_OPERATOR_ROUNDUP = "round up", r.Msg.MATH_ROUND_TOOLTIP = "Round a number up or down.", r.Msg.MATH_SINGLE_HELPURL = "https://en.wikipedia.org/wiki/Square_root", r.Msg.MATH_SINGLE_OP_ABSOLUTE = "absolute", r.Msg.MATH_SINGLE_OP_ROOT = "square root", r.Msg.MATH_SINGLE_TOOLTIP_ABS = "Return the absolute value of a number.", r.Msg.MATH_SINGLE_TOOLTIP_EXP = "Return e to the power of a number.", r.Msg.MATH_SINGLE_TOOLTIP_LN = "Return the natural logarithm of a number.", r.Msg.MATH_SINGLE_TOOLTIP_LOG10 = "Return the base 10 logarithm of a number.", r.Msg.MATH_SINGLE_TOOLTIP_NEG = "Return the negation of a number.", r.Msg.MATH_SINGLE_TOOLTIP_POW10 = "Return 10 to the power of a number.", r.Msg.MATH_SINGLE_TOOLTIP_ROOT = "Return the square root of a number.", r.Msg.MATH_SUBTRACTION_SYMBOL = "-", r.Msg.MATH_TRIG_ACOS = "acos", r.Msg.MATH_TRIG_ASIN = "asin", r.Msg.MATH_TRIG_ATAN = "atan", r.Msg.MATH_TRIG_COS = "cos", r.Msg.MATH_TRIG_HELPURL = "https://en.wikipedia.org/wiki/Trigonometric_functions", r.Msg.MATH_TRIG_SIN = "sin", r.Msg.MATH_TRIG_TAN = "tan", r.Msg.MATH_TRIG_TOOLTIP_ACOS = "Return the arccosine of a number.", r.Msg.MATH_TRIG_TOOLTIP_ASIN = "Return the arcsine of a number.", r.Msg.MATH_TRIG_TOOLTIP_ATAN = "Return the arctangent of a number.", r.Msg.MATH_TRIG_TOOLTIP_COS = "Return the cosine of a degree (not radian).", r.Msg.MATH_TRIG_TOOLTIP_SIN = "Return the sine of a degree (not radian).", r.Msg.MATH_TRIG_TOOLTIP_TAN = "Return the tangent of a degree (not radian).", r.Msg.MOVE_BLOCK = "Move Block", r.Msg.NEW_COLOUR_VARIABLE = "Create colour variable...", r.Msg.NEW_NUMBER_VARIABLE = "Create number variable...", r.Msg.NEW_STRING_VARIABLE = "Create string variable...", r.Msg.NEW_VARIABLE = "Create variable...", r.Msg.NEW_VARIABLE_TITLE = "New variable name:", r.Msg.NEW_VARIABLE_TYPE_TITLE = "New variable type:", r.Msg.OPTION_KEY = "\u2325 Option", r.Msg.ORDINAL_NUMBER_SUFFIX = "", r.Msg.PASTE_SHORTCUT = "Paste", r.Msg.PROCEDURES_ALLOW_STATEMENTS = "allow statements", r.Msg.PROCEDURES_BEFORE_PARAMS = "with:", r.Msg.PROCEDURES_CALLNORETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine", r.Msg.PROCEDURES_CALLNORETURN_TOOLTIP = "Run the user-defined function '%1'.", r.Msg.PROCEDURES_CALLRETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine", r.Msg.PROCEDURES_CALLRETURN_TOOLTIP = "Run the user-defined function '%1' and use its output.", r.Msg.PROCEDURES_CALL_BEFORE_PARAMS = "with:", r.Msg.PROCEDURES_CALL_DISABLED_DEF_WARNING = "Can't run the user-defined function '%1' because the definition block is disabled.", r.Msg.PROCEDURES_CREATE_DO = "Create '%1'", r.Msg.PROCEDURES_DEFNORETURN_COMMENT = "Describe this function...", r.Msg.PROCEDURES_DEFNORETURN_DO = "", r.Msg.PROCEDURES_DEFNORETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine", r.Msg.PROCEDURES_DEFNORETURN_PROCEDURE = "do something", r.Msg.PROCEDURES_DEFNORETURN_TITLE = "to", r.Msg.PROCEDURES_DEFNORETURN_TOOLTIP = "Creates a function with no output.", r.Msg.PROCEDURES_DEFRETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine", r.Msg.PROCEDURES_DEFRETURN_RETURN = "return", r.Msg.PROCEDURES_DEFRETURN_TOOLTIP = "Creates a function with an output.", r.Msg.PROCEDURES_DEF_DUPLICATE_WARNING = "Warning: This function has duplicate parameters.", r.Msg.PROCEDURES_HIGHLIGHT_DEF = "Highlight function definition", r.Msg.PROCEDURES_IFRETURN_HELPURL = "https://c2.com/cgi/wiki?GuardClause", r.Msg.PROCEDURES_IFRETURN_TOOLTIP = "If a value is true, then return a second value.", r.Msg.PROCEDURES_IFRETURN_WARNING = "Warning: This block may be used only within a function definition.", r.Msg.PROCEDURES_MUTATORARG_TITLE = "input name:", r.Msg.PROCEDURES_MUTATORARG_TOOLTIP = "Add an input to the function.", r.Msg.PROCEDURES_MUTATORCONTAINER_TITLE = "inputs", r.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP = "Add, remove, or reorder inputs to this function.", r.Msg.REDO = "Redo", r.Msg.REMOVE_COMMENT = "Remove Comment", r.Msg.RENAME_VARIABLE = "Rename variable...", r.Msg.RENAME_VARIABLE_TITLE = "Rename all '%1' variables to:", r.Msg.SHORTCUTS_CODE_NAVIGATION = "Code navigation", r.Msg.SHORTCUTS_EDITING = "Editing", r.Msg.SHORTCUTS_GENERAL = "General", r.Msg.TEXT_APPEND_HELPURL = "https://github.com/google/blockly/wiki/Text#text-modification", r.Msg.TEXT_APPEND_TITLE = "to %1 append text %2", r.Msg.TEXT_APPEND_TOOLTIP = "Append some text to variable '%1'.", r.Msg.TEXT_CHANGECASE_HELPURL = "https://github.com/google/blockly/wiki/Text#adjusting-text-case", r.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE = "to lower case", r.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE = "to Title Case", r.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE = "to UPPER CASE", r.Msg.TEXT_CHANGECASE_TOOLTIP = "Return a copy of the text in a different case.", r.Msg.TEXT_CHARAT_FIRST = "get first letter", r.Msg.TEXT_CHARAT_FROM_END = "get letter # from end", r.Msg.TEXT_CHARAT_FROM_START = "get letter #", r.Msg.TEXT_CHARAT_HELPURL = "https://github.com/google/blockly/wiki/Text#extracting-text", r.Msg.TEXT_CHARAT_LAST = "get last letter", r.Msg.TEXT_CHARAT_RANDOM = "get random letter", r.Msg.TEXT_CHARAT_TAIL = "", r.Msg.TEXT_CHARAT_TITLE = "in text %1 %2", r.Msg.TEXT_CHARAT_TOOLTIP = "Returns the letter at the specified position.", r.Msg.TEXT_COUNT_HELPURL = "https://github.com/google/blockly/wiki/Text#counting-substrings", r.Msg.TEXT_COUNT_MESSAGE0 = "count %1 in %2", r.Msg.TEXT_COUNT_TOOLTIP = "Count how many times some text occurs within some other text.", r.Msg.TEXT_CREATE_JOIN_ITEM_TOOLTIP = "Add an item to the text.", r.Msg.TEXT_CREATE_JOIN_TITLE_JOIN = "join", r.Msg.TEXT_CREATE_JOIN_TOOLTIP = "Add, remove, or reorder sections to reconfigure this text block.", r.Msg.TEXT_GET_SUBSTRING_END_FROM_END = "to letter # from end", r.Msg.TEXT_GET_SUBSTRING_END_FROM_START = "to letter #", r.Msg.TEXT_GET_SUBSTRING_END_LAST = "to last letter", r.Msg.TEXT_GET_SUBSTRING_HELPURL = "https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text", r.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT = "in text", r.Msg.TEXT_GET_SUBSTRING_START_FIRST = "get substring from first letter", r.Msg.TEXT_GET_SUBSTRING_START_FROM_END = "get substring from letter # from end", r.Msg.TEXT_GET_SUBSTRING_START_FROM_START = "get substring from letter #", r.Msg.TEXT_GET_SUBSTRING_TAIL = "", r.Msg.TEXT_GET_SUBSTRING_TOOLTIP = "Returns a specified portion of the text.", r.Msg.TEXT_INDEXOF_HELPURL = "https://github.com/google/blockly/wiki/Text#finding-text", r.Msg.TEXT_INDEXOF_OPERATOR_FIRST = "find first occurrence of text", r.Msg.TEXT_INDEXOF_OPERATOR_LAST = "find last occurrence of text", r.Msg.TEXT_INDEXOF_TITLE = "in text %1 %2 %3", r.Msg.TEXT_INDEXOF_TOOLTIP = "Returns the index of the first/last occurrence of the first text in the second text. Returns %1 if text is not found.", r.Msg.TEXT_ISEMPTY_HELPURL = "https://github.com/google/blockly/wiki/Text#checking-for-empty-text", r.Msg.TEXT_ISEMPTY_TITLE = "%1 is empty", r.Msg.TEXT_ISEMPTY_TOOLTIP = "Returns true if the provided text is empty.", r.Msg.TEXT_JOIN_HELPURL = "https://github.com/google/blockly/wiki/Text#text-creation", r.Msg.TEXT_JOIN_TITLE_CREATEWITH = "create text with", r.Msg.TEXT_JOIN_TOOLTIP = "Create a piece of text by joining together any number of items.", r.Msg.TEXT_LENGTH_HELPURL = "https://github.com/google/blockly/wiki/Text#text-modification", r.Msg.TEXT_LENGTH_TITLE = "length of %1", r.Msg.TEXT_LENGTH_TOOLTIP = "Returns the number of letters (including spaces) in the provided text.", r.Msg.TEXT_PRINT_HELPURL = "https://github.com/google/blockly/wiki/Text#printing-text", r.Msg.TEXT_PRINT_TITLE = "print %1", r.Msg.TEXT_PRINT_TOOLTIP = "Print the specified text, number or other value.", r.Msg.TEXT_PROMPT_HELPURL = "https://github.com/google/blockly/wiki/Text#getting-input-from-the-user", r.Msg.TEXT_PROMPT_TOOLTIP_NUMBER = "Prompt for user for a number.", r.Msg.TEXT_PROMPT_TOOLTIP_TEXT = "Prompt for user for some text.", r.Msg.TEXT_PROMPT_TYPE_NUMBER = "prompt for number with message", r.Msg.TEXT_PROMPT_TYPE_TEXT = "prompt for text with message", r.Msg.TEXT_REPLACE_HELPURL = "https://github.com/google/blockly/wiki/Text#replacing-substrings", r.Msg.TEXT_REPLACE_MESSAGE0 = "replace %1 with %2 in %3", r.Msg.TEXT_REPLACE_TOOLTIP = "Replace all occurances of some text within some other text.", r.Msg.TEXT_REVERSE_HELPURL = "https://github.com/google/blockly/wiki/Text#reversing-text", r.Msg.TEXT_REVERSE_MESSAGE0 = "reverse %1", r.Msg.TEXT_REVERSE_TOOLTIP = "Reverses the order of the characters in the text.", r.Msg.TEXT_TEXT_HELPURL = "https://en.wikipedia.org/wiki/String_(computer_science)", r.Msg.TEXT_TEXT_TOOLTIP = "A letter, word, or line of text.", r.Msg.TEXT_TRIM_HELPURL = "https://github.com/google/blockly/wiki/Text#trimming-removing-spaces", r.Msg.TEXT_TRIM_OPERATOR_BOTH = "trim spaces from both sides of", r.Msg.TEXT_TRIM_OPERATOR_LEFT = "trim spaces from left side of", r.Msg.TEXT_TRIM_OPERATOR_RIGHT = "trim spaces from right side of", r.Msg.TEXT_TRIM_TOOLTIP = "Return a copy of the text with spaces removed from one or both ends.", r.Msg.TODAY = "Today", r.Msg.UNDO = "Undo", r.Msg.UNKNOWN = "Unknown", r.Msg.UNNAMED_KEY = "unnamed", r.Msg.VARIABLES_DEFAULT_NAME = "item", r.Msg.VARIABLES_GET_CREATE_SET = "Create 'set %1'", r.Msg.VARIABLES_GET_HELPURL = "https://github.com/google/blockly/wiki/Variables#get", r.Msg.VARIABLES_GET_TOOLTIP = "Returns the value of this variable.", r.Msg.VARIABLES_SET = "set %1 to %2", r.Msg.VARIABLES_SET_CREATE_GET = "Create 'get %1'", r.Msg.VARIABLES_SET_HELPURL = "https://github.com/google/blockly/wiki/Variables#set", r.Msg.VARIABLES_SET_TOOLTIP = "Sets this variable to be equal to the input.", r.Msg.VARIABLE_ALREADY_EXISTS = "A variable named '%1' already exists.", r.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE = "A variable named '%1' already exists for another type: '%2'.", r.Msg.VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER = "A variable named '%1' already exists as a parameter in the procedure '%2'.", r.Msg.WINDOWS = "Windows", r.Msg.WORKSPACE_ARIA_LABEL = "Blockly Workspace", r.Msg.WORKSPACE_COMMENT_DEFAULT_TEXT = "Say something...", r.Msg.CONTROLS_FOREACH_INPUT_DO = r.Msg.CONTROLS_REPEAT_INPUT_DO, r.Msg.CONTROLS_FOR_INPUT_DO = r.Msg.CONTROLS_REPEAT_INPUT_DO, r.Msg.CONTROLS_IF_ELSEIF_TITLE_ELSEIF = r.Msg.CONTROLS_IF_MSG_ELSEIF, r.Msg.CONTROLS_IF_ELSE_TITLE_ELSE = r.Msg.CONTROLS_IF_MSG_ELSE, r.Msg.CONTROLS_IF_IF_TITLE_IF = r.Msg.CONTROLS_IF_MSG_IF, r.Msg.CONTROLS_IF_MSG_THEN = r.Msg.CONTROLS_REPEAT_INPUT_DO, r.Msg.CONTROLS_WHILEUNTIL_INPUT_DO = r.Msg.CONTROLS_REPEAT_INPUT_DO, r.Msg.LISTS_CREATE_WITH_ITEM_TITLE = r.Msg.VARIABLES_DEFAULT_NAME, r.Msg.LISTS_GET_INDEX_INPUT_IN_LIST = r.Msg.LISTS_INLIST, r.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST = r.Msg.LISTS_INLIST, r.Msg.LISTS_INDEX_OF_INPUT_IN_LIST = r.Msg.LISTS_INLIST, r.Msg.LISTS_SET_INDEX_INPUT_IN_LIST = r.Msg.LISTS_INLIST, r.Msg.MATH_CHANGE_TITLE_ITEM = r.Msg.VARIABLES_DEFAULT_NAME, r.Msg.PROCEDURES_DEFRETURN_COMMENT = r.Msg.PROCEDURES_DEFNORETURN_COMMENT, r.Msg.PROCEDURES_DEFRETURN_DO = r.Msg.PROCEDURES_DEFNORETURN_DO, r.Msg.PROCEDURES_DEFRETURN_PROCEDURE = r.Msg.PROCEDURES_DEFNORETURN_PROCEDURE, r.Msg.PROCEDURES_DEFRETURN_TITLE = r.Msg.PROCEDURES_DEFNORETURN_TITLE, r.Msg.TEXT_APPEND_VARIABLE = r.Msg.VARIABLES_DEFAULT_NAME, r.Msg.TEXT_CREATE_JOIN_ITEM_TITLE_ITEM = r.Msg.VARIABLES_DEFAULT_NAME, r.Msg.COLOUR_HUE = "20", r.Msg.LISTS_HUE = "260", r.Msg.LOGIC_HUE = "210", r.Msg.LOOPS_HUE = "120", r.Msg.MATH_HUE = "230", r.Msg.PROCEDURES_HUE = "290", r.Msg.TEXTS_HUE = "160", r.Msg.VARIABLES_DYNAMIC_HUE = "310", r.Msg.VARIABLES_HUE = "330", r.Msg;
      });
    });
    var F_ = P_(x_(), 1), { Block: oP, BlockFlyoutInflater: sP, BlockNavigationPolicy: iP, BlockSvg: rP, Blocks: nP, ButtonFlyoutInflater: lP, COLLAPSED_FIELD_NAME: cP, COLLAPSED_INPUT_NAME: aP, COLLAPSE_CHARS: uP, CodeGenerator: H_, CollapsibleToolboxCategory: hP, ComponentManager: dP, Connection: $P, ConnectionChecker: pP, ConnectionDB: gP, ConnectionNavigationPolicy: mP, ConnectionType: _P, ContextMenu: TP, ContextMenuItems: EP, ContextMenuRegistry: bP, Css: fP, DELETE_VARIABLE_ID: IP, DeleteArea: yP, DragTarget: CP, DropDownDiv: vP, Events: kd, Extensions: kP, Field: RP, FieldCheckbox: SP, FieldDropdown: OP, FieldImage: wP, FieldLabel: LP, FieldLabelSerializable: NP, FieldNavigationPolicy: AP, FieldNumber: MP, FieldTextInput: DP, FieldVariable: PP, Flyout: BP, FlyoutButton: xP, FlyoutButtonNavigationPolicy: FP, FlyoutItem: HP, FlyoutMetricsManager: UP, FlyoutNavigationPolicy: GP, FlyoutNavigator: VP, FlyoutSeparator: WP, FlyoutSeparatorNavigationPolicy: zP, FocusManager: XP, FocusableTreeTraverser: YP, Generator: KP, Gesture: jP, Grid: JP, HorizontalFlyout: qP, INPUT_VALUE: ZP, Input: QP, InsertionMarkerPreviewer: eB, KeyboardNavigationController: tB, LabelFlyoutInflater: oB, LineCursor: sB, Marker: iB, MarkerManager: rB, Menu: nB, MenuItem: lB, MetricsManager: cB, Msg: aB, NEXT_STATEMENT: uB, Names: hB, Navigator: dB, OPPOSITE_TYPE: $B, OUTPUT_VALUE: pB, Options: gB, PREVIOUS_STATEMENT: mB, PROCEDURE_CATEGORY_NAME: _B, Procedures: TB, RENAME_VARIABLE_ID: EB, RenderedConnection: bB, Scrollbar: fB, ScrollbarPair: IB, SeparatorFlyoutInflater: yB, ShortcutItems: CB, ShortcutRegistry: vB, TOOLBOX_AT_BOTTOM: kB, TOOLBOX_AT_LEFT: RB, TOOLBOX_AT_RIGHT: SB, TOOLBOX_AT_TOP: OB, Theme: U_, ThemeManager: wB, Themes: LB, Toast: NB, Toolbox: AB, ToolboxCategory: MB, ToolboxItem: DB, ToolboxSeparator: PB, Tooltip: BB, Touch: xB, Trashcan: FB, UnattachedFieldError: HB, VARIABLE_CATEGORY_NAME: UB, VARIABLE_DYNAMIC_CATEGORY_NAME: GB, VERSION: VB, VariableMap: WB, VariableModel: zB, Variables: XB, VariablesDynamic: YB, VerticalFlyout: KB, WidgetDiv: jB, Workspace: JB, WorkspaceAudio: qB, WorkspaceDragger: ZB, WorkspaceNavigationPolicy: QB, WorkspaceSvg: ex, Xml: tx, ZoomControls: ox, blockAnimations: sx, blockRendering: ix, browserEvents: rx, bubbles: nx, bumpObjects: lx, clipboard: cx, comments: ax, common: ce, config: ux, constants: hx, defineBlocksWithJsonArray: dx, dialog: $x, dragging: px, fieldRegistry: gx, geras: mx, getFocusManager: _x, getMainWorkspace: Tx, getSelected: Ex, hasBubble: bx, hideChaff: fx, icons: Ix, inject: G_, inputs: yx, isCopyable: Cx, isDeletable: vx, isDraggable: kx, isIcon: Rx, isObservable: Sx, isPaster: Ox, isRenderedElement: wx, isSelectable: Lx, isSerializable: Nx, isVariableBackedParameterModel: Ax, keyboardNavigationController: Mx, layers: Dx, navigateBlock: Px, navigateStacks: Bx, procedures: xx, registry: Fx, renderManagement: Hx, serialization: jl, setLocale: V_, setParentContainer: Ux, svgResize: Gx, thrasos: Vx, uiPosition: Wx, utils: zx, zelos: Xx } = F_.default;
    var Sd = {};
    NI(Sd, { ADD_COMMENT: () => YI, ALT_KEY: () => Aw, CANNOT_DELETE_VARIABLE_PROCEDURE: () => vy, CHANGE_VALUE_TITLE: () => dy, CHROME_OS: () => Rw, CLEAN_UP: () => ty, CLOSE: () => oy, COLLAPSED_WARNINGS_WARNING: () => bw, COLLAPSE_ALL: () => iy, COLLAPSE_BLOCK: () => sy, COLOUR_BLEND_COLOUR1: () => Hy, COLOUR_BLEND_COLOUR2: () => Uy, COLOUR_BLEND_HELPURL: () => xy, COLOUR_BLEND_RATIO: () => Gy, COLOUR_BLEND_TITLE: () => Fy, COLOUR_BLEND_TOOLTIP: () => Vy, COLOUR_HUE: () => FI, COLOUR_PICKER_HELPURL: () => Ry, COLOUR_PICKER_TOOLTIP: () => Sy, COLOUR_RANDOM_HELPURL: () => Oy, COLOUR_RANDOM_TITLE: () => wy, COLOUR_RANDOM_TOOLTIP: () => Ly, COLOUR_RGB_BLUE: () => Py, COLOUR_RGB_GREEN: () => Dy, COLOUR_RGB_HELPURL: () => Ny, COLOUR_RGB_RED: () => My, COLOUR_RGB_TITLE: () => Ay, COLOUR_RGB_TOOLTIP: () => By, COMMAND_KEY: () => Lw, CONTROLS_FLOW_STATEMENTS_HELPURL: () => cC, CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK: () => aC, CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE: () => uC, CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK: () => hC, CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE: () => dC, CONTROLS_FLOW_STATEMENTS_WARNING: () => $C, CONTROLS_FOREACH_HELPURL: () => iC, CONTROLS_FOREACH_INPUT_DO: () => nC, CONTROLS_FOREACH_TITLE: () => rC, CONTROLS_FOREACH_TOOLTIP: () => lC, CONTROLS_FOR_HELPURL: () => eC, CONTROLS_FOR_INPUT_DO: () => sC, CONTROLS_FOR_TITLE: () => oC, CONTROLS_FOR_TOOLTIP: () => tC, CONTROLS_IF_ELSEIF_TITLE_ELSEIF: () => vC, CONTROLS_IF_ELSEIF_TOOLTIP: () => kC, CONTROLS_IF_ELSE_TITLE_ELSE: () => RC, CONTROLS_IF_ELSE_TOOLTIP: () => SC, CONTROLS_IF_HELPURL: () => pC, CONTROLS_IF_IF_TITLE_IF: () => yC, CONTROLS_IF_IF_TOOLTIP: () => CC, CONTROLS_IF_MSG_ELSE: () => fC, CONTROLS_IF_MSG_ELSEIF: () => bC, CONTROLS_IF_MSG_IF: () => EC, CONTROLS_IF_MSG_THEN: () => IC, CONTROLS_IF_TOOLTIP_1: () => gC, CONTROLS_IF_TOOLTIP_2: () => mC, CONTROLS_IF_TOOLTIP_3: () => _C, CONTROLS_IF_TOOLTIP_4: () => TC, CONTROLS_REPEAT_HELPURL: () => Wy, CONTROLS_REPEAT_INPUT_DO: () => Xy, CONTROLS_REPEAT_TITLE: () => zy, CONTROLS_REPEAT_TOOLTIP: () => Yy, CONTROLS_WHILEUNTIL_HELPURL: () => Ky, CONTROLS_WHILEUNTIL_INPUT_DO: () => jy, CONTROLS_WHILEUNTIL_OPERATOR_UNTIL: () => qy, CONTROLS_WHILEUNTIL_OPERATOR_WHILE: () => Jy, CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL: () => Qy, CONTROLS_WHILEUNTIL_TOOLTIP_WHILE: () => Zy, CONTROL_KEY: () => ww, COPY_SHORTCUT: () => Dw, CUT_SHORTCUT: () => Mw, DELETE_ALL_BLOCKS: () => ey, DELETE_BLOCK: () => ZI, DELETE_VARIABLE: () => ky, DELETE_VARIABLE_CONFIRMATION: () => Cy, DELETE_X_BLOCKS: () => QI, DIALOG_CANCEL: () => Iw, DIALOG_OK: () => fw, DISABLE_BLOCK: () => ly, DUPLICATE_BLOCK: () => XI, DUPLICATE_COMMENT: () => jI, EDIT_BLOCK_CONTENTS: () => yw, ENABLE_BLOCK: () => cy, EXPAND_ALL: () => ny, EXPAND_BLOCK: () => ry, EXTERNAL_INPUTS: () => JI, HELP: () => ay, HELP_PROMPT: () => Bw, INLINE_INPUTS: () => qI, KEYBOARD_NAV_CONSTRAINED_MOVE_HINT: () => Gw, KEYBOARD_NAV_COPIED_HINT: () => Vw, KEYBOARD_NAV_CUT_HINT: () => Ww, KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT: () => Uw, LINUX: () => Sw, LISTS_CREATE_EMPTY_HELPURL: () => qR, LISTS_CREATE_EMPTY_TITLE: () => ZR, LISTS_CREATE_EMPTY_TOOLTIP: () => QR, LISTS_CREATE_WITH_CONTAINER_TITLE_ADD: () => sS, LISTS_CREATE_WITH_CONTAINER_TOOLTIP: () => iS, LISTS_CREATE_WITH_HELPURL: () => eS, LISTS_CREATE_WITH_INPUT_WITH: () => oS, LISTS_CREATE_WITH_ITEM_TITLE: () => rS, LISTS_CREATE_WITH_ITEM_TOOLTIP: () => nS, LISTS_CREATE_WITH_TOOLTIP: () => tS, LISTS_GET_INDEX_FIRST: () => SS, LISTS_GET_INDEX_FROM_END: () => RS, LISTS_GET_INDEX_FROM_START: () => kS, LISTS_GET_INDEX_GET: () => yS, LISTS_GET_INDEX_GET_REMOVE: () => CS, LISTS_GET_INDEX_HELPURL: () => IS, LISTS_GET_INDEX_INPUT_IN_LIST: () => NS, LISTS_GET_INDEX_LAST: () => OS, LISTS_GET_INDEX_RANDOM: () => wS, LISTS_GET_INDEX_REMOVE: () => vS, LISTS_GET_INDEX_TAIL: () => LS, LISTS_GET_INDEX_TOOLTIP_GET_FIRST: () => PS, LISTS_GET_INDEX_TOOLTIP_GET_FROM: () => DS, LISTS_GET_INDEX_TOOLTIP_GET_LAST: () => BS, LISTS_GET_INDEX_TOOLTIP_GET_RANDOM: () => xS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST: () => HS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM: () => FS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST: () => US, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM: () => GS, LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST: () => WS, LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM: () => VS, LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST: () => zS, LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM: () => XS, LISTS_GET_SUBLIST_END_FROM_END: () => dO, LISTS_GET_SUBLIST_END_FROM_START: () => hO, LISTS_GET_SUBLIST_END_LAST: () => $O, LISTS_GET_SUBLIST_HELPURL: () => nO, LISTS_GET_SUBLIST_INPUT_IN_LIST: () => lO, LISTS_GET_SUBLIST_START_FIRST: () => uO, LISTS_GET_SUBLIST_START_FROM_END: () => aO, LISTS_GET_SUBLIST_START_FROM_START: () => cO, LISTS_GET_SUBLIST_TAIL: () => pO, LISTS_GET_SUBLIST_TOOLTIP: () => gO, LISTS_HUE: () => xI, LISTS_INDEX_FROM_END_TOOLTIP: () => MS, LISTS_INDEX_FROM_START_TOOLTIP: () => AS, LISTS_INDEX_OF_FIRST: () => ES, LISTS_INDEX_OF_HELPURL: () => _S, LISTS_INDEX_OF_INPUT_IN_LIST: () => TS, LISTS_INDEX_OF_LAST: () => bS, LISTS_INDEX_OF_TOOLTIP: () => fS, LISTS_INLIST: () => mS, LISTS_ISEMPTY_HELPURL: () => $S, LISTS_ISEMPTY_TITLE: () => pS, LISTS_ISEMPTY_TOOLTIP: () => gS, LISTS_LENGTH_HELPURL: () => uS, LISTS_LENGTH_TITLE: () => hS, LISTS_LENGTH_TOOLTIP: () => dS, LISTS_REPEAT_HELPURL: () => lS, LISTS_REPEAT_TITLE: () => aS, LISTS_REPEAT_TOOLTIP: () => cS, LISTS_REVERSE_HELPURL: () => wO, LISTS_REVERSE_MESSAGE0: () => LO, LISTS_REVERSE_TOOLTIP: () => NO, LISTS_SET_INDEX_HELPURL: () => YS, LISTS_SET_INDEX_INPUT_IN_LIST: () => KS, LISTS_SET_INDEX_INPUT_TO: () => qS, LISTS_SET_INDEX_INSERT: () => JS, LISTS_SET_INDEX_SET: () => jS, LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST: () => sO, LISTS_SET_INDEX_TOOLTIP_INSERT_FROM: () => oO, LISTS_SET_INDEX_TOOLTIP_INSERT_LAST: () => iO, LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM: () => rO, LISTS_SET_INDEX_TOOLTIP_SET_FIRST: () => QS, LISTS_SET_INDEX_TOOLTIP_SET_FROM: () => ZS, LISTS_SET_INDEX_TOOLTIP_SET_LAST: () => eO, LISTS_SET_INDEX_TOOLTIP_SET_RANDOM: () => tO, LISTS_SORT_HELPURL: () => mO, LISTS_SORT_ORDER_ASCENDING: () => EO, LISTS_SORT_ORDER_DESCENDING: () => bO, LISTS_SORT_TITLE: () => _O, LISTS_SORT_TOOLTIP: () => TO, LISTS_SORT_TYPE_IGNORECASE: () => yO, LISTS_SORT_TYPE_NUMERIC: () => fO, LISTS_SORT_TYPE_TEXT: () => IO, LISTS_SPLIT_HELPURL: () => CO, LISTS_SPLIT_LIST_FROM_TEXT: () => vO, LISTS_SPLIT_TEXT_FROM_LIST: () => kO, LISTS_SPLIT_TOOLTIP_JOIN: () => OO, LISTS_SPLIT_TOOLTIP_SPLIT: () => SO, LISTS_SPLIT_WITH_DELIMITER: () => RO, LOGIC_BOOLEAN_FALSE: () => XC, LOGIC_BOOLEAN_HELPURL: () => WC, LOGIC_BOOLEAN_TOOLTIP: () => YC, LOGIC_BOOLEAN_TRUE: () => zC, LOGIC_COMPARE_HELPURL: () => OC, LOGIC_COMPARE_TOOLTIP_EQ: () => wC, LOGIC_COMPARE_TOOLTIP_GT: () => MC, LOGIC_COMPARE_TOOLTIP_GTE: () => DC, LOGIC_COMPARE_TOOLTIP_LT: () => NC, LOGIC_COMPARE_TOOLTIP_LTE: () => AC, LOGIC_COMPARE_TOOLTIP_NEQ: () => LC, LOGIC_HUE: () => MI, LOGIC_NEGATE_HELPURL: () => UC, LOGIC_NEGATE_TITLE: () => GC, LOGIC_NEGATE_TOOLTIP: () => VC, LOGIC_NULL: () => jC, LOGIC_NULL_HELPURL: () => KC, LOGIC_NULL_TOOLTIP: () => JC, LOGIC_OPERATION_AND: () => xC, LOGIC_OPERATION_HELPURL: () => PC, LOGIC_OPERATION_OR: () => HC, LOGIC_OPERATION_TOOLTIP_AND: () => BC, LOGIC_OPERATION_TOOLTIP_OR: () => FC, LOGIC_TERNARY_CONDITION: () => ZC, LOGIC_TERNARY_HELPURL: () => qC, LOGIC_TERNARY_IF_FALSE: () => ev, LOGIC_TERNARY_IF_TRUE: () => QC, LOGIC_TERNARY_TOOLTIP: () => tv, LOOPS_HUE: () => DI, MAC_OS: () => kw, MATH_ADDITION_SYMBOL: () => iv, MATH_ARITHMETIC_HELPURL: () => gv, MATH_ARITHMETIC_TOOLTIP_ADD: () => mv, MATH_ARITHMETIC_TOOLTIP_DIVIDE: () => Ev, MATH_ARITHMETIC_TOOLTIP_MINUS: () => _v, MATH_ARITHMETIC_TOOLTIP_MULTIPLY: () => Tv, MATH_ARITHMETIC_TOOLTIP_POWER: () => bv, MATH_ATAN2_HELPURL: () => Nk, MATH_ATAN2_TITLE: () => Ak, MATH_ATAN2_TOOLTIP: () => Mk, MATH_CHANGE_HELPURL: () => Kv, MATH_CHANGE_TITLE: () => jv, MATH_CHANGE_TITLE_ITEM: () => Jv, MATH_CHANGE_TOOLTIP: () => qv, MATH_CONSTANT_HELPURL: () => xv, MATH_CONSTANT_TOOLTIP: () => Fv, MATH_CONSTRAIN_HELPURL: () => yk, MATH_CONSTRAIN_TITLE: () => Ck, MATH_CONSTRAIN_TOOLTIP: () => vk, MATH_DIVISION_SYMBOL: () => nv, MATH_HUE: () => PI, MATH_IS_DIVISIBLE_BY: () => Xv, MATH_IS_EVEN: () => Hv, MATH_IS_NEGATIVE: () => zv, MATH_IS_ODD: () => Uv, MATH_IS_POSITIVE: () => Wv, MATH_IS_PRIME: () => Gv, MATH_IS_TOOLTIP: () => Yv, MATH_IS_WHOLE: () => Vv, MATH_MODULO_HELPURL: () => bk, MATH_MODULO_TITLE: () => fk, MATH_MODULO_TOOLTIP: () => Ik, MATH_MULTIPLICATION_SYMBOL: () => lv, MATH_NUMBER_HELPURL: () => ov, MATH_NUMBER_TOOLTIP: () => sv, MATH_ONLIST_HELPURL: () => sk, MATH_ONLIST_OPERATOR_AVERAGE: () => uk, MATH_ONLIST_OPERATOR_MAX: () => ck, MATH_ONLIST_OPERATOR_MEDIAN: () => dk, MATH_ONLIST_OPERATOR_MIN: () => nk, MATH_ONLIST_OPERATOR_MODE: () => pk, MATH_ONLIST_OPERATOR_RANDOM: () => Tk, MATH_ONLIST_OPERATOR_STD_DEV: () => mk, MATH_ONLIST_OPERATOR_SUM: () => ik, MATH_ONLIST_TOOLTIP_AVERAGE: () => hk, MATH_ONLIST_TOOLTIP_MAX: () => ak, MATH_ONLIST_TOOLTIP_MEDIAN: () => $k, MATH_ONLIST_TOOLTIP_MIN: () => lk, MATH_ONLIST_TOOLTIP_MODE: () => gk, MATH_ONLIST_TOOLTIP_RANDOM: () => Ek, MATH_ONLIST_TOOLTIP_STD_DEV: () => _k, MATH_ONLIST_TOOLTIP_SUM: () => rk, MATH_POWER_SYMBOL: () => cv, MATH_RANDOM_FLOAT_HELPURL: () => Ok, MATH_RANDOM_FLOAT_TITLE_RANDOM: () => wk, MATH_RANDOM_FLOAT_TOOLTIP: () => Lk, MATH_RANDOM_INT_HELPURL: () => kk, MATH_RANDOM_INT_TITLE: () => Rk, MATH_RANDOM_INT_TOOLTIP: () => Sk, MATH_ROUND_HELPURL: () => Zv, MATH_ROUND_OPERATOR_ROUND: () => ek, MATH_ROUND_OPERATOR_ROUNDDOWN: () => ok, MATH_ROUND_OPERATOR_ROUNDUP: () => tk, MATH_ROUND_TOOLTIP: () => Qv, MATH_SINGLE_HELPURL: () => fv, MATH_SINGLE_OP_ABSOLUTE: () => Cv, MATH_SINGLE_OP_ROOT: () => Iv, MATH_SINGLE_TOOLTIP_ABS: () => vv, MATH_SINGLE_TOOLTIP_EXP: () => Ov, MATH_SINGLE_TOOLTIP_LN: () => Rv, MATH_SINGLE_TOOLTIP_LOG10: () => Sv, MATH_SINGLE_TOOLTIP_NEG: () => kv, MATH_SINGLE_TOOLTIP_POW10: () => wv, MATH_SINGLE_TOOLTIP_ROOT: () => yv, MATH_SUBTRACTION_SYMBOL: () => rv, MATH_TRIG_ACOS: () => $v, MATH_TRIG_ASIN: () => dv, MATH_TRIG_ATAN: () => pv, MATH_TRIG_COS: () => uv, MATH_TRIG_HELPURL: () => Lv, MATH_TRIG_SIN: () => av, MATH_TRIG_TAN: () => hv, MATH_TRIG_TOOLTIP_ACOS: () => Pv, MATH_TRIG_TOOLTIP_ASIN: () => Dv, MATH_TRIG_TOOLTIP_ATAN: () => Bv, MATH_TRIG_TOOLTIP_COS: () => Av, MATH_TRIG_TOOLTIP_SIN: () => Nv, MATH_TRIG_TOOLTIP_TAN: () => Mv, MOVE_BLOCK: () => Cw, NEW_COLOUR_VARIABLE: () => Ty, NEW_NUMBER_VARIABLE: () => _y, NEW_STRING_VARIABLE: () => my, NEW_VARIABLE: () => gy, NEW_VARIABLE_TITLE: () => by, NEW_VARIABLE_TYPE_TITLE: () => Ey, OPTION_KEY: () => Nw, ORDINAL_NUMBER_SUFFIX: () => AO, PASTE_SHORTCUT: () => Pw, PROCEDURES_ALLOW_STATEMENTS: () => sw, PROCEDURES_BEFORE_PARAMS: () => WO, PROCEDURES_CALLNORETURN_HELPURL: () => rw, PROCEDURES_CALLNORETURN_TOOLTIP: () => nw, PROCEDURES_CALLRETURN_HELPURL: () => lw, PROCEDURES_CALLRETURN_TOOLTIP: () => cw, PROCEDURES_CALL_BEFORE_PARAMS: () => zO, PROCEDURES_CALL_DISABLED_DEF_WARNING: () => XO, PROCEDURES_CREATE_DO: () => pw, PROCEDURES_DEFNORETURN_COMMENT: () => jO, PROCEDURES_DEFNORETURN_DO: () => YO, PROCEDURES_DEFNORETURN_HELPURL: () => UO, PROCEDURES_DEFNORETURN_PROCEDURE: () => VO, PROCEDURES_DEFNORETURN_TITLE: () => GO, PROCEDURES_DEFNORETURN_TOOLTIP: () => KO, PROCEDURES_DEFRETURN_COMMENT: () => ew, PROCEDURES_DEFRETURN_DO: () => QO, PROCEDURES_DEFRETURN_HELPURL: () => JO, PROCEDURES_DEFRETURN_PROCEDURE: () => ZO, PROCEDURES_DEFRETURN_RETURN: () => tw, PROCEDURES_DEFRETURN_TITLE: () => qO, PROCEDURES_DEFRETURN_TOOLTIP: () => ow, PROCEDURES_DEF_DUPLICATE_WARNING: () => iw, PROCEDURES_HIGHLIGHT_DEF: () => $w, PROCEDURES_HUE: () => GI, PROCEDURES_IFRETURN_HELPURL: () => mw, PROCEDURES_IFRETURN_TOOLTIP: () => gw, PROCEDURES_IFRETURN_WARNING: () => _w, PROCEDURES_MUTATORARG_TITLE: () => hw, PROCEDURES_MUTATORARG_TOOLTIP: () => dw, PROCEDURES_MUTATORCONTAINER_TITLE: () => aw, PROCEDURES_MUTATORCONTAINER_TOOLTIP: () => uw, REDO: () => hy, REMOVE_COMMENT: () => KI, RENAME_VARIABLE: () => $y, RENAME_VARIABLE_TITLE: () => py, SHORTCUTS_CODE_NAVIGATION: () => Hw, SHORTCUTS_EDITING: () => Fw, SHORTCUTS_GENERAL: () => xw, TEXTS_HUE: () => BI, TEXT_APPEND_HELPURL: () => Wk, TEXT_APPEND_TITLE: () => zk, TEXT_APPEND_TOOLTIP: () => Yk, TEXT_APPEND_VARIABLE: () => Xk, TEXT_CHANGECASE_HELPURL: () => CR, TEXT_CHANGECASE_OPERATOR_LOWERCASE: () => RR, TEXT_CHANGECASE_OPERATOR_TITLECASE: () => SR, TEXT_CHANGECASE_OPERATOR_UPPERCASE: () => kR, TEXT_CHANGECASE_TOOLTIP: () => vR, TEXT_CHARAT_FIRST: () => aR, TEXT_CHARAT_FROM_END: () => cR, TEXT_CHARAT_FROM_START: () => lR, TEXT_CHARAT_HELPURL: () => rR, TEXT_CHARAT_LAST: () => uR, TEXT_CHARAT_RANDOM: () => hR, TEXT_CHARAT_TAIL: () => dR, TEXT_CHARAT_TITLE: () => nR, TEXT_CHARAT_TOOLTIP: () => $R, TEXT_COUNT_HELPURL: () => VR, TEXT_COUNT_MESSAGE0: () => GR, TEXT_COUNT_TOOLTIP: () => WR, TEXT_CREATE_JOIN_ITEM_TITLE_ITEM: () => Gk, TEXT_CREATE_JOIN_ITEM_TOOLTIP: () => Vk, TEXT_CREATE_JOIN_TITLE_JOIN: () => Hk, TEXT_CREATE_JOIN_TOOLTIP: () => Uk, TEXT_GET_SUBSTRING_END_FROM_END: () => fR, TEXT_GET_SUBSTRING_END_FROM_START: () => bR, TEXT_GET_SUBSTRING_END_LAST: () => IR, TEXT_GET_SUBSTRING_HELPURL: () => gR, TEXT_GET_SUBSTRING_INPUT_IN_TEXT: () => mR, TEXT_GET_SUBSTRING_START_FIRST: () => ER, TEXT_GET_SUBSTRING_START_FROM_END: () => TR, TEXT_GET_SUBSTRING_START_FROM_START: () => _R, TEXT_GET_SUBSTRING_TAIL: () => yR, TEXT_GET_SUBSTRING_TOOLTIP: () => pR, TEXT_INDEXOF_HELPURL: () => eR, TEXT_INDEXOF_OPERATOR_FIRST: () => sR, TEXT_INDEXOF_OPERATOR_LAST: () => iR, TEXT_INDEXOF_TITLE: () => oR, TEXT_INDEXOF_TOOLTIP: () => tR, TEXT_ISEMPTY_HELPURL: () => qk, TEXT_ISEMPTY_TITLE: () => Zk, TEXT_ISEMPTY_TOOLTIP: () => Qk, TEXT_JOIN_HELPURL: () => Bk, TEXT_JOIN_TITLE_CREATEWITH: () => xk, TEXT_JOIN_TOOLTIP: () => Fk, TEXT_LENGTH_HELPURL: () => Kk, TEXT_LENGTH_TITLE: () => jk, TEXT_LENGTH_TOOLTIP: () => Jk, TEXT_PRINT_HELPURL: () => MR, TEXT_PRINT_TITLE: () => DR, TEXT_PRINT_TOOLTIP: () => PR, TEXT_PROMPT_HELPURL: () => BR, TEXT_PROMPT_TOOLTIP_NUMBER: () => HR, TEXT_PROMPT_TOOLTIP_TEXT: () => UR, TEXT_PROMPT_TYPE_NUMBER: () => FR, TEXT_PROMPT_TYPE_TEXT: () => xR, TEXT_REPLACE_HELPURL: () => XR, TEXT_REPLACE_MESSAGE0: () => zR, TEXT_REPLACE_TOOLTIP: () => YR, TEXT_REVERSE_HELPURL: () => jR, TEXT_REVERSE_MESSAGE0: () => KR, TEXT_REVERSE_TOOLTIP: () => JR, TEXT_TEXT_HELPURL: () => Dk, TEXT_TEXT_TOOLTIP: () => Pk, TEXT_TRIM_HELPURL: () => OR, TEXT_TRIM_OPERATOR_BOTH: () => LR, TEXT_TRIM_OPERATOR_LEFT: () => NR, TEXT_TRIM_OPERATOR_RIGHT: () => AR, TEXT_TRIM_TOOLTIP: () => wR, TODAY: () => zI, UNDO: () => uy, UNKNOWN: () => Ow, UNNAMED_KEY: () => WI, VARIABLES_DEFAULT_NAME: () => VI, VARIABLES_DYNAMIC_HUE: () => UI, VARIABLES_GET_CREATE_SET: () => PO, VARIABLES_GET_HELPURL: () => MO, VARIABLES_GET_TOOLTIP: () => DO, VARIABLES_HUE: () => HI, VARIABLES_SET: () => xO, VARIABLES_SET_CREATE_GET: () => HO, VARIABLES_SET_HELPURL: () => BO, VARIABLES_SET_TOOLTIP: () => FO, VARIABLE_ALREADY_EXISTS: () => fy, VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE: () => Iy, VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER: () => yy, WINDOWS: () => vw, WORKSPACE_ARIA_LABEL: () => Ew, WORKSPACE_COMMENT_DEFAULT_TEXT: () => Tw });
    var X_ = P_(z_(), 1), { LOGIC_HUE: MI, LOOPS_HUE: DI, MATH_HUE: PI, TEXTS_HUE: BI, LISTS_HUE: xI, COLOUR_HUE: FI, VARIABLES_HUE: HI, VARIABLES_DYNAMIC_HUE: UI, PROCEDURES_HUE: GI, VARIABLES_DEFAULT_NAME: VI, UNNAMED_KEY: WI, TODAY: zI, DUPLICATE_BLOCK: XI, ADD_COMMENT: YI, REMOVE_COMMENT: KI, DUPLICATE_COMMENT: jI, EXTERNAL_INPUTS: JI, INLINE_INPUTS: qI, DELETE_BLOCK: ZI, DELETE_X_BLOCKS: QI, DELETE_ALL_BLOCKS: ey, CLEAN_UP: ty, CLOSE: oy, COLLAPSE_BLOCK: sy, COLLAPSE_ALL: iy, EXPAND_BLOCK: ry, EXPAND_ALL: ny, DISABLE_BLOCK: ly, ENABLE_BLOCK: cy, HELP: ay, UNDO: uy, REDO: hy, CHANGE_VALUE_TITLE: dy, RENAME_VARIABLE: $y, RENAME_VARIABLE_TITLE: py, NEW_VARIABLE: gy, NEW_STRING_VARIABLE: my, NEW_NUMBER_VARIABLE: _y, NEW_COLOUR_VARIABLE: Ty, NEW_VARIABLE_TYPE_TITLE: Ey, NEW_VARIABLE_TITLE: by, VARIABLE_ALREADY_EXISTS: fy, VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE: Iy, VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER: yy, DELETE_VARIABLE_CONFIRMATION: Cy, CANNOT_DELETE_VARIABLE_PROCEDURE: vy, DELETE_VARIABLE: ky, COLOUR_PICKER_HELPURL: Ry, COLOUR_PICKER_TOOLTIP: Sy, COLOUR_RANDOM_HELPURL: Oy, COLOUR_RANDOM_TITLE: wy, COLOUR_RANDOM_TOOLTIP: Ly, COLOUR_RGB_HELPURL: Ny, COLOUR_RGB_TITLE: Ay, COLOUR_RGB_RED: My, COLOUR_RGB_GREEN: Dy, COLOUR_RGB_BLUE: Py, COLOUR_RGB_TOOLTIP: By, COLOUR_BLEND_HELPURL: xy, COLOUR_BLEND_TITLE: Fy, COLOUR_BLEND_COLOUR1: Hy, COLOUR_BLEND_COLOUR2: Uy, COLOUR_BLEND_RATIO: Gy, COLOUR_BLEND_TOOLTIP: Vy, CONTROLS_REPEAT_HELPURL: Wy, CONTROLS_REPEAT_TITLE: zy, CONTROLS_REPEAT_INPUT_DO: Xy, CONTROLS_REPEAT_TOOLTIP: Yy, CONTROLS_WHILEUNTIL_HELPURL: Ky, CONTROLS_WHILEUNTIL_INPUT_DO: jy, CONTROLS_WHILEUNTIL_OPERATOR_WHILE: Jy, CONTROLS_WHILEUNTIL_OPERATOR_UNTIL: qy, CONTROLS_WHILEUNTIL_TOOLTIP_WHILE: Zy, CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL: Qy, CONTROLS_FOR_HELPURL: eC, CONTROLS_FOR_TOOLTIP: tC, CONTROLS_FOR_TITLE: oC, CONTROLS_FOR_INPUT_DO: sC, CONTROLS_FOREACH_HELPURL: iC, CONTROLS_FOREACH_TITLE: rC, CONTROLS_FOREACH_INPUT_DO: nC, CONTROLS_FOREACH_TOOLTIP: lC, CONTROLS_FLOW_STATEMENTS_HELPURL: cC, CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK: aC, CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE: uC, CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK: hC, CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE: dC, CONTROLS_FLOW_STATEMENTS_WARNING: $C, CONTROLS_IF_HELPURL: pC, CONTROLS_IF_TOOLTIP_1: gC, CONTROLS_IF_TOOLTIP_2: mC, CONTROLS_IF_TOOLTIP_3: _C, CONTROLS_IF_TOOLTIP_4: TC, CONTROLS_IF_MSG_IF: EC, CONTROLS_IF_MSG_ELSEIF: bC, CONTROLS_IF_MSG_ELSE: fC, CONTROLS_IF_MSG_THEN: IC, CONTROLS_IF_IF_TITLE_IF: yC, CONTROLS_IF_IF_TOOLTIP: CC, CONTROLS_IF_ELSEIF_TITLE_ELSEIF: vC, CONTROLS_IF_ELSEIF_TOOLTIP: kC, CONTROLS_IF_ELSE_TITLE_ELSE: RC, CONTROLS_IF_ELSE_TOOLTIP: SC, LOGIC_COMPARE_HELPURL: OC, LOGIC_COMPARE_TOOLTIP_EQ: wC, LOGIC_COMPARE_TOOLTIP_NEQ: LC, LOGIC_COMPARE_TOOLTIP_LT: NC, LOGIC_COMPARE_TOOLTIP_LTE: AC, LOGIC_COMPARE_TOOLTIP_GT: MC, LOGIC_COMPARE_TOOLTIP_GTE: DC, LOGIC_OPERATION_HELPURL: PC, LOGIC_OPERATION_TOOLTIP_AND: BC, LOGIC_OPERATION_AND: xC, LOGIC_OPERATION_TOOLTIP_OR: FC, LOGIC_OPERATION_OR: HC, LOGIC_NEGATE_HELPURL: UC, LOGIC_NEGATE_TITLE: GC, LOGIC_NEGATE_TOOLTIP: VC, LOGIC_BOOLEAN_HELPURL: WC, LOGIC_BOOLEAN_TRUE: zC, LOGIC_BOOLEAN_FALSE: XC, LOGIC_BOOLEAN_TOOLTIP: YC, LOGIC_NULL_HELPURL: KC, LOGIC_NULL: jC, LOGIC_NULL_TOOLTIP: JC, LOGIC_TERNARY_HELPURL: qC, LOGIC_TERNARY_CONDITION: ZC, LOGIC_TERNARY_IF_TRUE: QC, LOGIC_TERNARY_IF_FALSE: ev, LOGIC_TERNARY_TOOLTIP: tv, MATH_NUMBER_HELPURL: ov, MATH_NUMBER_TOOLTIP: sv, MATH_ADDITION_SYMBOL: iv, MATH_SUBTRACTION_SYMBOL: rv, MATH_DIVISION_SYMBOL: nv, MATH_MULTIPLICATION_SYMBOL: lv, MATH_POWER_SYMBOL: cv, MATH_TRIG_SIN: av, MATH_TRIG_COS: uv, MATH_TRIG_TAN: hv, MATH_TRIG_ASIN: dv, MATH_TRIG_ACOS: $v, MATH_TRIG_ATAN: pv, MATH_ARITHMETIC_HELPURL: gv, MATH_ARITHMETIC_TOOLTIP_ADD: mv, MATH_ARITHMETIC_TOOLTIP_MINUS: _v, MATH_ARITHMETIC_TOOLTIP_MULTIPLY: Tv, MATH_ARITHMETIC_TOOLTIP_DIVIDE: Ev, MATH_ARITHMETIC_TOOLTIP_POWER: bv, MATH_SINGLE_HELPURL: fv, MATH_SINGLE_OP_ROOT: Iv, MATH_SINGLE_TOOLTIP_ROOT: yv, MATH_SINGLE_OP_ABSOLUTE: Cv, MATH_SINGLE_TOOLTIP_ABS: vv, MATH_SINGLE_TOOLTIP_NEG: kv, MATH_SINGLE_TOOLTIP_LN: Rv, MATH_SINGLE_TOOLTIP_LOG10: Sv, MATH_SINGLE_TOOLTIP_EXP: Ov, MATH_SINGLE_TOOLTIP_POW10: wv, MATH_TRIG_HELPURL: Lv, MATH_TRIG_TOOLTIP_SIN: Nv, MATH_TRIG_TOOLTIP_COS: Av, MATH_TRIG_TOOLTIP_TAN: Mv, MATH_TRIG_TOOLTIP_ASIN: Dv, MATH_TRIG_TOOLTIP_ACOS: Pv, MATH_TRIG_TOOLTIP_ATAN: Bv, MATH_CONSTANT_HELPURL: xv, MATH_CONSTANT_TOOLTIP: Fv, MATH_IS_EVEN: Hv, MATH_IS_ODD: Uv, MATH_IS_PRIME: Gv, MATH_IS_WHOLE: Vv, MATH_IS_POSITIVE: Wv, MATH_IS_NEGATIVE: zv, MATH_IS_DIVISIBLE_BY: Xv, MATH_IS_TOOLTIP: Yv, MATH_CHANGE_HELPURL: Kv, MATH_CHANGE_TITLE: jv, MATH_CHANGE_TITLE_ITEM: Jv, MATH_CHANGE_TOOLTIP: qv, MATH_ROUND_HELPURL: Zv, MATH_ROUND_TOOLTIP: Qv, MATH_ROUND_OPERATOR_ROUND: ek, MATH_ROUND_OPERATOR_ROUNDUP: tk, MATH_ROUND_OPERATOR_ROUNDDOWN: ok, MATH_ONLIST_HELPURL: sk, MATH_ONLIST_OPERATOR_SUM: ik, MATH_ONLIST_TOOLTIP_SUM: rk, MATH_ONLIST_OPERATOR_MIN: nk, MATH_ONLIST_TOOLTIP_MIN: lk, MATH_ONLIST_OPERATOR_MAX: ck, MATH_ONLIST_TOOLTIP_MAX: ak, MATH_ONLIST_OPERATOR_AVERAGE: uk, MATH_ONLIST_TOOLTIP_AVERAGE: hk, MATH_ONLIST_OPERATOR_MEDIAN: dk, MATH_ONLIST_TOOLTIP_MEDIAN: $k, MATH_ONLIST_OPERATOR_MODE: pk, MATH_ONLIST_TOOLTIP_MODE: gk, MATH_ONLIST_OPERATOR_STD_DEV: mk, MATH_ONLIST_TOOLTIP_STD_DEV: _k, MATH_ONLIST_OPERATOR_RANDOM: Tk, MATH_ONLIST_TOOLTIP_RANDOM: Ek, MATH_MODULO_HELPURL: bk, MATH_MODULO_TITLE: fk, MATH_MODULO_TOOLTIP: Ik, MATH_CONSTRAIN_HELPURL: yk, MATH_CONSTRAIN_TITLE: Ck, MATH_CONSTRAIN_TOOLTIP: vk, MATH_RANDOM_INT_HELPURL: kk, MATH_RANDOM_INT_TITLE: Rk, MATH_RANDOM_INT_TOOLTIP: Sk, MATH_RANDOM_FLOAT_HELPURL: Ok, MATH_RANDOM_FLOAT_TITLE_RANDOM: wk, MATH_RANDOM_FLOAT_TOOLTIP: Lk, MATH_ATAN2_HELPURL: Nk, MATH_ATAN2_TITLE: Ak, MATH_ATAN2_TOOLTIP: Mk, TEXT_TEXT_HELPURL: Dk, TEXT_TEXT_TOOLTIP: Pk, TEXT_JOIN_HELPURL: Bk, TEXT_JOIN_TITLE_CREATEWITH: xk, TEXT_JOIN_TOOLTIP: Fk, TEXT_CREATE_JOIN_TITLE_JOIN: Hk, TEXT_CREATE_JOIN_TOOLTIP: Uk, TEXT_CREATE_JOIN_ITEM_TITLE_ITEM: Gk, TEXT_CREATE_JOIN_ITEM_TOOLTIP: Vk, TEXT_APPEND_HELPURL: Wk, TEXT_APPEND_TITLE: zk, TEXT_APPEND_VARIABLE: Xk, TEXT_APPEND_TOOLTIP: Yk, TEXT_LENGTH_HELPURL: Kk, TEXT_LENGTH_TITLE: jk, TEXT_LENGTH_TOOLTIP: Jk, TEXT_ISEMPTY_HELPURL: qk, TEXT_ISEMPTY_TITLE: Zk, TEXT_ISEMPTY_TOOLTIP: Qk, TEXT_INDEXOF_HELPURL: eR, TEXT_INDEXOF_TOOLTIP: tR, TEXT_INDEXOF_TITLE: oR, TEXT_INDEXOF_OPERATOR_FIRST: sR, TEXT_INDEXOF_OPERATOR_LAST: iR, TEXT_CHARAT_HELPURL: rR, TEXT_CHARAT_TITLE: nR, TEXT_CHARAT_FROM_START: lR, TEXT_CHARAT_FROM_END: cR, TEXT_CHARAT_FIRST: aR, TEXT_CHARAT_LAST: uR, TEXT_CHARAT_RANDOM: hR, TEXT_CHARAT_TAIL: dR, TEXT_CHARAT_TOOLTIP: $R, TEXT_GET_SUBSTRING_TOOLTIP: pR, TEXT_GET_SUBSTRING_HELPURL: gR, TEXT_GET_SUBSTRING_INPUT_IN_TEXT: mR, TEXT_GET_SUBSTRING_START_FROM_START: _R, TEXT_GET_SUBSTRING_START_FROM_END: TR, TEXT_GET_SUBSTRING_START_FIRST: ER, TEXT_GET_SUBSTRING_END_FROM_START: bR, TEXT_GET_SUBSTRING_END_FROM_END: fR, TEXT_GET_SUBSTRING_END_LAST: IR, TEXT_GET_SUBSTRING_TAIL: yR, TEXT_CHANGECASE_HELPURL: CR, TEXT_CHANGECASE_TOOLTIP: vR, TEXT_CHANGECASE_OPERATOR_UPPERCASE: kR, TEXT_CHANGECASE_OPERATOR_LOWERCASE: RR, TEXT_CHANGECASE_OPERATOR_TITLECASE: SR, TEXT_TRIM_HELPURL: OR, TEXT_TRIM_TOOLTIP: wR, TEXT_TRIM_OPERATOR_BOTH: LR, TEXT_TRIM_OPERATOR_LEFT: NR, TEXT_TRIM_OPERATOR_RIGHT: AR, TEXT_PRINT_HELPURL: MR, TEXT_PRINT_TITLE: DR, TEXT_PRINT_TOOLTIP: PR, TEXT_PROMPT_HELPURL: BR, TEXT_PROMPT_TYPE_TEXT: xR, TEXT_PROMPT_TYPE_NUMBER: FR, TEXT_PROMPT_TOOLTIP_NUMBER: HR, TEXT_PROMPT_TOOLTIP_TEXT: UR, TEXT_COUNT_MESSAGE0: GR, TEXT_COUNT_HELPURL: VR, TEXT_COUNT_TOOLTIP: WR, TEXT_REPLACE_MESSAGE0: zR, TEXT_REPLACE_HELPURL: XR, TEXT_REPLACE_TOOLTIP: YR, TEXT_REVERSE_MESSAGE0: KR, TEXT_REVERSE_HELPURL: jR, TEXT_REVERSE_TOOLTIP: JR, LISTS_CREATE_EMPTY_HELPURL: qR, LISTS_CREATE_EMPTY_TITLE: ZR, LISTS_CREATE_EMPTY_TOOLTIP: QR, LISTS_CREATE_WITH_HELPURL: eS, LISTS_CREATE_WITH_TOOLTIP: tS, LISTS_CREATE_WITH_INPUT_WITH: oS, LISTS_CREATE_WITH_CONTAINER_TITLE_ADD: sS, LISTS_CREATE_WITH_CONTAINER_TOOLTIP: iS, LISTS_CREATE_WITH_ITEM_TITLE: rS, LISTS_CREATE_WITH_ITEM_TOOLTIP: nS, LISTS_REPEAT_HELPURL: lS, LISTS_REPEAT_TOOLTIP: cS, LISTS_REPEAT_TITLE: aS, LISTS_LENGTH_HELPURL: uS, LISTS_LENGTH_TITLE: hS, LISTS_LENGTH_TOOLTIP: dS, LISTS_ISEMPTY_HELPURL: $S, LISTS_ISEMPTY_TITLE: pS, LISTS_ISEMPTY_TOOLTIP: gS, LISTS_INLIST: mS, LISTS_INDEX_OF_HELPURL: _S, LISTS_INDEX_OF_INPUT_IN_LIST: TS, LISTS_INDEX_OF_FIRST: ES, LISTS_INDEX_OF_LAST: bS, LISTS_INDEX_OF_TOOLTIP: fS, LISTS_GET_INDEX_HELPURL: IS, LISTS_GET_INDEX_GET: yS, LISTS_GET_INDEX_GET_REMOVE: CS, LISTS_GET_INDEX_REMOVE: vS, LISTS_GET_INDEX_FROM_START: kS, LISTS_GET_INDEX_FROM_END: RS, LISTS_GET_INDEX_FIRST: SS, LISTS_GET_INDEX_LAST: OS, LISTS_GET_INDEX_RANDOM: wS, LISTS_GET_INDEX_TAIL: LS, LISTS_GET_INDEX_INPUT_IN_LIST: NS, LISTS_INDEX_FROM_START_TOOLTIP: AS, LISTS_INDEX_FROM_END_TOOLTIP: MS, LISTS_GET_INDEX_TOOLTIP_GET_FROM: DS, LISTS_GET_INDEX_TOOLTIP_GET_FIRST: PS, LISTS_GET_INDEX_TOOLTIP_GET_LAST: BS, LISTS_GET_INDEX_TOOLTIP_GET_RANDOM: xS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM: FS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST: HS, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST: US, LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM: GS, LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM: VS, LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST: WS, LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST: zS, LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM: XS, LISTS_SET_INDEX_HELPURL: YS, LISTS_SET_INDEX_INPUT_IN_LIST: KS, LISTS_SET_INDEX_SET: jS, LISTS_SET_INDEX_INSERT: JS, LISTS_SET_INDEX_INPUT_TO: qS, LISTS_SET_INDEX_TOOLTIP_SET_FROM: ZS, LISTS_SET_INDEX_TOOLTIP_SET_FIRST: QS, LISTS_SET_INDEX_TOOLTIP_SET_LAST: eO, LISTS_SET_INDEX_TOOLTIP_SET_RANDOM: tO, LISTS_SET_INDEX_TOOLTIP_INSERT_FROM: oO, LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST: sO, LISTS_SET_INDEX_TOOLTIP_INSERT_LAST: iO, LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM: rO, LISTS_GET_SUBLIST_HELPURL: nO, LISTS_GET_SUBLIST_INPUT_IN_LIST: lO, LISTS_GET_SUBLIST_START_FROM_START: cO, LISTS_GET_SUBLIST_START_FROM_END: aO, LISTS_GET_SUBLIST_START_FIRST: uO, LISTS_GET_SUBLIST_END_FROM_START: hO, LISTS_GET_SUBLIST_END_FROM_END: dO, LISTS_GET_SUBLIST_END_LAST: $O, LISTS_GET_SUBLIST_TAIL: pO, LISTS_GET_SUBLIST_TOOLTIP: gO, LISTS_SORT_HELPURL: mO, LISTS_SORT_TITLE: _O, LISTS_SORT_TOOLTIP: TO, LISTS_SORT_ORDER_ASCENDING: EO, LISTS_SORT_ORDER_DESCENDING: bO, LISTS_SORT_TYPE_NUMERIC: fO, LISTS_SORT_TYPE_TEXT: IO, LISTS_SORT_TYPE_IGNORECASE: yO, LISTS_SPLIT_HELPURL: CO, LISTS_SPLIT_LIST_FROM_TEXT: vO, LISTS_SPLIT_TEXT_FROM_LIST: kO, LISTS_SPLIT_WITH_DELIMITER: RO, LISTS_SPLIT_TOOLTIP_SPLIT: SO, LISTS_SPLIT_TOOLTIP_JOIN: OO, LISTS_REVERSE_HELPURL: wO, LISTS_REVERSE_MESSAGE0: LO, LISTS_REVERSE_TOOLTIP: NO, ORDINAL_NUMBER_SUFFIX: AO, VARIABLES_GET_HELPURL: MO, VARIABLES_GET_TOOLTIP: DO, VARIABLES_GET_CREATE_SET: PO, VARIABLES_SET_HELPURL: BO, VARIABLES_SET: xO, VARIABLES_SET_TOOLTIP: FO, VARIABLES_SET_CREATE_GET: HO, PROCEDURES_DEFNORETURN_HELPURL: UO, PROCEDURES_DEFNORETURN_TITLE: GO, PROCEDURES_DEFNORETURN_PROCEDURE: VO, PROCEDURES_BEFORE_PARAMS: WO, PROCEDURES_CALL_BEFORE_PARAMS: zO, PROCEDURES_CALL_DISABLED_DEF_WARNING: XO, PROCEDURES_DEFNORETURN_DO: YO, PROCEDURES_DEFNORETURN_TOOLTIP: KO, PROCEDURES_DEFNORETURN_COMMENT: jO, PROCEDURES_DEFRETURN_HELPURL: JO, PROCEDURES_DEFRETURN_TITLE: qO, PROCEDURES_DEFRETURN_PROCEDURE: ZO, PROCEDURES_DEFRETURN_DO: QO, PROCEDURES_DEFRETURN_COMMENT: ew, PROCEDURES_DEFRETURN_RETURN: tw, PROCEDURES_DEFRETURN_TOOLTIP: ow, PROCEDURES_ALLOW_STATEMENTS: sw, PROCEDURES_DEF_DUPLICATE_WARNING: iw, PROCEDURES_CALLNORETURN_HELPURL: rw, PROCEDURES_CALLNORETURN_TOOLTIP: nw, PROCEDURES_CALLRETURN_HELPURL: lw, PROCEDURES_CALLRETURN_TOOLTIP: cw, PROCEDURES_MUTATORCONTAINER_TITLE: aw, PROCEDURES_MUTATORCONTAINER_TOOLTIP: uw, PROCEDURES_MUTATORARG_TITLE: hw, PROCEDURES_MUTATORARG_TOOLTIP: dw, PROCEDURES_HIGHLIGHT_DEF: $w, PROCEDURES_CREATE_DO: pw, PROCEDURES_IFRETURN_TOOLTIP: gw, PROCEDURES_IFRETURN_HELPURL: mw, PROCEDURES_IFRETURN_WARNING: _w, WORKSPACE_COMMENT_DEFAULT_TEXT: Tw, WORKSPACE_ARIA_LABEL: Ew, COLLAPSED_WARNINGS_WARNING: bw, DIALOG_OK: fw, DIALOG_CANCEL: Iw, EDIT_BLOCK_CONTENTS: yw, MOVE_BLOCK: Cw, WINDOWS: vw, MAC_OS: kw, CHROME_OS: Rw, LINUX: Sw, UNKNOWN: Ow, CONTROL_KEY: ww, COMMAND_KEY: Lw, OPTION_KEY: Nw, ALT_KEY: Aw, CUT_SHORTCUT: Mw, COPY_SHORTCUT: Dw, PASTE_SHORTCUT: Pw, HELP_PROMPT: Bw, SHORTCUTS_GENERAL: xw, SHORTCUTS_EDITING: Fw, SHORTCUTS_CODE_NAVIGATION: Hw, KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT: Uw, KEYBOARD_NAV_CONSTRAINED_MOVE_HINT: Gw, KEYBOARD_NAV_COPIED_HINT: Vw, KEYBOARD_NAV_CUT_HINT: Ww } = X_.default;
    var zw = [{ type: "ground_bool_true", tooltip: "Boolean true literal", message0: "true", output: "Proc", colour: "160" }, { type: "ground_bool_false", tooltip: "Boolean false literal", message0: "false", output: "Proc", colour: "160" }, { type: "ground_int", tooltip: "Integer literal", message0: "%1", args0: [{ type: "field_number", name: "VALUE", value: 0, precision: 1 }], output: "Proc", colour: "230" }, { type: "ground_string", tooltip: "String literal", message0: '"%1"', args0: [{ type: "field_input", name: "VALUE", text: "" }], output: "Proc", colour: "160" }, { type: "ground_uri", tooltip: "URI literal", message0: "`%1`", args0: [{ type: "field_input", name: "VALUE", text: "" }], output: "Proc", colour: "290" }, { type: "simple_type_bool", tooltip: "Bool type", message0: "Bool", output: "SimpleType", colour: "160" }, { type: "simple_type_int", tooltip: "Int type", message0: "Int", output: "SimpleType", colour: "230" }, { type: "simple_type_string", tooltip: "String type", message0: "String", output: "SimpleType", colour: "160" }, { type: "simple_type_uri", tooltip: "Uri type", message0: "Uri", output: "SimpleType", colour: "290" }, { type: "simple_type_byte_array", tooltip: "ByteArray type", message0: "ByteArray", output: "SimpleType", colour: "290" }], Od = ce.createBlockDefinitionsFromJsonArray(zw);
    var Xw = [{ type: "name_wildcard", tooltip: "Wildcard name pattern", message0: "_", output: "Name", colour: "65" }, { type: "name_var", tooltip: "Variable name", message0: "%1", args0: [{ type: "field_input", name: "VAR", text: "x" }], output: "Name", colour: "65" }, { type: "name_quote", tooltip: "Quote process to name: @Proc", message0: "@ %1", args0: [{ type: "input_value", name: "PROC", check: "Proc" }], inputsInline: true, output: "Name", colour: "65" }, { type: "name_decl_simple", tooltip: "Simple name declaration", message0: "%1", args0: [{ type: "field_input", name: "VAR", text: "x" }], output: "NameDecl", colour: "65" }, { type: "name_decl_urn", tooltip: "Name declaration with URN", message0: "%1 ( `%2` )", args0: [{ type: "field_input", name: "VAR", text: "x" }, { type: "field_input", name: "URN", text: "" }], output: "NameDecl", colour: "65" }, { type: "name_remainder", tooltip: "Name remainder pattern ...@var", message0: "...@ %1", args0: [{ type: "field_input", name: "VAR", text: "rest" }], output: "NameRemainder", colour: "65" }], wd = ce.createBlockDefinitionsFromJsonArray(Xw);
    var Yw = [{ type: "collect_list", tooltip: "List collection: [elements...]", message0: "[ %1 ]", args0: [{ type: "input_value", name: "ELEMENTS", check: "ProcList" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "collect_list_remainder", tooltip: "List with remainder: [elements...rest]", message0: "[ %1 ...%2 ]", args0: [{ type: "input_value", name: "ELEMENTS", check: "ProcList" }, { type: "field_input", name: "REMAINDER", text: "rest" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "tuple_single", tooltip: "Single element tuple: (element,)", message0: "( %1 ,)", args0: [{ type: "input_value", name: "ELEMENT", check: "Proc" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "tuple_multiple", tooltip: "Tuple: (element, elements...)", message0: "( %1 , %2 )", args0: [{ type: "input_value", name: "FIRST", check: "Proc" }, { type: "input_value", name: "REST", check: "ProcList" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "collect_set", tooltip: "Set collection: Set(elements...)", message0: "Set( %1 )", args0: [{ type: "input_value", name: "ELEMENTS", check: "ProcList" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "collect_map", tooltip: "Map collection: {key: value, ...}", message0: "{ %1 }", args0: [{ type: "input_value", name: "PAIRS", check: "KeyValuePairList" }], inputsInline: true, output: "Collection", colour: "260" }, { type: "key_value_pair", tooltip: "Key-value pair: key: value", message0: "%1 : %2", args0: [{ type: "input_value", name: "KEY", check: "Proc" }, { type: "input_value", name: "VALUE", check: "Proc" }], inputsInline: true, output: "KeyValuePair", colour: "260" }, { type: "proc_list", tooltip: "List of processes", message0: "%1 , %2", args0: [{ type: "input_value", name: "ITEM", check: "Proc" }, { type: "input_value", name: "NEXT", check: ["ProcList", "Proc"] }], inputsInline: true, output: "ProcList", colour: "260" }, { type: "proc_remainder", tooltip: "Process remainder: ...var", message0: "...%1", args0: [{ type: "field_input", name: "VAR", text: "rest" }], output: "ProcRemainder", colour: "260" }, { type: "name_list", tooltip: "List of names", message0: "%1 , %2", args0: [{ type: "input_value", name: "ITEM", check: "Name" }, { type: "input_value", name: "NEXT", check: ["NameList", "Name"] }], inputsInline: true, output: "NameList", colour: "65" }], Ld = ce.createBlockDefinitionsFromJsonArray(Yw);
    var Kw = [{ type: "linear_bind", tooltip: "Linear bind: pattern <- channel", message0: "%1 <- %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "LinearBind", colour: "210" }, { type: "linear_bind_receive_send", tooltip: "Linear bind with receive-send: pattern <- channel?!", message0: "%1 <- %2 ?!", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "LinearBind", colour: "210" }, { type: "linear_bind_send_receive", tooltip: "Linear bind with send-receive: pattern <- channel!?(args)", message0: "%1 <- %2 !?( %3 )", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }, { type: "input_value", name: "ARGS", check: "ProcList" }], inputsInline: true, output: "LinearBind", colour: "210" }, { type: "repeated_bind", tooltip: "Repeated bind: pattern <= channel", message0: "%1 <= %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "RepeatedBind", colour: "210" }, { type: "peek_bind", tooltip: "Peek bind: pattern <<- channel", message0: "%1 <<- %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "PeekBind", colour: "210" }, { type: "receipt_linear", tooltip: "Linear receipt", message0: "%1", args0: [{ type: "input_value", name: "BINDS", check: "LinearBind" }], inputsInline: true, output: "Receipt", colour: "210" }, { type: "receipt_repeated", tooltip: "Repeated receipt", message0: "%1", args0: [{ type: "input_value", name: "BINDS", check: "RepeatedBind" }], inputsInline: true, output: "Receipt", colour: "210" }, { type: "receipt_peek", tooltip: "Peek receipt", message0: "%1", args0: [{ type: "input_value", name: "BINDS", check: "PeekBind" }], inputsInline: true, output: "Receipt", colour: "210" }, { type: "concurrent_binds", tooltip: "Concurrent binds: bind1 & bind2", message0: "%1 & %2", args0: [{ type: "input_value", name: "LEFT", check: ["LinearBind", "RepeatedBind", "PeekBind"] }, { type: "input_value", name: "RIGHT", check: ["LinearBind", "RepeatedBind", "PeekBind"] }], inputsInline: true, output: ["LinearBind", "RepeatedBind", "PeekBind"], colour: "210" }, { type: "sequential_receipts", tooltip: "Sequential receipts: receipt1 ; receipt2", message0: "%1 ; %2", args0: [{ type: "input_value", name: "LEFT", check: "Receipt" }, { type: "input_value", name: "RIGHT", check: "Receipt" }], inputsInline: true, output: "Receipt", colour: "210" }, { type: "linear_bind_symm", tooltip: "Symmetric linear bind: pattern <-> channel", message0: "%1 <-> %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "LinearBindSymm", colour: "210" }, { type: "repeated_bind_symm", tooltip: "Symmetric repeated bind: pattern <=> channel", message0: "%1 <=> %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "RepeatedBindSymm", colour: "210" }, { type: "peek_bind_symm", tooltip: "Symmetric peek bind: pattern <<->> channel", message0: "%1 <<->> %2", args0: [{ type: "input_value", name: "PATTERN", check: ["Name", "NameList"] }, { type: "input_value", name: "SOURCE", check: "Name" }], inputsInline: true, output: "PeekBindSymm", colour: "210" }], Nd = ce.createBlockDefinitionsFromJsonArray(Kw);
    var jw = [{ type: "proc_if", tooltip: "Conditional: if (condition) body", message0: "if ( %1 ) %2", args0: [{ type: "input_value", name: "CONDITION", check: "Proc" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_if_else", tooltip: "Conditional: if (condition) then else", message0: "if ( %1 ) %2 else %3", args0: [{ type: "input_value", name: "CONDITION", check: "Proc" }, { type: "input_statement", name: "THEN_BODY", check: "Proc" }, { type: "input_statement", name: "ELSE_BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_match", tooltip: "Pattern match: match expr { cases }", message0: "match %1 { %2 }", args0: [{ type: "input_value", name: "EXPR", check: "Proc" }, { type: "input_statement", name: "CASES", check: "Case" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "case", tooltip: "Match case: pattern => body", message0: "%1 => %2", args0: [{ type: "input_value", name: "PATTERN", check: "Proc" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Case", nextStatement: "Case", colour: "208bfe" }, { type: "proc_select", tooltip: "Select: select { branches }", message0: "select { %1 }", args0: [{ type: "input_statement", name: "BRANCHES", check: "Branch" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "branch", tooltip: "Select branch: receipt => body", message0: "%1 => %2", args0: [{ type: "input_value", name: "RECEIPT", check: "LinearBind" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Branch", nextStatement: "Branch", colour: "208bfe" }], Ad = ce.createBlockDefinitionsFromJsonArray(jw);
    var Jw = [{ type: "proc_new", tooltip: "New: new names in body", message0: "new %1 in %2", args0: [{ type: "input_value", name: "NAMES", check: ["NameDecl", "NameDeclList"] }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "name_decl_list", tooltip: "Name declarations: name1, name2, ...", message0: "%1 , %2", args0: [{ type: "input_value", name: "ITEM", check: "NameDecl" }, { type: "input_value", name: "NEXT", check: ["NameDeclList", "NameDecl"] }], inputsInline: true, output: "NameDeclList", colour: "65" }, { type: "proc_let", tooltip: "Let: let decls in body", message0: "let %1 in { %2 }", args0: [{ type: "input_value", name: "DECLS", check: "Decl" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "decl", tooltip: "Declaration: names <- procs", message0: "%1 <- %2", args0: [{ type: "input_value", name: "NAMES", check: ["Name", "NameList"] }, { type: "input_value", name: "PROCS", check: ["Proc", "ProcList"] }], inputsInline: true, output: "Decl", colour: "208bfe" }, { type: "linear_decls", tooltip: "Linear declarations: decl1 ; decl2", message0: "%1 ; %2", args0: [{ type: "input_value", name: "LEFT", check: "Decl" }, { type: "input_value", name: "RIGHT", check: "Decl" }], inputsInline: true, output: "Decl", colour: "208bfe" }, { type: "conc_decls", tooltip: "Concurrent declarations: decl1 & decl2", message0: "%1 & %2", args0: [{ type: "input_value", name: "LEFT", check: "Decl" }, { type: "input_value", name: "RIGHT", check: "Decl" }], inputsInline: true, output: "Decl", colour: "208bfe" }, { type: "proc_contract", tooltip: "Contract: contract name(params) = { body }", message0: "contract %1 ( %2 ) = { %3 }", args0: [{ type: "input_value", name: "NAME", check: "Name" }, { type: "input_value", name: "PARAMS", check: ["Name", "NameList"] }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "1B9461" }, { type: "proc_contract_remainder", tooltip: "Contract with remainder: contract name(params...rest) = { body }", message0: "contract %1 ( %2 ...@ %3 ) = { %4 }", args0: [{ type: "input_value", name: "NAME", check: "Name" }, { type: "input_value", name: "PARAMS", check: ["Name", "NameList"] }, { type: "field_input", name: "REMAINDER", text: "rest" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "1B9461" }, { type: "proc_bundle_write", tooltip: "Write-only bundle: bundle+ { body }", message0: "bundle+ { %1 }", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_bundle_read", tooltip: "Read-only bundle: bundle- { body }", message0: "bundle- { %1 }", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_bundle_equiv", tooltip: "Equivalence bundle: bundle0 { body }", message0: "bundle0 { %1 }", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_bundle_rw", tooltip: "Read-write bundle: bundle { body }", message0: "bundle { %1 }", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }], Md = ce.createBlockDefinitionsFromJsonArray(Jw);
    var qw = [{ type: "proc_root", tooltip: "Root process - all blocks must connect to this", message0: "Root %1", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], colour: "0", deletable: false }, { type: "proc_nil", tooltip: "Nil process", message0: "Nil", output: "Proc", colour: "208bfe" }, { type: "proc_collect", tooltip: "Collection as process", message0: "%1", args0: [{ type: "input_value", name: "VALUE", check: "Collection" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_var", tooltip: "Process variable", message0: "%1", args0: [{ type: "field_input", name: "VAR", text: "x" }], output: "Proc", colour: "208bfe" }, { type: "proc_var_wildcard", tooltip: "Wildcard process variable", message0: "_", output: "Proc", colour: "208bfe" }, { type: "proc_var_ref", tooltip: "Variable reference: =var", message0: "= %1", args0: [{ type: "field_input", name: "VAR", text: "x" }], output: "Proc", colour: "208bfe" }, { type: "proc_var_ref_name", tooltip: "Name variable reference: =*var", message0: "=* %1", args0: [{ type: "field_input", name: "VAR", text: "x" }], output: "Proc", colour: "208bfe" }, { type: "proc_simple_type", tooltip: "Simple type as process", message0: "%1", args0: [{ type: "input_value", name: "TYPE", check: "SimpleType" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_eval", tooltip: "Evaluate name: *name", message0: "* %1", args0: [{ type: "input_value", name: "NAME", check: "Name" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_paren", tooltip: "Parenthesized expression", message0: "( %1 )", args0: [{ type: "input_value", name: "EXPR", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_negation", tooltip: "Process negation: ~proc", message0: "~ %1", args0: [{ type: "input_value", name: "PROC", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_conjunction", tooltip: "Process conjunction: proc /\\ proc", message0: "%1 /\\ %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_disjunction", tooltip: "Process disjunction: proc \\/ proc", message0: "%1 \\/ %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_not", tooltip: "Logical not: not proc", message0: "not %1", args0: [{ type: "input_value", name: "PROC", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_and", tooltip: "Logical and: proc and proc", message0: "%1 and %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_or", tooltip: "Logical or: proc or proc", message0: "%1 or %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_neg", tooltip: "Unary negation: -proc", message0: "- %1", args0: [{ type: "input_value", name: "PROC", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_mult", tooltip: "Multiplication: proc * proc", message0: "%1 * %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_div", tooltip: "Division: proc / proc", message0: "%1 / %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_mod", tooltip: "Modulo: proc % proc", message0: "%1 %% %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_percent_percent", tooltip: "Percent percent: proc %% proc", message0: "%1 %%%% %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_add", tooltip: "Addition: proc + proc", message0: "%1 + %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_minus", tooltip: "Subtraction: proc - proc", message0: "%1 - %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_plus_plus", tooltip: "List concatenation: proc ++ proc", message0: "%1 ++ %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_minus_minus", tooltip: "Set difference: proc -- proc", message0: "%1 -- %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_lt", tooltip: "Less than: proc < proc", message0: "%1 < %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_lte", tooltip: "Less than or equal: proc <= proc", message0: "%1 <= %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_gt", tooltip: "Greater than: proc > proc", message0: "%1 > %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_gte", tooltip: "Greater than or equal: proc >= proc", message0: "%1 >= %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_eq", tooltip: "Equality: proc == proc", message0: "%1 == %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_neq", tooltip: "Not equal: proc != proc", message0: "%1 != %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_matches", tooltip: "Pattern matches: proc matches proc", message0: "%1 matches %2", args0: [{ type: "input_value", name: "LEFT", check: "Proc" }, { type: "input_value", name: "RIGHT", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_method", tooltip: "Method call: proc.method(args)", message0: "%1 . %2 ( %3 )", args0: [{ type: "input_value", name: "OBJECT", check: "Proc" }, { type: "field_input", name: "METHOD", text: "method" }, { type: "input_value", name: "ARGS", check: ["Proc", "ProcList"] }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_path_map", tooltip: "Path map: %proc", message0: "%% %1", args0: [{ type: "input_value", name: "PROC", check: "Proc" }], inputsInline: true, output: "Proc", colour: "208bfe" }, { type: "proc_send", tooltip: "Send: channel!(args)", message0: "%1 ! ( %2 )", args0: [{ type: "input_value", name: "CHANNEL", check: "Name" }, { type: "input_value", name: "ARGS", check: ["Proc", "ProcList"] }], inputsInline: true, previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_send_multiple", tooltip: "Persistent send: channel!!(args)", message0: "%1 !! ( %2 )", args0: [{ type: "input_value", name: "CHANNEL", check: "Name" }, { type: "input_value", name: "ARGS", check: ["Proc", "ProcList"] }], inputsInline: true, previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_send_symm", tooltip: "Symmetric send: channel!$(args)", message0: "%1 !$ ( %2 )", args0: [{ type: "input_value", name: "CHANNEL", check: "Name" }, { type: "input_value", name: "ARGS", check: ["Proc", "ProcList"] }], inputsInline: true, previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_send_synch", tooltip: "Synchronous send: channel!?(args)", message0: "%1 !? ( %2 ) %3", args0: [{ type: "input_value", name: "CHANNEL", check: "Name" }, { type: "input_value", name: "ARGS", check: ["Proc", "ProcList"] }, { type: "input_value", name: "CONT", check: "SynchSendCont" }], inputsInline: true, previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "synch_send_cont_empty", tooltip: "Empty synchronous send continuation", message0: ".", output: "SynchSendCont", colour: "208bfe" }, { type: "synch_send_cont", tooltip: "Synchronous send continuation: ; proc", message0: "; %1", args0: [{ type: "input_statement", name: "BODY", check: "Proc" }], output: "SynchSendCont", colour: "208bfe" }, { type: "proc_for", tooltip: "For: for (receipts) { body }", message0: "for ( %1 ) { %2 }", args0: [{ type: "input_value", name: "RECEIPTS", check: "Receipt" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_foreach", tooltip: "Foreach: foreach (receipts) { body }", message0: "foreach ( %1 ) { %2 }", args0: [{ type: "input_value", name: "RECEIPTS", check: "Receipt" }, { type: "input_statement", name: "BODY", check: "Proc" }], previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }, { type: "proc_par", tooltip: "Parallel composition: proc | proc", message0: "%1 | %2", args0: [{ type: "input_statement", name: "LEFT", check: "Proc" }, { type: "input_statement", name: "RIGHT", check: "Proc" }], inputsInline: true, previousStatement: "Proc", nextStatement: "Proc", colour: "208bfe" }], Dd = ce.createBlockDefinitionsFromJsonArray(qw);
    function Y_() {
      ce.defineBlocks(Od), ce.defineBlocks(wd), ce.defineBlocks(Ld), ce.defineBlocks(Nd), ce.defineBlocks(Ad), ce.defineBlocks(Md), ce.defineBlocks(Dd);
    }
    var K_ = { kind: "categoryToolbox", contents: [{ kind: "category", name: "Ground Types", contents: [{ kind: "block", type: "ground_bool_true" }, { kind: "block", type: "ground_bool_false" }, { kind: "block", type: "ground_int" }, { kind: "block", type: "ground_string" }, { kind: "block", type: "ground_uri" }, { kind: "block", type: "simple_type_bool" }, { kind: "block", type: "simple_type_int" }, { kind: "block", type: "simple_type_string" }, { kind: "block", type: "simple_type_uri" }, { kind: "block", type: "simple_type_byte_array" }] }, { kind: "category", name: "Names", contents: [{ kind: "block", type: "name_wildcard" }, { kind: "block", type: "name_var" }, { kind: "block", type: "name_quote", inputs: { PROC: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "name_decl_simple" }, { kind: "block", type: "name_decl_urn" }, { kind: "block", type: "name_remainder" }, { kind: "block", type: "name_list", inputs: { ITEM: { shadow: { type: "name_var" } }, NEXT: { shadow: { type: "name_var" } } } }] }, { kind: "category", name: "Collections", contents: [{ kind: "block", type: "collect_list", inputs: { ELEMENTS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "collect_list_remainder", inputs: { ELEMENTS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "tuple_single", inputs: { ELEMENT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "tuple_multiple", inputs: { FIRST: { shadow: { type: "proc_var" } }, REST: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "collect_set", inputs: { ELEMENTS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "collect_map" }, { kind: "block", type: "key_value_pair", inputs: { KEY: { shadow: { type: "proc_var" } }, VALUE: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_remainder" }, { kind: "block", type: "name_list", inputs: { ITEM: { shadow: { type: "name_var" } }, NEXT: { shadow: { type: "name_var" } } } }] }, { kind: "category", name: "Receipts & Binds", contents: [{ kind: "block", type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "linear_bind_receive_send", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "linear_bind_send_receive", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "repeated_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "peek_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "receipt_linear", inputs: { BINDS: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } }, { kind: "block", type: "receipt_repeated", inputs: { BINDS: { shadow: { type: "repeated_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } }, { kind: "block", type: "receipt_peek", inputs: { BINDS: { shadow: { type: "peek_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } }, { kind: "block", type: "concurrent_binds", inputs: { LEFT: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } }, RIGHT: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } }, { kind: "block", type: "sequential_receipts", inputs: { LEFT: { shadow: { type: "receipt_linear", inputs: { BINDS: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } } }, RIGHT: { shadow: { type: "receipt_linear", inputs: { BINDS: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } } } } }, { kind: "block", type: "linear_bind_symm", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "repeated_bind_symm", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }, { kind: "block", type: "peek_bind_symm", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } }] }, { kind: "category", name: "Control Flow", contents: [{ kind: "block", type: "proc_if", inputs: { CONDITION: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_if_else", inputs: { CONDITION: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_match", inputs: { EXPR: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "case", inputs: { PATTERN: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_select" }, { kind: "block", type: "branch", inputs: { RECEIPT: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } }] }, { kind: "category", name: "Declarations", contents: [{ kind: "block", type: "proc_new", inputs: { NAMES: { shadow: { type: "name_decl_simple" } } } }, { kind: "block", type: "name_decl_list", inputs: { ITEM: { shadow: { type: "name_decl_simple" } }, NEXT: { shadow: { type: "name_decl_simple" } } } }, { kind: "block", type: "proc_let", inputs: { DECLS: { shadow: { type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "linear_decls", inputs: { LEFT: { shadow: { type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } } }, RIGHT: { shadow: { type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "conc_decls", inputs: { LEFT: { shadow: { type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } } }, RIGHT: { shadow: { type: "decl", inputs: { NAMES: { shadow: { type: "name_var" } }, PROCS: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "proc_contract", inputs: { NAME: { shadow: { type: "name_var" } }, PARAMS: { shadow: { type: "name_var" } } } }, { kind: "block", type: "proc_contract_remainder", inputs: { NAME: { shadow: { type: "name_var" } }, PARAMS: { shadow: { type: "name_var" } } } }, { kind: "block", type: "proc_bundle_write" }, { kind: "block", type: "proc_bundle_read" }, { kind: "block", type: "proc_bundle_equiv" }, { kind: "block", type: "proc_bundle_rw" }] }, { kind: "category", name: "Basic Processes", contents: [{ kind: "block", type: "proc_nil" }, { kind: "block", type: "proc_collect", inputs: { VALUE: { shadow: { type: "collect_list", inputs: { ELEMENTS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } } } } }, { kind: "block", type: "proc_var" }, { kind: "block", type: "proc_var_wildcard" }, { kind: "block", type: "proc_var_ref" }, { kind: "block", type: "proc_var_ref_name" }, { kind: "block", type: "proc_simple_type", inputs: { TYPE: { shadow: { type: "simple_type_int" } } } }, { kind: "block", type: "proc_eval", inputs: { NAME: { shadow: { type: "name_var" } } } }, { kind: "block", type: "proc_paren", inputs: { EXPR: { shadow: { type: "proc_var" } } } }] }, { kind: "category", name: "Logical Operations", contents: [{ kind: "block", type: "proc_negation", inputs: { PROC: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_conjunction", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_disjunction", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_not", inputs: { PROC: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_and", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_or", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }] }, { kind: "category", name: "Arithmetic", contents: [{ kind: "block", type: "proc_neg", inputs: { PROC: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_mult", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_div", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_mod", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_percent_percent", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_add", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_minus", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_plus_plus", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_minus_minus", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }] }, { kind: "category", name: "Comparison", contents: [{ kind: "block", type: "proc_lt", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_lte", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_gt", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_gte", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_eq", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_neq", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }, { kind: "block", type: "proc_matches", inputs: { LEFT: { shadow: { type: "proc_var" } }, RIGHT: { shadow: { type: "proc_var" } } } }] }, { kind: "category", name: "Methods & Paths", contents: [{ kind: "block", type: "proc_method", inputs: { OBJECT: { shadow: { type: "proc_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "proc_path_map", inputs: { PROC: { shadow: { type: "proc_var" } } } }] }, { kind: "category", name: "Send & Receive", contents: [{ kind: "block", type: "proc_send", inputs: { CHANNEL: { shadow: { type: "name_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "proc_send_multiple", inputs: { CHANNEL: { shadow: { type: "name_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "proc_send_symm", inputs: { CHANNEL: { shadow: { type: "name_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } } } }, { kind: "block", type: "proc_send_synch", inputs: { CHANNEL: { shadow: { type: "name_var" } }, ARGS: { shadow: { type: "proc_list", inputs: { ITEM: { shadow: { type: "proc_var" } }, NEXT: { shadow: { type: "proc_var" } } } } }, CONT: { shadow: { type: "synch_send_cont_empty" } } } }, { kind: "block", type: "synch_send_cont_empty" }, { kind: "block", type: "synch_send_cont" }, { kind: "block", type: "proc_for", inputs: { RECEIPTS: { shadow: { type: "receipt_linear", inputs: { BINDS: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } } } } }, { kind: "block", type: "proc_foreach", inputs: { RECEIPTS: { shadow: { type: "receipt_linear", inputs: { BINDS: { shadow: { type: "linear_bind", inputs: { PATTERN: { shadow: { type: "name_var" } }, SOURCE: { shadow: { type: "name_var" } } } } } } } } } }] }, { kind: "category", name: "Composition", contents: [{ kind: "block", type: "proc_par" }] }] };
    function Zw() {
      let r = new H_("Rholang"), c = { ATOMIC: 0, MEMBER: 1, UNARY: 2, MULTIPLICATIVE: 3, ADDITIVE: 4, RELATIONAL: 5, EQUALITY: 6, CONJUNCTION: 7, DISJUNCTION: 8, AND: 9, OR: 10, PARALLEL: 11, NONE: 99 };
      return r.forBlock.proc_root = function(u) {
        return r.statementToCode(u, "BODY");
      }, r.forBlock.ground_bool_true = function() {
        return ["true", c.ATOMIC];
      }, r.forBlock.ground_bool_false = function() {
        return ["false", c.ATOMIC];
      }, r.forBlock.ground_int = function(u) {
        let p = u.getFieldValue("VALUE");
        return [String(p), c.ATOMIC];
      }, r.forBlock.ground_string = function(u) {
        return [`"${u.getFieldValue("VALUE")}"`, c.ATOMIC];
      }, r.forBlock.ground_uri = function(u) {
        return [`\`${u.getFieldValue("VALUE")}\``, c.ATOMIC];
      }, r.forBlock.simple_type_bool = function() {
        return ["Bool", c.ATOMIC];
      }, r.forBlock.simple_type_int = function() {
        return ["Int", c.ATOMIC];
      }, r.forBlock.simple_type_string = function() {
        return ["String", c.ATOMIC];
      }, r.forBlock.simple_type_uri = function() {
        return ["Uri", c.ATOMIC];
      }, r.forBlock.simple_type_byte_array = function() {
        return ["ByteArray", c.ATOMIC];
      }, r.forBlock.name_wildcard = function() {
        return ["_", c.ATOMIC];
      }, r.forBlock.name_var = function(u) {
        return [u.getFieldValue("VAR"), c.ATOMIC];
      }, r.forBlock.name_quote = function(u) {
        return [`@${r.valueToCode(u, "PROC", c.UNARY)}`, c.UNARY];
      }, r.forBlock.name_decl_simple = function(u) {
        return [u.getFieldValue("VAR"), c.ATOMIC];
      }, r.forBlock.name_decl_urn = function(u) {
        let p = u.getFieldValue("VAR"), T = u.getFieldValue("URN");
        return [`${p}(\`${T}\`)`, c.ATOMIC];
      }, r.forBlock.name_remainder = function(u) {
        return [`...@${u.getFieldValue("VAR")}`, c.ATOMIC];
      }, r.forBlock.collect_list = function(u) {
        return [`[${r.valueToCode(u, "ELEMENTS", c.NONE)}]`, c.ATOMIC];
      }, r.forBlock.collect_list_remainder = function(u) {
        let p = r.valueToCode(u, "ELEMENTS", c.NONE), T = u.getFieldValue("REMAINDER");
        return [`[${p}...${T}]`, c.ATOMIC];
      }, r.forBlock.tuple_single = function(u) {
        return [`(${r.valueToCode(u, "ELEMENT", c.NONE)},)`, c.ATOMIC];
      }, r.forBlock.tuple_multiple = function(u) {
        let p = r.valueToCode(u, "FIRST", c.NONE), T = r.valueToCode(u, "REST", c.NONE);
        return [`(${p}, ${T})`, c.ATOMIC];
      }, r.forBlock.collect_set = function(u) {
        return [`Set(${r.valueToCode(u, "ELEMENTS", c.NONE)})`, c.ATOMIC];
      }, r.forBlock.collect_map = function(u) {
        return [`{${r.valueToCode(u, "PAIRS", c.NONE)}}`, c.ATOMIC];
      }, r.forBlock.key_value_pair = function(u) {
        let p = r.valueToCode(u, "KEY", c.NONE), T = r.valueToCode(u, "VALUE", c.NONE);
        return [`${p}: ${T}`, c.ATOMIC];
      }, r.forBlock.proc_list = function(u) {
        let p = r.valueToCode(u, "ITEM", c.NONE), T = r.valueToCode(u, "NEXT", c.NONE);
        return [`${p}, ${T}`, c.NONE];
      }, r.forBlock.proc_remainder = function(u) {
        return [`...${u.getFieldValue("VAR")}`, c.ATOMIC];
      }, r.forBlock.name_list = function(u) {
        let p = r.valueToCode(u, "ITEM", c.NONE), T = r.valueToCode(u, "NEXT", c.NONE);
        return [`${p}, ${T}`, c.NONE];
      }, r.forBlock.linear_bind = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <- ${T}`, c.NONE];
      }, r.forBlock.linear_bind_receive_send = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <- ${T}?!`, c.NONE];
      }, r.forBlock.linear_bind_send_receive = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE), G = r.valueToCode(u, "ARGS", c.NONE);
        return [`${p} <- ${T}!?(${G})`, c.NONE];
      }, r.forBlock.repeated_bind = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <= ${T}`, c.NONE];
      }, r.forBlock.peek_bind = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <<- ${T}`, c.NONE];
      }, r.forBlock.receipt_linear = function(u) {
        return [r.valueToCode(u, "BINDS", c.NONE), c.NONE];
      }, r.forBlock.receipt_repeated = function(u) {
        return [r.valueToCode(u, "BINDS", c.NONE), c.NONE];
      }, r.forBlock.receipt_peek = function(u) {
        return [r.valueToCode(u, "BINDS", c.NONE), c.NONE];
      }, r.forBlock.concurrent_binds = function(u) {
        let p = r.valueToCode(u, "LEFT", c.NONE), T = r.valueToCode(u, "RIGHT", c.NONE);
        return [`${p} & ${T}`, c.NONE];
      }, r.forBlock.sequential_receipts = function(u) {
        let p = r.valueToCode(u, "LEFT", c.NONE), T = r.valueToCode(u, "RIGHT", c.NONE);
        return [`${p}; ${T}`, c.NONE];
      }, r.forBlock.linear_bind_symm = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <-> ${T}`, c.NONE];
      }, r.forBlock.repeated_bind_symm = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <=> ${T}`, c.NONE];
      }, r.forBlock.peek_bind_symm = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.valueToCode(u, "SOURCE", c.NONE);
        return [`${p} <<->> ${T}`, c.NONE];
      }, r.forBlock.proc_if = function(u) {
        let p = r.valueToCode(u, "CONDITION", c.NONE), T = r.statementToCode(u, "BODY");
        return `if (${p}) {
${T}}
`;
      }, r.forBlock.proc_if_else = function(u) {
        let p = r.valueToCode(u, "CONDITION", c.NONE), T = r.statementToCode(u, "THEN_BODY"), G = r.statementToCode(u, "ELSE_BODY");
        return `if (${p}) {
${T}} else {
${G}}
`;
      }, r.forBlock.proc_match = function(u) {
        let p = r.valueToCode(u, "EXPR", c.NONE), T = r.statementToCode(u, "CASES");
        return `match ${p} {
${T}}
`;
      }, r.forBlock.case = function(u) {
        let p = r.valueToCode(u, "PATTERN", c.NONE), T = r.statementToCode(u, "BODY");
        return `${p} => {
${T}}
`;
      }, r.forBlock.proc_select = function(u) {
        return `select {
${r.statementToCode(u, "BRANCHES")}}
`;
      }, r.forBlock.branch = function(u) {
        let p = r.valueToCode(u, "RECEIPT", c.NONE), T = r.statementToCode(u, "BODY");
        return `${p} => {
${T}}
`;
      }, r.forBlock.proc_new = function(u) {
        let p = r.valueToCode(u, "NAMES", c.NONE), T = r.statementToCode(u, "BODY");
        return `new ${p} in {
${T}}
`;
      }, r.forBlock.name_decl_list = function(u) {
        let p = r.valueToCode(u, "ITEM", c.NONE), T = r.valueToCode(u, "NEXT", c.NONE);
        return [`${p}, ${T}`, c.NONE];
      }, r.forBlock.proc_let = function(u) {
        let p = r.valueToCode(u, "DECLS", c.NONE), T = r.statementToCode(u, "BODY");
        return `let ${p} in {
${T}}
`;
      }, r.forBlock.decl = function(u) {
        let p = r.valueToCode(u, "NAMES", c.NONE), T = r.valueToCode(u, "PROCS", c.NONE);
        return [`${p} <- ${T}`, c.NONE];
      }, r.forBlock.linear_decls = function(u) {
        let p = r.valueToCode(u, "LEFT", c.NONE), T = r.valueToCode(u, "RIGHT", c.NONE);
        return [`${p}; ${T}`, c.NONE];
      }, r.forBlock.conc_decls = function(u) {
        let p = r.valueToCode(u, "LEFT", c.NONE), T = r.valueToCode(u, "RIGHT", c.NONE);
        return [`${p} & ${T}`, c.NONE];
      }, r.forBlock.proc_contract = function(u) {
        let p = r.valueToCode(u, "NAME", c.NONE), T = r.valueToCode(u, "PARAMS", c.NONE), G = r.statementToCode(u, "BODY");
        return `contract ${p}(${T}) = {
${G}}
`;
      }, r.forBlock.proc_contract_remainder = function(u) {
        let p = r.valueToCode(u, "NAME", c.NONE), T = r.valueToCode(u, "PARAMS", c.NONE), G = u.getFieldValue("REMAINDER"), Y = r.statementToCode(u, "BODY");
        return `contract ${p}(${T}...@${G}) = {
${Y}}
`;
      }, r.forBlock.proc_bundle_write = function(u) {
        return `bundle+ {
${r.statementToCode(u, "BODY")}}
`;
      }, r.forBlock.proc_bundle_read = function(u) {
        return `bundle- {
${r.statementToCode(u, "BODY")}}
`;
      }, r.forBlock.proc_bundle_equiv = function(u) {
        return `bundle0 {
${r.statementToCode(u, "BODY")}}
`;
      }, r.forBlock.proc_bundle_rw = function(u) {
        return `bundle {
${r.statementToCode(u, "BODY")}}
`;
      }, r.forBlock.proc_nil = function() {
        return ["Nil", c.ATOMIC];
      }, r.forBlock.proc_collect = function(u) {
        return [r.valueToCode(u, "VALUE", c.NONE), c.ATOMIC];
      }, r.forBlock.proc_var = function(u) {
        return [u.getFieldValue("VAR"), c.ATOMIC];
      }, r.forBlock.proc_var_wildcard = function() {
        return ["_", c.ATOMIC];
      }, r.forBlock.proc_var_ref = function(u) {
        return [`=${u.getFieldValue("VAR")}`, c.UNARY];
      }, r.forBlock.proc_var_ref_name = function(u) {
        return [`=*${u.getFieldValue("VAR")}`, c.UNARY];
      }, r.forBlock.proc_simple_type = function(u) {
        return [r.valueToCode(u, "TYPE", c.NONE), c.ATOMIC];
      }, r.forBlock.proc_eval = function(u) {
        return [`*${r.valueToCode(u, "NAME", c.UNARY)}`, c.UNARY];
      }, r.forBlock.proc_paren = function(u) {
        return [`(${r.valueToCode(u, "EXPR", c.NONE)})`, c.ATOMIC];
      }, r.forBlock.proc_negation = function(u) {
        return [`~${r.valueToCode(u, "PROC", c.UNARY)}`, c.UNARY];
      }, r.forBlock.proc_conjunction = function(u) {
        let p = r.valueToCode(u, "LEFT", c.CONJUNCTION), T = r.valueToCode(u, "RIGHT", c.CONJUNCTION);
        return [`${p} /\\ ${T}`, c.CONJUNCTION];
      }, r.forBlock.proc_disjunction = function(u) {
        let p = r.valueToCode(u, "LEFT", c.DISJUNCTION), T = r.valueToCode(u, "RIGHT", c.DISJUNCTION);
        return [`${p} \\/ ${T}`, c.DISJUNCTION];
      }, r.forBlock.proc_not = function(u) {
        return [`not ${r.valueToCode(u, "PROC", c.UNARY)}`, c.UNARY];
      }, r.forBlock.proc_and = function(u) {
        let p = r.valueToCode(u, "LEFT", c.AND), T = r.valueToCode(u, "RIGHT", c.AND);
        return [`${p} and ${T}`, c.AND];
      }, r.forBlock.proc_or = function(u) {
        let p = r.valueToCode(u, "LEFT", c.OR), T = r.valueToCode(u, "RIGHT", c.OR);
        return [`${p} or ${T}`, c.OR];
      }, r.forBlock.proc_neg = function(u) {
        return [`-${r.valueToCode(u, "PROC", c.UNARY)}`, c.UNARY];
      }, r.forBlock.proc_mult = function(u) {
        let p = r.valueToCode(u, "LEFT", c.MULTIPLICATIVE), T = r.valueToCode(u, "RIGHT", c.MULTIPLICATIVE);
        return [`${p} * ${T}`, c.MULTIPLICATIVE];
      }, r.forBlock.proc_div = function(u) {
        let p = r.valueToCode(u, "LEFT", c.MULTIPLICATIVE), T = r.valueToCode(u, "RIGHT", c.MULTIPLICATIVE);
        return [`${p} / ${T}`, c.MULTIPLICATIVE];
      }, r.forBlock.proc_mod = function(u) {
        let p = r.valueToCode(u, "LEFT", c.MULTIPLICATIVE), T = r.valueToCode(u, "RIGHT", c.MULTIPLICATIVE);
        return [`${p} % ${T}`, c.MULTIPLICATIVE];
      }, r.forBlock.proc_percent_percent = function(u) {
        let p = r.valueToCode(u, "LEFT", c.MULTIPLICATIVE), T = r.valueToCode(u, "RIGHT", c.MULTIPLICATIVE);
        return [`${p} %% ${T}`, c.MULTIPLICATIVE];
      }, r.forBlock.proc_add = function(u) {
        let p = r.valueToCode(u, "LEFT", c.ADDITIVE), T = r.valueToCode(u, "RIGHT", c.ADDITIVE);
        return [`${p} + ${T}`, c.ADDITIVE];
      }, r.forBlock.proc_minus = function(u) {
        let p = r.valueToCode(u, "LEFT", c.ADDITIVE), T = r.valueToCode(u, "RIGHT", c.ADDITIVE);
        return [`${p} - ${T}`, c.ADDITIVE];
      }, r.forBlock.proc_plus_plus = function(u) {
        let p = r.valueToCode(u, "LEFT", c.ADDITIVE), T = r.valueToCode(u, "RIGHT", c.ADDITIVE);
        return [`${p} ++ ${T}`, c.ADDITIVE];
      }, r.forBlock.proc_minus_minus = function(u) {
        let p = r.valueToCode(u, "LEFT", c.ADDITIVE), T = r.valueToCode(u, "RIGHT", c.ADDITIVE);
        return [`${p} -- ${T}`, c.ADDITIVE];
      }, r.forBlock.proc_lt = function(u) {
        let p = r.valueToCode(u, "LEFT", c.RELATIONAL), T = r.valueToCode(u, "RIGHT", c.RELATIONAL);
        return [`${p} < ${T}`, c.RELATIONAL];
      }, r.forBlock.proc_lte = function(u) {
        let p = r.valueToCode(u, "LEFT", c.RELATIONAL), T = r.valueToCode(u, "RIGHT", c.RELATIONAL);
        return [`${p} <= ${T}`, c.RELATIONAL];
      }, r.forBlock.proc_gt = function(u) {
        let p = r.valueToCode(u, "LEFT", c.RELATIONAL), T = r.valueToCode(u, "RIGHT", c.RELATIONAL);
        return [`${p} > ${T}`, c.RELATIONAL];
      }, r.forBlock.proc_gte = function(u) {
        let p = r.valueToCode(u, "LEFT", c.RELATIONAL), T = r.valueToCode(u, "RIGHT", c.RELATIONAL);
        return [`${p} >= ${T}`, c.RELATIONAL];
      }, r.forBlock.proc_eq = function(u) {
        let p = r.valueToCode(u, "LEFT", c.EQUALITY), T = r.valueToCode(u, "RIGHT", c.EQUALITY);
        return [`${p} == ${T}`, c.EQUALITY];
      }, r.forBlock.proc_neq = function(u) {
        let p = r.valueToCode(u, "LEFT", c.EQUALITY), T = r.valueToCode(u, "RIGHT", c.EQUALITY);
        return [`${p} != ${T}`, c.EQUALITY];
      }, r.forBlock.proc_matches = function(u) {
        let p = r.valueToCode(u, "LEFT", c.EQUALITY), T = r.valueToCode(u, "RIGHT", c.EQUALITY);
        return [`${p} matches ${T}`, c.EQUALITY];
      }, r.forBlock.proc_method = function(u) {
        let p = r.valueToCode(u, "OBJECT", c.MEMBER), T = u.getFieldValue("METHOD"), G = r.valueToCode(u, "ARGS", c.NONE);
        return [`${p}.${T}(${G})`, c.MEMBER];
      }, r.forBlock.proc_path_map = function(u) {
        return [`%${r.valueToCode(u, "PROC", c.UNARY)}`, c.UNARY];
      }, r.forBlock.proc_send = function(u) {
        let p = r.valueToCode(u, "CHANNEL", c.NONE), T = r.valueToCode(u, "ARGS", c.NONE);
        return `${p}!(${T})
`;
      }, r.forBlock.proc_send_multiple = function(u) {
        let p = r.valueToCode(u, "CHANNEL", c.NONE), T = r.valueToCode(u, "ARGS", c.NONE);
        return `${p}!!(${T})
`;
      }, r.forBlock.proc_send_symm = function(u) {
        let p = r.valueToCode(u, "CHANNEL", c.NONE), T = r.valueToCode(u, "ARGS", c.NONE);
        return `${p}!$(${T})
`;
      }, r.forBlock.proc_send_synch = function(u) {
        let p = r.valueToCode(u, "CHANNEL", c.NONE), T = r.valueToCode(u, "ARGS", c.NONE), G = r.valueToCode(u, "CONT", c.NONE);
        return `${p}!?(${T})${G}
`;
      }, r.forBlock.synch_send_cont_empty = function() {
        return [".", c.ATOMIC];
      }, r.forBlock.synch_send_cont = function(u) {
        return [`; ${r.statementToCode(u, "BODY")}`, c.NONE];
      }, r.forBlock.proc_for = function(u) {
        let p = r.valueToCode(u, "RECEIPTS", c.NONE), T = r.statementToCode(u, "BODY");
        return `for (${p}) {
${T}}
`;
      }, r.forBlock.proc_foreach = function(u) {
        let p = r.valueToCode(u, "RECEIPTS", c.NONE), T = r.statementToCode(u, "BODY");
        return `foreach (${p}) {
${T}}
`;
      }, r.forBlock.proc_par = function(u) {
        let p = r.statementToCode(u, "LEFT"), T = r.statementToCode(u, "RIGHT");
        return `${p} | ${T}
`;
      }, r;
    }
    var j_ = Zw;
    var Vt = { primary: "#208bfe", primaryLight: "#4ea3ff", primaryDark: "#0066cc", ground: 160, names: 280, collections: 320, receipts: 40, control: 208, declarations: 180, processes: 208, logical: 260, arithmetic: 20, comparison: 140, methods: 100, sendReceive: 60, composition: 340, workspace: "#161E27", toolbox: "#ffffff", flyout: "#f8f8f8", scrollbar: "#cccccc", scrollbarOpacity: 0.4, insertionMarker: "#000000", insertionMarkerOpacity: 0.2, text: "#000000", textSecondary: "#575e75" }, Qw = { ground_blocks: { colourPrimary: "#5cb85c", colourSecondary: "#4a9d4a", colourTertiary: "#3d8b3d" }, name_blocks: { colourPrimary: "#9966ff", colourSecondary: "#7f52d9", colourTertiary: "#6640b3" }, collection_blocks: { colourPrimary: "#ff6680", colourSecondary: "#d94f6b", colourTertiary: "#b34256" }, receipt_blocks: { colourPrimary: "#ffab19", colourSecondary: "#d98f15", colourTertiary: "#b37612" }, control_blocks: { colourPrimary: "#208bfe", colourSecondary: "#1a73d8", colourTertiary: "#155db3" }, declaration_blocks: { colourPrimary: "#00c9c9", colourSecondary: "#00a7a7", colourTertiary: "#008686" }, process_blocks: { colourPrimary: "#4d97ff", colourSecondary: "#3d7fd9", colourTertiary: "#3268b3" }, logical_blocks: { colourPrimary: "#a366ff", colourSecondary: "#8852d9", colourTertiary: "#6f42b3" }, arithmetic_blocks: { colourPrimary: "#ff6b35", colourSecondary: "#d9592c", colourTertiary: "#b34924" }, comparison_blocks: { colourPrimary: "#40bf86", colourSecondary: "#359f6f", colourTertiary: "#2c8259" }, method_blocks: { colourPrimary: "#c4d91f", colourSecondary: "#a3b619", colourTertiary: "#859414" }, send_receive_blocks: { colourPrimary: "#ffcc00", colourSecondary: "#d9ad00", colourTertiary: "#b38f00" }, composition_blocks: { colourPrimary: "#ff4da6", colourSecondary: "#d93f8a", colourTertiary: "#b33371" } }, eL = { ground_category: { colour: "#5cb85c" }, names_category: { colour: "#9966ff" }, collections_category: { colour: "#ff6680" }, receipts_category: { colour: "#ffab19" }, control_category: { colour: "#208bfe" }, declarations_category: { colour: "#00c9c9" }, processes_category: { colour: "#4d97ff" }, logical_category: { colour: "#a366ff" }, arithmetic_category: { colour: "#ff6b35" }, comparison_category: { colour: "#40bf86" }, methods_category: { colour: "#c4d91f" }, send_receive_category: { colour: "#ffcc00" }, composition_category: { colour: "#ff4da6" } }, tL = { workspaceBackgroundColour: Vt.workspace, toolboxBackgroundColour: Vt.toolbox, toolboxForegroundColour: Vt.textSecondary, flyoutBackgroundColour: Vt.flyout, flyoutForegroundColour: Vt.text, flyoutOpacity: 0.95, scrollbarColour: Vt.scrollbar, scrollbarOpacity: Vt.scrollbarOpacity, insertionMarkerColour: Vt.insertionMarker, insertionMarkerOpacity: Vt.insertionMarkerOpacity, cursorColour: "#cc0000", markerColour: "#4d97ff" }, oL = { family: "'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace", weight: "normal", size: 12 }, J_ = U_.defineTheme("oslf_theme", { name: "OSLF Editor Theme", blockStyles: Qw, categoryStyles: eL, componentStyles: tL, fontStyle: oL, startHats: true });
    Y_();
    var sL = ((Y) => (Y.TREE_REQUEST = "tree:request", Y.TREE_RETURN = "tree:return", Y.BLOCKLY_REQUEST = "blockly:request", Y.BLOCKLY_RETURN = "blockly:return", Y.BLOCKLY_LOAD = "blockly:load", Y.BLOCKLY_CHANGE = "blockly:change", Y))(sL || {});
    function iL() {
      let r = G_("blockly", { trashcan: false, sounds: false, scrollbars: false, grid: { spacing: 7, length: 1, colour: "#3e4042", snap: true }, toolbox: K_, theme: J_ }), c = r.newBlock("proc_root");
      c.initSvg(), c.render(), c.moveBy(50, 50), r.addChangeListener(kd.disableOrphans), r.addChangeListener((T) => {
        if (T.type === kd.SELECTED) {
          let G = document.querySelector(".blocklyToolboxDiv");
          G && (G.style.display = "block");
          let Y = r;
          if (Y.getFlyout && Y.getFlyout()) {
            let ht = Y.getFlyout();
            ht && ht.setVisible(true);
          }
        }
      });
      let u = r, p = u.getCanvas().ownerSVGElement;
      return p && p.addEventListener("click", (T) => {
        let G = T.target;
        if (G.classList.contains("blocklyMainBackground") || G.classList.contains("blocklyWorkspace") || G.tagName === "svg") {
          let Y = u.getFlyout();
          Y && Y.setVisible(false);
        }
      }), r;
    }
    var Pd = class extends HTMLElement {
      handlers = [];
      workspace;
      static observedAttributes = ["width", "height"];
      constructor() {
        super(), this.attachShadow({ mode: "open" }), V_(Sd);
      }
      connectedCallback() {
        this.render();
      }
      handleListeners() {
        this.handlers.forEach((T) => T());
        let c = () => {
          let G = j_().workspaceToCode(this.workspace);
          console.log(G), this.dispatchEvent(new CustomEvent("tree:return", { detail: G, bubbles: true, composed: true }));
        };
        this.addEventListener("tree:request", c), this.handlers.push(() => {
          this.removeEventListener("tree:request", c), console.log("Callback removed");
        });
        let u = () => {
          let T = jl.workspaces.save(this.workspace);
          console.log(T), this.dispatchEvent(new CustomEvent("blockly:return", { detail: T, bubbles: true, composed: true }));
        };
        this.addEventListener("blockly:request", u), this.handlers.push(() => {
          this.removeEventListener("blockly:request", u), console.log("Blockly callback removed");
        });
        let p = (T) => {
          let G = T.detail;
          G && (jl.workspaces.load(G, this.workspace), console.log("Blockly state loaded"));
        };
        this.addEventListener("blockly:load", p), this.handlers.push(() => {
          this.removeEventListener("blockly:load", p), console.log("Blockly load callback removed");
        });
      }
      render() {
        console.time("Rendering"), this.handleListeners(), this.workspace = iL();
        let c = null;
        this.workspace.addChangeListener((u) => {
          u.isUiEvent || (c && clearTimeout(c), c = setTimeout(() => {
            let p = jl.workspaces.save(this.workspace);
            this.dispatchEvent(new CustomEvent("blockly:change", { detail: p, bubbles: true, composed: true }));
          }, 1e3));
        }), console.timeEnd("Rendering");
      }
      attributeChangedCallback(c, u, p) {
        this[c] = p;
      }
    };
    window.customElements.define("oslf-editor", Pd);
  })();

  // index.tsx
  var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
  var root = (0, import_client.createRoot)(document.getElementById("app"));
  root.render(/* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(App, {}, void 0, false, {
    fileName: "index.tsx",
    lineNumber: 7,
    columnNumber: 13
  }));
  var STORAGE_KEY = "oslf-editor-blockly-state";
  function App() {
    const ref = (0, import_react.useRef)(null);
    const saveToStorageRef = (0, import_react.useRef)(false);
    const [generatedCode, setGeneratedCode] = (0, import_react.useState)("");
    const [blocklyState, setBlocklyState] = (0, import_react.useState)("");
    const [loadInput, setLoadInput] = (0, import_react.useState)("");
    const [codeCopied, setCodeCopied] = (0, import_react.useState)(false);
    const [stateCopied, setStateCopied] = (0, import_react.useState)(false);
    (0, import_react.useEffect)(() => {
      const editor = ref.current;
      if (!editor) return;
      const handleTreeReturn = (event) => {
        setGeneratedCode(event.detail);
      };
      const handleBlocklyReturn = (event) => {
        const stateJson = JSON.stringify(event.detail, null, 2);
        setBlocklyState(stateJson);
        if (saveToStorageRef.current) {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(event.detail));
          saveToStorageRef.current = false;
        }
      };
      const handleBlocklyChange = (event) => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(event.detail));
      };
      editor.addEventListener("tree:return", handleTreeReturn);
      editor.addEventListener("blockly:return", handleBlocklyReturn);
      editor.addEventListener("blockly:change", handleBlocklyChange);
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const state = JSON.parse(saved);
          editor.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
        } catch (e) {
          console.log("Failed to load from localStorage. Value:", saved);
          console.error("Parse error:", e);
          localStorage.removeItem(STORAGE_KEY);
        }
      }
      return () => {
        editor.removeEventListener("tree:return", handleTreeReturn);
        editor.removeEventListener("blockly:return", handleBlocklyReturn);
        editor.removeEventListener("blockly:change", handleBlocklyChange);
      };
    }, []);
    const handleGenerateCode = () => {
      if (ref.current) {
        ref.current.dispatchEvent(new CustomEvent("tree:request"));
      }
    };
    const handleExportBlockly = () => {
      if (ref.current) {
        ref.current.dispatchEvent(new CustomEvent("blockly:request"));
      }
    };
    const handleLoadBlockly = () => {
      if (ref.current && loadInput) {
        try {
          const state = JSON.parse(loadInput);
          ref.current.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
        } catch (e) {
          console.error("Invalid JSON", e);
        }
      }
    };
    const handleSaveToStorage = () => {
      if (ref.current) {
        saveToStorageRef.current = true;
        ref.current.dispatchEvent(new CustomEvent("blockly:request"));
      }
    };
    const handleLoadFromStorage = () => {
      if (ref.current) {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const state = JSON.parse(saved);
            ref.current.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
          } catch (e) {
            console.error("Invalid saved state", e);
          }
        }
      }
    };
    const handleCopyCode = async () => {
      try {
        await navigator.clipboard.writeText(generatedCode);
        setCodeCopied(true);
        setTimeout(() => setCodeCopied(false), 2e3);
      } catch (e) {
        console.error("Failed to copy code", e);
      }
    };
    const handleCopyState = async () => {
      try {
        await navigator.clipboard.writeText(blocklyState);
        setStateCopied(true);
        setTimeout(() => setStateCopied(false), 2e3);
      } catch (e) {
        console.error("Failed to copy state", e);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginBottom: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleGenerateCode, children: "Generate Code" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 140,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleExportBlockly, style: { marginLeft: "10px" }, children: "Export Blockly" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 141,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleLoadBlockly, style: { marginLeft: "10px" }, children: "Load Blockly" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 142,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleSaveToStorage, style: { marginLeft: "10px" }, children: "Save" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 143,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleLoadFromStorage, style: { marginLeft: "10px" }, children: "Load" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 144,
          columnNumber: 5
        }, this)
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 139,
        columnNumber: 4
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginBottom: "10px" }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
        "textarea",
        {
          value: loadInput,
          onChange: (e) => setLoadInput(e.target.value),
          placeholder: "Paste Blockly JSON here to load...",
          style: {
            width: "100%",
            height: "100px",
            fontFamily: "monospace",
            fontSize: "12px"
          }
        },
        void 0,
        false,
        {
          fileName: "index.tsx",
          lineNumber: 147,
          columnNumber: 5
        },
        this
      ) }, void 0, false, {
        fileName: "index.tsx",
        lineNumber: 146,
        columnNumber: 4
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("oslf-editor", { ref }, void 0, false, {
        fileName: "index.tsx",
        lineNumber: 159,
        columnNumber: 4
      }, this),
      generatedCode && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginTop: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h3", { style: { margin: 0 }, children: "Generated Code:" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 163,
            columnNumber: 7
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleCopyCode, children: codeCopied ? "Copied!" : "Copy" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 164,
            columnNumber: 7
          }, this)
        ] }, void 0, true, {
          fileName: "index.tsx",
          lineNumber: 162,
          columnNumber: 6
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
          "pre",
          {
            style: {
              backgroundColor: "#f4f4f4",
              padding: "10px",
              borderRadius: "4px",
              overflow: "auto",
              marginTop: "10px"
            },
            children: generatedCode
          },
          void 0,
          false,
          {
            fileName: "index.tsx",
            lineNumber: 168,
            columnNumber: 6
          },
          this
        )
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 161,
        columnNumber: 5
      }, this),
      blocklyState && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginTop: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h3", { style: { margin: 0 }, children: "Blockly State:" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 184,
            columnNumber: 7
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleCopyState, children: stateCopied ? "Copied!" : "Copy" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 185,
            columnNumber: 7
          }, this)
        ] }, void 0, true, {
          fileName: "index.tsx",
          lineNumber: 183,
          columnNumber: 6
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
          "pre",
          {
            style: {
              backgroundColor: "#e8f4e8",
              padding: "10px",
              borderRadius: "4px",
              overflow: "auto",
              maxHeight: "300px",
              marginTop: "10px"
            },
            children: blocklyState
          },
          void 0,
          false,
          {
            fileName: "index.tsx",
            lineNumber: 189,
            columnNumber: 6
          },
          this
        )
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 182,
        columnNumber: 5
      }, this)
    ] }, void 0, true, {
      fileName: "index.tsx",
      lineNumber: 138,
      columnNumber: 3
    }, this);
  }
})();
/*! Bundled license information:

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-dev-runtime.development.js:
  (**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
