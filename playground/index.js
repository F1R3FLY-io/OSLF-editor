(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config, children) {
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i]);
          i = {};
          var key = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set) {
          var array = [];
          set.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root3, element) {
          root3.context === emptyContextObject && (updateContainerImpl(root3.current, 2, element, root3, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root3, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root3.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return type.displayName || "Context";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i = type.length - 1; 0 <= i; i--)
                  if ("string" === typeof type[i].name) return type[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "", previous = null;
            do {
              info += describeFiber(workInProgress2, previous);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info;
                    a: {
                      var name = entry.name, env = entry.env, location = entry.debugLocation;
                      if (null != location) {
                        var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                        if (-1 !== lastLine.indexOf(name)) {
                          var JSCompiler_inline_result = "\n" + lastLine;
                          break a;
                        }
                      }
                      JSCompiler_inline_result = describeBuiltInComponentFrame(
                        name + (env ? " [" + env + "]" : "")
                      );
                    }
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              previous = workInProgress2;
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (workInProgress2 && debugStack) {
                  var formattedStack = formatOwnerStack(debugStack);
                  "" !== formattedStack && (info += "\n" + formattedStack);
                }
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %o.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root3.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
          root3 = root3.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root3, renderLanes2) {
          return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root3, updateLane) {
          root3.pendingLanes |= updateLane;
          268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
        }
        function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root3.pendingLanes;
          root3.pendingLanes = remainingLanes;
          root3.suspendedLanes = 0;
          root3.pingedLanes = 0;
          root3.warmLanes = 0;
          root3.expiredLanes &= remainingLanes;
          root3.entangledLanes &= remainingLanes;
          root3.errorRecoveryDisabledLanes &= remainingLanes;
          root3.shellSuspendCounter = 0;
          var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
          root3.pendingLanes |= spawnedLane;
          root3.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root3.entangledLanes |= spawnedLane;
          root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
        }
        function markRootEntangled(root3, entangledLanes) {
          var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
          for (root3 = root3.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root3[index] & entangledLanes && (root3[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root3, renderLanes2) {
          var renderLane = renderLanes2 & -renderLanes2;
          renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root3, fiber, lanes) {
          if (isDevToolsPresent)
            for (root3 = root3.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root3[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root3, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap, memoizedUpdaters = root3.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root3 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root3;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root3) {
          var resources = root3[internalRootNodeResourcesKey];
          resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? "checked" : "value";
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              "" + node[valueField]
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
              track(element);
              return;
            }
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = true;
                setDefaultSelected && (node[i].defaultSelected = true);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
          track(element);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 31:
              return "Activity";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i.length; node++)
            serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function noop$1() {
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root3, offset) {
          var node = getLeafNode(root3);
          root3 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root3 + node.textContent.length;
              if (root3 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root3 };
              root3 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function getArrayKind(array) {
          for (var kind = EMPTY_ARRAY, i = 0; i < array.length; i++) {
            var value = array[i];
            if ("object" === typeof value && null !== value)
              if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
                if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                  return COMPLEX_ARRAY;
                kind = ENTRIES_ARRAY;
              } else return COMPLEX_ARRAY;
            else {
              if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
                return COMPLEX_ARRAY;
              kind = PRIMITIVE_ARRAY;
            }
          }
          return kind;
        }
        function addObjectToProperties(object, properties, indent, prefix2) {
          for (var key in object)
            hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
        }
        function addValueToProperties(propertyName, value, properties, indent, prefix2) {
          switch (typeof value) {
            case "object":
              if (null === value) {
                value = "null";
                break;
              } else {
                if (value.$$typeof === REACT_ELEMENT_TYPE) {
                  var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                  value = value.props;
                  var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                  if (null == key && 0 === propsLength) {
                    value = "<" + typeName2 + " />";
                    break;
                  }
                  if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                    value = "<" + typeName2 + " \u2026 />";
                    break;
                  }
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    "<" + typeName2
                  ]);
                  null !== key && addValueToProperties(
                    "key",
                    key,
                    properties,
                    indent + 1,
                    prefix2
                  );
                  propertyName = false;
                  for (var propKey in value)
                    "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  properties.push([
                    "",
                    propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                  ]);
                  return;
                }
                typeName2 = Object.prototype.toString.call(value);
                typeName2 = typeName2.slice(8, typeName2.length - 1);
                if ("Array" === typeName2) {
                  if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                    value = JSON.stringify(value);
                    break;
                  } else if (propKey === ENTRIES_ARRAY) {
                    properties.push([
                      prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                      ""
                    ]);
                    for (propertyName = 0; propertyName < value.length; propertyName++)
                      typeName2 = value[propertyName], addValueToProperties(
                        typeName2[0],
                        typeName2[1],
                        properties,
                        indent + 1,
                        prefix2
                      );
                    return;
                  }
                }
                if ("Promise" === typeName2) {
                  if ("fulfilled" === value.status) {
                    if (typeName2 = properties.length, addValueToProperties(
                      propertyName,
                      value.value,
                      properties,
                      indent,
                      prefix2
                    ), properties.length > typeName2) {
                      properties = properties[typeName2];
                      properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                      return;
                    }
                  } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.reason,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2)) {
                    properties = properties[typeName2];
                    properties[1] = "Rejected Promise<" + properties[1] + ">";
                    return;
                  }
                  properties.push([
                    "\xA0\xA0".repeat(indent) + propertyName,
                    "Promise"
                  ]);
                  return;
                }
                "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
                ]);
                3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
                return;
              }
            case "function":
              value = "" === value.name ? "() => {}" : value.name + "() {}";
              break;
            case "string":
              value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
              break;
            case "undefined":
              value = "undefined";
              break;
            case "boolean":
              value = value ? "true" : "false";
              break;
            default:
              value = String(value);
          }
          properties.push([
            prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
            value
          ]);
        }
        function addObjectDiffToProperties(prev, next, properties, indent) {
          var isDeeplyEqual = true;
          for (key in prev)
            key in next || (properties.push([
              REMOVED + "\xA0\xA0".repeat(indent) + key,
              "\u2026"
            ]), isDeeplyEqual = false);
          for (var _key in next)
            if (_key in prev) {
              var key = prev[_key];
              var nextValue = next[_key];
              if (key !== nextValue) {
                if (0 === indent && "children" === _key)
                  isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                    [REMOVED + isDeeplyEqual, "\u2026"],
                    [ADDED + isDeeplyEqual, "\u2026"]
                  );
                else {
                  if (!(3 <= indent)) {
                    if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                      if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                        if (key.type === nextValue.type && key.key === nextValue.key) {
                          key = getComponentNameFromType(nextValue.type) || "\u2026";
                          isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                          key = "<" + key + " \u2026 />";
                          properties.push(
                            [REMOVED + isDeeplyEqual, key],
                            [ADDED + isDeeplyEqual, key]
                          );
                          isDeeplyEqual = false;
                          continue;
                        }
                      } else {
                        var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                        if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                          prevKind = [
                            UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                            "[object Array]" === nextKind ? "Array" : ""
                          ];
                          properties.push(prevKind);
                          nextKind = properties.length;
                          addObjectDiffToProperties(
                            key,
                            nextValue,
                            properties,
                            indent + 1
                          ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                          continue;
                        }
                      }
                    else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                      key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                      properties.push([
                        UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                        key + " Referentially unequal function closure. Consider memoization."
                      ]);
                      continue;
                    }
                  }
                  addValueToProperties(_key, key, properties, indent, REMOVED);
                  addValueToProperties(_key, nextValue, properties, indent, ADDED);
                }
                isDeeplyEqual = false;
              }
            } else
              properties.push([
                ADDED + "\xA0\xA0".repeat(indent) + _key,
                "\u2026"
              ]), isDeeplyEqual = false;
          return isDeeplyEqual;
        }
        function setCurrentTrackFromLanes(lanes) {
          currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
        }
        function logComponentTrigger(fiber, startTime, endTime, trigger) {
          supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
            performance.measure.bind(
              performance,
              trigger,
              reusableComponentOptions
            )
          ) : performance.measure(trigger, reusableComponentOptions));
        }
        function logComponentReappeared(fiber, startTime, endTime) {
          logComponentTrigger(fiber, startTime, endTime, "Reconnect");
        }
        function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name && supportsUserTiming) {
            var alternate = fiber.alternate, selfTime = fiber.actualDuration;
            if (null === alternate || alternate.child !== fiber.child)
              for (var child = fiber.child; null !== child; child = child.sibling)
                selfTime -= child.actualDuration;
            wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
            var props = fiber.memoizedProps;
            selfTime = fiber._debugTask;
            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
              performance.measure.bind(
                performance,
                "\u200B" + name,
                reusableComponentOptions
              )
            ) : performance.measure(
              "\u200B" + name,
              reusableComponentOptions
            ))) : null != selfTime ? selfTime.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            );
          }
        }
        function logComponentErrored(fiber, startTime, endTime, errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              for (var debugTask = null, properties = [], i = 0; i < errors.length; i++) {
                var capturedValue = errors[i];
                null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
                capturedValue = capturedValue.value;
                properties.push([
                  "Error",
                  "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
              null == debugTask && (debugTask = fiber._debugTask);
              fiber = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                    properties
                  }
                }
              };
              debugTask ? debugTask.run(
                performance.measure.bind(performance, "\u200B" + name, fiber)
              ) : performance.measure("\u200B" + name, fiber);
            }
          }
        }
        function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
          if (null !== errors) {
            if (supportsUserTiming) {
              var name = getComponentNameFromFiber(fiber);
              if (null !== name) {
                selfTime = [];
                for (var i = 0; i < errors.length; i++) {
                  var error = errors[i].value;
                  selfTime.push([
                    "Error",
                    "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                  ]);
                }
                null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
                startTime = {
                  start: startTime,
                  end: endTime,
                  detail: {
                    devtools: {
                      color: "error",
                      track: COMPONENTS_TRACK,
                      tooltipText: "A lifecycle or effect errored",
                      properties: selfTime
                    }
                  }
                };
                (fiber = fiber._debugTask) ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200B" + name,
                    startTime
                  )
                ) : performance.measure("\u200B" + name, startTime);
              }
            }
          } else
            name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                errors
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            ));
        }
        function logRenderPhase(startTime, endTime, lanes, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
            lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
            debugTask ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            ) : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
          }
        }
        function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            lanes = [];
            for (var i = 0; i < recoverableErrors.length; i++) {
              var error = recoverableErrors[i].value;
              lanes.push([
                "Recoverable Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "primary-dark",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                  properties: lanes
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            ) : performance.measure("Recovered", startTime);
          }
        }
        function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            )
          ) : console.timeStamp(
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          ));
        }
        function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            )
          ) : console.timeStamp(
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          ));
        }
        function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            for (var properties = [], i = 0; i < errors.length; i++) {
              var error = errors[i].value;
              properties.push([
                "Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            ) : performance.measure("Errored", startTime);
          }
        }
        function logAnimatingPhase(startTime, endTime, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          do {
            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
            _fiber = _fiber.type;
            var candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = _fiber;
                break;
              case 11:
                candidateType = _fiber.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            _fiber = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
            _fiber && (fiber._debugNeedsRemount = true);
            if (_fiber || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || _fiber || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            if (null === sibling) break;
            fiber = sibling;
          } while (1);
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(18, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnIfHydrating() {
          isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          );
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              );
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber, true);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function startUpdateTimerByLane(lane, method, fiber) {
          if (0 !== (lane & 127))
            0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
          else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
            lane = resolveEventTimeStamp();
            method = resolveEventType();
            if (lane !== transitionEventRepeatTime || method !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = lane;
            transitionEventType = method;
          }
        }
        function startHostActionTimer(fiber) {
          if (0 > blockingUpdateTime) {
            blockingUpdateTime = now();
            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
            blockingEventTime = newEventTime;
            blockingEventType = newEventType;
          }
          if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
            fiber = resolveEventTimeStamp();
            newEventTime = resolveEventType();
            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = fiber;
            transitionEventType = newEventTime;
          }
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function resetComponentEffectTimers() {
          componentEffectEndTime = componentEffectStartTime = -1.1;
        }
        function pushComponentEffectStart() {
          var prevEffectStart = componentEffectStartTime;
          componentEffectStartTime = -1.1;
          return prevEffectStart;
        }
        function popComponentEffectStart(prevEffectStart) {
          0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
        }
        function pushComponentEffectDuration() {
          var prevEffectDuration = componentEffectDuration;
          componentEffectDuration = -0;
          return prevEffectDuration;
        }
        function popComponentEffectDuration(prevEffectDuration) {
          0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
        }
        function pushComponentEffectErrors() {
          var prevErrors = componentEffectErrors;
          componentEffectErrors = null;
          return prevErrors;
        }
        function pushComponentEffectDidSpawnUpdate() {
          var prev = componentEffectSpawnedUpdate;
          componentEffectSpawnedUpdate = false;
          return prev;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var endTime = now(), elapsedTime = endTime - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
            componentEffectDuration += elapsedTime;
            componentEffectEndTime = endTime;
          }
        }
        function recordEffectError(errorInfo) {
          null === componentEffectErrors && (componentEffectErrors = []);
          componentEffectErrors.push(errorInfo);
          null === commitErrors && (commitErrors = []);
          commitErrors.push(errorInfo);
        }
        function startEffectTimer() {
          profilerStartTime = now();
          0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$1, noop$1), thenable = index);
          if (void 0 === thenable._debugInfo) {
            thenableState2 = performance.now();
            trackedThenables = thenable.displayName;
            var ioInfo = {
              name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
              start: thenableState2,
              end: thenableState2,
              value: thenable
            };
            thenable._debugInfo = [{ awaited: ioInfo }];
            "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
              ioInfo.end = performance.now();
            }, thenable.then(thenableState2, thenableState2));
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            return callLazyInitInDEV(lazyType);
          } catch (x) {
            if (null !== x && "object" === typeof x && "function" === typeof x.then)
              throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
            throw x;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function getCurrentDebugTask() {
          var debugInfo = currentDebugInfo;
          if (null != debugInfo) {
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if (null != debugInfo[i].name) {
                var debugTask = debugInfo[i].debugTask;
                if (null != debugTask) return debugTask;
              }
          }
          return null;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
        }
        function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root3, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(suspenseHandlerStackCursor, fiber, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create, deps) {
          tag = { tag, create, deps, inst, next: null };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            { destroy: void 0 },
            create,
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, deps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
          else {
            var events = componentUpdateQueue.events;
            null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
          }
        }
        function mountEvent(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref, nextImpl: callback });
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              ReactSharedInternals.asyncTransitions++;
              returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startHostActionTimer(formFiber);
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "_";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root3 = enqueueUpdate(provider, refreshUpdate, lane);
                null !== root3 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root3, provider, lane), entangleTransitions(root3, provider, lane));
                fiber = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root3 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                refreshUpdate.payload = { cache: fiber };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root3, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root3, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root3.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root3, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root3.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root3, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root3, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root3,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root3,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root3, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root3, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root3.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root3, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root3
                ), enqueueCapturedUpdate(sourceFiber, root3), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root3,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
          var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextProps = workInProgress2.child = current2.child;
                for (nextChildren = 0; null !== nextProps; )
                  nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
                nextProps = nextChildren & ~prevState;
              } else nextProps = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                prevState,
                renderLanes2,
                nextProps
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2,
                nextProps
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function bailoutOffscreenComponent(current2, workInProgress2) {
          null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          return workInProgress2.sibling;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          workInProgress2.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress2, nextProps) {
          var hiddenProp = nextProps.hidden;
          void 0 !== hiddenProp && console.error(
            `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
            true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
            hiddenProp ? 'mode="hidden"' : 'mode="visible"'
          );
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress2.mode
          );
          nextProps.ref = workInProgress2.ref;
          workInProgress2.child = nextProps;
          nextProps.return = workInProgress2;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountActivityChildren(
            workInProgress2,
            workInProgress2.pendingProps
          );
          current2.flags |= 2;
          popSuspenseHandler(workInProgress2);
          workInProgress2.memoizedState = null;
          return current2;
        }
        function updateActivityComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
          workInProgress2.flags &= -129;
          if (null === current2) {
            if (isHydrating) {
              if ("hidden" === nextProps.mode)
                return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
              pushDehydratedActivitySuspenseHandler(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              workInProgress2.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress2, nextProps);
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var activityInstance = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            if (didSuspend)
              if (workInProgress2.flags & 256)
                workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              else if (null !== workInProgress2.memoizedState)
                workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
              else
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
              nextProps = workInProgressRoot;
              if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
                nextProps,
                renderLanes2
              ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
                throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
              renderDidSuspendDelayIfPossible();
              workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                activityInstance.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
            return workInProgress2;
          }
          prevState = current2.child;
          nextProps = { mode: nextProps.mode, children: nextProps.children };
          0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          current2 = createWorkInProgress(prevState, nextProps);
          current2.ref = workInProgress2.ref;
          workInProgress2.child = current2;
          current2.return = workInProgress2;
          return current2;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2724;
          var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_message_2723 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
              return null;
            }
            var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
            JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
            if (JSCompiler_object_inline_message_2723) {
              reuseSuspenseHandlerOnStack(workInProgress2);
              var mode = workInProgress2.mode;
              nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "hidden", children: nextPrimaryChildren },
                mode
              );
              JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2725,
                mode,
                renderLanes2,
                null
              );
              nextPrimaryChildren.return = workInProgress2;
              JSCompiler_object_inline_stack_2725.return = workInProgress2;
              nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
              workInProgress2.child = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = workInProgress2.child;
              JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              );
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              );
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              nextPrimaryChildren
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
            if (null !== JSCompiler_object_inline_componentStack_2726) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2725.children
                  },
                  mode
                ), nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  mode,
                  renderLanes2,
                  null
                ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                  null,
                  JSCompiler_object_inline_stack_2725
                ));
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
                JSCompiler_object_inline_componentStack_2726
              )) {
                JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2724) {
                  nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                  var message = JSCompiler_object_inline_digest_2724.msg;
                  mode = JSCompiler_object_inline_digest_2724.stck;
                  var componentStack = JSCompiler_object_inline_digest_2724.cstck;
                }
                JSCompiler_object_inline_message_2723 = message;
                JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
                JSCompiler_object_inline_stack_2725 = mode;
                JSCompiler_object_inline_componentStack_2726 = componentStack;
                nextPrimaryChildren = JSCompiler_object_inline_message_2723;
                mode = JSCompiler_object_inline_componentStack_2726;
                nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
                nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
                JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
                JSCompiler_object_inline_stack_2725 = {
                  value: nextPrimaryChildren,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2724
                };
                "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                  nextPrimaryChildren,
                  JSCompiler_object_inline_stack_2725
                );
                queueHydrationError(JSCompiler_object_inline_stack_2725);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
                JSCompiler_object_inline_digest_2724 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2724,
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), SelectiveHydrationException;
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2725.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
          }
          if (JSCompiler_object_inline_message_2723)
            return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
              componentStack,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2725.children
              }
            ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
              JSCompiler_object_inline_componentStack_2726,
              nextPrimaryChildren
            ) : (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              mode,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
              baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
              cachePool: mode
            }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
              current2.child,
              JSCompiler_object_inline_stack_2725
            );
          null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2725.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode,
            treeForkCount: treeForkCount2
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
          (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
          push(suspenseStackCursor, suspenseContext, workInProgress2);
          suspenseContext = null == revealOrder ? "null" : revealOrder;
          if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
            if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
              console.error(
                'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
              );
            else if ("backwards" === revealOrder)
              console.error(
                'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
              );
            else if ("string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                case "independent":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          suspenseContext = null == tailMode ? "null" : tailMode;
          if (!didWarnAboutTailOptions[suspenseContext])
            if (null == tailMode) {
              if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
                didWarnAboutTailOptions[suspenseContext] = true, console.error(
                  'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
                );
            } else
              "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
            if (isArrayImpl(newChildren))
              for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
                if (!validateSuspenseListNestedChild(
                  newChildren[suspenseContext],
                  suspenseContext
                ))
                  break a;
              }
            else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
              if (suspenseContext = suspenseContext.call(newChildren))
                for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
          if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode,
                newChildren
              );
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode,
                newChildren
              );
              break;
            case "together":
              initSuspenseListRenderState(
                workInProgress2,
                false,
                null,
                null,
                void 0,
                newChildren
              );
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== workInProgress2.memoizedState)
                return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
              return workInProgress2.lanes = 0, updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                renderLanes2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    renderLanes2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = renderLanes2; renderLanes2; )
                      renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
                renderLanes2,
                returnFiber.tag,
                current2.ancestorInfo.implicitRootScope
              ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
                current2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return updateActivityComponent(current2, workInProgress2, renderLanes2);
            case 22:
              return updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
          if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
            type = false;
          if (type) {
            if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
              if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
              else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
              else
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          } else workInProgress2.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                null,
                newProps,
                renderLanes2
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                current2,
                newProps,
                renderLanes2
              ));
              return null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var _currentHostContext = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
                else {
                  nextResource = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(type, _currentHostContext.ancestorInfo);
                  _currentHostContext = _currentHostContext.context;
                  nextResource = getOwnerDocumentFromRootContainer(nextResource);
                  switch (_currentHostContext) {
                    case HostContextNamespaceSvg:
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case HostContextNamespaceMath:
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    default:
                      switch (type) {
                        case "svg":
                          nextResource = nextResource.createElementNS(
                            SVG_NAMESPACE,
                            type
                          );
                          break;
                        case "math":
                          nextResource = nextResource.createElementNS(
                            MATH_NAMESPACE,
                            type
                          );
                          break;
                        case "script":
                          nextResource = nextResource.createElement("div");
                          nextResource.innerHTML = "<script><\/script>";
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild
                          );
                          break;
                        case "select":
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                            is: newProps.is
                          }) : nextResource.createElement("select");
                          newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                            is: newProps.is
                          }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            type
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            type
                          )));
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress2;
                  nextResource[internalPropsKey] = newProps;
                  a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                    if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                      nextResource.appendChild(_currentHostContext.stateNode);
                    else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                      _currentHostContext.child.return = _currentHostContext;
                      _currentHostContext = _currentHostContext.child;
                      continue;
                    }
                    if (_currentHostContext === workInProgress2) break a;
                    for (; null === _currentHostContext.sibling; ) {
                      if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                        break a;
                      _currentHostContext = _currentHostContext.return;
                    }
                    _currentHostContext.sibling.return = _currentHostContext.return;
                    _currentHostContext = _currentHostContext.sibling;
                  }
                  workInProgress2.stateNode = nextResource;
                  a: switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                  newProps && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                workInProgress2.type,
                null === current2 ? null : current2.memoizedProps,
                workInProgress2.pendingProps,
                renderLanes2
              );
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  type = !didSuspendOrErrorDEV;
                  newProps = null;
                  nextResource = hydrationParentFiber;
                  if (null !== nextResource)
                    switch (nextResource.tag) {
                      case 3:
                        type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                        break;
                      case 27:
                      case 5:
                        newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2, true);
                } else
                  type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 31:
              renderLanes2 = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState) {
                newProps = popHydrationState(workInProgress2);
                if (null !== renderLanes2) {
                  if (null === current2) {
                    if (!newProps)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    current2 = workInProgress2.memoizedState;
                    current2 = null !== current2 ? current2.dehydrated : null;
                    if (!current2)
                      throw Error(
                        "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    current2[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  current2 = false;
                } else
                  renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
                if (!current2) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
                if (0 !== (workInProgress2.flags & 128))
                  throw Error(
                    "Client rendering an Activity suspended it again. This is a bug in React."
                  );
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                type = newProps;
                nextResource = popHydrationState(workInProgress2);
                if (null !== type && null !== type.dehydrated) {
                  if (null === current2) {
                    if (!nextResource)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    nextResource = workInProgress2.memoizedState;
                    nextResource = null !== nextResource ? nextResource.dehydrated : null;
                    if (!nextResource)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    nextResource[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  type = false;
                } else
                  type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
                if (!type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              newProps = workInProgress2.memoizedState;
              if (null === newProps) return bubbleProperties(workInProgress2), null;
              type = 0 !== (workInProgress2.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      nextResource = findFirstSuspended(current2);
                      if (null !== nextResource) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(newProps, false);
                        current2 = nextResource.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!type)
                  if (current2 = findFirstSuspended(nextResource), null !== current2) {
                    if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
              }
              if (null !== newProps.tail)
                return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 31:
              if (null !== workInProgress2.memoizedState) {
                popSuspenseHandler(workInProgress2);
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 31:
              null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHydratingParent(current2, finishedWork) {
          return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
        }
        function commitBeforeMutationEffects(root3, firstChild) {
          root3 = root3.containerInfo;
          eventsEnabled = _enabled;
          root3 = getActiveElementDeep(root3);
          if (hasSelectionCapabilities(root3)) {
            if ("selectionStart" in root3)
              var JSCompiler_temp = {
                start: root3.selectionStart,
                end: root3.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root3) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root3,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
              root3.return = firstChild, nextEffect = root3;
            else
              for (; null !== nextEffect; ) {
                root3 = firstChild = nextEffect;
                JSCompiler_temp = root3.alternate;
                anchorOffset = root3.flags;
                switch (root3.tag) {
                  case 0:
                    if (0 !== (anchorOffset & 4) && (root3 = root3.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                      for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                        anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root3, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root3 = root3.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root3);
                      else if (1 === JSCompiler_temp)
                        switch (root3.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root3);
                            break;
                          default:
                            root3.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root3 = firstChild.sibling;
                if (null !== root3) {
                  root3.return = firstChild.return;
                  nextEffect = root3;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (null === current2) {
                if (flags & 4) commitHostMount(finishedWork);
                else if (flags & 64) {
                  finishedRoot = finishedWork.type;
                  current2 = finishedWork.memoizedProps;
                  prevProps = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedInstance,
                      prevProps,
                      finishedRoot,
                      current2,
                      finishedWork
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error
                    );
                  }
                }
              }
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, flags))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            deletedFiber,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedActivityInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root3 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                deletedFiber,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
              root3 = deletedFiber;
              returnFiber = root3.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root3.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root3) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
                var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
                flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
              }
              break;
            case 26:
              existingHiddenCallbacks = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4) {
                var currentResource = null !== current2 ? current2.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                        b: switch (flags) {
                          case "title":
                            currentResource = existingHiddenCallbacks.getElementsByTagName(
                              "title"
                            )[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                              currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                                currentResource,
                                existingHiddenCallbacks.querySelector(
                                  "head > title"
                                )
                              );
                            setInitialProperties(currentResource, flags, current2);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              existingHiddenCallbacks
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              existingHiddenCallbacks
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      existingHiddenCallbacks,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    resetTextContent,
                    existingHiddenCallbacks
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                existingHiddenCallbacks,
                null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    existingHiddenCallbacks,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              existingHiddenCallbacks = pushNestedEffectDurations();
              tagCaches = null;
              currentResource = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root3.containerInfo);
              recursivelyTraverseMutationEffects(root3, finishedWork);
              currentHoistableRoot = currentResource;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root3.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root3.effectDuration += popNestedEffectDurations(
                existingHiddenCallbacks
              );
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              existingHiddenCallbacks = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root3 = finishedWork.stateNode, root3._visibility = existingHiddenCallbacks ? root3._visibility & ~OffscreenVisible : root3._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                )), current2 = null, root3 = finishedWork; ; ) {
                  if (5 === root3.tag || 26 === root3.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root3;
                      try {
                        currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          currentResource
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root3.tag) {
                    if (null === current2) {
                      wasHidden = root3;
                      try {
                        maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          maybeNodes,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root3.tag) {
                    if (null === current2) {
                      wasHidden = root3;
                      try {
                        i = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideDehydratedBoundary,
                          i
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideDehydratedBoundary,
                          wasHidden.stateNode
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                    root3.child.return = root3;
                    root3 = root3.child;
                    continue;
                  }
                  if (root3 === finishedWork) break a;
                  for (; null === root3.sibling; ) {
                    if (null === root3.return || root3.return === finishedWork)
                      break a;
                    current2 === root3 && (current2 = null);
                    root3 = root3.return;
                  }
                  current2 === root3 && (current2 = null);
                  root3.sibling.return = root3.return;
                  root3 = root3.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root3, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions, endTime) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var nextSibling = parentFiber.sibling;
              commitPassiveMountOnFiber(
                root3,
                parentFiber,
                committedLanes,
                committedTransitions,
                null !== nextSibling ? nextSibling.actualStartTime : endTime
              );
              parentFiber = nextSibling;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                []
              ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              ));
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
              inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = wasInHydratedSubtree;
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(
                prevProfilerEffectDuration
              );
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
              break;
            case 31:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true) : inHydratedSubtree = false;
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 13:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 23:
              break;
            case 22:
              wasInHydratedSubtree = finishedWork.stateNode;
              prevProfilerEffectDuration = finishedWork.alternate;
              null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
                endTime
              ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                prevProfilerEffectDuration,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          if ((finishedWork.mode & ProfileMode) !== NoMode) {
            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
              committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
          }
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
          includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree,
            committedLanes
          );
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (var child = parentFiber.child; null !== child; ) {
              parentFiber = child.sibling;
              var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
              (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
                child,
                child.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              var flags = child.flags;
              switch (child.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
              }
              alreadyWarnedForDeepEquality = prevDeepEquality;
              child = parentFiber;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState
              ), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                suspendedState,
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 12:
              prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 22:
              prevProfilerEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              current2,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            );
            popComponentEffectStart(prevEffectStart);
            popComponentEffectDuration(prevEffectDuration);
            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
            componentEffectErrors = prevEffectErrors;
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                prevEffectStart = current2.sibling;
                prevEffectDuration = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== prevEffectStart) {
                  prevEffectStart.return = prevEffectDuration;
                  nextEffect = prevEffectStart;
                  break a;
                }
                nextEffect = prevEffectDuration;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root3, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root3 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            prepareFreshStack(root3, 0), markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root3, lane);
          if ((executionContext & RenderContext) !== NoContext && root3 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root3 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root3) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root3), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root3,
                    root3
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root3, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root3 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root3);
        }
        function performWorkOnRoot(root3, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
            var yieldedFiber = workInProgress, yieldEndTime = now$1();
            switch (yieldReason) {
              case SuspendedOnImmediate:
              case SuspendedOnData:
                var startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              case SuspendedOnAction:
                startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              default:
                supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
                ));
            }
          }
          startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root3.expiredLanes) || checkIfRootIsPrerendering(root3, lanes)) ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes, true);
          var renderWasConcurrent = forceSync;
          do {
            if (startTime === RootInProgress) {
              workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root3, lanes, 0, false);
              lanes = workInProgressSuspendedReason;
              yieldStartTime = now();
              yieldReason = lanes;
              break;
            } else {
              yieldedFiber = now$1();
              yieldEndTime = root3.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
                setCurrentTrackFromLanes(lanes);
                yieldEndTime = renderStartTime;
                startTime = yieldedFiber;
                !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  )
                ) : console.timeStamp(
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                ));
                finalizeRender(lanes, yieldedFiber);
                startTime = renderRootSync(root3, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (startTime === RootErrored) {
                renderWasConcurrent = lanes;
                if (root3.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root3.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  setCurrentTrackFromLanes(lanes);
                  logErroredRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  lanes = errorRetryLanes;
                  a: {
                    yieldedFiber = root3;
                    startTime = renderWasConcurrent;
                    renderWasConcurrent = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                    errorRetryLanes = renderRootSync(
                      yieldedFiber,
                      errorRetryLanes,
                      false
                    );
                    if (errorRetryLanes !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                        workInProgressRootInterleavedUpdatedLanes |= startTime;
                        startTime = RootSuspendedWithDelay;
                        break a;
                      }
                      yieldedFiber = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = renderWasConcurrent;
                      null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        yieldedFiber
                      ));
                    }
                    startTime = errorRetryLanes;
                  }
                  renderWasConcurrent = false;
                  if (startTime !== RootErrored) continue;
                  else yieldedFiber = now$1();
                }
              }
              if (startTime === RootFatalErrored) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                prepareFreshStack(root3, 0);
                markRootSuspended(root3, lanes, 0, true);
                break;
              }
              a: {
                forceSync = root3;
                switch (startTime) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    setCurrentTrackFromLanes(lanes);
                    logSuspendedRenderPhase(
                      renderStartTime,
                      yieldedFiber,
                      lanes,
                      workInProgressUpdateTask
                    );
                    finalizeRender(lanes, yieldedFiber);
                    yieldEndTime = lanes;
                    0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    forceSync,
                    yieldEndTime,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    startTime,
                    null,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(forceSync, 0, true)) break a;
                    pendingEffectsLanes = lanes;
                    forceSync.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        forceSync,
                        yieldEndTime,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        startTime,
                        "Throttled",
                        renderStartTime,
                        yieldedFiber
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root3);
        }
        function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root3.timeoutHandle = noTimeout;
          var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: true,
              waitingForViewTransition: false,
              unsuspend: noop$1
            }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
              pendingEffectsLanes = lanes;
              root3.cancelPendingCommit = subtreeFlags(
                commitRoot.bind(
                  null,
                  root3,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedState,
                  suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root3,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root3,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedState,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root3.suspendedLanes |= suspendedLanes;
          root3.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root3.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function finalizeRender(lanes, finalizationTime) {
          0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
          0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
          0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
          0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
        }
        function prepareFreshStack(root3, lanes) {
          supportsUserTiming && (console.timeStamp(
            "Blocking Track",
            3e-3,
            3e-3,
            "Blocking",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Transition Track",
            3e-3,
            3e-3,
            "Transition",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Suspense Track",
            3e-3,
            3e-3,
            "Suspense",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Idle Track",
            3e-3,
            3e-3,
            "Idle",
            LANES_TRACK_GROUP,
            "primary-light"
          ));
          var previousRenderStartTime = renderStartTime;
          renderStartTime = now();
          if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
            setCurrentTrackFromLanes(workInProgressRootRenderLanes);
            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
              logSuspendedRenderPhase(
                previousRenderStartTime,
                renderStartTime,
                lanes,
                workInProgressUpdateTask
              );
            else {
              var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
              if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
                var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
                debugTask ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                ) : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
              }
            }
            finalizeRender(workInProgressRootRenderLanes, renderStartTime);
          }
          previousRenderStartTime = workInProgressUpdateTask;
          workInProgressUpdateTask = null;
          if (0 !== (lanes & 127)) {
            workInProgressUpdateTask = blockingUpdateTask;
            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
            0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
            previousRenderStartTime = debugTask;
            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
            debugTask = renderStartTime;
            endTime = blockingUpdateTask;
            color = blockingUpdateMethodName;
            label = blockingUpdateComponentName;
            if (supportsUserTiming) {
              currentTrack = "Blocking";
              0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
              0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
              if (null !== eventType && previousRenderStartTime > eventTime) {
                var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
                endTime ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                ) : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
              }
              debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
                start: previousRenderStartTime,
                end: debugTask,
                detail: {
                  devtools: {
                    properties: isPingedUpdate,
                    track: currentTrack,
                    trackGroup: LANES_TRACK_GROUP,
                    color: eventTime
                  }
                }
              }, endTime ? endTime.run(
                performance.measure.bind(
                  performance,
                  isSpawnedUpdate,
                  previousRenderStartTime
                )
              ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
            }
            blockingUpdateTime = -1.1;
            blockingUpdateType = 0;
            blockingUpdateComponentName = blockingUpdateMethodName = null;
            blockingSuspendedTime = -1.1;
            blockingEventRepeatTime = blockingEventTime;
            blockingEventTime = -1.1;
            blockingClampTime = now();
          }
          0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
            transitionSuspendedTime,
            color,
            lanes,
            workInProgressUpdateTask
          )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              eventType ? "Consecutive" : "Event: " + eventTime,
              isPingedUpdate,
              debugTask,
              currentTrack,
              LANES_TRACK_GROUP,
              color$jscomp$0
            )
          ) : console.timeStamp(
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              "Action",
              debugTask,
              previousRenderStartTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "primary-dark"
            )
          ) : console.timeStamp(
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: color,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: "primary-light"
              }
            }
          }, endTime ? endTime.run(
            performance.measure.bind(
              performance,
              debugTask,
              previousRenderStartTime
            )
          ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
          0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
          0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
          previousRenderStartTime = root3.timeoutHandle;
          previousRenderStartTime !== noTimeout && (root3.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
          previousRenderStartTime = root3.cancelPendingCommit;
          null !== previousRenderStartTime && (root3.cancelPendingCommit = null, previousRenderStartTime());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root3;
          workInProgress = previousRenderStartTime = createWorkInProgress(
            root3.current,
            null
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          endTime = root3.entangledLanes;
          if (0 !== endTime)
            for (root3 = root3.entanglements, endTime &= lanes; 0 < endTime; )
              debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root3[debugTask], endTime &= ~color;
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          root3 = getCurrentTime();
          1e3 < root3 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root3);
          ReactStrictModeWarnings.discardPendingWarnings();
          return previousRenderStartTime;
        }
        function handleThrow(root3, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function markRenderDerivedCause(fiber) {
          null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root3, lanes);
          }
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root3, thrownValue$8);
            }
          while (1);
          lanes && root3.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root3, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root3,
              lanes
            );
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root3 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root3);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root3, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return RootInProgress;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root3,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root3,
                createCapturedValueAtFiber(thrownValue, root3.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root3 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root3 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root3);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root3.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          setCurrentTrackFromLanes(lanes);
          exitStatus === RootErrored ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          ) : null !== recoverableErrors ? logRecoveredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            recoverableErrors,
            null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
            workInProgressUpdateTask
          ) : logRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          );
          if (null !== finishedWork) {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root3.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root3,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root3;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            pendingEffectsRenderEndTime = completedRenderEndTime;
            pendingSuspendedCommitReason = suspendedCommitReason;
            pendingDelayedCommitReason = IMMEDIATE_COMMIT;
            pendingSuspendedViewTransitionReason = null;
            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            })) : (root3.callbackNode = null, root3.callbackPriority = 0);
            commitErrors = null;
            commitStartTime = now();
            null !== suspendedCommitReason && logSuspendedCommitPhase(
              completedRenderEndTime,
              commitStartTime,
              suspendedCommitReason,
              workInProgressUpdateTask
            );
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root3, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root3;
                resetComponentEffectTimers();
                commitMutationEffectsOnFiber(finishedWork, root3);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root3.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
            if (null !== suspendedViewTransitionReason) {
              commitStartTime = now();
              var startTime = commitEndTime, endTime = commitStartTime;
              !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            suspendedViewTransitionReason = pendingEffectsRoot;
            startTime = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var _previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var _prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                  suspendedViewTransitionReason,
                  startTime.alternate,
                  startTime
                ), inProgressRoot = inProgressLanes = null;
              } finally {
                executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            suspendedViewTransitionReason = pendingEffectsRenderEndTime;
            startTime = pendingSuspendedCommitReason;
            commitEndTime = now();
            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
            startTime = commitEndTime;
            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            rootHasLayoutEffect = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              false,
              rootHasLayoutEffect
            ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
              console.timeStamp.bind(
                console,
                endTime ? "Commit Interrupted View Transition" : "Commit",
                suspendedViewTransitionReason,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                endTime ? "error" : "secondary-dark"
              )
            ) : console.timeStamp(
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            ));
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
              var startViewTransitionStartTime = commitEndTime;
              commitEndTime = now();
              var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
              !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? "error" : "secondary-light"
                )
              ) : console.timeStamp(
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? " error" : "secondary-light"
              ));
              pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
            }
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            startViewTransitionStartTime = pendingEffectsRoot;
            var finishedWork = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            abortedViewTransition = pendingRecoverableErrors;
            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
            remainingLanes = lanesToEventPriority(endTime);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (remainingLanes) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== abortedViewTransition) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
                for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                  var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(startViewTransitionStartTime);
            remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root3, remainingLanes) {
          0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            priority = pendingEffectsRoot;
            var lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            setCurrentTrackFromLanes(lanes);
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            var passiveEffectStartTime = 0;
            commitErrors = null;
            passiveEffectStartTime = now$1();
            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
              logAnimatingPhase(
                commitEndTime,
                passiveEffectStartTime,
                animatingTask
              );
            else {
              var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
              !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            startTime = executionContext;
            executionContext |= CommitContext;
            var finishedWork = priority.current;
            resetComponentEffectTimers();
            commitPassiveUnmountOnFiber(finishedWork);
            var finishedWork$jscomp$0 = priority.current;
            finishedWork = pendingEffectsRenderEndTime;
            resetComponentEffectTimers();
            commitPassiveMountOnFiber(
              priority,
              finishedWork$jscomp$0,
              lanes,
              transitions,
              finishedWork
            );
            commitDoubleInvokeEffectsInDEV(priority);
            executionContext = startTime;
            var passiveEffectsEndTime = now$1();
            finishedWork$jscomp$0 = passiveEffectStartTime;
            finishedWork = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              true,
              finishedWork
            ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
              console.timeStamp.bind(
                console,
                "Remaining Effects",
                finishedWork$jscomp$0,
                passiveEffectsEndTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            ) : console.timeStamp(
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
            finalizeRender(lanes, passiveEffectsEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, priority);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            var stateNode = priority.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root3, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          recordEffectError(sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  recordEffectError(sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root3, wakeable, lanes) {
          var pingCache = root3.pingCache;
          if (null === pingCache) {
            pingCache = root3.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root3, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root3, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root3, wakeable, pingedLanes) {
          var pingCache = root3.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          root3.warmLanes &= ~pingedLanes;
          0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root3);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root3 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root3,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root3,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root3, fiber) {
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root3, fiber.alternate, fiber, false), reconnectPassiveEffects(root3, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root3) {
          var doubleInvokeEffects = true;
          root3.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root3,
            root3.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root3, lanes) {
          isDevToolsPresent && root3.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root3, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root3) {
          root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root3 = firstScheduledRoot; null !== root3; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root3.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root3,
                      root3 === workInProgressRoot ? nextLanes : 0,
                      null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root3, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                root3 = root3.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          schedulerEvent = window.event;
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
          for (var currentTime = now$1(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
            var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
            if (0 === nextLanes)
              root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root3 = next;
          }
          pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
          for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root3,
            root3 === currentTime ? suspendedLanes : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          pingedLanes = root3.callbackNode;
          if (0 === suspendedLanes || root3 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root3.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root3.callbackPriority = currentTime;
            root3.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root3.callbackPriority = 2;
          root3.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          schedulerEvent = window.event;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root3.callbackNode = null, root3.callbackPriority = 0, null;
          var originalCallbackNode = root3.callbackNode;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root3,
            root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root3,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root3, now$1());
          return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
        }
        function performSyncWorkOnRoot(root3, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root3, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                          lastHostComponent++;
                        _instance2 = 0;
                        for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                          _instance2++;
                        for (; 0 < lastHostComponent - _instance2; )
                          reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                        for (; 0 < _instance2 - lastHostComponent; )
                          instance = inCapturePhase(instance), _instance2--;
                        for (; lastHostComponent--; ) {
                          if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return true;
            default:
              return false;
          }
        }
        function estimateBandwidth() {
          if ("function" === typeof performance.getEntriesByType) {
            for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
              var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
              if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i += 1; i < resourceEntries.length; i++) {
                  var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
                }
                --i;
                bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function resolveEventType() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.type : null;
        }
        function resolveEventTimeStamp() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.timeStamp : -1.1;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitHydratedInstance() {
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function warnForReactChildrenConflict(container) {
          if (!container.__reactWarnedAboutChildrenConflict) {
            var props = container[internalPropsKey] || null;
            if (null !== props) {
              var fiber = getInstanceFromNode(container);
              null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })));
            }
          }
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
                depth++;
              else if (node === PREAMBLE_CONTRIBUTION_HTML)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement
                );
              else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA)
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function hideDehydratedBoundary(suspenseInstance) {
          hideOrUnhideDehydratedBoundary(suspenseInstance, true);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideDehydratedBoundary(dehydratedInstance) {
          hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data === SUSPENSE_QUEUED_START_DATA)
            instance._reactRetry = callback;
          else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
                return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else
                data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedActivityInstance(activityInstance) {
          retryIfBlockedOn(activityInstance);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root3) {
          for (var nodes = root3.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function() {
                state.waitingForImages = false;
                if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root3, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root3);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root3, precedences);
              for (var nodes = root3.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          tag |= ProfileMode;
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane(fiber);
            lane = getBumpedLaneForHydrationByLane(lane);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root3 = fiber;
                          root3.pendingLanes |= 2;
                          for (root3.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root3.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept && "react-transition" === event.info && event.intercept({
              handler: function() {
                return new Promise(function(resolve) {
                  return pendingResolve = resolve;
                });
              },
              focusReset: "manual",
              scroll: "manual"
            });
          }
          function handleNavigateComplete() {
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
                state: currentEntry.getState(),
                info: "react-transition",
                history: "replace"
              });
            }
          }
          if ("object" === typeof navigation) {
            var isCancelled = false, pendingResolve = null;
            navigation.addEventListener("navigate", handleNavigate);
            navigation.addEventListener("navigatesuccess", handleNavigateComplete);
            navigation.addEventListener("navigateerror", handleNavigateComplete);
            setTimeout(startFakeNavigation, 100);
            return function() {
              isCancelled = true;
              navigation.removeEventListener("navigate", handleNavigate);
              navigation.removeEventListener(
                "navigatesuccess",
                handleNavigateComplete
              );
              navigation.removeEventListener(
                "navigateerror",
                handleNavigateComplete
              );
              null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root2 = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
          color: "primary",
          properties: null,
          tooltipText: "",
          track: COMPONENTS_TRACK
        }, reusableComponentOptions = {
          start: -0,
          end: -0,
          detail: { devtools: reusableComponentDevToolDetails }
        }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
          return null;
        }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          globalMostRecentTransitionTime = now$1();
          if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
            if (0 > transitionStartTime && 0 > transitionUpdateTime) {
              transitionStartTime = now();
              var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
              if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
                transitionEventRepeatTime = -1.1;
              transitionEventTime = newEventTime;
              transitionEventType = newEventType;
            }
            entangleAsyncAction(transition, returnValue);
          }
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          }
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          cacheSignal: function() {
            return readContext(CacheContext).controller.signal;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        };
        scheduleRetry = function(fiber) {
          var lane = claimNextRetryLane(), root3 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root3 = this._internalRoot;
          if (null === root3) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root3.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root3, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!(function() {
          var internals = {
            bundleType: 1,
            version: "19.2.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.2.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.scheduleRetry = scheduleRetry;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          return injectInternals(internals);
        })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js
  var require_react_jsx_dev_runtime_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
              return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
          React,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            isStaticChildren,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-dev-runtime.js
  var require_jsx_dev_runtime = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-dev-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_dev_runtime_development();
      }
    }
  });

  // index.tsx
  var import_client = __toESM(require_client());
  var import_react = __toESM(require_react());

  // ../editor/dist/index.js
  (() => {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var require_blockly_compressed = __commonJS2({
      "node_modules/.pnpm/blockly@12.3.1/node_modules/blockly/blockly_compressed.js"(exports, module) {
        (function(root2, factory) {
          if (typeof define === "function" && define.amd) {
            define([], factory);
          } else if (typeof exports === "object") {
            module.exports = factory();
          } else {
            root2.Blockly = factory();
          }
        })(exports, function() {
          var $ = {};
          var register$$module$build$src$core$registry, validate$$module$build$src$core$registry, unregister$$module$build$src$core$registry, getItem$$module$build$src$core$registry, hasItem$$module$build$src$core$registry, getClass$$module$build$src$core$registry, getObject$$module$build$src$core$registry, getAllItems$$module$build$src$core$registry, getClassFromOptions$$module$build$src$core$registry, longStart$$module$build$src$core$touch, longStop$$module$build$src$core$touch, clearTouchIdentifier$$module$build$src$core$touch, shouldHandleEvent$$module$build$src$core$touch, getTouchIdentifierFromEvent$$module$build$src$core$touch, checkTouchIdentifier$$module$build$src$core$touch, conditionalBind$$module$build$src$core$browser_events, bind$$module$build$src$core$browser_events, unbind$$module$build$src$core$browser_events, isTargetInput$$module$build$src$core$browser_events, isRightButton$$module$build$src$core$browser_events, mouseToSvg$$module$build$src$core$browser_events, getScrollDeltaPixels$$module$build$src$core$browser_events, getNextUniqueId$$module$build$src$core$utils$idgenerator, genUid$$module$build$src$core$utils$idgenerator, isBlockCreate$$module$build$src$core$events$predicates, isBlockDelete$$module$build$src$core$events$predicates, isBlockChange$$module$build$src$core$events$predicates, isBlockFieldIntermediateChange$$module$build$src$core$events$predicates, isBlockMove$$module$build$src$core$events$predicates, isVarCreate$$module$build$src$core$events$predicates, isVarDelete$$module$build$src$core$events$predicates, isVarRename$$module$build$src$core$events$predicates, isBlockDrag$$module$build$src$core$events$predicates, isSelected$$module$build$src$core$events$predicates, isClick$$module$build$src$core$events$predicates, isBubbleOpen$$module$build$src$core$events$predicates, isTrashcanOpen$$module$build$src$core$events$predicates, isToolboxItemSelect$$module$build$src$core$events$predicates, isThemeChange$$module$build$src$core$events$predicates, isViewportChange$$module$build$src$core$events$predicates, isCommentCreate$$module$build$src$core$events$predicates, isCommentDelete$$module$build$src$core$events$predicates, isCommentChange$$module$build$src$core$events$predicates, isCommentMove$$module$build$src$core$events$predicates, isCommentResize$$module$build$src$core$events$predicates, isCommentDrag$$module$build$src$core$events$predicates, isCommentCollapse$$module$build$src$core$events$predicates, isFinishedLoading$$module$build$src$core$events$predicates, getRecordUndo$$module$build$src$core$events$utils, fire$$module$build$src$core$events$utils, fireInternal$$module$build$src$core$events$utils, fireNow$$module$build$src$core$events$utils, enqueueEvent$$module$build$src$core$events$utils, filter$$module$build$src$core$events$utils, clearPendingUndo$$module$build$src$core$events$utils, isEnabled$$module$build$src$core$events$utils, setGroupInternal$$module$build$src$core$events$utils, getDescendantIds$$module$build$src$core$events$utils, fromJson$$module$build$src$core$events$utils, get$$module$build$src$core$events$utils, disableOrphans$$module$build$src$core$events$utils, createSvgElement$$module$build$src$core$utils$dom, addClass$$module$build$src$core$utils$dom, removeClasses$$module$build$src$core$utils$dom, removeClass$$module$build$src$core$utils$dom, hasClass$$module$build$src$core$utils$dom, removeNode$$module$build$src$core$utils$dom, insertAfter$$module$build$src$core$utils$dom, setCssTransform$$module$build$src$core$utils$dom, startTextWidthCache$$module$build$src$core$utils$dom, stopTextWidthCache$$module$build$src$core$utils$dom, getTextWidth$$module$build$src$core$utils$dom, getFastTextWidth$$module$build$src$core$utils$dom, getFastTextWidthWithSizeString$$module$build$src$core$utils$dom, measureFontMetrics$$module$build$src$core$utils$dom, isFocusableNode$$module$build$src$core$interfaces$i_focusable_node, isSelectable$$module$build$src$core$interfaces$i_selectable, deepMerge$$module$build$src$core$utils$object, getWorkspaceById$$module$build$src$core$common, getAllWorkspaces$$module$build$src$core$common, registerWorkspace$$module$build$src$core$common, unregisterWorkpace$$module$build$src$core$common, getMainWorkspace$$module$build$src$core$common, setMainWorkspace$$module$build$src$core$common, getSelected$$module$build$src$core$common, setSelected$$module$build$src$core$common, fireSelectedEvent$$module$build$src$core$common, getParentContainer$$module$build$src$core$common, setParentContainer$$module$build$src$core$common, svgResize$$module$build$src$core$common, getBlockTypeCounts$$module$build$src$core$common, jsonInitFactory$$module$build$src$core$common, defineBlocksWithJsonArray$$module$build$src$core$common, defineBlocksWithJsonArrayInternal$$module$build$src$core$common, globalShortcutHandler$$module$build$src$core$common, removeElem$$module$build$src$core$utils$array, register$$module$build$src$core$css, inject$$module$build$src$core$css, getSize$$module$build$src$core$utils$style, getSizeInternal$$module$build$src$core$utils$style, getSizeWithDisplay$$module$build$src$core$utils$style, getComputedStyle$$module$build$src$core$utils$style, getPageOffset$$module$build$src$core$utils$style, getViewportPageOffset$$module$build$src$core$utils$style, getBorderBox$$module$build$src$core$utils$style, scrollIntoContainerView$$module$build$src$core$utils$style, getContainerOffsetToScrollInto$$module$build$src$core$utils$style, getRelativeXY$$module$build$src$core$utils$svg_math, getInjectionDivXY$$module$build$src$core$utils$svg_math, getViewportBBox$$module$build$src$core$utils$svg_math, getDocumentScroll$$module$build$src$core$utils$svg_math, screenToWsCoordinates$$module$build$src$core$utils$svg_math, wsToScreenCoordinates$$module$build$src$core$utils$svg_math, injectDependencies$$module$build$src$core$utils$xml, domToText$$module$build$src$core$utils$xml, sanitizeText$$module$build$src$core$utils$xml, convertToolboxDefToJson$$module$build$src$core$utils$toolbox, validateToolbox$$module$build$src$core$utils$toolbox, convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox, hasCategories$$module$build$src$core$utils$toolbox, hasCategoriesInternal$$module$build$src$core$utils$toolbox, isCategoryCollapsible$$module$build$src$core$utils$toolbox, convertToToolboxJson$$module$build$src$core$utils$toolbox, xmlToJsonArray$$module$build$src$core$utils$toolbox, addAttributes$$module$build$src$core$utils$toolbox, parseToolboxTree$$module$build$src$core$utils$toolbox, getStartPositionRect$$module$build$src$core$positionable_helpers, getCornerOppositeToolbox$$module$build$src$core$positionable_helpers, bumpPositionRect$$module$build$src$core$positionable_helpers, register$$module$build$src$core$serialization$registry, unregister$$module$build$src$core$serialization$registry, save$$module$build$src$core$serialization$workspace_comments, append$$module$build$src$core$serialization$workspace_comments, register$$module$build$src$core$clipboard$registry, unregister$$module$build$src$core$clipboard$registry, moveCommentToNotConflict$$module$build$src$core$clipboard$workspace_comment_paster, commentOverlapsOtherExactly$$module$build$src$core$clipboard$workspace_comment_paster, setRole$$module$build$src$core$utils$aria, setState$$module$build$src$core$utils$aria, isSerializable$$module$build$src$core$interfaces$i_serializable, queueRender$$module$build$src$core$render_management, finishQueuedRenders$$module$build$src$core$render_management, triggerQueuedRenders$$module$build$src$core$render_management, alwaysImmediatelyRender$$module$build$src$core$render_management, queueBlock$$module$build$src$core$render_management, doRenders$$module$build$src$core$render_management, dequeueBlock$$module$build$src$core$render_management, shouldRenderRootBlock$$module$build$src$core$render_management, renderBlock$$module$build$src$core$render_management, alert$$module$build$src$core$dialog, setAlert$$module$build$src$core$dialog, confirm$$module$build$src$core$dialog, setConfirm$$module$build$src$core$dialog, prompt$$module$build$src$core$dialog, setPrompt$$module$build$src$core$dialog, toast$$module$build$src$core$dialog, setToast$$module$build$src$core$dialog, isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks, isLegacyProcedureCallBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks, isVariableBackedParameterModel$$module$build$src$core$interfaces$i_variable_backed_parameter_model, warn$$module$build$src$core$utils$deprecation, internalFlyoutCategory$$module$build$src$core$variables, flyoutCategory$$module$build$src$core$variables, generateVariableFieldJson$$module$build$src$core$variables, jsonFlyoutCategoryBlocks$$module$build$src$core$variables, xmlFlyoutCategory$$module$build$src$core$variables, flyoutCategoryBlocks$$module$build$src$core$variables, generateUniqueName$$module$build$src$core$variables, generateUniqueNameInternal$$module$build$src$core$variables, generateUniqueNameFromOptions$$module$build$src$core$variables, createVariableButtonHandler$$module$build$src$core$variables, promptName$$module$build$src$core$variables, nameUsedWithOtherType$$module$build$src$core$variables, nameUsedWithAnyType$$module$build$src$core$variables, nameUsedWithConflictingParam$$module$build$src$core$variables, checkForConflictingParamWithProcedureModels$$module$build$src$core$variables, checkForConflictingParamWithLegacyProcedures$$module$build$src$core$variables, generateVariableFieldDom$$module$build$src$core$variables, createVariable$$module$build$src$core$variables, getAddedVariables$$module$build$src$core$variables, compareByName$$module$build$src$core$variables, getVariableUsesById$$module$build$src$core$variables, save$$module$build$src$core$serialization$blocks, saveAttributes$$module$build$src$core$serialization$blocks, saveCoords$$module$build$src$core$serialization$blocks, saveExtraState$$module$build$src$core$serialization$blocks, saveIcons$$module$build$src$core$serialization$blocks, saveFields$$module$build$src$core$serialization$blocks, saveInputBlocks$$module$build$src$core$serialization$blocks, saveNextBlocks$$module$build$src$core$serialization$blocks, saveConnection$$module$build$src$core$serialization$blocks, append$$module$build$src$core$serialization$blocks, appendInternal$$module$build$src$core$serialization$blocks, appendPrivate$$module$build$src$core$serialization$blocks, checkNewVariables$$module$build$src$core$serialization$blocks, loadCoords$$module$build$src$core$serialization$blocks, loadAttributes$$module$build$src$core$serialization$blocks, loadExtraState$$module$build$src$core$serialization$blocks, tryToConnectParent$$module$build$src$core$serialization$blocks, loadIcons$$module$build$src$core$serialization$blocks, loadFields$$module$build$src$core$serialization$blocks, loadInputBlocks$$module$build$src$core$serialization$blocks, loadNextBlocks$$module$build$src$core$serialization$blocks, loadConnection$$module$build$src$core$serialization$blocks, initBlock$$module$build$src$core$serialization$blocks, hasBubble$$module$build$src$core$interfaces$i_has_bubble, toRadians$$module$build$src$core$utils$math, toDegrees$$module$build$src$core$utils$math, clamp$$module$build$src$core$utils$math, createDom$$module$build$src$core$dropdowndiv, setBoundsElement$$module$build$src$core$dropdowndiv, getOwner$$module$build$src$core$dropdowndiv, getContentDiv$$module$build$src$core$dropdowndiv, clearContent$$module$build$src$core$dropdowndiv, setColour$$module$build$src$core$dropdowndiv, showPositionedByBlock$$module$build$src$core$dropdowndiv, showPositionedByField$$module$build$src$core$dropdowndiv, getScaledBboxOfBlock$$module$build$src$core$dropdowndiv, getScaledBboxOfField$$module$build$src$core$dropdowndiv, showPositionedByRect$$module$build$src$core$dropdowndiv, show$$module$build$src$core$dropdowndiv, getPositionBelowMetrics$$module$build$src$core$dropdowndiv, getPositionAboveMetrics$$module$build$src$core$dropdowndiv, getPositionTopOfPageMetrics$$module$build$src$core$dropdowndiv, getPositionX$$module$build$src$core$dropdowndiv, isVisible$$module$build$src$core$dropdowndiv, hideIfOwner$$module$build$src$core$dropdowndiv, hide$$module$build$src$core$dropdowndiv, hideWithoutAnimation$$module$build$src$core$dropdowndiv, positionInternal$$module$build$src$core$dropdowndiv, repositionForWindowResize$$module$build$src$core$dropdowndiv, shortestStringLength$$module$build$src$core$utils$string, commonWordPrefix$$module$build$src$core$utils$string, commonWordSuffix$$module$build$src$core$utils$string, wrapLine$$module$build$src$core$utils$string, wrapScore$$module$build$src$core$utils$string, wrapMutate$$module$build$src$core$utils$string, wrapToText$$module$build$src$core$utils$string, setCustomTooltip$$module$build$src$core$tooltip, getCustomTooltip$$module$build$src$core$tooltip, isVisible$$module$build$src$core$tooltip, getDiv$$module$build$src$core$tooltip, getTooltipOfObject$$module$build$src$core$tooltip, getTargetObject$$module$build$src$core$tooltip, createDom$$module$build$src$core$tooltip, bindMouseEvents$$module$build$src$core$tooltip, unbindMouseEvents$$module$build$src$core$tooltip, onMouseOver$$module$build$src$core$tooltip, onMouseOut$$module$build$src$core$tooltip, onMouseMove$$module$build$src$core$tooltip, dispose$$module$build$src$core$tooltip, hide$$module$build$src$core$tooltip, block$$module$build$src$core$tooltip, unblock$$module$build$src$core$tooltip, renderContent$$module$build$src$core$tooltip, renderDefaultContent$$module$build$src$core$tooltip, getPosition$$module$build$src$core$tooltip, show$$module$build$src$core$tooltip, getHsvSaturation$$module$build$src$core$utils$colour, setHsvSaturation$$module$build$src$core$utils$colour, getHsvValue$$module$build$src$core$utils$colour, setHsvValue$$module$build$src$core$utils$colour, parse$$module$build$src$core$utils$colour, rgbToHex$$module$build$src$core$utils$colour, hexToRgb$$module$build$src$core$utils$colour, hsvToHex$$module$build$src$core$utils$colour, blend$$module$build$src$core$utils$colour, hueToHex$$module$build$src$core$utils$colour, tokenizeInterpolationInternal$$module$build$src$core$utils$parsing, tokenizeInterpolation$$module$build$src$core$utils$parsing, replaceMessageReferences$$module$build$src$core$utils$parsing, checkMessageReferences$$module$build$src$core$utils$parsing, parseBlockColour$$module$build$src$core$utils$parsing, getDiv$$module$build$src$core$widgetdiv, testOnly_setDiv$$module$build$src$core$widgetdiv, createDom$$module$build$src$core$widgetdiv, show$$module$build$src$core$widgetdiv, hide$$module$build$src$core$widgetdiv, isVisible$$module$build$src$core$widgetdiv, hideIfOwner$$module$build$src$core$widgetdiv, hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv, positionInternal$$module$build$src$core$widgetdiv, positionWithAnchor$$module$build$src$core$widgetdiv, calculateX$$module$build$src$core$widgetdiv, calculateY$$module$build$src$core$widgetdiv, isRepositionable$$module$build$src$core$widgetdiv, repositionForWindowResize$$module$build$src$core$widgetdiv, getCurrentBlock$$module$build$src$core$contextmenu, setCurrentBlock$$module$build$src$core$contextmenu, show$$module$build$src$core$contextmenu, populate_$$module$build$src$core$contextmenu, position_$$module$build$src$core$contextmenu, createWidget_$$module$build$src$core$contextmenu, haltPropagation$$module$build$src$core$contextmenu, hide$$module$build$src$core$contextmenu, dispose$$module$build$src$core$contextmenu, mouseToWorkspacePoint$$module$build$src$core$utils$drag, start$$module$build$src$core$utils$drag, move$$module$build$src$core$utils$drag, workspaceToDom$$module$build$src$core$xml, saveWorkspaceComment$$module$build$src$core$xml, variablesToDom$$module$build$src$core$xml, blockToDomWithXY$$module$build$src$core$xml, fieldToDom$$module$build$src$core$xml, allFieldsToDom$$module$build$src$core$xml, blockToDom$$module$build$src$core$xml, cloneShadow$$module$build$src$core$xml, domToText$$module$build$src$core$xml, domToPrettyText$$module$build$src$core$xml, clearWorkspaceAndLoadFromXml$$module$build$src$core$xml, loadWorkspaceComment$$module$build$src$core$xml, appendDomToWorkspace$$module$build$src$core$xml, domToBlockInternal$$module$build$src$core$xml, domToVariables$$module$build$src$core$xml, mapSupportedXmlTags$$module$build$src$core$xml, applyMutationTagNodes$$module$build$src$core$xml, applyCommentTagNodes$$module$build$src$core$xml, applyDataTagNodes$$module$build$src$core$xml, applyFieldTagNodes$$module$build$src$core$xml, findChildBlocks$$module$build$src$core$xml, applyInputTagNodes$$module$build$src$core$xml, applyNextTagNodes$$module$build$src$core$xml, domToBlockHeadless$$module$build$src$core$xml, domToField$$module$build$src$core$xml, deleteNext$$module$build$src$core$xml, isElement$$module$build$src$core$xml, register$$module$build$src$core$field_registry, unregister$$module$build$src$core$field_registry, fromJsonInternal$$module$build$src$core$field_registry, isImageProperties$$module$build$src$core$field_dropdown, unregister$$module$build$src$core$extensions, isRegistered$$module$build$src$core$extensions, apply$$module$build$src$core$extensions, checkNoMutatorProperties$$module$build$src$core$extensions, checkXmlHooks$$module$build$src$core$extensions, checkJsonHooks$$module$build$src$core$extensions, checkMutatorDialog$$module$build$src$core$extensions, checkHasFunctionPair$$module$build$src$core$extensions, checkHasMutatorProperties$$module$build$src$core$extensions, getMutatorProperties$$module$build$src$core$extensions, mutatorPropertiesMatch$$module$build$src$core$extensions, runAfterPageLoad$$module$build$src$core$extensions, checkDropdownOptionsInTable$$module$build$src$core$extensions, extensionParentTooltip$$module$build$src$core$extensions, point$$module$build$src$core$utils$svg_paths, curve$$module$build$src$core$utils$svg_paths, moveTo$$module$build$src$core$utils$svg_paths, moveBy$$module$build$src$core$utils$svg_paths, lineTo$$module$build$src$core$utils$svg_paths, line$$module$build$src$core$utils$svg_paths, lineOnAxis$$module$build$src$core$utils$svg_paths, arc$$module$build$src$core$utils$svg_paths, connectReciprocally$$module$build$src$core$connection, getSingleConnection$$module$build$src$core$connection, getConnectionForOrphanedOutput$$module$build$src$core$connection, isIcon$$module$build$src$core$interfaces$i_icon, isCommentIcon$$module$build$src$core$interfaces$i_comment_icon, disposeUiEffect$$module$build$src$core$block_animations, disposeUiStep$$module$build$src$core$block_animations, connectionUiEffect$$module$build$src$core$block_animations, disconnectUiEffect$$module$build$src$core$block_animations, disconnectUiStep$$module$build$src$core$block_animations, disconnectUiStop$$module$build$src$core$block_animations, moveBlockToNotConflict$$module$build$src$core$clipboard$block_paster, blockOverlapsOtherExactly$$module$build$src$core$clipboard$block_paster, blockIsInSnapRadius$$module$build$src$core$clipboard$block_paster, bumpObjectIntoBounds$$module$build$src$core$bump_objects, bumpIntoBoundsHandler$$module$build$src$core$bump_objects, extractObjectFromEvent$$module$build$src$core$bump_objects, bumpTopObjectsIntoBounds$$module$build$src$core$bump_objects, isDeletable$$module$build$src$core$interfaces$i_deletable, getBlockNavigationCandidates$$module$build$src$core$keyboard_nav$block_navigation_policy, navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy, navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy, register$$module$build$src$core$icons$registry, unregister$$module$build$src$core$icons$registry, isDraggable$$module$build$src$core$interfaces$i_draggable, isAutoHideable$$module$build$src$core$interfaces$i_autohideable, isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block, isObservable$$module$build$src$core$interfaces$i_observable, allProcedures$$module$build$src$core$procedures, procTupleComparator$$module$build$src$core$procedures, isLegalName$$module$build$src$core$procedures, isNameUsed$$module$build$src$core$procedures, xmlFlyoutCategory$$module$build$src$core$procedures, internalFlyoutCategory$$module$build$src$core$procedures, flyoutCategory$$module$build$src$core$procedures, updateMutatorFlyout$$module$build$src$core$procedures, mutatorOpenListener$$module$build$src$core$procedures, mutatorChangeListener$$module$build$src$core$procedures, getCallers$$module$build$src$core$procedures, blockIsModernCallerFor$$module$build$src$core$procedures, isDynamicShape$$module$build$src$core$renderers$common$constants, isPuzzleTab$$module$build$src$core$renderers$common$constants, isNotch$$module$build$src$core$renderers$common$constants, register$$module$build$src$core$renderers$common$block_rendering, unregister$$module$build$src$core$renderers$common$block_rendering, init$$module$build$src$core$renderers$common$block_rendering, stringButtonClickHandler$$module$build$src$core$variables_dynamic, numberButtonClickHandler$$module$build$src$core$variables_dynamic, colourButtonClickHandler$$module$build$src$core$variables_dynamic, internalFlyoutCategory$$module$build$src$core$variables_dynamic, flyoutCategory$$module$build$src$core$variables_dynamic, xmlFlyoutCategory$$module$build$src$core$variables_dynamic, flyoutCategoryBlocks$$module$build$src$core$variables_dynamic, resizeSvgContents$$module$build$src$core$workspace_svg, copy$$module$build$src$core$clipboard, getLastCopiedData$$module$build$src$core$clipboard, setLastCopiedData$$module$build$src$core$clipboard, getLastCopiedWorkspace$$module$build$src$core$clipboard, setLastCopiedWorkspace$$module$build$src$core$clipboard, getLastCopiedLocation$$module$build$src$core$clipboard, setLastCopiedLocation$$module$build$src$core$clipboard, paste$$module$build$src$core$clipboard, pasteFromData$$module$build$src$core$clipboard, isCopyable$$module$build$src$core$interfaces$i_copyable, registerEscape$$module$build$src$core$shortcut_items, registerDelete$$module$build$src$core$shortcut_items, isCopyable$$module$build$src$core$shortcut_items, isCuttable$$module$build$src$core$shortcut_items, registerCopy$$module$build$src$core$shortcut_items, registerCut$$module$build$src$core$shortcut_items, registerPaste$$module$build$src$core$shortcut_items, registerUndo$$module$build$src$core$shortcut_items, registerRedo$$module$build$src$core$shortcut_items, registerDefaultShortcuts$$module$build$src$core$shortcut_items, saveProcedure$$module$build$src$core$serialization$procedures, loadProcedure$$module$build$src$core$serialization$procedures, save$$module$build$src$core$serialization$workspaces, load$$module$build$src$core$serialization$workspaces, inject$$module$build$src$core$inject, createDom$$module$build$src$core$inject, createMainWorkspace$$module$build$src$core$inject, init$$module$build$src$core$inject, bindDocumentEvents$$module$build$src$core$inject, loadSounds$$module$build$src$core$inject, isFullBlockField$$module$build$src$core$contextmenu_items, registerUndo$$module$build$src$core$contextmenu_items, registerRedo$$module$build$src$core$contextmenu_items, registerCleanup$$module$build$src$core$contextmenu_items, toggleOption_$$module$build$src$core$contextmenu_items, registerCollapse$$module$build$src$core$contextmenu_items, registerExpand$$module$build$src$core$contextmenu_items, addDeletableBlocks_$$module$build$src$core$contextmenu_items, getDeletableBlocks_$$module$build$src$core$contextmenu_items, deleteNext_$$module$build$src$core$contextmenu_items, registerDeleteAll$$module$build$src$core$contextmenu_items, registerWorkspaceOptions_$$module$build$src$core$contextmenu_items, registerDuplicate$$module$build$src$core$contextmenu_items, registerComment$$module$build$src$core$contextmenu_items, registerInline$$module$build$src$core$contextmenu_items, registerCollapseExpandBlock$$module$build$src$core$contextmenu_items, registerDisable$$module$build$src$core$contextmenu_items, registerDelete$$module$build$src$core$contextmenu_items, registerHelp$$module$build$src$core$contextmenu_items, registerCommentDelete$$module$build$src$core$contextmenu_items, registerCommentDuplicate$$module$build$src$core$contextmenu_items, registerCommentCreate$$module$build$src$core$contextmenu_items, registerBlockOptions_$$module$build$src$core$contextmenu_items, registerCommentOptions$$module$build$src$core$contextmenu_items, registerDefaultOptions$$module$build$src$core$contextmenu_items, isPaster$$module$build$src$core$interfaces$i_paster, isRenderedElement$$module$build$src$core$interfaces$i_rendered_element, isSelectableToolboxItem$$module$build$src$core$interfaces$i_selectable_toolbox_item, hideChaff$$module$build$src$core$blockly, isFocusableTree$$module$build$src$core$interfaces$i_focusable_tree, $jscomp;
          register$$module$build$src$core$registry = function(a, b, c, d) {
            if (!(a instanceof Type$$module$build$src$core$registry) && typeof a !== "string" || `${a}`.trim() === "") throw Error('Invalid type "' + a + '". The type must be a non-empty string or a Blockly.registry.Type.');
            a = `${a}`.toLowerCase();
            if (typeof b !== "string" || b.trim() === "") throw Error('Invalid name "' + b + '". The name must be a non-empty string.');
            const e = b.toLowerCase();
            if (!c) throw Error("Can not register a null value");
            let f = typeMap$$module$build$src$core$registry[a], g = nameMap$$module$build$src$core$registry[a];
            f || (f = typeMap$$module$build$src$core$registry[a] = /* @__PURE__ */ Object.create(null), g = nameMap$$module$build$src$core$registry[a] = /* @__PURE__ */ Object.create(null));
            validate$$module$build$src$core$registry(a, c);
            if (!d && f[e] && f[e] !== c) throw Error('Name "' + e + '" with type "' + a + '" already registered.');
            f[e] = c;
            g[e] = b;
          };
          validate$$module$build$src$core$registry = function(a, b) {
            switch (a) {
              case String(Type$$module$build$src$core$registry.FIELD):
                if (typeof b.fromJson !== "function") throw Error('Type "' + a + '" must have a fromJson function');
            }
          };
          unregister$$module$build$src$core$registry = function(a, b) {
            a = `${a}`.toLowerCase();
            b = b.toLowerCase();
            const c = typeMap$$module$build$src$core$registry[a];
            c && c[b] ? (delete typeMap$$module$build$src$core$registry[a][b], delete nameMap$$module$build$src$core$registry[a][b]) : console.warn("Unable to unregister [" + b + "][" + a + "] from the registry.");
          };
          getItem$$module$build$src$core$registry = function(a, b, c) {
            a = `${a}`.toLowerCase();
            b = b.toLowerCase();
            const d = typeMap$$module$build$src$core$registry[a];
            if (!d || !d[b]) {
              b = "Unable to find [" + b + "][" + a + "] in the registry.";
              if (c) throw Error(b + " You must require or register a " + a + " plugin.");
              console.warn(b);
              return null;
            }
            return d[b];
          };
          hasItem$$module$build$src$core$registry = function(a, b) {
            a = `${a}`.toLowerCase();
            b = b.toLowerCase();
            return (a = typeMap$$module$build$src$core$registry[a]) ? !!a[b] : false;
          };
          getClass$$module$build$src$core$registry = function(a, b, c) {
            return getItem$$module$build$src$core$registry(a, b, c);
          };
          getObject$$module$build$src$core$registry = function(a, b, c) {
            return getItem$$module$build$src$core$registry(a, b, c);
          };
          getAllItems$$module$build$src$core$registry = function(a, b, c) {
            a = `${a}`.toLowerCase();
            var d = typeMap$$module$build$src$core$registry[a];
            if (!d) {
              d = `Unable to find [${a}] in the registry.`;
              if (c) throw Error(`${d} You must require or register a ${a} plugin.`);
              console.warn(d);
              return null;
            }
            if (!b) return d;
            a = nameMap$$module$build$src$core$registry[a];
            c = /* @__PURE__ */ Object.create(null);
            for (const e of Object.keys(d)) c[a[e]] = d[e];
            return c;
          };
          getClassFromOptions$$module$build$src$core$registry = function(a, b, c) {
            b = b.plugins[String(a)] || DEFAULT$$module$build$src$core$registry;
            return typeof b === "function" ? b : getClass$$module$build$src$core$registry(a, b, c);
          };
          longStart$$module$build$src$core$touch = function(a, b) {
            longStop$$module$build$src$core$touch();
            longPid_$$module$build$src$core$touch = setTimeout(function() {
              b && b.handleRightClick(a);
            }, LONGPRESS$$module$build$src$core$touch);
          };
          longStop$$module$build$src$core$touch = function() {
            longPid_$$module$build$src$core$touch && (clearTimeout(longPid_$$module$build$src$core$touch), longPid_$$module$build$src$core$touch = 0);
          };
          clearTouchIdentifier$$module$build$src$core$touch = function() {
            touchIdentifier_$$module$build$src$core$touch = null;
          };
          shouldHandleEvent$$module$build$src$core$touch = function(a) {
            return !a.type.startsWith("pointer") || a instanceof PointerEvent && checkTouchIdentifier$$module$build$src$core$touch(a);
          };
          getTouchIdentifierFromEvent$$module$build$src$core$touch = function(a) {
            return `${a.pointerId}`;
          };
          checkTouchIdentifier$$module$build$src$core$touch = function(a) {
            const b = getTouchIdentifierFromEvent$$module$build$src$core$touch(a);
            return touchIdentifier_$$module$build$src$core$touch ? touchIdentifier_$$module$build$src$core$touch === b : a.type === "pointerdown" ? (touchIdentifier_$$module$build$src$core$touch = b, true) : false;
          };
          conditionalBind$$module$build$src$core$browser_events = function(a, b, c, d, e) {
            function f(h) {
              if (e || shouldHandleEvent$$module$build$src$core$touch(h)) c ? d.call(c, h) : d(h);
            }
            const g = [];
            if (b in TOUCH_MAP$$module$build$src$core$touch) for (let h = 0; h < TOUCH_MAP$$module$build$src$core$touch[b].length; h++) {
              const k = TOUCH_MAP$$module$build$src$core$touch[b][h];
              a.addEventListener(k, f, false);
              g.push([a, k, f]);
            }
            else a.addEventListener(b, f, false), g.push([a, b, f]);
            return g;
          };
          bind$$module$build$src$core$browser_events = function(a, b, c, d) {
            function e(g) {
              c ? d.call(c, g) : d(g);
            }
            const f = [];
            if (b in TOUCH_MAP$$module$build$src$core$touch) for (let g = 0; g < TOUCH_MAP$$module$build$src$core$touch[b].length; g++) {
              const h = TOUCH_MAP$$module$build$src$core$touch[b][g];
              a.addEventListener(h, e, false);
              f.push([a, h, e]);
            }
            else a.addEventListener(b, e, false), f.push([a, b, e]);
            return f;
          };
          unbind$$module$build$src$core$browser_events = function(a) {
            const b = a[a.length - 1][2];
            for (; a.length; ) {
              const [c, d, e] = a.pop();
              c.removeEventListener(d, e, false);
            }
            return b;
          };
          isTargetInput$$module$build$src$core$browser_events = function(a) {
            if (a.target instanceof HTMLElement) {
              if (a.target.isContentEditable || a.target.getAttribute("data-is-text-input") === "true") return true;
              if (a.target instanceof HTMLInputElement) return a = a.target, a.type === "text" || a.type === "number" || a.type === "email" || a.type === "password" || a.type === "search" || a.type === "tel" || a.type === "url";
              if (a.target instanceof HTMLTextAreaElement) return true;
            }
            return false;
          };
          isRightButton$$module$build$src$core$browser_events = function(a) {
            return a.ctrlKey && MAC$$module$build$src$core$utils$useragent ? true : a.button === 2;
          };
          mouseToSvg$$module$build$src$core$browser_events = function(a, b, c) {
            const d = b.createSVGPoint();
            d.x = a.clientX;
            d.y = a.clientY;
            c || (c = b.getScreenCTM().inverse());
            return d.matrixTransform(c);
          };
          getScrollDeltaPixels$$module$build$src$core$browser_events = function(a) {
            switch (a.deltaMode) {
              default:
                return { x: a.deltaX, y: a.deltaY };
              case 1:
                return { x: a.deltaX * LINE_MODE_MULTIPLIER$$module$build$src$core$browser_events, y: a.deltaY * LINE_MODE_MULTIPLIER$$module$build$src$core$browser_events };
              case 2:
                return { x: a.deltaX * PAGE_MODE_MULTIPLIER$$module$build$src$core$browser_events, y: a.deltaY * PAGE_MODE_MULTIPLIER$$module$build$src$core$browser_events };
            }
          };
          getNextUniqueId$$module$build$src$core$utils$idgenerator = function() {
            return "blockly-" + (nextId$$module$build$src$core$utils$idgenerator++).toString(36);
          };
          genUid$$module$build$src$core$utils$idgenerator = function() {
            return internal$$module$build$src$core$utils$idgenerator.genUid();
          };
          isBlockCreate$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_CREATE;
          };
          isBlockDelete$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_DELETE;
          };
          isBlockChange$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_CHANGE;
          };
          isBlockFieldIntermediateChange$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE;
          };
          isBlockMove$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_MOVE;
          };
          isVarCreate$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.VAR_CREATE;
          };
          isVarDelete$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.VAR_DELETE;
          };
          isVarRename$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.VAR_RENAME;
          };
          isBlockDrag$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BLOCK_DRAG;
          };
          isSelected$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.SELECTED;
          };
          isClick$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.CLICK;
          };
          isBubbleOpen$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.BUBBLE_OPEN;
          };
          isTrashcanOpen$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.TRASHCAN_OPEN;
          };
          isToolboxItemSelect$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.TOOLBOX_ITEM_SELECT;
          };
          isThemeChange$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.THEME_CHANGE;
          };
          isViewportChange$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.VIEWPORT_CHANGE;
          };
          isCommentCreate$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_CREATE;
          };
          isCommentDelete$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_DELETE;
          };
          isCommentChange$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_CHANGE;
          };
          isCommentMove$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_MOVE;
          };
          isCommentResize$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_RESIZE;
          };
          isCommentDrag$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_DRAG;
          };
          isCommentCollapse$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.COMMENT_COLLAPSE;
          };
          isFinishedLoading$$module$build$src$core$events$predicates = function(a) {
            return a.type === EventType$$module$build$src$core$events$type.FINISHED_LOADING;
          };
          $.setRecordUndo$$module$build$src$core$events$utils = function(a) {
            recordUndo$$module$build$src$core$events$utils = a;
          };
          getRecordUndo$$module$build$src$core$events$utils = function() {
            return recordUndo$$module$build$src$core$events$utils;
          };
          fire$$module$build$src$core$events$utils = function(a) {
            TEST_ONLY$$module$build$src$core$events$utils.fireInternal(a);
          };
          fireInternal$$module$build$src$core$events$utils = function(a) {
            if (isEnabled$$module$build$src$core$events$utils()) {
              if (!FIRE_QUEUE$$module$build$src$core$events$utils.length) try {
                requestAnimationFrame(() => {
                  setTimeout(fireNow$$module$build$src$core$events$utils, 0);
                });
              } catch (b) {
                setTimeout(fireNow$$module$build$src$core$events$utils, 0);
              }
              enqueueEvent$$module$build$src$core$events$utils(a);
            }
          };
          fireNow$$module$build$src$core$events$utils = function() {
            const a = filter$$module$build$src$core$events$utils(FIRE_QUEUE$$module$build$src$core$events$utils);
            FIRE_QUEUE$$module$build$src$core$events$utils.length = 0;
            for (const b of a) {
              if (!b.workspaceId) continue;
              let c;
              (c = getWorkspaceById$$module$build$src$core$common(b.workspaceId)) == null || c.fireChangeListener(b);
            }
          };
          enqueueEvent$$module$build$src$core$events$utils = function(a) {
            if (isBlockChange$$module$build$src$core$events$predicates(a) && a.element === "mutation") {
              let b;
              for (b = FIRE_QUEUE$$module$build$src$core$events$utils.length; b > 0; b--) {
                const c = FIRE_QUEUE$$module$build$src$core$events$utils[b - 1];
                if (c.group !== a.group || c.workspaceId !== a.workspaceId || !isBlockMove$$module$build$src$core$events$predicates(c) || c.newParentId !== a.blockId) break;
              }
              FIRE_QUEUE$$module$build$src$core$events$utils.splice(b, 0, a);
            } else FIRE_QUEUE$$module$build$src$core$events$utils.push(a);
          };
          filter$$module$build$src$core$events$utils = function(a) {
            const b = [];
            for (const c of a) if (a = b[b.length - 1], !c.isNull()) if (a && a.workspaceId === c.workspaceId && a.group === c.group) if (isBlockMove$$module$build$src$core$events$predicates(c) && isBlockMove$$module$build$src$core$events$predicates(a) && c.blockId === a.blockId) {
              if (a.newParentId = c.newParentId, a.newInputName = c.newInputName, a.newCoordinate = c.newCoordinate, a.reason || c.reason) {
                let d, e;
                a.reason = Array.from(new Set(((d = a.reason) != null ? d : []).concat((e = c.reason) != null ? e : [])));
              }
            } else isBlockChange$$module$build$src$core$events$predicates(c) && isBlockChange$$module$build$src$core$events$predicates(a) && c.blockId === a.blockId && c.element === a.element && c.name === a.name ? a.newValue = c.newValue : isViewportChange$$module$build$src$core$events$predicates(c) && isViewportChange$$module$build$src$core$events$predicates(a) ? (a.viewTop = c.viewTop, a.viewLeft = c.viewLeft, a.scale = c.scale, a.oldScale = c.oldScale) : isClick$$module$build$src$core$events$predicates(c) && isBubbleOpen$$module$build$src$core$events$predicates(a) || b.push(c);
            else b.push(c);
            return a = b.filter((c) => !c.isNull());
          };
          clearPendingUndo$$module$build$src$core$events$utils = function() {
            for (let a = 0, b; b = FIRE_QUEUE$$module$build$src$core$events$utils[a]; a++) b.recordUndo = false;
          };
          $.disable$$module$build$src$core$events$utils = function() {
            disabled$$module$build$src$core$events$utils++;
          };
          $.enable$$module$build$src$core$events$utils = function() {
            disabled$$module$build$src$core$events$utils--;
          };
          isEnabled$$module$build$src$core$events$utils = function() {
            return disabled$$module$build$src$core$events$utils === 0;
          };
          $.getGroup$$module$build$src$core$events$utils = function() {
            return group$$module$build$src$core$events$utils;
          };
          $.setGroup$$module$build$src$core$events$utils = function(a) {
            TEST_ONLY$$module$build$src$core$events$utils.setGroupInternal(a);
          };
          setGroupInternal$$module$build$src$core$events$utils = function(a) {
            group$$module$build$src$core$events$utils = typeof a === "boolean" ? a ? genUid$$module$build$src$core$utils$idgenerator() : "" : a;
          };
          getDescendantIds$$module$build$src$core$events$utils = function(a) {
            const b = [];
            a = a.getDescendants(false);
            for (let c = 0, d; d = a[c]; c++) b[c] = d.id;
            return b;
          };
          fromJson$$module$build$src$core$events$utils = function(a, b) {
            const c = get$$module$build$src$core$events$utils(a.type);
            if (!c) throw Error("Unknown event type.");
            return c.fromJson(a, b);
          };
          get$$module$build$src$core$events$utils = function(a) {
            const b = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, a);
            if (!b) throw Error(`Event type ${a} not found in registry.`);
            return b;
          };
          disableOrphans$$module$build$src$core$events$utils = function(a) {
            if ((isBlockMove$$module$build$src$core$events$predicates(a) || isBlockCreate$$module$build$src$core$events$predicates(a)) && a.workspaceId) {
              var b = getWorkspaceById$$module$build$src$core$common(a.workspaceId);
              if (!a.blockId) throw Error("Encountered a blockEvent without a proper blockId");
              if (a = b.getBlockById(a.blockId)) {
                const c = recordUndo$$module$build$src$core$events$utils;
                try {
                  recordUndo$$module$build$src$core$events$utils = false;
                  const d = a.getParent();
                  if (d && !d.hasDisabledReason(ORPHANED_BLOCK_DISABLED_REASON$$module$build$src$core$events$utils)) {
                    const e = a.getDescendants(false);
                    for (let f = 0, g; g = e[f]; f++) g.setDisabledReason(false, ORPHANED_BLOCK_DISABLED_REASON$$module$build$src$core$events$utils);
                  } else if ((a.outputConnection || a.previousConnection) && !b.isDragging()) {
                    do
                      a.setDisabledReason(true, ORPHANED_BLOCK_DISABLED_REASON$$module$build$src$core$events$utils), a = a.getNextBlock();
                    while (a);
                  }
                } finally {
                  recordUndo$$module$build$src$core$events$utils = c;
                }
              }
            }
          };
          createSvgElement$$module$build$src$core$utils$dom = function(a, b, c) {
            a = document.createElementNS(SVG_NS$$module$build$src$core$utils$dom, `${a}`);
            for (const d in b) a.setAttribute(d, `${b[d]}`);
            c && c.appendChild(a);
            return a;
          };
          addClass$$module$build$src$core$utils$dom = function(a, b) {
            b = b.split(" ");
            if (b.every((c) => a.classList.contains(c))) return false;
            a.classList.add(...b);
            return true;
          };
          removeClasses$$module$build$src$core$utils$dom = function(a, b) {
            a.classList.remove(...b.split(" "));
          };
          removeClass$$module$build$src$core$utils$dom = function(a, b) {
            b = b.split(" ");
            if (b.every((c) => !a.classList.contains(c))) return false;
            a.classList.remove(...b);
            return true;
          };
          hasClass$$module$build$src$core$utils$dom = function(a, b) {
            return a.classList.contains(b);
          };
          removeNode$$module$build$src$core$utils$dom = function(a) {
            return a && a.parentNode ? a.parentNode.removeChild(a) : null;
          };
          insertAfter$$module$build$src$core$utils$dom = function(a, b) {
            const c = b.nextSibling;
            b = b.parentNode;
            if (!b) throw Error("Reference node has no parent.");
            c ? b.insertBefore(a, c) : b.appendChild(a);
          };
          setCssTransform$$module$build$src$core$utils$dom = function(a, b) {
            a.style.transform = b;
            a.style["-webkit-transform"] = b;
          };
          startTextWidthCache$$module$build$src$core$utils$dom = function() {
            cacheReference$$module$build$src$core$utils$dom++;
            cacheWidths$$module$build$src$core$utils$dom || (cacheWidths$$module$build$src$core$utils$dom = /* @__PURE__ */ Object.create(null));
          };
          stopTextWidthCache$$module$build$src$core$utils$dom = function() {
            cacheReference$$module$build$src$core$utils$dom--;
            cacheReference$$module$build$src$core$utils$dom || (cacheWidths$$module$build$src$core$utils$dom = null);
          };
          getTextWidth$$module$build$src$core$utils$dom = function(a) {
            const b = a.textContent + "\n" + a.className.baseVal;
            var c;
            if (cacheWidths$$module$build$src$core$utils$dom && (c = cacheWidths$$module$build$src$core$utils$dom[b])) return c;
            c = window.getComputedStyle(a);
            c = getFastTextWidthWithSizeString$$module$build$src$core$utils$dom(a, c.fontSize, c.fontWeight, c.fontFamily);
            cacheWidths$$module$build$src$core$utils$dom && (cacheWidths$$module$build$src$core$utils$dom[b] = c);
            return c;
          };
          getFastTextWidth$$module$build$src$core$utils$dom = function(a, b, c, d) {
            return getFastTextWidthWithSizeString$$module$build$src$core$utils$dom(a, b + "pt", c, d);
          };
          getFastTextWidthWithSizeString$$module$build$src$core$utils$dom = function(a, b, c, d) {
            const e = a.textContent;
            a = e + "\n" + a.className.baseVal;
            var f;
            if (cacheWidths$$module$build$src$core$utils$dom && (f = cacheWidths$$module$build$src$core$utils$dom[a])) return f;
            canvasContext$$module$build$src$core$utils$dom || (f = document.createElement("canvas"), f.className = "blocklyComputeCanvas", document.body.appendChild(f), canvasContext$$module$build$src$core$utils$dom = f.getContext("2d"));
            e && canvasContext$$module$build$src$core$utils$dom ? (canvasContext$$module$build$src$core$utils$dom.font = c + " " + b + " " + d, f = canvasContext$$module$build$src$core$utils$dom.measureText(e).width) : f = 0;
            cacheWidths$$module$build$src$core$utils$dom && (cacheWidths$$module$build$src$core$utils$dom[a] = f);
            return f;
          };
          measureFontMetrics$$module$build$src$core$utils$dom = function(a, b, c, d) {
            const e = document.createElement("span");
            e.style.font = c + " " + b + " " + d;
            e.textContent = a;
            a = document.createElement("div");
            a.style.width = "1px";
            a.style.height = "0";
            b = document.createElement("div");
            b.style.display = "flex";
            b.style.position = "fixed";
            b.style.top = "0";
            b.style.left = "0";
            b.appendChild(e);
            b.appendChild(a);
            document.body.appendChild(b);
            c = { height: 0, baseline: 0 };
            try {
              b.style.alignItems = "baseline", c.baseline = a.offsetTop - e.offsetTop, b.style.alignItems = "flex-end", c.height = a.offsetTop - e.offsetTop;
            } finally {
              document.body.removeChild(b);
            }
            return c;
          };
          $.getFocusManager$$module$build$src$core$focus_manager = function() {
            return FocusManager$$module$build$src$core$focus_manager.getFocusManager();
          };
          isFocusableNode$$module$build$src$core$interfaces$i_focusable_node = function(a) {
            return a && typeof a.getFocusableElement === "function" && typeof a.getFocusableTree === "function" && typeof a.onNodeFocus === "function" && typeof a.onNodeBlur === "function" && typeof a.canBeFocused === "function";
          };
          isSelectable$$module$build$src$core$interfaces$i_selectable = function(a) {
            return isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(a) && typeof a.id === "string" && typeof a.workspace === "object" && typeof a.select === "function" && typeof a.unselect === "function";
          };
          deepMerge$$module$build$src$core$utils$object = function(a, b) {
            for (const c in b) b[c] !== null && Array.isArray(b[c]) ? a[c] = deepMerge$$module$build$src$core$utils$object(a[c] || [], b[c]) : a[c] = b[c] !== null && typeof b[c] === "object" ? deepMerge$$module$build$src$core$utils$object(a[c] || /* @__PURE__ */ Object.create(null), b[c]) : b[c];
            return a;
          };
          getWorkspaceById$$module$build$src$core$common = function(a) {
            return WorkspaceDB_$$module$build$src$core$common[a] || null;
          };
          getAllWorkspaces$$module$build$src$core$common = function() {
            const a = [];
            for (const b in WorkspaceDB_$$module$build$src$core$common) a.push(WorkspaceDB_$$module$build$src$core$common[b]);
            return a;
          };
          registerWorkspace$$module$build$src$core$common = function(a) {
            WorkspaceDB_$$module$build$src$core$common[a.id] = a;
          };
          unregisterWorkpace$$module$build$src$core$common = function(a) {
            delete WorkspaceDB_$$module$build$src$core$common[a.id];
          };
          getMainWorkspace$$module$build$src$core$common = function() {
            return mainWorkspace$$module$build$src$core$common;
          };
          setMainWorkspace$$module$build$src$core$common = function(a) {
            mainWorkspace$$module$build$src$core$common = a;
          };
          getSelected$$module$build$src$core$common = function() {
            const a = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode();
            return a && isSelectable$$module$build$src$core$interfaces$i_selectable(a) ? a : null;
          };
          setSelected$$module$build$src$core$common = function(a) {
            $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a);
          };
          fireSelectedEvent$$module$build$src$core$common = function(a) {
            const b = getSelected$$module$build$src$core$common();
            let c, d, e, f;
            const g = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.SELECTED))((c = b == null ? void 0 : b.id) != null ? c : null, (d = a == null ? void 0 : a.id) != null ? d : null, (f = (e = a == null ? void 0 : a.workspace.id) != null ? e : b == null ? void 0 : b.workspace.id) != null ? f : "");
            fire$$module$build$src$core$events$utils(g);
          };
          getParentContainer$$module$build$src$core$common = function() {
            return parentContainer$$module$build$src$core$common;
          };
          setParentContainer$$module$build$src$core$common = function(a) {
            parentContainer$$module$build$src$core$common = a;
          };
          svgResize$$module$build$src$core$common = function(a) {
            for (; a.options.parentWorkspace; ) a = a.options.parentWorkspace;
            const b = a.getParentSvg(), c = a.getCachedParentSvgSize();
            var d = b.parentElement;
            if (d instanceof HTMLElement) {
              var e = d.offsetWidth;
              d = d.offsetHeight;
              c.width !== e && (b.setAttribute("width", e + "px"), a.setCachedParentSvgSize(e, null));
              c.height !== d && (b.setAttribute("height", d + "px"), a.setCachedParentSvgSize(null, d));
              a.resize();
            }
          };
          getBlockTypeCounts$$module$build$src$core$common = function(a, b) {
            const c = /* @__PURE__ */ Object.create(null), d = a.getDescendants(true);
            b && (a = a.getNextBlock()) && (a = d.indexOf(a), d.splice(a, d.length - a));
            for (let e = 0, f; f = d[e]; e++) c[f.type] ? c[f.type]++ : c[f.type] = 1;
            return c;
          };
          jsonInitFactory$$module$build$src$core$common = function(a) {
            return function() {
              this.jsonInit(a);
            };
          };
          defineBlocksWithJsonArray$$module$build$src$core$common = function(a) {
            TEST_ONLY$$module$build$src$core$common.defineBlocksWithJsonArrayInternal(a);
          };
          defineBlocksWithJsonArrayInternal$$module$build$src$core$common = function(a) {
            $.defineBlocks$$module$build$src$core$common($.createBlockDefinitionsFromJsonArray$$module$build$src$core$common(a));
          };
          $.createBlockDefinitionsFromJsonArray$$module$build$src$core$common = function(a) {
            const b = {};
            for (let c = 0; c < a.length; c++) {
              const d = a[c];
              if (!d) {
                console.warn(`Block definition #${c} in JSON array is ${d}. Skipping`);
                continue;
              }
              const e = d.type;
              e ? b[e] = { init: jsonInitFactory$$module$build$src$core$common(d) } : console.warn(`Block definition #${c} in JSON array is missing a type attribute. Skipping.`);
            }
            return b;
          };
          $.defineBlocks$$module$build$src$core$common = function(a) {
            for (const b of Object.keys(a)) {
              const c = a[b];
              b in Blocks$$module$build$src$core$blocks && console.warn(`Block definition "${b}" overwrites previous definition.`);
              Blocks$$module$build$src$core$blocks[b] = c;
            }
          };
          globalShortcutHandler$$module$build$src$core$common = function(a) {
            let b = getMainWorkspace$$module$build$src$core$common();
            const c = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedTree();
            for (const d of getAllWorkspaces$$module$build$src$core$common()) if (c === d) {
              b = d;
              break;
            }
            if (!isTargetInput$$module$build$src$core$browser_events(a) && b && (!b.rendered || b.isFlyout || b.isVisible())) ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.onKeyDown(b, a);
          };
          removeElem$$module$build$src$core$utils$array = function(a, b) {
            b = a.indexOf(b);
            if (b === -1) return false;
            a.splice(b, 1);
            return true;
          };
          register$$module$build$src$core$css = function(a) {
            if (injected$$module$build$src$core$css) throw Error("CSS already injected");
            content$$module$build$src$core$css += "\n" + a;
          };
          inject$$module$build$src$core$css = function(a, b) {
            injected$$module$build$src$core$css || (injected$$module$build$src$core$css = true, a && (a = b.replace(/[\\/]$/, ""), b = content$$module$build$src$core$css.replace(/<<<PATH>>>/g, a), content$$module$build$src$core$css = "", a = document.createElement("style"), a.id = "blockly-common-style", b = document.createTextNode(b), a.appendChild(b), document.head.insertBefore(a, document.head.firstChild)));
          };
          getSize$$module$build$src$core$utils$style = function(a) {
            return TEST_ONLY$$module$build$src$core$utils$style.getSizeInternal(a);
          };
          getSizeInternal$$module$build$src$core$utils$style = function(a) {
            if (getComputedStyle$$module$build$src$core$utils$style(a, "display") !== "none") return getSizeWithDisplay$$module$build$src$core$utils$style(a);
            const b = a.style, c = b.display, d = b.visibility, e = b.position;
            b.visibility = "hidden";
            b.position = "absolute";
            b.display = "inline";
            const f = a.offsetWidth;
            a = a.offsetHeight;
            b.display = c;
            b.position = e;
            b.visibility = d;
            return new Size$$module$build$src$core$utils$size(f, a);
          };
          getSizeWithDisplay$$module$build$src$core$utils$style = function(a) {
            return new Size$$module$build$src$core$utils$size(a.offsetWidth, a.offsetHeight);
          };
          getComputedStyle$$module$build$src$core$utils$style = function(a, b) {
            a = window.getComputedStyle(a);
            return a[b] || a.getPropertyValue(b);
          };
          getPageOffset$$module$build$src$core$utils$style = function(a) {
            const b = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
            a = a.getBoundingClientRect();
            var c = document.documentElement;
            c = new Coordinate$$module$build$src$core$utils$coordinate(window.pageXOffset || c.scrollLeft, window.pageYOffset || c.scrollTop);
            b.x = a.left + c.x;
            b.y = a.top + c.y;
            return b;
          };
          getViewportPageOffset$$module$build$src$core$utils$style = function() {
            const a = document.body, b = document.documentElement;
            return new Coordinate$$module$build$src$core$utils$coordinate(a.scrollLeft || b.scrollLeft, a.scrollTop || b.scrollTop);
          };
          getBorderBox$$module$build$src$core$utils$style = function(a) {
            const b = parseFloat(getComputedStyle$$module$build$src$core$utils$style(a, "borderLeftWidth")), c = parseFloat(getComputedStyle$$module$build$src$core$utils$style(a, "borderRightWidth")), d = parseFloat(getComputedStyle$$module$build$src$core$utils$style(a, "borderTopWidth"));
            a = parseFloat(getComputedStyle$$module$build$src$core$utils$style(a, "borderBottomWidth"));
            return new Rect$$module$build$src$core$utils$rect(d, a, b, c);
          };
          scrollIntoContainerView$$module$build$src$core$utils$style = function(a, b, c) {
            a = getContainerOffsetToScrollInto$$module$build$src$core$utils$style(a, b, c);
            b.scrollLeft = a.x;
            b.scrollTop = a.y;
          };
          getContainerOffsetToScrollInto$$module$build$src$core$utils$style = function(a, b, c) {
            var d = getPageOffset$$module$build$src$core$utils$style(a), e = getPageOffset$$module$build$src$core$utils$style(b), f = getBorderBox$$module$build$src$core$utils$style(b);
            const g = d.x - e.x - f.left;
            d = d.y - e.y - f.top;
            e = getSizeWithDisplay$$module$build$src$core$utils$style(a);
            a = b.clientWidth - e.width;
            e = b.clientHeight - e.height;
            f = b.scrollLeft;
            b = b.scrollTop;
            c ? (f += g - a / 2, b += d - e / 2) : (f += Math.min(g, Math.max(g - a, 0)), b += Math.min(d, Math.max(d - e, 0)));
            return new Coordinate$$module$build$src$core$utils$coordinate(f, b);
          };
          getRelativeXY$$module$build$src$core$utils$svg_math = function(a) {
            const b = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
            var c = a.x && a.getAttribute("x");
            const d = a.y && a.getAttribute("y");
            c && (b.x = parseInt(c));
            d && (b.y = parseInt(d));
            if (c = (c = a.getAttribute("transform")) && c.match(XY_REGEX$$module$build$src$core$utils$svg_math)) b.x += Number(c[1]), c[3] && (b.y += Number(c[3]));
            (a = a.getAttribute("style")) && a.includes("translate") && (a = a.match(XY_STYLE_REGEX$$module$build$src$core$utils$svg_math)) && (b.x += Number(a[1]), a[3] && (b.y += Number(a[3])));
            return b;
          };
          getInjectionDivXY$$module$build$src$core$utils$svg_math = function(a) {
            let b = 0, c = 0;
            for (; a; ) {
              const d = getRelativeXY$$module$build$src$core$utils$svg_math(a);
              b += d.x;
              c += d.y;
              if ((" " + (a.getAttribute("class") || "") + " ").includes(" injectionDiv ")) break;
              a = a.parentNode;
            }
            return new Coordinate$$module$build$src$core$utils$coordinate(b, c);
          };
          getViewportBBox$$module$build$src$core$utils$svg_math = function() {
            const a = getViewportPageOffset$$module$build$src$core$utils$style();
            return new Rect$$module$build$src$core$utils$rect(a.y, document.documentElement.clientHeight + a.y, a.x, document.documentElement.clientWidth + a.x);
          };
          getDocumentScroll$$module$build$src$core$utils$svg_math = function() {
            const a = document.documentElement, b = window;
            return new Coordinate$$module$build$src$core$utils$coordinate(b.pageXOffset || a.scrollLeft, b.pageYOffset || a.scrollTop);
          };
          screenToWsCoordinates$$module$build$src$core$utils$svg_math = function(a, b) {
            var c = b.x;
            b = b.y;
            const d = a.getInjectionDiv().getBoundingClientRect();
            c = new Coordinate$$module$build$src$core$utils$coordinate(c - d.left, b - d.top);
            b = a.getOriginOffsetInPixels();
            return Coordinate$$module$build$src$core$utils$coordinate.difference(c, b).scale(1 / a.scale);
          };
          wsToScreenCoordinates$$module$build$src$core$utils$svg_math = function(a, b) {
            var c = b.scale(a.scale);
            b = c.x;
            c = c.y;
            const d = a.getInjectionDiv().getBoundingClientRect();
            a = a.getOriginOffsetInPixels();
            return new Coordinate$$module$build$src$core$utils$coordinate(b + d.left + a.x, c + d.top + a.y);
          };
          injectDependencies$$module$build$src$core$utils$xml = function(a) {
            ({ document: document$$module$build$src$core$utils$xml = document$$module$build$src$core$utils$xml, DOMParser: DOMParser$$module$build$src$core$utils$xml = DOMParser$$module$build$src$core$utils$xml, XMLSerializer: XMLSerializer$$module$build$src$core$utils$xml = XMLSerializer$$module$build$src$core$utils$xml } = a);
            domParser$$module$build$src$core$utils$xml = new DOMParser$$module$build$src$core$utils$xml();
            xmlSerializer$$module$build$src$core$utils$xml = new XMLSerializer$$module$build$src$core$utils$xml();
          };
          $.createElement$$module$build$src$core$utils$xml = function(a) {
            return document$$module$build$src$core$utils$xml.createElementNS(NAME_SPACE$$module$build$src$core$utils$xml, a);
          };
          $.createTextNode$$module$build$src$core$utils$xml = function(a) {
            return document$$module$build$src$core$utils$xml.createTextNode(a);
          };
          $.textToDom$$module$build$src$core$utils$xml = function(a) {
            let b = domParser$$module$build$src$core$utils$xml.parseFromString(a, "text/xml");
            if (b && b.documentElement && !b.getElementsByTagName("parsererror").length) return b.documentElement;
            if ((b = domParser$$module$build$src$core$utils$xml.parseFromString(a, "text/html")) && b.body.firstChild && b.body.firstChild.nodeName.toLowerCase() === "xml") return b.body.firstChild;
            throw Error(`DOMParser was unable to parse: ${a}`);
          };
          domToText$$module$build$src$core$utils$xml = function(a) {
            return sanitizeText$$module$build$src$core$utils$xml(xmlSerializer$$module$build$src$core$utils$xml.serializeToString(a));
          };
          sanitizeText$$module$build$src$core$utils$xml = function(a) {
            return a.replace(INVALID_CONTROL_CHARS$$module$build$src$core$utils$xml, (b) => `&#${b.charCodeAt(0)};`);
          };
          convertToolboxDefToJson$$module$build$src$core$utils$toolbox = function(a) {
            if (!a) return null;
            if (a instanceof Element || typeof a === "string") a = parseToolboxTree$$module$build$src$core$utils$toolbox(a), a = convertToToolboxJson$$module$build$src$core$utils$toolbox(a);
            validateToolbox$$module$build$src$core$utils$toolbox(a);
            return a;
          };
          validateToolbox$$module$build$src$core$utils$toolbox = function(a) {
            const b = a.kind;
            a = a.contents;
            if (b && b !== FLYOUT_TOOLBOX_KIND$$module$build$src$core$utils$toolbox && b !== CATEGORY_TOOLBOX_KIND$$module$build$src$core$utils$toolbox) throw Error("Invalid toolbox kind " + b + ". Please supply either " + FLYOUT_TOOLBOX_KIND$$module$build$src$core$utils$toolbox + " or " + CATEGORY_TOOLBOX_KIND$$module$build$src$core$utils$toolbox);
            if (!a) throw Error("Toolbox must have a contents attribute.");
          };
          convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox = function(a) {
            return a ? a.contents ? a.contents : Array.isArray(a) && a.length > 0 && !a[0].nodeType ? a : xmlToJsonArray$$module$build$src$core$utils$toolbox(a) : [];
          };
          hasCategories$$module$build$src$core$utils$toolbox = function(a) {
            return TEST_ONLY$$module$build$src$core$utils$toolbox.hasCategoriesInternal(a);
          };
          hasCategoriesInternal$$module$build$src$core$utils$toolbox = function(a) {
            if (!a) return false;
            const b = a.kind;
            return b ? b === CATEGORY_TOOLBOX_KIND$$module$build$src$core$utils$toolbox : !!a.contents.filter((c) => c.kind.toUpperCase() === "CATEGORY").length;
          };
          isCategoryCollapsible$$module$build$src$core$utils$toolbox = function(a) {
            return a && a.contents ? !!a.contents.filter(function(b) {
              return b.kind.toUpperCase() === "CATEGORY";
            }).length : false;
          };
          convertToToolboxJson$$module$build$src$core$utils$toolbox = function(a) {
            const b = { contents: xmlToJsonArray$$module$build$src$core$utils$toolbox(a) };
            a instanceof Node && addAttributes$$module$build$src$core$utils$toolbox(a, b);
            return b;
          };
          xmlToJsonArray$$module$build$src$core$utils$toolbox = function(a) {
            const b = [];
            let c = a.childNodes;
            c || (c = a);
            for (let d = 0, e; e = c[d]; d++) {
              if (!e.tagName) continue;
              a = {};
              const f = e.tagName.toUpperCase();
              a.kind = f;
              f === "BLOCK" ? a.blockxml = e : e.childNodes && e.childNodes.length > 0 && (a.contents = xmlToJsonArray$$module$build$src$core$utils$toolbox(e));
              addAttributes$$module$build$src$core$utils$toolbox(e, a);
              b.push(a);
            }
            return b;
          };
          addAttributes$$module$build$src$core$utils$toolbox = function(a, b) {
            for (let c = 0; c < a.attributes.length; c++) {
              const d = a.attributes[c];
              d.nodeName.includes("css-") ? (b.cssconfig = b.cssconfig || {}, b.cssconfig[d.nodeName.replace("css-", "")] = d.value) : b[d.nodeName] = d.value;
            }
          };
          parseToolboxTree$$module$build$src$core$utils$toolbox = function(a) {
            let b = null;
            if (a) if (typeof a === "string") {
              if (b = $.textToDom$$module$build$src$core$utils$xml(a), b.nodeName.toLowerCase() !== "xml") throw TypeError("Toolbox should be an <xml> document.");
            } else a instanceof Element && (b = a);
            return b;
          };
          getStartPositionRect$$module$build$src$core$positionable_helpers = function(a, b, c, d, e, f) {
            const g = f.scrollbar && f.scrollbar.canScrollVertically();
            a.horizontal === horizontalPosition$$module$build$src$core$positionable_helpers.LEFT ? (c = e.absoluteMetrics.left + c, g && f.RTL && (c += Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness)) : (c = e.absoluteMetrics.left + e.viewMetrics.width - b.width - c, g && !f.RTL && (c -= Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness));
            a.vertical === verticalPosition$$module$build$src$core$positionable_helpers.TOP ? a = e.absoluteMetrics.top + d : (a = e.absoluteMetrics.top + e.viewMetrics.height - b.height - d, f.scrollbar && f.scrollbar.canScrollHorizontally() && (a -= Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness));
            return new Rect$$module$build$src$core$utils$rect(a, a + b.height, c, c + b.width);
          };
          getCornerOppositeToolbox$$module$build$src$core$positionable_helpers = function(a, b) {
            return { horizontal: b.toolboxMetrics.position === Position$$module$build$src$core$utils$toolbox.LEFT || a.horizontalLayout && !a.RTL ? horizontalPosition$$module$build$src$core$positionable_helpers.RIGHT : horizontalPosition$$module$build$src$core$positionable_helpers.LEFT, vertical: b.toolboxMetrics.position === Position$$module$build$src$core$utils$toolbox.BOTTOM ? verticalPosition$$module$build$src$core$positionable_helpers.TOP : verticalPosition$$module$build$src$core$positionable_helpers.BOTTOM };
          };
          bumpPositionRect$$module$build$src$core$positionable_helpers = function(a, b, c, d) {
            const e = a.left, f = a.right - a.left, g = a.bottom - a.top;
            for (let h = 0; h < d.length; h++) {
              const k = d[h];
              a.intersects(k) && (a = c === bumpDirection$$module$build$src$core$positionable_helpers.UP ? k.top - g - b : k.bottom + b, a = new Rect$$module$build$src$core$utils$rect(a, a + g, e, e + f), h = -1);
            }
            return a;
          };
          register$$module$build$src$core$serialization$registry = function(a, b) {
            register$$module$build$src$core$registry(Type$$module$build$src$core$registry.SERIALIZER, a, b);
          };
          unregister$$module$build$src$core$serialization$registry = function(a) {
            unregister$$module$build$src$core$registry(Type$$module$build$src$core$registry.SERIALIZER, a);
          };
          save$$module$build$src$core$serialization$workspace_comments = function(a, { addCoordinates: b = false, saveIds: c = true } = {}) {
            const d = a.workspace, e = /* @__PURE__ */ Object.create(null);
            e.height = a.getSize().height;
            e.width = a.getSize().width;
            c && (e.id = a.id);
            b && (b = a.getRelativeToSurfaceXY(), e.x = d.RTL ? d.getWidth() - b.x : b.x, e.y = b.y);
            a.getText() && (e.text = a.getText());
            a.isCollapsed() && (e.collapsed = true);
            a.isOwnEditable() || (e.editable = false);
            a.isOwnMovable() || (e.movable = false);
            a.isOwnDeletable() || (e.deletable = false);
            return e;
          };
          append$$module$build$src$core$serialization$workspace_comments = function(a, b, { recordUndo: c = false } = {}) {
            const d = getRecordUndo$$module$build$src$core$events$utils();
            $.setRecordUndo$$module$build$src$core$events$utils(c);
            c = b.newComment(a.id);
            a.text !== void 0 && c.setText(a.text);
            if (a.x !== void 0 || a.y !== void 0) {
              const f = c.getRelativeToSurfaceXY();
              let g, h = (g = a.x) != null ? g : f.x;
              h = b.RTL ? b.getWidth() - h : h;
              var e;
              b = (e = a.y) != null ? e : f.y;
              c.moveTo(new Coordinate$$module$build$src$core$utils$coordinate(h, b));
            }
            if (a.width !== void 0 || a.height) {
              e = c.getSize();
              let f, g;
              c.setSize(new Size$$module$build$src$core$utils$size((f = a.width) != null ? f : e.width, (g = a.height) != null ? g : e.height));
            }
            a.collapsed !== void 0 && c.setCollapsed(a.collapsed);
            a.editable !== void 0 && c.setEditable(a.editable);
            a.movable !== void 0 && c.setMovable(a.movable);
            a.deletable !== void 0 && c.setDeletable(a.deletable);
            $.setRecordUndo$$module$build$src$core$events$utils(d);
            return c;
          };
          register$$module$build$src$core$clipboard$registry = function(a, b) {
            register$$module$build$src$core$registry(Type$$module$build$src$core$registry.PASTER, a, b);
          };
          unregister$$module$build$src$core$clipboard$registry = function(a) {
            unregister$$module$build$src$core$registry(Type$$module$build$src$core$registry.PASTER, a);
          };
          moveCommentToNotConflict$$module$build$src$core$clipboard$workspace_comment_paster = function(a) {
            const b = a.workspace, c = a.getRelativeToSurfaceXY(), d = new Coordinate$$module$build$src$core$utils$coordinate(0, 0), e = b.getTopComments(false).filter((f) => f.id !== a.id).map((f) => f.getRelativeToSurfaceXY());
            for (; commentOverlapsOtherExactly$$module$build$src$core$clipboard$workspace_comment_paster(Coordinate$$module$build$src$core$utils$coordinate.sum(c, d), e); ) d.translate(b.RTL ? -30 : 30, 30);
            a.moveTo(Coordinate$$module$build$src$core$utils$coordinate.sum(
              c,
              d
            ));
          };
          commentOverlapsOtherExactly$$module$build$src$core$clipboard$workspace_comment_paster = function(a, b) {
            return b.some((c) => Math.abs(c.x - a.x) <= 1 && Math.abs(c.y - a.y) <= 1);
          };
          setRole$$module$build$src$core$utils$aria = function(a, b) {
            a.setAttribute(ROLE_ATTRIBUTE$$module$build$src$core$utils$aria, b);
          };
          setState$$module$build$src$core$utils$aria = function(a, b, c) {
            Array.isArray(c) && (c = c.join(" "));
            a.setAttribute(ARIA_PREFIX$$module$build$src$core$utils$aria + b, `${c}`);
          };
          isSerializable$$module$build$src$core$interfaces$i_serializable = function(a) {
            return a && typeof a.saveState === "function" && typeof a.loadState === "function";
          };
          queueRender$$module$build$src$core$render_management = function(a) {
            queueBlock$$module$build$src$core$render_management(a);
            if (alwaysImmediatelyRender$$module$build$src$core$render_management()) return doRenders$$module$build$src$core$render_management(), Promise.resolve();
            afterRendersPromise$$module$build$src$core$render_management || (afterRendersPromise$$module$build$src$core$render_management = new Promise((b) => {
              afterRendersResolver$$module$build$src$core$render_management = b;
              animationRequestId$$module$build$src$core$render_management = window.requestAnimationFrame(() => {
                doRenders$$module$build$src$core$render_management();
                b();
              });
            }));
            return afterRendersPromise$$module$build$src$core$render_management;
          };
          finishQueuedRenders$$module$build$src$core$render_management = function() {
            return afterRendersPromise$$module$build$src$core$render_management ? afterRendersPromise$$module$build$src$core$render_management : Promise.resolve();
          };
          triggerQueuedRenders$$module$build$src$core$render_management = function(a) {
            a || window.cancelAnimationFrame(animationRequestId$$module$build$src$core$render_management);
            doRenders$$module$build$src$core$render_management(a);
            !a && afterRendersResolver$$module$build$src$core$render_management && afterRendersResolver$$module$build$src$core$render_management();
          };
          alwaysImmediatelyRender$$module$build$src$core$render_management = function() {
            return JavaFx$$module$build$src$core$utils$useragent;
          };
          queueBlock$$module$build$src$core$render_management = function(a) {
            dirtyBlocks$$module$build$src$core$render_management.add(a);
            eventGroups$$module$build$src$core$render_management.set(a, $.getGroup$$module$build$src$core$events$utils());
            const b = a.getParent();
            b ? queueBlock$$module$build$src$core$render_management(b) : rootBlocks$$module$build$src$core$render_management.add(a);
          };
          doRenders$$module$build$src$core$render_management = function(a) {
            const b = a ? /* @__PURE__ */ new Set([a]) : new Set([...rootBlocks$$module$build$src$core$render_management].map((f) => f.workspace)), c = [...rootBlocks$$module$build$src$core$render_management].filter(shouldRenderRootBlock$$module$build$src$core$render_management).filter((f) => b.has(f.workspace));
            for (var d of c) renderBlock$$module$build$src$core$render_management(d);
            for (const f of b) f.resizeContents();
            for (var e of c) d = e.getRelativeToSurfaceXY(), e.updateComponentLocations(d);
            for (const f of c) e = $.getGroup$$module$build$src$core$events$utils(), (d = eventGroups$$module$build$src$core$render_management.get(f)) && $.setGroup$$module$build$src$core$events$utils(d), f.bumpNeighbours(), $.setGroup$$module$build$src$core$events$utils(e);
            for (const f of c) dequeueBlock$$module$build$src$core$render_management(f);
            a || (afterRendersPromise$$module$build$src$core$render_management = null);
          };
          dequeueBlock$$module$build$src$core$render_management = function(a) {
            rootBlocks$$module$build$src$core$render_management.delete(a);
            dirtyBlocks$$module$build$src$core$render_management.delete(a);
            eventGroups$$module$build$src$core$render_management.delete(a);
            for (const b of a.getChildren(false)) dequeueBlock$$module$build$src$core$render_management(b);
          };
          shouldRenderRootBlock$$module$build$src$core$render_management = function(a) {
            return !a.isDisposed() && !a.getParent();
          };
          renderBlock$$module$build$src$core$render_management = function(a) {
            if (dirtyBlocks$$module$build$src$core$render_management.has(a) && a.initialized) {
              for (const b of a.getChildren(false)) renderBlock$$module$build$src$core$render_management(b);
              a.renderEfficiently();
            }
          };
          alert$$module$build$src$core$dialog = function(a, b) {
            alertImplementation$$module$build$src$core$dialog(a, b);
          };
          setAlert$$module$build$src$core$dialog = function(a = defaultAlert$$module$build$src$core$dialog) {
            alertImplementation$$module$build$src$core$dialog = a;
          };
          confirm$$module$build$src$core$dialog = function(a, b) {
            confirmImplementation$$module$build$src$core$dialog(a, b);
          };
          setConfirm$$module$build$src$core$dialog = function(a = defaultConfirm$$module$build$src$core$dialog) {
            confirmImplementation$$module$build$src$core$dialog = a;
          };
          prompt$$module$build$src$core$dialog = function(a, b, c) {
            promptImplementation$$module$build$src$core$dialog(a, b, c);
          };
          setPrompt$$module$build$src$core$dialog = function(a = defaultPrompt$$module$build$src$core$dialog) {
            promptImplementation$$module$build$src$core$dialog = a;
          };
          toast$$module$build$src$core$dialog = function(a, b) {
            toastImplementation$$module$build$src$core$dialog(a, b);
          };
          setToast$$module$build$src$core$dialog = function(a = defaultToast$$module$build$src$core$dialog) {
            toastImplementation$$module$build$src$core$dialog = a;
          };
          isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks = function(a) {
            return a && typeof a.getProcedureDef === "function";
          };
          isLegacyProcedureCallBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks = function(a) {
            return a && typeof a.getProcedureCall === "function" && typeof a.renameProcedure === "function";
          };
          isVariableBackedParameterModel$$module$build$src$core$interfaces$i_variable_backed_parameter_model = function(a) {
            return a.getVariableModel !== void 0;
          };
          warn$$module$build$src$core$utils$deprecation = function(a, b, c, d) {
            a = a + " was deprecated in " + b + " and will be deleted in " + c + ".";
            d && (a += "\nUse " + d + " instead.");
            previousWarnings$$module$build$src$core$utils$deprecation.has(a) || (previousWarnings$$module$build$src$core$utils$deprecation.add(a), console.warn(a));
          };
          $.allUsedVarModels$$module$build$src$core$variables = function(a) {
            a = a.getAllBlocks(false);
            const b = /* @__PURE__ */ new Set();
            for (let c = 0; c < a.length; c++) {
              const d = a[c].getVarModels();
              if (d) for (let e = 0; e < d.length; e++) {
                const f = d[e];
                f.getId() && b.add(f);
              }
            }
            return Array.from(b.values());
          };
          $.allDeveloperVariables$$module$build$src$core$variables = function(a) {
            a = a.getAllBlocks(false);
            const b = /* @__PURE__ */ new Set();
            for (let d = 0, e; e = a[d]; d++) {
              var c = e.getDeveloperVariables;
              if (c) {
                c = c();
                for (let f = 0; f < c.length; f++) b.add(c[f]);
              }
            }
            return Array.from(b.values());
          };
          internalFlyoutCategory$$module$build$src$core$variables = function(a) {
            return flyoutCategory$$module$build$src$core$variables(a, false);
          };
          flyoutCategory$$module$build$src$core$variables = function(a, b = true) {
            Blocks$$module$build$src$core$blocks.variables_set || Blocks$$module$build$src$core$blocks.variables_get || console.warn("There are no variable blocks, but there is a variable category.");
            if (b) return warn$$module$build$src$core$utils$deprecation("The XML return value of Blockly.Variables.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), xmlFlyoutCategory$$module$build$src$core$variables(a);
            a.registerButtonCallback("CREATE_VARIABLE", function(c) {
              createVariableButtonHandler$$module$build$src$core$variables(c.getTargetWorkspace());
            });
            return [{ kind: "button", text: "%{BKY_NEW_VARIABLE}", callbackkey: "CREATE_VARIABLE" }, ...jsonFlyoutCategoryBlocks$$module$build$src$core$variables(a, a.getVariableMap().getVariablesOfType(""), true)];
          };
          generateVariableFieldJson$$module$build$src$core$variables = function(a) {
            return { VAR: { name: a.getName(), type: a.getType() } };
          };
          jsonFlyoutCategoryBlocks$$module$build$src$core$variables = function(a, b, c, d = "variables_get", e = "variables_set") {
            c && (c = Blocks$$module$build$src$core$blocks.math_change);
            a = [];
            const f = b.slice(-1)[0];
            f && (Blocks$$module$build$src$core$blocks[e] && a.push({ kind: "block", type: e, gap: c ? 8 : 24, fields: generateVariableFieldJson$$module$build$src$core$variables(f) }), c && a.push({
              kind: "block",
              type: "math_change",
              gap: Blocks$$module$build$src$core$blocks[d] ? 20 : 8,
              fields: generateVariableFieldJson$$module$build$src$core$variables(f),
              inputs: { DELTA: { shadow: { type: "math_number", fields: { NUM: 1 } } } }
            }));
            Blocks$$module$build$src$core$blocks[d] && a.push(...b.sort(compareByName$$module$build$src$core$variables).map((g) => ({ kind: "block", type: d, gap: 8, fields: generateVariableFieldJson$$module$build$src$core$variables(g) })));
            return a;
          };
          xmlFlyoutCategory$$module$build$src$core$variables = function(a) {
            let b = [];
            const c = document.createElement("button");
            c.setAttribute("text", "%{BKY_NEW_VARIABLE}");
            c.setAttribute("callbackKey", "CREATE_VARIABLE");
            a.registerButtonCallback("CREATE_VARIABLE", function(d) {
              createVariableButtonHandler$$module$build$src$core$variables(d.getTargetWorkspace());
            });
            b.push(c);
            a = flyoutCategoryBlocks$$module$build$src$core$variables(a);
            return b = b.concat(a);
          };
          flyoutCategoryBlocks$$module$build$src$core$variables = function(a) {
            a = a.getVariableMap().getVariablesOfType("");
            const b = [];
            if (a.length > 0) {
              var c = a[a.length - 1];
              if (Blocks$$module$build$src$core$blocks.variables_set) {
                var d = $.createElement$$module$build$src$core$utils$xml("block");
                d.setAttribute("type", "variables_set");
                d.setAttribute("gap", Blocks$$module$build$src$core$blocks.math_change ? "8" : "24");
                d.appendChild(generateVariableFieldDom$$module$build$src$core$variables(c));
                b.push(d);
              }
              Blocks$$module$build$src$core$blocks.math_change && (d = $.createElement$$module$build$src$core$utils$xml("block"), d.setAttribute("type", "math_change"), d.setAttribute("gap", Blocks$$module$build$src$core$blocks.variables_get ? "20" : "8"), d.appendChild(generateVariableFieldDom$$module$build$src$core$variables(c)), c = $.textToDom$$module$build$src$core$utils$xml('<value name="DELTA"><shadow type="math_number"><field name="NUM">1</field></shadow></value>'), d.appendChild(c), b.push(d));
              if (Blocks$$module$build$src$core$blocks.variables_get) {
                a.sort(compareByName$$module$build$src$core$variables);
                for (let e = 0, f; f = a[e]; e++) c = $.createElement$$module$build$src$core$utils$xml("block"), c.setAttribute("type", "variables_get"), c.setAttribute("gap", "8"), c.appendChild(generateVariableFieldDom$$module$build$src$core$variables(f)), b.push(c);
              }
            }
            return b;
          };
          generateUniqueName$$module$build$src$core$variables = function(a) {
            return TEST_ONLY$$module$build$src$core$variables.generateUniqueNameInternal(a);
          };
          generateUniqueNameInternal$$module$build$src$core$variables = function(a) {
            return generateUniqueNameFromOptions$$module$build$src$core$variables(VAR_LETTER_OPTIONS$$module$build$src$core$variables.charAt(0), a.getVariableMap().getAllVariables().map((b) => b.getName()));
          };
          generateUniqueNameFromOptions$$module$build$src$core$variables = function(a, b) {
            if (!b.length) return a;
            const c = VAR_LETTER_OPTIONS$$module$build$src$core$variables;
            let d = "", e = c.indexOf(a);
            for (; ; ) {
              let f = false;
              for (let g = 0; g < b.length; g++) if (b[g].toLowerCase() === a) {
                f = true;
                break;
              }
              if (!f) break;
              e++;
              e === c.length && (e = 0, d = `${Number(d) + 1}`);
              a = c.charAt(e) + d;
            }
            return a;
          };
          createVariableButtonHandler$$module$build$src$core$variables = function(a, b, c) {
            function d(f) {
              promptName$$module$build$src$core$variables($.Msg$$module$build$src$core$msg.NEW_VARIABLE_TITLE, f, function(g) {
                if (g) {
                  var h = nameUsedWithAnyType$$module$build$src$core$variables(g, a);
                  if (h) {
                    if (h.getType() === e) var k = $.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS.replace("%1", h.getName());
                    else k = $.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE, k = k.replace("%1", h.getName()).replace(
                      "%2",
                      h.getType()
                    );
                    alert$$module$build$src$core$dialog(k, function() {
                      d(g);
                    });
                  } else a.getVariableMap().createVariable(g, e), b && b(g);
                } else b && b(null);
              });
            }
            const e = c || "";
            d("");
          };
          $.renameVariable$$module$build$src$core$variables = function(a, b, c) {
            function d(e) {
              const f = $.Msg$$module$build$src$core$msg.RENAME_VARIABLE_TITLE.replace("%1", b.getName());
              promptName$$module$build$src$core$variables(f, e, function(g) {
                if (g) {
                  var h = nameUsedWithOtherType$$module$build$src$core$variables(g, b.getType(), a), k = nameUsedWithConflictingParam$$module$build$src$core$variables(b.getName(), g, a);
                  if (h || k) {
                    var l = "";
                    h ? l = $.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace(
                      "%1",
                      h.getName()
                    ).replace("%2", h.getType()) : k && (l = $.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER.replace("%1", g).replace("%2", k));
                    alert$$module$build$src$core$dialog(l, function() {
                      d(g);
                    });
                  } else a.getVariableMap().renameVariable(b, g), c && c(g);
                } else c && c(null);
              });
            }
            d("");
          };
          promptName$$module$build$src$core$variables = function(a, b, c) {
            prompt$$module$build$src$core$dialog(a, b, function(d) {
              d && (d = d.replace(/[\s\xa0]+/g, " ").trim(), d === $.Msg$$module$build$src$core$msg.RENAME_VARIABLE || d === $.Msg$$module$build$src$core$msg.NEW_VARIABLE) && (d = null);
              c(d);
            });
          };
          nameUsedWithOtherType$$module$build$src$core$variables = function(a, b, c) {
            c = c.getVariableMap().getAllVariables();
            a = a.toLowerCase();
            for (let d = 0, e; e = c[d]; d++) if (e.getName().toLowerCase() === a && e.getType() !== b) return e;
            return null;
          };
          nameUsedWithAnyType$$module$build$src$core$variables = function(a, b) {
            b = b.getVariableMap().getAllVariables();
            a = a.toLowerCase();
            for (let c = 0, d; d = b[c]; c++) if (d.getName().toLowerCase() === a) return d;
            return null;
          };
          nameUsedWithConflictingParam$$module$build$src$core$variables = function(a, b, c) {
            return c.getProcedureMap().getProcedures().length ? checkForConflictingParamWithProcedureModels$$module$build$src$core$variables(a, b, c) : checkForConflictingParamWithLegacyProcedures$$module$build$src$core$variables(a, b, c);
          };
          checkForConflictingParamWithProcedureModels$$module$build$src$core$variables = function(a, b, c) {
            a = a.toLowerCase();
            b = b.toLowerCase();
            c = c.getProcedureMap().getProcedures();
            for (const e of c) {
              var d = e.getParameters().filter(isVariableBackedParameterModel$$module$build$src$core$interfaces$i_variable_backed_parameter_model).map((f) => f.getVariableModel().getName());
              if (d && (c = d.some((f) => f.toLowerCase() === a), d = d.some((f) => f.toLowerCase() === b), c && d)) return e.getName();
            }
            return null;
          };
          checkForConflictingParamWithLegacyProcedures$$module$build$src$core$variables = function(a, b, c) {
            a = a.toLowerCase();
            b = b.toLowerCase();
            c = c.getAllBlocks(false);
            for (const e of c) {
              if (!isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(e)) continue;
              c = e.getProcedureDef();
              var d = c[1];
              const f = d.some((g) => g.toLowerCase() === a);
              d = d.some((g) => g.toLowerCase() === b);
              if (f && d) return c[0];
            }
            return null;
          };
          generateVariableFieldDom$$module$build$src$core$variables = function(a) {
            const b = $.createElement$$module$build$src$core$utils$xml("field");
            b.setAttribute("name", "VAR");
            b.setAttribute("id", a.getId());
            b.setAttribute("variabletype", a.getType());
            a = $.createTextNode$$module$build$src$core$utils$xml(a.getName());
            b.appendChild(a);
            return b;
          };
          $.getOrCreateVariablePackage$$module$build$src$core$variables = function(a, b, c, d) {
            let e = $.getVariable$$module$build$src$core$variables(a, b, c, d);
            e || (e = createVariable$$module$build$src$core$variables(a, b, c, d));
            return e;
          };
          $.getVariable$$module$build$src$core$variables = function(a, b, c, d) {
            const e = a.getPotentialVariableMap();
            let f = null;
            if (b && (f = a.getVariableById(b), !f && e && (f = e.getVariableById(b)), f)) return f;
            if (c) {
              if (d === void 0) throw Error("Tried to look up a variable by name without a type");
              f = a.getVariable(c, d);
              !f && e && (f = e.getVariable(c, d));
            }
            return f;
          };
          createVariable$$module$build$src$core$variables = function(a, b, c, d) {
            const e = a.getVariableMap(), f = a.getPotentialVariableMap();
            c || (c = generateUniqueName$$module$build$src$core$variables(a.isFlyout ? a.targetWorkspace : a));
            return f ? f.createVariable(c, d, b != null ? b : void 0) : e.createVariable(c, d, b);
          };
          getAddedVariables$$module$build$src$core$variables = function(a, b) {
            a = a.getAllVariables();
            const c = [];
            if (b.length !== a.length) for (let d = 0; d < a.length; d++) {
              const e = a[d];
              b.includes(e) || c.push(e);
            }
            return c;
          };
          compareByName$$module$build$src$core$variables = function(a, b) {
            return a.getName().localeCompare(b.getName(), void 0, { sensitivity: "base" });
          };
          getVariableUsesById$$module$build$src$core$variables = function(a, b) {
            const c = [];
            a = a.getAllBlocks(false);
            for (let d = 0; d < a.length; d++) {
              const e = a[d].getVarModels();
              if (e) for (let f = 0; f < e.length; f++) e[f].getId() === b && c.push(a[d]);
            }
            return c;
          };
          $.deleteVariable$$module$build$src$core$variables = function(a, b, c) {
            var d = b.getName();
            const e = getVariableUsesById$$module$build$src$core$variables(a, b.getId());
            for (let f = e.length - 1; f >= 0; f--) {
              const g = e[f];
              if (g.type === "procedures_defnoreturn" || g.type === "procedures_defreturn") {
                c = String(g.getFieldValue("NAME"));
                d = $.Msg$$module$build$src$core$msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace("%1", d).replace("%2", c);
                alert$$module$build$src$core$dialog(d);
                return;
              }
              g === c && e.splice(f, 1);
            }
            c && e.length || e.length > 1 ? (d = $.Msg$$module$build$src$core$msg.DELETE_VARIABLE_CONFIRMATION.replace("%1", String(e.length + (c && !c.workspace.isFlyout ? 1 : 0))).replace("%2", d), confirm$$module$build$src$core$dialog(d, (f) => {
              f && b && a.getVariableMap().deleteVariable(b);
            })) : a.getVariableMap().deleteVariable(b);
          };
          save$$module$build$src$core$serialization$blocks = function(a, { addCoordinates: b = false, addInputBlocks: c = true, addNextBlocks: d = true, doFullSerialization: e = true, saveIds: f = true } = {}) {
            if (a.isInsertionMarker()) return null;
            const g = { type: a.type, id: f ? a.id : void 0 };
            b && saveCoords$$module$build$src$core$serialization$blocks(a, g);
            saveAttributes$$module$build$src$core$serialization$blocks(a, g);
            saveExtraState$$module$build$src$core$serialization$blocks(a, g, e);
            saveIcons$$module$build$src$core$serialization$blocks(a, g, e);
            saveFields$$module$build$src$core$serialization$blocks(
              a,
              g,
              e
            );
            c && saveInputBlocks$$module$build$src$core$serialization$blocks(a, g, e, f);
            d && saveNextBlocks$$module$build$src$core$serialization$blocks(a, g, e, f);
            return g;
          };
          saveAttributes$$module$build$src$core$serialization$blocks = function(a, b) {
            a.isCollapsed() && (b.collapsed = true);
            a.isEnabled() || (b.disabledReasons = Array.from(a.getDisabledReasons()));
            a.isOwnDeletable() || (b.deletable = false);
            a.isOwnMovable() || (b.movable = false);
            a.isOwnEditable() || (b.editable = false);
            a.inputsInline !== void 0 && a.inputsInline !== a.inputsInlineDefault && (b.inline = a.inputsInline);
            a.data && (b.data = a.data);
          };
          saveCoords$$module$build$src$core$serialization$blocks = function(a, b) {
            const c = a.workspace;
            a = a.getRelativeToSurfaceXY();
            b.x = Math.round(c.RTL ? c.getWidth() - a.x : a.x);
            b.y = Math.round(a.y);
          };
          saveExtraState$$module$build$src$core$serialization$blocks = function(a, b, c) {
            a.saveExtraState ? (a = a.saveExtraState(c), a !== null && (b.extraState = a)) : a.mutationToDom && (a = a.mutationToDom(), a !== null && (b.extraState = domToText$$module$build$src$core$xml(a).replace(' xmlns="https://developers.google.com/blockly/xml"', "")));
          };
          saveIcons$$module$build$src$core$serialization$blocks = function(a, b, c) {
            const d = /* @__PURE__ */ Object.create(null);
            for (const e of a.getIcons()) isSerializable$$module$build$src$core$interfaces$i_serializable(e) && (a = e.saveState(c)) && (d[e.getType().toString()] = a);
            Object.keys(d).length && (b.icons = d);
          };
          saveFields$$module$build$src$core$serialization$blocks = function(a, b, c) {
            const d = /* @__PURE__ */ Object.create(null);
            for (const e of a.getFields()) e.isSerializable() && (d[e.name] = e.saveState(c));
            Object.keys(d).length && (b.fields = d);
          };
          saveInputBlocks$$module$build$src$core$serialization$blocks = function(a, b, c, d) {
            const e = /* @__PURE__ */ Object.create(null);
            for (let f = 0; f < a.inputList.length; f++) {
              const g = a.inputList[f];
              if (!g.connection) continue;
              const h = saveConnection$$module$build$src$core$serialization$blocks(g.connection, c, d);
              h && (e[g.name] = h);
            }
            Object.keys(e).length && (b.inputs = e);
          };
          saveNextBlocks$$module$build$src$core$serialization$blocks = function(a, b, c, d) {
            a.nextConnection && (a = saveConnection$$module$build$src$core$serialization$blocks(a.nextConnection, c, d)) && (b.next = a);
          };
          saveConnection$$module$build$src$core$serialization$blocks = function(a, b, c) {
            const d = a.getShadowState(true);
            a = a.targetBlock();
            if (!d && !a) return null;
            const e = /* @__PURE__ */ Object.create(null);
            d && (e.shadow = d);
            a && !a.isShadow() && (e.block = save$$module$build$src$core$serialization$blocks(a, { doFullSerialization: b, saveIds: c }));
            return e;
          };
          append$$module$build$src$core$serialization$blocks = function(a, b, { recordUndo: c = false } = {}) {
            a = appendInternal$$module$build$src$core$serialization$blocks(a, b, { recordUndo: c });
            b.rendered && triggerQueuedRenders$$module$build$src$core$render_management();
            return a;
          };
          appendInternal$$module$build$src$core$serialization$blocks = function(a, b, { parentConnection: c, isShadow: d = false, recordUndo: e = false } = {}) {
            const f = getRecordUndo$$module$build$src$core$events$utils();
            $.setRecordUndo$$module$build$src$core$events$utils(e);
            (e = $.getGroup$$module$build$src$core$events$utils()) || $.setGroup$$module$build$src$core$events$utils(true);
            $.disable$$module$build$src$core$events$utils();
            const g = b.getAllVariables();
            let h;
            try {
              h = appendPrivate$$module$build$src$core$serialization$blocks(a, b, {
                parentConnection: c,
                isShadow: d
              });
            } finally {
              $.enable$$module$build$src$core$events$utils();
            }
            checkNewVariables$$module$build$src$core$serialization$blocks(b, g);
            isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(h));
            $.setGroup$$module$build$src$core$events$utils(e);
            $.setRecordUndo$$module$build$src$core$events$utils(f);
            if (b.rendered) {
              const k = h;
              setTimeout(
                () => {
                  k.disposed || k.setConnectionTracking(true);
                },
                1
              );
            }
            return h;
          };
          appendPrivate$$module$build$src$core$serialization$blocks = function(a, b, { parentConnection: c, isShadow: d = false } = {}) {
            if (!a.type) throw new MissingBlockType$$module$build$src$core$serialization$exceptions(a);
            const e = b.newBlock(a.type, a.id);
            e.setShadow(d);
            loadCoords$$module$build$src$core$serialization$blocks(e, a);
            loadAttributes$$module$build$src$core$serialization$blocks(e, a);
            loadExtraState$$module$build$src$core$serialization$blocks(e, a);
            tryToConnectParent$$module$build$src$core$serialization$blocks(
              c,
              e,
              a
            );
            loadIcons$$module$build$src$core$serialization$blocks(e, a);
            loadFields$$module$build$src$core$serialization$blocks(e, a);
            loadInputBlocks$$module$build$src$core$serialization$blocks(e, a);
            loadNextBlocks$$module$build$src$core$serialization$blocks(e, a);
            initBlock$$module$build$src$core$serialization$blocks(e, b.rendered);
            return e;
          };
          checkNewVariables$$module$build$src$core$serialization$blocks = function(a, b) {
            if (isEnabled$$module$build$src$core$events$utils()) for (a = getAddedVariables$$module$build$src$core$variables(a, b), b = 0; b < a.length; b++) {
              const c = a[b];
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_CREATE))(c));
            }
          };
          loadCoords$$module$build$src$core$serialization$blocks = function(a, b) {
            let c = b.x === void 0 ? 0 : b.x;
            b = b.y === void 0 ? 0 : b.y;
            const d = a.workspace;
            c = d.RTL ? d.getWidth() - c : c;
            a.moveBy(c, b);
          };
          loadAttributes$$module$build$src$core$serialization$blocks = function(a, b) {
            b.collapsed && a.setCollapsed(true);
            b.deletable === false && a.setDeletable(false);
            b.movable === false && a.setMovable(false);
            b.editable === false && a.setEditable(false);
            b.enabled === false && a.setDisabledReason(true, MANUALLY_DISABLED$$module$build$src$core$constants);
            if (Array.isArray(b.disabledReasons)) for (const c of b.disabledReasons) a.setDisabledReason(true, c);
            b.inline !== void 0 && a.setInputsInline(b.inline);
            b.data !== void 0 && (a.data = b.data);
          };
          loadExtraState$$module$build$src$core$serialization$blocks = function(a, b) {
            b.extraState && (a.loadExtraState ? a.loadExtraState(b.extraState) : a.domToMutation && a.domToMutation($.textToDom$$module$build$src$core$utils$xml(b.extraState)));
          };
          tryToConnectParent$$module$build$src$core$serialization$blocks = function(a, b, c) {
            if (a) {
              if (a.getSourceBlock().isShadow() && !b.isShadow()) throw new RealChildOfShadow$$module$build$src$core$serialization$exceptions(c);
              if (a.type === $.inputTypes$$module$build$src$core$inputs$input_types.VALUE) {
                var d = b.outputConnection;
                if (!d) throw new MissingConnection$$module$build$src$core$serialization$exceptions("output", b, c);
              } else if (d = b.previousConnection, !d) throw new MissingConnection$$module$build$src$core$serialization$exceptions(
                "previous",
                b,
                c
              );
              if (!a.connect(d)) {
                const e = b.workspace.connectionChecker;
                throw new BadConnectionCheck$$module$build$src$core$serialization$exceptions(e.getErrorMessage(e.canConnectWithReason(d, a, false), d, a), a.type === $.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? "output connection" : "previous connection", b, c);
              }
            }
          };
          loadIcons$$module$build$src$core$serialization$blocks = function(a, b) {
            if (b.icons) {
              var c = Object.keys(b.icons);
              for (const e of c) {
                c = b.icons[e];
                var d = a.getIcon(e);
                if (!d) {
                  d = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.ICON, e, false);
                  if (!d) throw new UnregisteredIcon$$module$build$src$core$serialization$exceptions(e, a, b);
                  d = new d(a);
                  a.addIcon(d);
                }
                isSerializable$$module$build$src$core$interfaces$i_serializable(d) && d.loadState(c);
              }
            }
          };
          loadFields$$module$build$src$core$serialization$blocks = function(a, b) {
            if (b.fields) {
              var c = Object.keys(b.fields);
              for (let d = 0; d < c.length; d++) {
                const e = c[d], f = b.fields[e], g = a.getField(e);
                g ? g.loadState(f) : console.warn(`Ignoring non-existant field ${e} in block ${a.type}`);
              }
            }
          };
          loadInputBlocks$$module$build$src$core$serialization$blocks = function(a, b) {
            if (b.inputs) {
              var c = Object.keys(b.inputs);
              for (let d = 0; d < c.length; d++) {
                const e = c[d], f = a.getInput(e);
                if (!f || !f.connection) throw new MissingConnection$$module$build$src$core$serialization$exceptions(e, a, b);
                loadConnection$$module$build$src$core$serialization$blocks(f.connection, b.inputs[e]);
              }
            }
          };
          loadNextBlocks$$module$build$src$core$serialization$blocks = function(a, b) {
            if (b.next) {
              if (!a.nextConnection) throw new MissingConnection$$module$build$src$core$serialization$exceptions("next", a, b);
              loadConnection$$module$build$src$core$serialization$blocks(a.nextConnection, b.next);
            }
          };
          loadConnection$$module$build$src$core$serialization$blocks = function(a, b) {
            b.shadow && a.setShadowState(b.shadow);
            b.block && appendPrivate$$module$build$src$core$serialization$blocks(b.block, a.getSourceBlock().workspace, { parentConnection: a });
          };
          initBlock$$module$build$src$core$serialization$blocks = function(a, b) {
            if (b) {
              a.setConnectionTracking(false);
              a.initSvg();
              a.queueRender();
              for (const c of a.getIcons()) c.onLocationChange(a.getRelativeToSurfaceXY());
            } else a.initModel();
          };
          hasBubble$$module$build$src$core$interfaces$i_has_bubble = function(a) {
            return typeof a.bubbleIsVisible === "function" && typeof a.setBubbleVisible === "function" && typeof a.getBubble === "function";
          };
          toRadians$$module$build$src$core$utils$math = function(a) {
            return a * Math.PI / 180;
          };
          toDegrees$$module$build$src$core$utils$math = function(a) {
            return a * 180 / Math.PI;
          };
          clamp$$module$build$src$core$utils$math = function(a, b, c) {
            if (c < a) {
              const d = c;
              c = a;
              a = d;
            }
            return Math.max(a, Math.min(b, c));
          };
          createDom$$module$build$src$core$dropdowndiv = function() {
            document.querySelector(".blocklyDropDownDiv") || (div$$module$build$src$core$dropdowndiv = document.createElement("div"), div$$module$build$src$core$dropdowndiv.className = "blocklyDropDownDiv", div$$module$build$src$core$dropdowndiv.tabIndex = -1, (getParentContainer$$module$build$src$core$common() || document.body).appendChild(div$$module$build$src$core$dropdowndiv), content$$module$build$src$core$dropdowndiv = document.createElement("div"), content$$module$build$src$core$dropdowndiv.className = "blocklyDropDownContent", div$$module$build$src$core$dropdowndiv.appendChild(content$$module$build$src$core$dropdowndiv), keydownListener$$module$build$src$core$dropdowndiv = conditionalBind$$module$build$src$core$browser_events(content$$module$build$src$core$dropdowndiv, "keydown", null, globalShortcutHandler$$module$build$src$core$common), arrow$$module$build$src$core$dropdowndiv = document.createElement("div"), arrow$$module$build$src$core$dropdowndiv.className = "blocklyDropDownArrow", div$$module$build$src$core$dropdowndiv.appendChild(arrow$$module$build$src$core$dropdowndiv), div$$module$build$src$core$dropdowndiv.style.opacity = "0", div$$module$build$src$core$dropdowndiv.style.transition = "transform " + ANIMATION_TIME$$module$build$src$core$dropdowndiv + "s, opacity " + ANIMATION_TIME$$module$build$src$core$dropdowndiv + "s");
          };
          setBoundsElement$$module$build$src$core$dropdowndiv = function(a) {
            boundsElement$$module$build$src$core$dropdowndiv = a;
          };
          getOwner$$module$build$src$core$dropdowndiv = function() {
            return owner$$module$build$src$core$dropdowndiv;
          };
          getContentDiv$$module$build$src$core$dropdowndiv = function() {
            return content$$module$build$src$core$dropdowndiv;
          };
          clearContent$$module$build$src$core$dropdowndiv = function() {
            keydownListener$$module$build$src$core$dropdowndiv && (unbind$$module$build$src$core$browser_events(keydownListener$$module$build$src$core$dropdowndiv), keydownListener$$module$build$src$core$dropdowndiv = null);
            div$$module$build$src$core$dropdowndiv.remove();
            createDom$$module$build$src$core$dropdowndiv();
          };
          setColour$$module$build$src$core$dropdowndiv = function(a, b) {
            div$$module$build$src$core$dropdowndiv.style.backgroundColor = a;
            div$$module$build$src$core$dropdowndiv.style.borderColor = b;
          };
          showPositionedByBlock$$module$build$src$core$dropdowndiv = function(a, b, c, d, e = true) {
            return showPositionedByRect$$module$build$src$core$dropdowndiv(getScaledBboxOfBlock$$module$build$src$core$dropdowndiv(b), a, e, c, d);
          };
          showPositionedByField$$module$build$src$core$dropdowndiv = function(a, b, c, d = true) {
            positionToField$$module$build$src$core$dropdowndiv = true;
            return showPositionedByRect$$module$build$src$core$dropdowndiv(getScaledBboxOfField$$module$build$src$core$dropdowndiv(a), a, d, b, c);
          };
          getScaledBboxOfBlock$$module$build$src$core$dropdowndiv = function(a) {
            var b = a.getSvgRoot();
            const c = a.workspace.scale, d = a.height * c;
            a = a.width * c;
            b = getPageOffset$$module$build$src$core$utils$style(b);
            return new Rect$$module$build$src$core$utils$rect(b.y, b.y + d, b.x, b.x + a);
          };
          getScaledBboxOfField$$module$build$src$core$dropdowndiv = function(a) {
            a = a.getScaledBBox();
            return new Rect$$module$build$src$core$utils$rect(a.top, a.bottom, a.left, a.right);
          };
          showPositionedByRect$$module$build$src$core$dropdowndiv = function(a, b, c, d, e) {
            const f = a.left + (a.right - a.left) / 2, g = a.bottom;
            a = a.top;
            e && (a += e);
            e = b.getSourceBlock();
            let h = e.workspace;
            for (; h.options.parentWorkspace; ) h = h.options.parentWorkspace;
            setBoundsElement$$module$build$src$core$dropdowndiv(h.getParentSvg().parentNode);
            return show$$module$build$src$core$dropdowndiv(b, e.RTL, f, g, f, a, c, d);
          };
          show$$module$build$src$core$dropdowndiv = function(a, b, c, d, e, f, g, h) {
            owner$$module$build$src$core$dropdowndiv = a;
            onHide$$module$build$src$core$dropdowndiv = h || null;
            div$$module$build$src$core$dropdowndiv.style.direction = b ? "rtl" : "ltr";
            a = getMainWorkspace$$module$build$src$core$common();
            renderedClassName$$module$build$src$core$dropdowndiv = a.getRenderer().getClassName();
            themeClassName$$module$build$src$core$dropdowndiv = a.getTheme().getClassName();
            addClass$$module$build$src$core$utils$dom(
              div$$module$build$src$core$dropdowndiv,
              renderedClassName$$module$build$src$core$dropdowndiv
            );
            addClass$$module$build$src$core$utils$dom(div$$module$build$src$core$dropdowndiv, themeClassName$$module$build$src$core$dropdowndiv);
            c = positionInternal$$module$build$src$core$dropdowndiv(c, d, e, f);
            g && (returnEphemeralFocus$$module$build$src$core$dropdowndiv = $.getFocusManager$$module$build$src$core$focus_manager().takeEphemeralFocus(div$$module$build$src$core$dropdowndiv));
            return c;
          };
          getPositionBelowMetrics$$module$build$src$core$dropdowndiv = function(a, b, c, d) {
            a = getPositionX$$module$build$src$core$dropdowndiv(a, c.left, c.right, d.width);
            return { initialX: a.divX, initialY: b, finalX: a.divX, finalY: b + PADDING_Y$$module$build$src$core$dropdowndiv, arrowX: a.arrowX, arrowY: -(ARROW_SIZE$$module$build$src$core$dropdowndiv / 2 + BORDER_SIZE$$module$build$src$core$dropdowndiv), arrowAtTop: true, arrowVisible: true };
          };
          getPositionAboveMetrics$$module$build$src$core$dropdowndiv = function(a, b, c, d) {
            a = getPositionX$$module$build$src$core$dropdowndiv(a, c.left, c.right, d.width);
            return { initialX: a.divX, initialY: b - d.height, finalX: a.divX, finalY: b - d.height - PADDING_Y$$module$build$src$core$dropdowndiv, arrowX: a.arrowX, arrowY: d.height - BORDER_SIZE$$module$build$src$core$dropdowndiv * 2 - ARROW_SIZE$$module$build$src$core$dropdowndiv / 2, arrowAtTop: false, arrowVisible: true };
          };
          getPositionTopOfPageMetrics$$module$build$src$core$dropdowndiv = function(a, b, c) {
            a = getPositionX$$module$build$src$core$dropdowndiv(a, b.left, b.right, c.width);
            return { initialX: a.divX, initialY: 0, finalX: a.divX, finalY: 0, arrowAtTop: null, arrowX: null, arrowY: null, arrowVisible: false };
          };
          getPositionX$$module$build$src$core$dropdowndiv = function(a, b, c, d) {
            b = clamp$$module$build$src$core$utils$math(b, a - d / 2, c - d);
            a = a - ARROW_SIZE$$module$build$src$core$dropdowndiv / 2 - b;
            c = ARROW_HORIZONTAL_PADDING$$module$build$src$core$dropdowndiv;
            a = clamp$$module$build$src$core$utils$math(c, a, d - c - ARROW_SIZE$$module$build$src$core$dropdowndiv);
            return { arrowX: a, divX: b };
          };
          isVisible$$module$build$src$core$dropdowndiv = function() {
            return !!owner$$module$build$src$core$dropdowndiv;
          };
          hideIfOwner$$module$build$src$core$dropdowndiv = function(a, b) {
            return owner$$module$build$src$core$dropdowndiv === a ? (b ? hideWithoutAnimation$$module$build$src$core$dropdowndiv() : hide$$module$build$src$core$dropdowndiv(), true) : false;
          };
          hide$$module$build$src$core$dropdowndiv = function() {
            div$$module$build$src$core$dropdowndiv.style.transform = "translate(0, 0)";
            div$$module$build$src$core$dropdowndiv.style.opacity = "0";
            animateOutTimer$$module$build$src$core$dropdowndiv = setTimeout(function() {
              hideWithoutAnimation$$module$build$src$core$dropdowndiv();
            }, ANIMATION_TIME$$module$build$src$core$dropdowndiv * 1e3);
            onHide$$module$build$src$core$dropdowndiv && (onHide$$module$build$src$core$dropdowndiv(), onHide$$module$build$src$core$dropdowndiv = null);
          };
          hideWithoutAnimation$$module$build$src$core$dropdowndiv = function() {
            isVisible$$module$build$src$core$dropdowndiv() && (animateOutTimer$$module$build$src$core$dropdowndiv && clearTimeout(animateOutTimer$$module$build$src$core$dropdowndiv), onHide$$module$build$src$core$dropdowndiv && (onHide$$module$build$src$core$dropdowndiv(), onHide$$module$build$src$core$dropdowndiv = null), clearContent$$module$build$src$core$dropdowndiv(), owner$$module$build$src$core$dropdowndiv = null, getMainWorkspace$$module$build$src$core$common().markFocused(), returnEphemeralFocus$$module$build$src$core$dropdowndiv && (returnEphemeralFocus$$module$build$src$core$dropdowndiv(), returnEphemeralFocus$$module$build$src$core$dropdowndiv = null));
          };
          positionInternal$$module$build$src$core$dropdowndiv = function(a, b, c, d) {
            a = internal$$module$build$src$core$dropdowndiv.getPositionMetrics(a, b, c, d);
            a.arrowVisible ? (b = a.arrowX, c = a.arrowY, d = a.arrowAtTop ? 45 : 225, arrow$$module$build$src$core$dropdowndiv.style.display = "", arrow$$module$build$src$core$dropdowndiv.style.transform = `translate(${b}px, ${c}px) rotate(${d}deg)`, arrow$$module$build$src$core$dropdowndiv.setAttribute("class", "blocklyDropDownArrow")) : arrow$$module$build$src$core$dropdowndiv.style.display = "none";
            b = Math.floor(a.initialX);
            c = Math.floor(a.initialY);
            d = Math.floor(a.finalX);
            const e = Math.floor(a.finalY);
            div$$module$build$src$core$dropdowndiv.style.left = b + "px";
            div$$module$build$src$core$dropdowndiv.style.top = c + "px";
            div$$module$build$src$core$dropdowndiv.style.display = "block";
            div$$module$build$src$core$dropdowndiv.style.opacity = "1";
            div$$module$build$src$core$dropdowndiv.style.transform = "translate(" + (d - b) + "px," + (e - c) + "px)";
            return !!a.arrowAtTop;
          };
          repositionForWindowResize$$module$build$src$core$dropdowndiv = function() {
            if (owner$$module$build$src$core$dropdowndiv) {
              var a = owner$$module$build$src$core$dropdowndiv.getSourceBlock();
              a = positionToField$$module$build$src$core$dropdowndiv ? getScaledBboxOfField$$module$build$src$core$dropdowndiv(owner$$module$build$src$core$dropdowndiv) : getScaledBboxOfBlock$$module$build$src$core$dropdowndiv(a);
              const b = a.left + (a.right - a.left) / 2;
              positionInternal$$module$build$src$core$dropdowndiv(b, a.bottom, b, a.top);
            } else hide$$module$build$src$core$dropdowndiv();
          };
          shortestStringLength$$module$build$src$core$utils$string = function(a) {
            return a.length ? a.reduce(function(b, c) {
              return b.length < c.length ? b : c;
            }).length : 0;
          };
          commonWordPrefix$$module$build$src$core$utils$string = function(a, b) {
            if (!a.length) return 0;
            if (a.length === 1) return a[0].length;
            let c = 0;
            b = b || shortestStringLength$$module$build$src$core$utils$string(a);
            let d;
            for (d = 0; d < b; d++) {
              var e = a[0][d];
              for (var f = 1; f < a.length; f++) if (e !== a[f][d]) return c;
              e === " " && (c = d + 1);
            }
            for (e = 1; e < a.length; e++) if ((f = a[e][d]) && f !== " ") return c;
            return b;
          };
          commonWordSuffix$$module$build$src$core$utils$string = function(a, b) {
            if (!a.length) return 0;
            if (a.length === 1) return a[0].length;
            let c = 0;
            b = b || shortestStringLength$$module$build$src$core$utils$string(a);
            let d;
            for (d = 0; d < b; d++) {
              var e = a[0].substr(-d - 1, 1);
              for (var f = 1; f < a.length; f++) if (e !== a[f].substr(-d - 1, 1)) return c;
              e === " " && (c = d + 1);
            }
            for (e = 1; e < a.length; e++) if ((f = a[e].charAt(a[e].length - d - 1)) && f !== " ") return c;
            return b;
          };
          $.wrap$$module$build$src$core$utils$string = function(a, b) {
            a = a.split("\n");
            for (let c = 0; c < a.length; c++) a[c] = wrapLine$$module$build$src$core$utils$string(a[c], b);
            return a.join("\n");
          };
          wrapLine$$module$build$src$core$utils$string = function(a, b) {
            if (a.length <= b) return a;
            const c = a.trim().split(/\s+/);
            for (var d = 0; d < c.length; d++) c[d].length > b && (b = c[d].length);
            var e = -Infinity;
            let f, g = 1;
            do {
              d = e;
              f = a;
              a = [];
              e = c.length / g;
              let h = 1;
              for (let k = 0; k < c.length - 1; k++) h < (k + 1.5) / e ? (h++, a[k] = true) : a[k] = false;
              a = wrapMutate$$module$build$src$core$utils$string(c, a, b);
              e = wrapScore$$module$build$src$core$utils$string(c, a, b);
              a = wrapToText$$module$build$src$core$utils$string(c, a);
              g++;
            } while (e > d);
            return f;
          };
          wrapScore$$module$build$src$core$utils$string = function(a, b, c) {
            const d = [0], e = [];
            for (var f = 0; f < a.length; f++) d[d.length - 1] += a[f].length, b[f] === true ? (d.push(0), e.push(a[f].charAt(a[f].length - 1))) : b[f] === false && d[d.length - 1]++;
            a = Math.max(...d);
            b = 0;
            for (f = 0; f < d.length; f++) b -= Math.pow(Math.abs(c - d[f]), 1.5) * 2, b -= Math.pow(a - d[f], 1.5), ".?!".includes(e[f]) ? b += c / 3 : ",;)]}".includes(e[f]) && (b += c / 4);
            d.length > 1 && d[d.length - 1] <= d[d.length - 2] && (b += 0.5);
            return b;
          };
          wrapMutate$$module$build$src$core$utils$string = function(a, b, c) {
            let d = wrapScore$$module$build$src$core$utils$string(a, b, c), e;
            for (let f = 0; f < b.length - 1; f++) {
              if (b[f] === b[f + 1]) continue;
              const g = [].concat(b);
              g[f] = !g[f];
              g[f + 1] = !g[f + 1];
              const h = wrapScore$$module$build$src$core$utils$string(a, g, c);
              h > d && (d = h, e = g);
            }
            return e ? wrapMutate$$module$build$src$core$utils$string(a, e, c) : b;
          };
          wrapToText$$module$build$src$core$utils$string = function(a, b) {
            const c = [];
            for (let d = 0; d < a.length; d++) c.push(a[d]), b[d] !== void 0 && c.push(b[d] ? "\n" : " ");
            return c.join("");
          };
          $.isNumber$$module$build$src$core$utils$string = function(a) {
            return /^\s*-?\d+(\.\d+)?\s*$/.test(a);
          };
          setCustomTooltip$$module$build$src$core$tooltip = function(a) {
            customTooltip$$module$build$src$core$tooltip = a;
          };
          getCustomTooltip$$module$build$src$core$tooltip = function() {
            return customTooltip$$module$build$src$core$tooltip;
          };
          isVisible$$module$build$src$core$tooltip = function() {
            return visible$$module$build$src$core$tooltip;
          };
          getDiv$$module$build$src$core$tooltip = function() {
            return containerDiv$$module$build$src$core$tooltip;
          };
          getTooltipOfObject$$module$build$src$core$tooltip = function(a) {
            if (a = getTargetObject$$module$build$src$core$tooltip(a)) {
              for (a = a.tooltip; typeof a === "function"; ) a = a();
              if (typeof a !== "string") throw Error("Tooltip function must return a string.");
              return a;
            }
            return "";
          };
          getTargetObject$$module$build$src$core$tooltip = function(a) {
            for (; a && a.tooltip; ) {
              if (typeof a.tooltip === "string" || typeof a.tooltip === "function") return a;
              a = a.tooltip;
            }
            return null;
          };
          createDom$$module$build$src$core$tooltip = function() {
            document.querySelector(".blocklyTooltipDiv") || (containerDiv$$module$build$src$core$tooltip = document.createElement("div"), containerDiv$$module$build$src$core$tooltip.className = "blocklyTooltipDiv", (getParentContainer$$module$build$src$core$common() || document.body).appendChild(containerDiv$$module$build$src$core$tooltip));
          };
          bindMouseEvents$$module$build$src$core$tooltip = function(a) {
            a.mouseOverWrapper_ = bind$$module$build$src$core$browser_events(a, "pointerover", null, onMouseOver$$module$build$src$core$tooltip);
            a.mouseOutWrapper_ = bind$$module$build$src$core$browser_events(a, "pointerout", null, onMouseOut$$module$build$src$core$tooltip);
            a.addEventListener("pointermove", onMouseMove$$module$build$src$core$tooltip, false);
          };
          unbindMouseEvents$$module$build$src$core$tooltip = function(a) {
            a && (unbind$$module$build$src$core$browser_events(a.mouseOverWrapper_), unbind$$module$build$src$core$browser_events(a.mouseOutWrapper_), a.removeEventListener("pointermove", onMouseMove$$module$build$src$core$tooltip));
          };
          onMouseOver$$module$build$src$core$tooltip = function(a) {
            blocked$$module$build$src$core$tooltip || (a = getTargetObject$$module$build$src$core$tooltip(a.currentTarget), element$$module$build$src$core$tooltip !== a && (hide$$module$build$src$core$tooltip(), poisonedElement$$module$build$src$core$tooltip = null, element$$module$build$src$core$tooltip = a), clearTimeout(mouseOutPid$$module$build$src$core$tooltip));
          };
          onMouseOut$$module$build$src$core$tooltip = function(a) {
            blocked$$module$build$src$core$tooltip || (mouseOutPid$$module$build$src$core$tooltip = setTimeout(function() {
              poisonedElement$$module$build$src$core$tooltip = element$$module$build$src$core$tooltip = null;
              hide$$module$build$src$core$tooltip();
            }, 1), clearTimeout(showPid$$module$build$src$core$tooltip), showPid$$module$build$src$core$tooltip = 0);
          };
          onMouseMove$$module$build$src$core$tooltip = function(a) {
            if (element$$module$build$src$core$tooltip && element$$module$build$src$core$tooltip.tooltip && !blocked$$module$build$src$core$tooltip) if (visible$$module$build$src$core$tooltip) {
              const b = lastX$$module$build$src$core$tooltip - a.pageX;
              a = lastY$$module$build$src$core$tooltip - a.pageY;
              Math.sqrt(b * b + a * a) > RADIUS_OK$$module$build$src$core$tooltip && hide$$module$build$src$core$tooltip();
            } else poisonedElement$$module$build$src$core$tooltip !== element$$module$build$src$core$tooltip && (clearTimeout(showPid$$module$build$src$core$tooltip), lastX$$module$build$src$core$tooltip = a.pageX, lastY$$module$build$src$core$tooltip = a.pageY, showPid$$module$build$src$core$tooltip = setTimeout(show$$module$build$src$core$tooltip, HOVER_MS$$module$build$src$core$tooltip));
          };
          dispose$$module$build$src$core$tooltip = function() {
            poisonedElement$$module$build$src$core$tooltip = element$$module$build$src$core$tooltip = null;
            hide$$module$build$src$core$tooltip();
          };
          hide$$module$build$src$core$tooltip = function() {
            visible$$module$build$src$core$tooltip && (visible$$module$build$src$core$tooltip = false, containerDiv$$module$build$src$core$tooltip && (containerDiv$$module$build$src$core$tooltip.style.display = "none"));
            showPid$$module$build$src$core$tooltip && (clearTimeout(showPid$$module$build$src$core$tooltip), showPid$$module$build$src$core$tooltip = 0);
          };
          block$$module$build$src$core$tooltip = function() {
            hide$$module$build$src$core$tooltip();
            blocked$$module$build$src$core$tooltip = true;
          };
          unblock$$module$build$src$core$tooltip = function() {
            blocked$$module$build$src$core$tooltip = false;
          };
          renderContent$$module$build$src$core$tooltip = function() {
            containerDiv$$module$build$src$core$tooltip && element$$module$build$src$core$tooltip && (typeof customTooltip$$module$build$src$core$tooltip === "function" ? customTooltip$$module$build$src$core$tooltip(containerDiv$$module$build$src$core$tooltip, element$$module$build$src$core$tooltip) : renderDefaultContent$$module$build$src$core$tooltip());
          };
          renderDefaultContent$$module$build$src$core$tooltip = function() {
            var a = getTooltipOfObject$$module$build$src$core$tooltip(element$$module$build$src$core$tooltip);
            a = $.wrap$$module$build$src$core$utils$string(a, LIMIT$$module$build$src$core$tooltip);
            a = a.split("\n");
            for (let b = 0; b < a.length; b++) {
              const c = document.createElement("div");
              c.appendChild(document.createTextNode(a[b]));
              containerDiv$$module$build$src$core$tooltip.appendChild(c);
            }
          };
          getPosition$$module$build$src$core$tooltip = function(a) {
            const b = document.documentElement.clientWidth, c = document.documentElement.clientHeight;
            let d = lastX$$module$build$src$core$tooltip;
            d = a ? d - (OFFSET_X$$module$build$src$core$tooltip + containerDiv$$module$build$src$core$tooltip.offsetWidth) : d + OFFSET_X$$module$build$src$core$tooltip;
            let e = lastY$$module$build$src$core$tooltip + OFFSET_Y$$module$build$src$core$tooltip;
            e + containerDiv$$module$build$src$core$tooltip.offsetHeight > c + window.scrollY && (e -= containerDiv$$module$build$src$core$tooltip.offsetHeight + 2 * OFFSET_Y$$module$build$src$core$tooltip);
            a ? d = Math.max(MARGINS$$module$build$src$core$tooltip - window.scrollX, d) : d + containerDiv$$module$build$src$core$tooltip.offsetWidth > b + window.scrollX - 2 * MARGINS$$module$build$src$core$tooltip && (d = b - containerDiv$$module$build$src$core$tooltip.offsetWidth - 2 * MARGINS$$module$build$src$core$tooltip);
            return { x: d, y: e };
          };
          show$$module$build$src$core$tooltip = function() {
            if (!blocked$$module$build$src$core$tooltip && (poisonedElement$$module$build$src$core$tooltip = element$$module$build$src$core$tooltip, containerDiv$$module$build$src$core$tooltip)) {
              containerDiv$$module$build$src$core$tooltip.textContent = "";
              renderContent$$module$build$src$core$tooltip();
              var a = element$$module$build$src$core$tooltip.RTL;
              containerDiv$$module$build$src$core$tooltip.style.direction = a ? "rtl" : "ltr";
              containerDiv$$module$build$src$core$tooltip.style.display = "block";
              visible$$module$build$src$core$tooltip = true;
              var { x: b, y: c } = getPosition$$module$build$src$core$tooltip(a);
              containerDiv$$module$build$src$core$tooltip.style.left = b + "px";
              containerDiv$$module$build$src$core$tooltip.style.top = c + "px";
            }
          };
          getHsvSaturation$$module$build$src$core$utils$colour = function() {
            return hsvSaturation$$module$build$src$core$utils$colour;
          };
          setHsvSaturation$$module$build$src$core$utils$colour = function(a) {
            hsvSaturation$$module$build$src$core$utils$colour = a;
          };
          getHsvValue$$module$build$src$core$utils$colour = function() {
            return hsvValue$$module$build$src$core$utils$colour;
          };
          setHsvValue$$module$build$src$core$utils$colour = function(a) {
            hsvValue$$module$build$src$core$utils$colour = a;
          };
          parse$$module$build$src$core$utils$colour = function(a) {
            a = `${a}`.toLowerCase().trim();
            var b = names$$module$build$src$core$utils$colour[a];
            if (b) return b;
            b = a.substring(0, 2) === "0x" ? "#" + a.substring(2) : a;
            b = b[0] === "#" ? b : "#" + b;
            if (/^#[0-9a-f]{6}$/.test(b)) return b;
            if (/^#[0-9a-f]{3}$/.test(b)) return ["#", b[1], b[1], b[2], b[2], b[3], b[3]].join("");
            var c = a.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
            return c && (a = Number(c[1]), b = Number(c[2]), c = Number(c[3]), a >= 0 && a < 256 && b >= 0 && b < 256 && c >= 0 && c < 256) ? rgbToHex$$module$build$src$core$utils$colour(
              a,
              b,
              c
            ) : null;
          };
          rgbToHex$$module$build$src$core$utils$colour = function(a, b, c) {
            b = a << 16 | b << 8 | c;
            return a < 16 ? "#" + (16777216 | b).toString(16).substr(1) : "#" + b.toString(16);
          };
          hexToRgb$$module$build$src$core$utils$colour = function(a) {
            a = parse$$module$build$src$core$utils$colour(a);
            if (!a) return [0, 0, 0];
            a = parseInt(a.substr(1), 16);
            return [a >> 16, a >> 8 & 255, a & 255];
          };
          hsvToHex$$module$build$src$core$utils$colour = function(a, b, c) {
            let d = 0, e = 0, f = 0;
            if (b === 0) f = e = d = c;
            else {
              const g = Math.floor(a / 60), h = a / 60 - g;
              a = c * (1 - b);
              const k = c * (1 - b * h);
              b = c * (1 - b * (1 - h));
              switch (g) {
                case 1:
                  d = k;
                  e = c;
                  f = a;
                  break;
                case 2:
                  d = a;
                  e = c;
                  f = b;
                  break;
                case 3:
                  d = a;
                  e = k;
                  f = c;
                  break;
                case 4:
                  d = b;
                  e = a;
                  f = c;
                  break;
                case 5:
                  d = c;
                  e = a;
                  f = k;
                  break;
                case 6:
                case 0:
                  d = c, e = b, f = a;
              }
            }
            return rgbToHex$$module$build$src$core$utils$colour(Math.floor(d), Math.floor(e), Math.floor(f));
          };
          blend$$module$build$src$core$utils$colour = function(a, b, c) {
            a = parse$$module$build$src$core$utils$colour(a);
            if (!a) return null;
            b = parse$$module$build$src$core$utils$colour(b);
            if (!b) return null;
            a = hexToRgb$$module$build$src$core$utils$colour(a);
            b = hexToRgb$$module$build$src$core$utils$colour(b);
            return rgbToHex$$module$build$src$core$utils$colour(Math.round(b[0] + c * (a[0] - b[0])), Math.round(b[1] + c * (a[1] - b[1])), Math.round(b[2] + c * (a[2] - b[2])));
          };
          hueToHex$$module$build$src$core$utils$colour = function(a) {
            return hsvToHex$$module$build$src$core$utils$colour(a, hsvSaturation$$module$build$src$core$utils$colour, hsvValue$$module$build$src$core$utils$colour * 255);
          };
          tokenizeInterpolationInternal$$module$build$src$core$utils$parsing = function(a, b, c) {
            const d = [];
            var e = a.split("");
            e.push("");
            var f = 0;
            a = [];
            let g = null;
            for (let l = 0; l < e.length; l++) {
              var h = e[l];
              if (f === 0) if (h === "%") (f = a.join("")) && d.push(f), a.length = 0, f = 1;
              else if (c && h === "\n") {
                const m = a.join("");
                m && d.push(m);
                a.length = 0;
                d.push(h);
              } else a.push(h);
              else if (f === 1) h === "%" ? (a.push(h), f = 0) : b && "0" <= h && h <= "9" ? (f = 2, g = h, (h = a.join("")) && d.push(h), a.length = 0) : h === "{" ? f = 3 : (a.push("%", h), f = 0);
              else if (f === 2) if ("0" <= h && h <= "9") g += h;
              else {
                var k = void 0;
                d.push(parseInt((k = g) != null ? k : "", 10));
                l--;
                f = 0;
              }
              else f === 3 && (h === "" ? (a.splice(0, 0, "%{"), l--, f = 0) : h !== "}" ? a.push(h) : (f = a.join(""), /[A-Z]\w*/i.test(f) ? (h = f.toUpperCase(), (h = h.startsWith("BKY_") ? h.substring(4) : null) && h in $.Msg$$module$build$src$core$msg ? (f = $.Msg$$module$build$src$core$msg[h], typeof f === "string" ? Array.prototype.push.apply(d, tokenizeInterpolationInternal$$module$build$src$core$utils$parsing(f, b, c)) : b ? d.push(`${f}`) : d.push(f)) : d.push("%{" + f + "}")) : d.push("%{" + f + "}"), f = a.length = 0));
            }
            (b = a.join("")) && d.push(b);
            k = [];
            a.length = 0;
            for (e = 0; e < d.length; e++) typeof d[e] !== "string" || c && d[e] === "\n" ? ((b = a.join("")) && k.push(b), a.length = 0, k.push(d[e])) : a.push(d[e]);
            (b = a.join("")) && k.push(b);
            a.length = 0;
            return k;
          };
          tokenizeInterpolation$$module$build$src$core$utils$parsing = function(a) {
            return tokenizeInterpolationInternal$$module$build$src$core$utils$parsing(a, true, true);
          };
          replaceMessageReferences$$module$build$src$core$utils$parsing = function(a) {
            if (typeof a !== "string") return a;
            a = tokenizeInterpolationInternal$$module$build$src$core$utils$parsing(a, false, false);
            return a.length ? String(a[0]) : "";
          };
          checkMessageReferences$$module$build$src$core$utils$parsing = function(a) {
            let b = true;
            const c = $.Msg$$module$build$src$core$msg, d = a.match(/%{BKY_[A-Z]\w*}/gi);
            if (d) for (let e = 0; e < d.length; e++) {
              const f = d[e].toUpperCase();
              c[f.slice(6, -1)] === void 0 && (console.warn("No message string for " + d[e] + " in " + a), b = false);
            }
            return b;
          };
          parseBlockColour$$module$build$src$core$utils$parsing = function(a) {
            const b = typeof a === "string" ? replaceMessageReferences$$module$build$src$core$utils$parsing(a) : a;
            var c = Number(b);
            if (!isNaN(c) && 0 <= c && c <= 360) return { hue: c, hex: hsvToHex$$module$build$src$core$utils$colour(c, getHsvSaturation$$module$build$src$core$utils$colour(), getHsvValue$$module$build$src$core$utils$colour() * 255) };
            if (c = parse$$module$build$src$core$utils$colour(b)) return { hue: null, hex: c };
            c = 'Invalid colour: "' + b + '"';
            a !== b && (c += ' (from "' + a + '")');
            throw Error(c);
          };
          getDiv$$module$build$src$core$widgetdiv = function() {
            return containerDiv$$module$build$src$core$widgetdiv;
          };
          testOnly_setDiv$$module$build$src$core$widgetdiv = function(a) {
            containerDiv$$module$build$src$core$widgetdiv = a;
            if (a === null) {
              let b;
              (b = document.querySelector("." + containerClassName$$module$build$src$core$widgetdiv)) == null || b.remove();
            }
          };
          createDom$$module$build$src$core$widgetdiv = function() {
            const a = getParentContainer$$module$build$src$core$common() || document.body, b = document.querySelector("div." + containerClassName$$module$build$src$core$widgetdiv);
            b ? containerDiv$$module$build$src$core$widgetdiv = b : (containerDiv$$module$build$src$core$widgetdiv = document.createElement("div"), containerDiv$$module$build$src$core$widgetdiv.className = containerClassName$$module$build$src$core$widgetdiv, containerDiv$$module$build$src$core$widgetdiv.tabIndex = -1);
            conditionalBind$$module$build$src$core$browser_events(containerDiv$$module$build$src$core$widgetdiv, "keydown", null, globalShortcutHandler$$module$build$src$core$common);
            a.appendChild(containerDiv$$module$build$src$core$widgetdiv);
          };
          show$$module$build$src$core$widgetdiv = function(a, b, c, d, e = true) {
            hide$$module$build$src$core$widgetdiv();
            owner$$module$build$src$core$widgetdiv = a;
            dispose$$module$build$src$core$widgetdiv = c;
            if (c = containerDiv$$module$build$src$core$widgetdiv) {
              c.style.direction = b ? "rtl" : "ltr";
              c.style.display = "block";
              if (!d && a instanceof Field$$module$build$src$core$field) {
                let h;
                d = (h = a.getSourceBlock()) == null ? void 0 : h.workspace;
              }
              var f;
              ownerWorkspace$$module$build$src$core$widgetdiv = (f = d) != null ? f : null;
              var g;
              a = (g = d) != null ? g : getMainWorkspace$$module$build$src$core$common();
              rendererClassName$$module$build$src$core$widgetdiv = a.getRenderer().getClassName();
              themeClassName$$module$build$src$core$widgetdiv = a.getTheme().getClassName();
              rendererClassName$$module$build$src$core$widgetdiv && addClass$$module$build$src$core$utils$dom(c, rendererClassName$$module$build$src$core$widgetdiv);
              themeClassName$$module$build$src$core$widgetdiv && addClass$$module$build$src$core$utils$dom(c, themeClassName$$module$build$src$core$widgetdiv);
              e && (returnEphemeralFocus$$module$build$src$core$widgetdiv = $.getFocusManager$$module$build$src$core$focus_manager().takeEphemeralFocus(c));
            }
          };
          hide$$module$build$src$core$widgetdiv = function() {
            if (isVisible$$module$build$src$core$widgetdiv()) {
              owner$$module$build$src$core$widgetdiv = null;
              var a = containerDiv$$module$build$src$core$widgetdiv;
              a && (a.style.display = "none", a.style.left = "", a.style.top = "", dispose$$module$build$src$core$widgetdiv && (dispose$$module$build$src$core$widgetdiv(), dispose$$module$build$src$core$widgetdiv = null), a.textContent = "", rendererClassName$$module$build$src$core$widgetdiv && (removeClass$$module$build$src$core$utils$dom(
                a,
                rendererClassName$$module$build$src$core$widgetdiv
              ), rendererClassName$$module$build$src$core$widgetdiv = ""), themeClassName$$module$build$src$core$widgetdiv && (removeClass$$module$build$src$core$utils$dom(a, themeClassName$$module$build$src$core$widgetdiv), themeClassName$$module$build$src$core$widgetdiv = ""), getMainWorkspace$$module$build$src$core$common().markFocused(), returnEphemeralFocus$$module$build$src$core$widgetdiv && (returnEphemeralFocus$$module$build$src$core$widgetdiv(), returnEphemeralFocus$$module$build$src$core$widgetdiv = null));
            }
          };
          isVisible$$module$build$src$core$widgetdiv = function() {
            return !!owner$$module$build$src$core$widgetdiv;
          };
          hideIfOwner$$module$build$src$core$widgetdiv = function(a) {
            owner$$module$build$src$core$widgetdiv === a && hide$$module$build$src$core$widgetdiv();
          };
          hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv = function(a) {
            let b = ownerWorkspace$$module$build$src$core$widgetdiv === null, c = a;
            for (; !b && c; ) {
              if (c === a) {
                b = true;
                break;
              }
              c = a.options.parentWorkspace;
            }
            b && hide$$module$build$src$core$widgetdiv();
          };
          positionInternal$$module$build$src$core$widgetdiv = function(a, b, c) {
            containerDiv$$module$build$src$core$widgetdiv.style.left = a + "px";
            containerDiv$$module$build$src$core$widgetdiv.style.top = b + "px";
            containerDiv$$module$build$src$core$widgetdiv.style.height = c + "px";
          };
          positionWithAnchor$$module$build$src$core$widgetdiv = function(a, b, c, d) {
            const e = calculateY$$module$build$src$core$widgetdiv(a, b, c);
            a = calculateX$$module$build$src$core$widgetdiv(a, b, c, d);
            e < 0 ? positionInternal$$module$build$src$core$widgetdiv(a, 0, c.height + e) : positionInternal$$module$build$src$core$widgetdiv(a, e, c.height);
          };
          calculateX$$module$build$src$core$widgetdiv = function(a, b, c, d) {
            return d ? Math.min(Math.max(b.right - c.width, a.left), a.right - c.width) : Math.max(Math.min(b.left, a.right - c.width), a.left);
          };
          calculateY$$module$build$src$core$widgetdiv = function(a, b, c) {
            return b.bottom + c.height >= a.bottom ? b.top - c.height : b.bottom;
          };
          isRepositionable$$module$build$src$core$widgetdiv = function(a) {
            return !(a == null || !a.repositionForWindowResize);
          };
          repositionForWindowResize$$module$build$src$core$widgetdiv = function() {
            isRepositionable$$module$build$src$core$widgetdiv(owner$$module$build$src$core$widgetdiv) && owner$$module$build$src$core$widgetdiv.repositionForWindowResize() || hide$$module$build$src$core$widgetdiv();
          };
          getCurrentBlock$$module$build$src$core$contextmenu = function() {
            return currentBlock$$module$build$src$core$contextmenu;
          };
          setCurrentBlock$$module$build$src$core$contextmenu = function(a) {
            currentBlock$$module$build$src$core$contextmenu = a;
          };
          show$$module$build$src$core$contextmenu = function(a, b, c, d, e) {
            show$$module$build$src$core$widgetdiv(dummyOwner$$module$build$src$core$contextmenu, c, dispose$$module$build$src$core$contextmenu, d);
            if (b.length) {
              e || (a instanceof PointerEvent ? e = new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY) : (console.warn("Context menu opened with keyboard but no location given"), e = new Coordinate$$module$build$src$core$utils$coordinate(0, 0)));
              var f = populate_$$module$build$src$core$contextmenu(
                b,
                c,
                a,
                e
              );
              menu_$$module$build$src$core$contextmenu = f;
              position_$$module$build$src$core$contextmenu(f, c, e);
              setTimeout(function() {
                f.focus();
              }, 1);
              currentBlock$$module$build$src$core$contextmenu = null;
            } else hide$$module$build$src$core$contextmenu();
          };
          populate_$$module$build$src$core$contextmenu = function(a, b, c, d) {
            const e = new Menu$$module$build$src$core$menu();
            e.setRole(Role$$module$build$src$core$utils$aria.MENU);
            for (let f = 0; f < a.length; f++) {
              const g = a[f];
              if (g.separator) {
                e.addChild(new MenuSeparator$$module$build$src$core$menu_separator());
                continue;
              }
              const h = new MenuItem$$module$build$src$core$menuitem(g.text);
              h.setRightToLeft(b);
              h.setRole(Role$$module$build$src$core$utils$aria.MENUITEM);
              e.addChild(h);
              h.setEnabled(g.enabled);
              if (g.enabled) h.onAction(function(k, l) {
                hide$$module$build$src$core$contextmenu();
                requestAnimationFrame(() => {
                  setTimeout(() => {
                    g.callback(g.scope, c, l, d);
                  }, 0);
                });
              }, {});
            }
            return e;
          };
          position_$$module$build$src$core$contextmenu = function(a, b, c) {
            const d = getViewportBBox$$module$build$src$core$utils$svg_math();
            c = new Rect$$module$build$src$core$utils$rect(c.y + d.top, c.y + d.top, c.x + d.left, c.x + d.left);
            createWidget_$$module$build$src$core$contextmenu(a);
            const e = a.getSize();
            b && (c.left += e.width, c.right += e.width, d.left += e.width, d.right += e.width);
            positionWithAnchor$$module$build$src$core$widgetdiv(d, c, e, b);
            a.focus();
          };
          createWidget_$$module$build$src$core$contextmenu = function(a) {
            var b = getDiv$$module$build$src$core$widgetdiv();
            if (!b) throw Error("Attempting to create a context menu when widget div is null");
            b = a.render(b);
            addClass$$module$build$src$core$utils$dom(b, "blocklyContextMenu");
            conditionalBind$$module$build$src$core$browser_events(b, "contextmenu", null, haltPropagation$$module$build$src$core$contextmenu);
            a.focus();
          };
          haltPropagation$$module$build$src$core$contextmenu = function(a) {
            a.preventDefault();
            a.stopPropagation();
          };
          hide$$module$build$src$core$contextmenu = function() {
            hideIfOwner$$module$build$src$core$widgetdiv(dummyOwner$$module$build$src$core$contextmenu);
            currentBlock$$module$build$src$core$contextmenu = null;
          };
          dispose$$module$build$src$core$contextmenu = function() {
            menu_$$module$build$src$core$contextmenu && (menu_$$module$build$src$core$contextmenu.dispose(), menu_$$module$build$src$core$contextmenu = null);
          };
          $.callbackFactory$$module$build$src$core$contextmenu = function(a, b) {
            return () => {
              $.disable$$module$build$src$core$events$utils();
              let c;
              try {
                c = b instanceof Element ? domToBlockInternal$$module$build$src$core$xml(b, a.workspace) : appendInternal$$module$build$src$core$serialization$blocks(b, a.workspace);
                const d = a.getRelativeToSurfaceXY();
                d.x = a.RTL ? d.x - $.config$$module$build$src$core$config.snapRadius : d.x + $.config$$module$build$src$core$config.snapRadius;
                d.y += $.config$$module$build$src$core$config.snapRadius * 2;
                c.moveBy(d.x, d.y);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
              isEnabled$$module$build$src$core$events$utils() && !c.isShadow() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(c));
              $.getFocusManager$$module$build$src$core$focus_manager().focusNode(c);
              return c;
            };
          };
          mouseToWorkspacePoint$$module$build$src$core$utils$drag = function(a, b) {
            b = mouseToSvg$$module$build$src$core$browser_events(b, a.getParentSvg(), a.getInverseScreenCTM());
            b.x /= a.scale;
            b.y /= a.scale;
            return b;
          };
          start$$module$build$src$core$utils$drag = function(a, b, c) {
            b = mouseToWorkspacePoint$$module$build$src$core$utils$drag(a, b);
            workspaceToDragDelta$$module$build$src$core$utils$drag.set(a, Coordinate$$module$build$src$core$utils$coordinate.difference(c, b));
          };
          move$$module$build$src$core$utils$drag = function(a, b) {
            b = mouseToWorkspacePoint$$module$build$src$core$utils$drag(a, b);
            a = workspaceToDragDelta$$module$build$src$core$utils$drag.get(a);
            if (!a) throw Error("Drag not initialized");
            return Coordinate$$module$build$src$core$utils$coordinate.sum(a, b);
          };
          workspaceToDom$$module$build$src$core$xml = function(a, b = false) {
            const c = $.createElement$$module$build$src$core$utils$xml("xml");
            var d = variablesToDom$$module$build$src$core$xml($.allUsedVarModels$$module$build$src$core$variables(a));
            d.hasChildNodes() && c.appendChild(d);
            for (const e of a.getTopComments()) c.appendChild(saveWorkspaceComment$$module$build$src$core$xml(e, b));
            a = a.getTopBlocks(true);
            for (d = 0; d < a.length; d++) c.appendChild(blockToDomWithXY$$module$build$src$core$xml(a[d], b));
            return c;
          };
          saveWorkspaceComment$$module$build$src$core$xml = function(a, b = false) {
            const c = $.createElement$$module$build$src$core$utils$xml("comment");
            b || c.setAttribute("id", a.id);
            b = a.workspace;
            const d = a.getRelativeToSurfaceXY().clone();
            d.x = b.RTL ? b.getWidth() - d.x : d.x;
            c.setAttribute("x", `${d.x}`);
            c.setAttribute("y", `${d.y}`);
            c.setAttribute("w", `${a.getSize().width}`);
            c.setAttribute("h", `${a.getSize().height}`);
            a.getText() && (c.textContent = a.getText());
            a.isCollapsed() && c.setAttribute("collapsed", "true");
            a.isOwnEditable() || c.setAttribute("editable", "false");
            a.isOwnMovable() || c.setAttribute("movable", "false");
            a.isOwnDeletable() || c.setAttribute("deletable", "false");
            return c;
          };
          variablesToDom$$module$build$src$core$xml = function(a) {
            const b = $.createElement$$module$build$src$core$utils$xml("variables");
            for (let c = 0; c < a.length; c++) {
              const d = a[c], e = $.createElement$$module$build$src$core$utils$xml("variable");
              e.appendChild($.createTextNode$$module$build$src$core$utils$xml(d.getName()));
              d.getType() && e.setAttribute("type", d.getType());
              e.id = d.getId();
              b.appendChild(e);
            }
            return b;
          };
          blockToDomWithXY$$module$build$src$core$xml = function(a, b) {
            if (a.isInsertionMarker() && (a = a.getChildren(false)[0], !a)) return new DocumentFragment();
            let c = 0;
            a.workspace.RTL && (c = a.workspace.getWidth());
            b = blockToDom$$module$build$src$core$xml(a, b);
            if (isElement$$module$build$src$core$xml(b)) {
              const d = a.getRelativeToSurfaceXY();
              b.setAttribute("x", String(Math.round(a.workspace.RTL ? c - d.x : d.x)));
              b.setAttribute("y", String(Math.round(d.y)));
            }
            return b;
          };
          fieldToDom$$module$build$src$core$xml = function(a) {
            if (a.isSerializable()) {
              const b = $.createElement$$module$build$src$core$utils$xml("field");
              b.setAttribute("name", a.name || "");
              return a.toXml(b);
            }
            return null;
          };
          allFieldsToDom$$module$build$src$core$xml = function(a, b) {
            for (const c of a.getFields()) (a = fieldToDom$$module$build$src$core$xml(c)) && b.appendChild(a);
          };
          blockToDom$$module$build$src$core$xml = function(a, b) {
            if (a.isInsertionMarker()) return (b = a.getChildren(false)[0]) ? blockToDom$$module$build$src$core$xml(b) : new DocumentFragment();
            const c = $.createElement$$module$build$src$core$utils$xml(a.isShadow() ? "shadow" : "block");
            c.setAttribute("type", a.type);
            b || (c.id = a.id);
            if (a.mutationToDom) {
              var d = a.mutationToDom();
              d && (d.hasChildNodes() || d.hasAttributes()) && c.appendChild(d);
            }
            allFieldsToDom$$module$build$src$core$xml(a, c);
            if (d = a.getCommentText()) {
              var e = a.getIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT), f = e.getBubbleSize(), g = e.bubbleIsVisible();
              e = e.getBubbleLocation();
              var h = $.createElement$$module$build$src$core$utils$xml("comment");
              h.appendChild($.createTextNode$$module$build$src$core$utils$xml(d));
              h.setAttribute("pinned", `${g}`);
              h.setAttribute("h", `${f.height}`);
              h.setAttribute("w", `${f.width}`);
              e && (h.setAttribute("x", `${a.workspace.RTL ? a.workspace.getWidth() - (e.x + f.width) : e.x}`), h.setAttribute("y", `${e.y}`));
              c.appendChild(h);
            }
            a.data && (d = $.createElement$$module$build$src$core$utils$xml("data"), d.appendChild($.createTextNode$$module$build$src$core$utils$xml(a.data)), c.appendChild(d));
            for (d = 0; d < a.inputList.length; d++) {
              f = a.inputList[d];
              var k = void 0;
              g = true;
              f.type !== $.inputTypes$$module$build$src$core$inputs$input_types.DUMMY && f.type !== $.inputTypes$$module$build$src$core$inputs$input_types.END_ROW && (e = f.connection.targetBlock(), f.type === $.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? k = $.createElement$$module$build$src$core$utils$xml("value") : f.type === $.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT && (k = $.createElement$$module$build$src$core$utils$xml("statement")), h = f.connection.getShadowDom(), !h || e && e.isShadow() || k.appendChild(cloneShadow$$module$build$src$core$xml(h, b)), e && (e = blockToDom$$module$build$src$core$xml(e, b), e.nodeType === NodeType$$module$build$src$core$utils$dom.ELEMENT_NODE && (k.appendChild(e), g = false)), k.setAttribute("name", f.name), g || c.appendChild(k));
            }
            a.inputsInline !== void 0 && a.inputsInline !== a.inputsInlineDefault && c.setAttribute("inline", String(a.inputsInline));
            a.isCollapsed() && c.setAttribute("collapsed", "true");
            a.isEnabled() || c.setAttribute(
              "disabled-reasons",
              Array.from(a.getDisabledReasons()).map(encodeURIComponent).join(",")
            );
            a.isOwnDeletable() || c.setAttribute("deletable", "false");
            a.isOwnMovable() || c.setAttribute("movable", "false");
            a.isOwnEditable() || c.setAttribute("editable", "false");
            k = a.getNextBlock();
            let l;
            k && (d = blockToDom$$module$build$src$core$xml(k, b), d.nodeType === NodeType$$module$build$src$core$utils$dom.ELEMENT_NODE && (l = $.createElement$$module$build$src$core$utils$xml("next"), l.appendChild(d), c.appendChild(l)));
            a = a.nextConnection && a.nextConnection.getShadowDom();
            !a || k && k.isShadow() || l.appendChild(cloneShadow$$module$build$src$core$xml(a, b));
            return c;
          };
          cloneShadow$$module$build$src$core$xml = function(a, b) {
            let c = a = a.cloneNode(true), d;
            for (; c; ) if (b && c.nodeName === "shadow" && c.removeAttribute("id"), c.firstChild) c = c.firstChild;
            else {
              for (; c && !c.nextSibling; ) {
                d = c;
                c = c.parentNode;
                let e;
                d.nodeType === NodeType$$module$build$src$core$utils$dom.TEXT_NODE && d.data.trim() === "" && ((e = c) == null ? void 0 : e.firstChild) !== d && removeNode$$module$build$src$core$utils$dom(d);
              }
              c && (d = c, c = c.nextSibling, d.nodeType === NodeType$$module$build$src$core$utils$dom.TEXT_NODE && d.data.trim() === "" && removeNode$$module$build$src$core$utils$dom(d));
            }
            return a;
          };
          domToText$$module$build$src$core$xml = function(a) {
            return domToText$$module$build$src$core$utils$xml(a).replace(/<(\w+)([^<]*)\/>/g, "<$1$2></$1>");
          };
          domToPrettyText$$module$build$src$core$xml = function(a) {
            a = domToText$$module$build$src$core$xml(a).split("<");
            let b = "";
            for (let c = 1; c < a.length; c++) {
              const d = a[c];
              d[0] === "/" && (b = b.substring(2));
              a[c] = b + "<" + d;
              d[0] !== "/" && d.slice(-2) !== "/>" && (b += "  ");
            }
            a = a.join("\n");
            a = a.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>");
            return a.replace(/^\n/, "");
          };
          clearWorkspaceAndLoadFromXml$$module$build$src$core$xml = function(a, b) {
            b.setResizesEnabled(false);
            b.clear();
            a = $.domToWorkspace$$module$build$src$core$xml(a, b);
            b.setResizesEnabled(true);
            return a;
          };
          $.domToWorkspace$$module$build$src$core$xml = function(a, b) {
            let c = 0;
            b.RTL && (c = b.getWidth());
            const d = [];
            startTextWidthCache$$module$build$src$core$utils$dom();
            const e = $.getGroup$$module$build$src$core$events$utils();
            e || $.setGroup$$module$build$src$core$events$utils(true);
            b.setResizesEnabled && b.setResizesEnabled(false);
            let f = true;
            try {
              for (let g = 0, h; h = a.childNodes[g]; g++) {
                const k = h.nodeName.toLowerCase(), l = h;
                if (k === "block" || k === "shadow" && !getRecordUndo$$module$build$src$core$events$utils()) {
                  const m = domToBlockInternal$$module$build$src$core$xml(
                    l,
                    b
                  );
                  d.push(m.id);
                  let n;
                  const p = parseInt((n = l.getAttribute("x")) != null ? n : "10", 10);
                  let r;
                  const q = parseInt((r = l.getAttribute("y")) != null ? r : "10", 10);
                  isNaN(p) || isNaN(q) || m.moveBy(b.RTL ? c - p : p, q, ["create"]);
                  f = false;
                } else {
                  if (k === "shadow") throw TypeError("Shadow block cannot be a top-level block.");
                  if (k === "comment") loadWorkspaceComment$$module$build$src$core$xml(l, b);
                  else if (k === "variables") {
                    if (f) domToVariables$$module$build$src$core$xml(l, b);
                    else throw Error("'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.");
                    f = false;
                  }
                }
              }
            } finally {
              $.setGroup$$module$build$src$core$events$utils(e), b.setResizesEnabled && b.setResizesEnabled(true), b.rendered && triggerQueuedRenders$$module$build$src$core$render_management(), stopTextWidthCache$$module$build$src$core$utils$dom();
            }
            fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.FINISHED_LOADING))(b));
            return d;
          };
          loadWorkspaceComment$$module$build$src$core$xml = function(a, b) {
            var c;
            const d = (c = a.getAttribute("id")) != null ? c : void 0;
            c = b.rendered ? new RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment(b, d) : new WorkspaceComment$$module$build$src$core$comments$workspace_comment(b, d);
            var e;
            c.setText((e = a.textContent) != null ? e : "");
            var f;
            e = parseInt((f = a.getAttribute("x")) != null ? f : "", 10);
            let g;
            f = parseInt((g = a.getAttribute("y")) != null ? g : "", 10);
            isNaN(e) || isNaN(f) || (e = b.RTL ? b.getWidth() - e : e, c.moveTo(new Coordinate$$module$build$src$core$utils$coordinate(e, f)));
            var h;
            b = parseInt((h = a.getAttribute("w")) != null ? h : "", 10);
            let k;
            h = parseInt((k = a.getAttribute("h")) != null ? k : "", 10);
            isNaN(b) || isNaN(h) || c.setSize(new Size$$module$build$src$core$utils$size(b, h));
            a.getAttribute("collapsed") === "true" && c.setCollapsed(true);
            a.getAttribute("editable") === "false" && c.setEditable(false);
            a.getAttribute("movable") === "false" && c.setMovable(false);
            a.getAttribute("deletable") === "false" && c.setDeletable(false);
            return c;
          };
          appendDomToWorkspace$$module$build$src$core$xml = function(a, b) {
            if (!b.getBlocksBoundingBox) return $.domToWorkspace$$module$build$src$core$xml(a, b);
            var c = b.getBlocksBoundingBox();
            a = $.domToWorkspace$$module$build$src$core$xml(a, b);
            if (c && c.top !== c.bottom) {
              var d = c.bottom;
              c = b.RTL ? c.right : c.left;
              var e = Infinity;
              let f = -Infinity, g = Infinity;
              for (let h = 0; h < a.length; h++) {
                const k = b.getBlockById(a[h]).getRelativeToSurfaceXY();
                k.y < g && (g = k.y);
                k.x < e && (e = k.x);
                k.x > f && (f = k.x);
              }
              d = d - g + 10;
              c = b.RTL ? c - f : c - e;
              for (e = 0; e < a.length; e++) b.getBlockById(a[e]).moveBy(
                c,
                d,
                ["create"]
              );
            }
            return a;
          };
          $.domToBlock$$module$build$src$core$xml = function(a, b) {
            a = domToBlockInternal$$module$build$src$core$xml(a, b);
            b.rendered && triggerQueuedRenders$$module$build$src$core$render_management();
            return a;
          };
          domToBlockInternal$$module$build$src$core$xml = function(a, b) {
            $.disable$$module$build$src$core$events$utils();
            var c = b.getAllVariables();
            let d;
            try {
              if (d = domToBlockHeadless$$module$build$src$core$xml(a, b), b.rendered) {
                const e = d, f = d.getDescendants(false);
                e.setConnectionTracking(false);
                for (let g = f.length - 1; g >= 0; g--) f[g].initSvg();
                for (let g = f.length - 1; g >= 0; g--) f[g].queueRender();
                setTimeout(function() {
                  e.disposed || e.setConnectionTracking(true);
                }, 1);
                b.resizeContents();
              } else {
                const e = d.getDescendants(false);
                for (let f = e.length - 1; f >= 0; f--) e[f].initModel();
              }
            } finally {
              $.enable$$module$build$src$core$events$utils();
            }
            if (isEnabled$$module$build$src$core$events$utils()) {
              a = getAddedVariables$$module$build$src$core$variables(b, c);
              for (b = 0; b < a.length; b++) c = a[b], fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_CREATE))(c));
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(d));
            }
            return d;
          };
          domToVariables$$module$build$src$core$xml = function(a, b) {
            for (let d = 0; d < a.children.length; d++) {
              var c = a.children[d];
              const e = c.getAttribute("type"), f = c.getAttribute("id");
              c = c.textContent;
              if (!c) break;
              let g;
              b.getVariableMap().createVariable(c, (g = e) != null ? g : void 0, f);
            }
          };
          mapSupportedXmlTags$$module$build$src$core$xml = function(a) {
            const b = { mutation: [], comment: [], data: [], field: [], input: [], next: [] };
            for (let c = 0; c < a.children.length; c++) {
              const d = a.children[c];
              if (d.nodeType !== NodeType$$module$build$src$core$utils$dom.TEXT_NODE) switch (d.nodeName.toLowerCase()) {
                case "mutation":
                  b.mutation.push(d);
                  break;
                case "comment":
                  b.comment.push(d);
                  break;
                case "data":
                  b.data.push(d);
                  break;
                case "title":
                case "field":
                  b.field.push(d);
                  break;
                case "value":
                case "statement":
                  b.input.push(d);
                  break;
                case "next":
                  b.next.push(d);
                  break;
                default:
                  console.warn("Ignoring unknown tag: " + d.nodeName);
              }
            }
            return b;
          };
          applyMutationTagNodes$$module$build$src$core$xml = function(a, b) {
            let c = false;
            for (let d = 0; d < a.length; d++) {
              const e = a[d];
              b.domToMutation && (b.domToMutation(e), b.initSvg && (c = true));
            }
            return c;
          };
          applyCommentTagNodes$$module$build$src$core$xml = function(a, b) {
            for (let c = 0; c < a.length; c++) {
              const d = a[c], e = d.textContent, f = d.getAttribute("pinned") === "true";
              let g;
              const h = parseInt((g = d.getAttribute("w")) != null ? g : "50", 10);
              let k;
              const l = parseInt((k = d.getAttribute("h")) != null ? k : "50", 10);
              let m, n = parseInt((m = d.getAttribute("x")) != null ? m : "", 10), p;
              const r = parseInt((p = d.getAttribute("y")) != null ? p : "", 10);
              b.setCommentText(e);
              const q = b.getIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT);
              isNaN(h) || isNaN(l) || q.setBubbleSize(new Size$$module$build$src$core$utils$size(h, l));
              q.setBubbleVisible(f);
              setTimeout(() => {
                isNaN(n) || isNaN(r) || (n = b.workspace.RTL ? b.workspace.getWidth() - (n + h) : n, q.setBubbleLocation(new Coordinate$$module$build$src$core$utils$coordinate(n, r)));
                q.setBubbleVisible(f);
              }, 1);
            }
          };
          applyDataTagNodes$$module$build$src$core$xml = function(a, b) {
            for (let c = 0; c < a.length; c++) b.data = a[c].textContent;
          };
          applyFieldTagNodes$$module$build$src$core$xml = function(a, b) {
            for (let c = 0; c < a.length; c++) {
              const d = a[c], e = d.getAttribute("name");
              e ? domToField$$module$build$src$core$xml(b, e, d) : console.warn(`Ignoring unnamed field in block ${b.type}`);
            }
          };
          findChildBlocks$$module$build$src$core$xml = function(a) {
            let b = null, c = null;
            for (let d = 0; d < a.childNodes.length; d++) {
              const e = a.childNodes[d];
              isElement$$module$build$src$core$xml(e) && (e.nodeName.toLowerCase() === "block" ? b = e : e.nodeName.toLowerCase() === "shadow" && (c = e));
            }
            return { childBlockElement: b, childShadowElement: c };
          };
          applyInputTagNodes$$module$build$src$core$xml = function(a, b, c, d) {
            for (let f = 0; f < a.length; f++) {
              var e = a[f];
              const g = e.getAttribute("name"), h = g ? c.getInput(g) : null;
              if (!h) {
                console.warn("Ignoring non-existent input " + g + " in block " + d);
                break;
              }
              e = findChildBlocks$$module$build$src$core$xml(e);
              if (e.childBlockElement) {
                if (!h.connection) throw TypeError("Input connection does not exist.");
                domToBlockHeadless$$module$build$src$core$xml(e.childBlockElement, b, h.connection, false);
              }
              if (e.childShadowElement) {
                let k;
                (k = h.connection) == null || k.setShadowDom(e.childShadowElement);
              }
            }
          };
          applyNextTagNodes$$module$build$src$core$xml = function(a, b, c) {
            for (let d = 0; d < a.length; d++) {
              const e = findChildBlocks$$module$build$src$core$xml(a[d]);
              if (e.childBlockElement) {
                if (!c.nextConnection) throw TypeError("Next statement does not exist.");
                if (c.nextConnection.isConnected()) throw TypeError("Next statement is already connected.");
                domToBlockHeadless$$module$build$src$core$xml(e.childBlockElement, b, c.nextConnection, true);
              }
              e.childShadowElement && c.nextConnection && c.nextConnection.setShadowDom(e.childShadowElement);
            }
          };
          domToBlockHeadless$$module$build$src$core$xml = function(a, b, c, d) {
            var e;
            const f = a.getAttribute("type");
            if (!f) throw TypeError("Block type unspecified: " + a.outerHTML);
            var g = (e = a.getAttribute("id")) != null ? e : void 0;
            e = b.newBlock(f, g);
            g = mapSupportedXmlTags$$module$build$src$core$xml(a);
            const h = applyMutationTagNodes$$module$build$src$core$xml(g.mutation, e);
            applyCommentTagNodes$$module$build$src$core$xml(g.comment, e);
            applyDataTagNodes$$module$build$src$core$xml(g.data, e);
            if (c) if (d) if (e.previousConnection) c.connect(e.previousConnection);
            else throw TypeError("Next block does not have previous statement.");
            else if (e.outputConnection) c.connect(e.outputConnection);
            else if (e.previousConnection) c.connect(e.previousConnection);
            else throw TypeError("Child block does not have output or previous statement.");
            applyFieldTagNodes$$module$build$src$core$xml(g.field, e);
            applyInputTagNodes$$module$build$src$core$xml(g.input, b, e, f);
            applyNextTagNodes$$module$build$src$core$xml(g.next, b, e);
            h && e.initSvg();
            (b = a.getAttribute("inline")) && e.setInputsInline(b === "true");
            (b = a.getAttribute("disabled")) && e.setDisabledReason(b === "true" || b === "disabled", MANUALLY_DISABLED$$module$build$src$core$constants);
            b = a.getAttribute("disabled-reasons");
            if (b !== null) for (var k of b.split(",")) e.setDisabledReason(true, decodeURIComponent(k));
            (k = a.getAttribute("deletable")) && e.setDeletable(k === "true");
            (k = a.getAttribute("movable")) && e.setMovable(k === "true");
            (k = a.getAttribute("editable")) && e.setEditable(k === "true");
            (k = a.getAttribute("collapsed")) && e.setCollapsed(k === "true");
            if (a.nodeName.toLowerCase() === "shadow") {
              a = e.getChildren(false);
              for (k = 0; k < a.length; k++) if (!a[k].isShadow()) throw TypeError("Shadow block not allowed non-shadow child.");
              e.setShadow(true);
            }
            return e;
          };
          domToField$$module$build$src$core$xml = function(a, b, c) {
            const d = a.getField(b);
            d ? d.fromXml(c) : console.warn("Ignoring non-existent field " + b + " in block " + a.type);
          };
          deleteNext$$module$build$src$core$xml = function(a) {
            for (let b = 0; b < a.childNodes.length; b++) {
              const c = a.childNodes[b];
              if (c.nodeName.toLowerCase() === "next") {
                a.removeChild(c);
                break;
              }
            }
          };
          isElement$$module$build$src$core$xml = function(a) {
            return a.nodeType === NodeType$$module$build$src$core$utils$dom.ELEMENT_NODE;
          };
          register$$module$build$src$core$field_registry = function(a, b) {
            register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FIELD, a, b, true);
          };
          unregister$$module$build$src$core$field_registry = function(a) {
            unregister$$module$build$src$core$registry(Type$$module$build$src$core$registry.FIELD, a);
          };
          $.fromJson$$module$build$src$core$field_registry = function(a) {
            return TEST_ONLY$$module$build$src$core$field_registry.fromJsonInternal(a);
          };
          fromJsonInternal$$module$build$src$core$field_registry = function(a) {
            const b = getObject$$module$build$src$core$registry(Type$$module$build$src$core$registry.FIELD, a.type);
            return b ? b.fromJson(a) : (console.warn("Blockly could not create a field of type " + a.type + ". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached."), null);
          };
          isImageProperties$$module$build$src$core$field_dropdown = function(a) {
            return a && typeof a === "object" && "src" in a && typeof a.src === "string" && "alt" in a && typeof a.alt === "string" && "width" in a && typeof a.width === "number" && "height" in a && typeof a.height === "number";
          };
          $.register$$module$build$src$core$extensions = function(a, b) {
            if (typeof a !== "string" || a.trim() === "") throw Error('Error: Invalid extension name "' + a + '"');
            if (allExtensions$$module$build$src$core$extensions[a]) throw Error('Error: Extension "' + a + '" is already registered.');
            if (typeof b !== "function") throw Error('Error: Extension "' + a + '" must be a function');
            allExtensions$$module$build$src$core$extensions[a] = b;
          };
          $.registerMixin$$module$build$src$core$extensions = function(a, b) {
            if (!b || typeof b !== "object") throw Error('Error: Mixin "' + a + '" must be a object');
            $.register$$module$build$src$core$extensions(a, function() {
              this.mixin(b);
            });
          };
          $.registerMutator$$module$build$src$core$extensions = function(a, b, c, d) {
            const e = 'Error when registering mutator "' + a + '": ';
            checkHasMutatorProperties$$module$build$src$core$extensions(e, b);
            const f = checkMutatorDialog$$module$build$src$core$extensions(b, e);
            if (c && typeof c !== "function") throw Error(e + 'Extension "' + a + '" is not a function');
            $.register$$module$build$src$core$extensions(a, function() {
              f && this.setMutator(new $.MutatorIcon$$module$build$src$core$icons$mutator_icon(d || [], this));
              this.mixin(b);
              c && c.apply(this);
            });
          };
          unregister$$module$build$src$core$extensions = function(a) {
            isRegistered$$module$build$src$core$extensions(a) ? delete allExtensions$$module$build$src$core$extensions[a] : console.warn('No extension mapping for name "' + a + '" found to unregister');
          };
          isRegistered$$module$build$src$core$extensions = function(a) {
            return !!allExtensions$$module$build$src$core$extensions[a];
          };
          apply$$module$build$src$core$extensions = function(a, b, c) {
            const d = allExtensions$$module$build$src$core$extensions[a];
            if (typeof d !== "function") throw Error('Error: Extension "' + a + '" not found.');
            let e;
            c ? checkNoMutatorProperties$$module$build$src$core$extensions(a, b) : e = getMutatorProperties$$module$build$src$core$extensions(b);
            d.apply(b);
            if (c) checkHasMutatorProperties$$module$build$src$core$extensions('Error after applying mutator "' + a + '": ', b);
            else if (!mutatorPropertiesMatch$$module$build$src$core$extensions(
              e,
              b
            )) throw Error('Error when applying extension "' + a + '": mutation properties changed when applying a non-mutator extension.');
          };
          checkNoMutatorProperties$$module$build$src$core$extensions = function(a, b) {
            if (getMutatorProperties$$module$build$src$core$extensions(b).length) throw Error('Error: tried to apply mutation "' + a + '" to a block that already has mutator functions.  Block id: ' + b.id);
          };
          checkXmlHooks$$module$build$src$core$extensions = function(a, b) {
            return checkHasFunctionPair$$module$build$src$core$extensions(a.mutationToDom, a.domToMutation, b + " mutationToDom/domToMutation");
          };
          checkJsonHooks$$module$build$src$core$extensions = function(a, b) {
            return checkHasFunctionPair$$module$build$src$core$extensions(a.saveExtraState, a.loadExtraState, b + " saveExtraState/loadExtraState");
          };
          checkMutatorDialog$$module$build$src$core$extensions = function(a, b) {
            return checkHasFunctionPair$$module$build$src$core$extensions(a.compose, a.decompose, b + " compose/decompose");
          };
          checkHasFunctionPair$$module$build$src$core$extensions = function(a, b, c) {
            if (a && b) {
              if (typeof a !== "function" || typeof b !== "function") throw Error(c + " must be a function");
              return true;
            }
            if (!a && !b) return false;
            throw Error(c + "Must have both or neither functions");
          };
          checkHasMutatorProperties$$module$build$src$core$extensions = function(a, b) {
            const c = checkXmlHooks$$module$build$src$core$extensions(b, a), d = checkJsonHooks$$module$build$src$core$extensions(b, a);
            if (!c && !d) throw Error(a + "Mutations must contain either XML hooks, or JSON hooks, or both");
            checkMutatorDialog$$module$build$src$core$extensions(b, a);
          };
          getMutatorProperties$$module$build$src$core$extensions = function(a) {
            const b = [];
            a.domToMutation !== void 0 && b.push(a.domToMutation);
            a.mutationToDom !== void 0 && b.push(a.mutationToDom);
            a.saveExtraState !== void 0 && b.push(a.saveExtraState);
            a.loadExtraState !== void 0 && b.push(a.loadExtraState);
            a.compose !== void 0 && b.push(a.compose);
            a.decompose !== void 0 && b.push(a.decompose);
            return b;
          };
          mutatorPropertiesMatch$$module$build$src$core$extensions = function(a, b) {
            b = getMutatorProperties$$module$build$src$core$extensions(b);
            if (b.length !== a.length) return false;
            for (let c = 0; c < b.length; c++) if (a[c] !== b[c]) return false;
            return true;
          };
          runAfterPageLoad$$module$build$src$core$extensions = function(a) {
            if (typeof document !== "object") throw Error("runAfterPageLoad() requires browser document.");
            if (document.readyState === "complete") a();
            else {
              const b = setInterval(function() {
                document.readyState === "complete" && (clearInterval(b), a());
              }, 10);
            }
          };
          $.buildTooltipForDropdown$$module$build$src$core$extensions = function(a, b) {
            const c = [];
            return function() {
              c.includes(this.type) || (checkDropdownOptionsInTable$$module$build$src$core$extensions(this, a, b), c.push(this.type));
              this.setTooltip(function() {
                const d = String(this.getFieldValue(a));
                return replaceMessageReferences$$module$build$src$core$utils$parsing(b[d]);
              }.bind(this));
            };
          };
          checkDropdownOptionsInTable$$module$build$src$core$extensions = function(a, b, c) {
            var d = a.getField(b);
            if (d instanceof FieldDropdown$$module$build$src$core$field_dropdown && !d.isOptionListDynamic()) {
              d = d.getOptions();
              for (const e of d) e !== FieldDropdown$$module$build$src$core$field_dropdown.SEPARATOR && ([, d] = e, c[d] === void 0 && console.warn(`No tooltip mapping for value ${d} of field ${b} of block type ${a.type}.`));
            }
          };
          $.buildTooltipWithFieldText$$module$build$src$core$extensions = function(a, b) {
            return function() {
              this.setTooltip(function() {
                const c = this.getField(b);
                return replaceMessageReferences$$module$build$src$core$utils$parsing(a).replace("%1", c ? c.getText() : "");
              }.bind(this));
            };
          };
          extensionParentTooltip$$module$build$src$core$extensions = function() {
            const a = this.tooltip;
            this.setTooltip(function() {
              const b = this.getParent();
              return b && b.getInputsInline() && b.tooltip || a;
            }.bind(this));
          };
          point$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " " + a + "," + b + " ";
          };
          curve$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " " + a + b.join("");
          };
          moveTo$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " M " + a + "," + b + " ";
          };
          moveBy$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " m " + a + "," + b + " ";
          };
          lineTo$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " l " + a + "," + b + " ";
          };
          line$$module$build$src$core$utils$svg_paths = function(a) {
            return " l" + a.join("");
          };
          lineOnAxis$$module$build$src$core$utils$svg_paths = function(a, b) {
            return " " + a + " " + b + " ";
          };
          arc$$module$build$src$core$utils$svg_paths = function(a, b, c, d) {
            return a + " " + c + " " + c + " " + b + d;
          };
          connectReciprocally$$module$build$src$core$connection = function(a, b) {
            if (!a || !b) throw Error("Cannot connect null connections.");
            a.targetConnection = b;
            b.targetConnection = a;
          };
          getSingleConnection$$module$build$src$core$connection = function(a, b) {
            let c = null;
            b = b.outputConnection;
            const d = b == null ? void 0 : b.getConnectionChecker();
            for (let e = 0, f; f = a.inputList[e]; e++) {
              const g = f.connection;
              let h;
              if (g && ((h = d) == null ? 0 : h.canConnect(b, g, false))) {
                if (c) return null;
                c = g;
              }
            }
            return c;
          };
          getConnectionForOrphanedOutput$$module$build$src$core$connection = function(a, b) {
            let c;
            for (; c = getSingleConnection$$module$build$src$core$connection(a, b); ) if (a = c.targetBlock(), !a || a.isShadow()) return c;
            return null;
          };
          isIcon$$module$build$src$core$interfaces$i_icon = function(a) {
            return isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(a) && typeof a.getType === "function" && typeof a.initView === "function" && typeof a.dispose === "function" && typeof a.getWeight === "function" && typeof a.getSize === "function" && typeof a.applyColour === "function" && typeof a.hideForInsertionMarker === "function" && typeof a.updateEditable === "function" && typeof a.updateCollapsed === "function" && typeof a.isShownWhenCollapsed === "function" && typeof a.setOffsetInBlock === "function" && typeof a.onLocationChange === "function" && typeof a.onClick === "function";
          };
          isCommentIcon$$module$build$src$core$interfaces$i_comment_icon = function(a) {
            return isIcon$$module$build$src$core$interfaces$i_icon(a) && hasBubble$$module$build$src$core$interfaces$i_has_bubble(a) && isSerializable$$module$build$src$core$interfaces$i_serializable(a) && typeof a.setText === "function" && typeof a.getText === "function" && typeof a.setBubbleSize === "function" && typeof a.getBubbleSize === "function" && typeof a.setBubbleLocation === "function" && typeof a.getBubbleLocation === "function" && a.getType() === IconType$$module$build$src$core$icons$icon_types.COMMENT;
          };
          disposeUiEffect$$module$build$src$core$block_animations = function(a) {
            if (!(a.getDescendants(false).length > 100)) {
              var b = a.workspace, c = a.getSvgRoot();
              b.getAudioManager().play("delete");
              var d = a.getRelativeToSurfaceXY(), e = c.cloneNode(true);
              e.setAttribute("transform", "translate(" + d.x + "," + d.y + ")");
              var f;
              (f = b.getLayerManager()) == null || f.appendToAnimationLayer({ getSvgRoot: () => e });
              disposeUiStep$$module$build$src$core$block_animations(e, { x: d.x, y: d.y, width: a.width, height: a.height }, b.RTL, /* @__PURE__ */ new Date());
            }
          };
          disposeUiStep$$module$build$src$core$block_animations = function(a, b, c, d) {
            const e = ((/* @__PURE__ */ new Date()).getTime() - d.getTime()) / 150;
            e > 1 ? removeNode$$module$build$src$core$utils$dom(a) : (a.setAttribute("transform", "translate(" + (b.x + (c ? -1 : 1) * b.width / 2 * e) + "," + (b.y + b.height / 2 * e) + ") scale(" + (1 - e) + ")"), setTimeout(disposeUiStep$$module$build$src$core$block_animations, 10, a, b, c, d));
          };
          connectionUiEffect$$module$build$src$core$block_animations = function(a) {
            var b = a.workspace;
            const c = b.scale;
            b.getAudioManager().play("click");
            if (!(c < 1)) {
              var d = b.getSvgXY(a.getSvgRoot());
              a.outputConnection ? (d.x += (a.RTL ? 3 : -3) * c, d.y += 13 * c) : a.previousConnection && (d.x += (a.RTL ? -23 : 23) * c, d.y += 3 * c);
              var e = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CIRCLE, { cx: d.x, cy: d.y, r: 0, fill: "none", stroke: "#888", "stroke-width": 10 }, b.getParentSvg());
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.ANIMATE,
                { id: "animationCircle", begin: "indefinite", attributeName: "r", dur: "150ms", from: 0, to: 25 * c },
                e
              );
              b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.ANIMATE, { id: "animationOpacity", begin: "indefinite", attributeName: "opacity", dur: "150ms", from: 1, to: 0 }, e);
              a.beginElement();
              b.beginElement();
              setTimeout(() => void removeNode$$module$build$src$core$utils$dom(e), 150);
            }
          };
          disconnectUiEffect$$module$build$src$core$block_animations = function(a) {
            disconnectUiStop$$module$build$src$core$block_animations();
            a.workspace.getAudioManager().play("disconnect");
            if (!(a.workspace.scale < 1)) {
              var b = a.getHeightWidth().height;
              b = Math.atan(10 / b) / Math.PI * 180;
              a.RTL || (b *= -1);
              wobblingBlock$$module$build$src$core$block_animations = a;
              disconnectUiStep$$module$build$src$core$block_animations(a, b, /* @__PURE__ */ new Date(), 0);
            }
          };
          disconnectUiStep$$module$build$src$core$block_animations = function(a, b, c, d) {
            const e = [0.66, 1, 0.66, 0, -0.66, -1, -0.66, 0];
            let f = "";
            c.getTime() + 200 > (/* @__PURE__ */ new Date()).getTime() && (f = `skewX(${Math.round(e[d % e.length] * b)})`, disconnectPid$$module$build$src$core$block_animations = setTimeout(disconnectUiStep$$module$build$src$core$block_animations, 15, a, b, c, d + 1));
            a.getSvgRoot().setAttribute("transform", `${a.getTranslation()} ${f}`);
          };
          disconnectUiStop$$module$build$src$core$block_animations = function() {
            wobblingBlock$$module$build$src$core$block_animations && (disconnectPid$$module$build$src$core$block_animations && (clearTimeout(disconnectPid$$module$build$src$core$block_animations), disconnectPid$$module$build$src$core$block_animations = null), wobblingBlock$$module$build$src$core$block_animations.getSvgRoot().setAttribute("transform", wobblingBlock$$module$build$src$core$block_animations.getTranslation()), wobblingBlock$$module$build$src$core$block_animations = null);
          };
          moveBlockToNotConflict$$module$build$src$core$clipboard$block_paster = function(a, b) {
            a.workspace.RTL && (b.x = a.workspace.getWidth() - b.x);
            const c = a.workspace, d = $.config$$module$build$src$core$config.snapRadius, e = Coordinate$$module$build$src$core$utils$coordinate.difference(b, a.getRelativeToSurfaceXY()), f = new Coordinate$$module$build$src$core$utils$coordinate(0, 0), g = c.getAllBlocks(false).filter((h) => h.id != a.id).map((h) => h.getRelativeToSurfaceXY());
            for (; blockOverlapsOtherExactly$$module$build$src$core$clipboard$block_paster(
              Coordinate$$module$build$src$core$utils$coordinate.sum(b, f),
              g
            ) || blockIsInSnapRadius$$module$build$src$core$clipboard$block_paster(a, Coordinate$$module$build$src$core$utils$coordinate.sum(e, f), d); ) c.RTL ? f.translate(-d, d * 2) : f.translate(d, d * 2);
            a.moveTo(Coordinate$$module$build$src$core$utils$coordinate.sum(b, f));
          };
          blockOverlapsOtherExactly$$module$build$src$core$clipboard$block_paster = function(a, b) {
            return b.some((c) => Math.abs(c.x - a.x) <= 1 && Math.abs(c.y - a.y) <= 1);
          };
          blockIsInSnapRadius$$module$build$src$core$clipboard$block_paster = function(a, b, c) {
            return a.getConnections_(false).some((d) => !!d.closest(c, b).connection);
          };
          bumpObjectIntoBounds$$module$build$src$core$bump_objects = function(a, b, c) {
            const d = c.getBoundingRectangle(), e = d.right - d.left, f = clamp$$module$build$src$core$utils$math(b.top, d.top, b.top + b.height - (d.bottom - d.top)) - d.top;
            let g = b.left;
            b = b.left + b.width - e;
            a.RTL ? g = Math.min(b, g) : b = Math.max(g, b);
            return (a = clamp$$module$build$src$core$utils$math(g, d.left, b) - d.left) || f ? (c.moveBy(a, f, ["inbounds"]), true) : false;
          };
          bumpIntoBoundsHandler$$module$build$src$core$bump_objects = function(a) {
            return (b) => {
              var c = a.getMetricsManager();
              if (c.hasFixedEdges() && !a.isDragging()) {
                var d;
                if (BUMP_EVENTS$$module$build$src$core$events$type.includes((d = b.type) != null ? d : "")) {
                  d = c.getScrollMetrics(true);
                  const e = extractObjectFromEvent$$module$build$src$core$bump_objects(a, b);
                  e && (c = $.getGroup$$module$build$src$core$events$utils() || false, $.setGroup$$module$build$src$core$events$utils(b.group), bumpObjectIntoBounds$$module$build$src$core$bump_objects(
                    a,
                    d,
                    e
                  ) && !b.group && console.warn("Moved object in bounds but there was no event group. This may break undo."), $.setGroup$$module$build$src$core$events$utils(c));
                } else isViewportChange$$module$build$src$core$events$predicates(b) && b.scale && b.oldScale && b.scale > b.oldScale && bumpTopObjectsIntoBounds$$module$build$src$core$bump_objects(a);
              }
            };
          };
          extractObjectFromEvent$$module$build$src$core$bump_objects = function(a, b) {
            let c = null;
            switch (b.type) {
              case EventType$$module$build$src$core$events$type.BLOCK_CREATE:
              case EventType$$module$build$src$core$events$type.BLOCK_MOVE:
                (c = a.getBlockById(b.blockId)) && (c = c.getRootBlock());
                break;
              case EventType$$module$build$src$core$events$type.COMMENT_CREATE:
              case EventType$$module$build$src$core$events$type.COMMENT_MOVE:
              case EventType$$module$build$src$core$events$type.COMMENT_RESIZE:
                c = a.getCommentById(b.commentId);
            }
            return c;
          };
          bumpTopObjectsIntoBounds$$module$build$src$core$bump_objects = function(a) {
            var b = a.getMetricsManager();
            if (b.hasFixedEdges() && !a.isDragging()) {
              b = b.getScrollMetrics(true);
              var c = a.getTopBoundedElements();
              for (let d = 0, e; e = c[d]; d++) bumpObjectIntoBounds$$module$build$src$core$bump_objects(a, b, e);
            }
          };
          isDeletable$$module$build$src$core$interfaces$i_deletable = function(a) {
            return a && typeof a.isDeletable === "function" && typeof a.dispose === "function" && typeof a.setDeleteStyle === "function";
          };
          getBlockNavigationCandidates$$module$build$src$core$keyboard_nav$block_navigation_policy = function(a, b) {
            const c = a.getIcons();
            for (const d of a.inputList) {
              if (!d.isVisible()) continue;
              c.push(...d.fieldRow);
              let e;
              if ((e = d.connection) == null ? 0 : e.targetBlock()) if (a = d.connection.targetBlock(), d.connection.type !== ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT || b) c.push(a);
              else {
                let f;
                (a = (f = a.lastConnectionInStack(false)) == null ? void 0 : f.getSourceBlock()) && c.push(a);
              }
              else {
                let f;
                ((f = d.connection) == null ? void 0 : f.type) === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE && c.push(d.connection);
              }
            }
            return c;
          };
          navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy = function(a, b) {
            const c = a.workspace.getTopBoundedElements(true).filter((e) => isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(e));
            a = c.indexOf(a instanceof BlockSvg$$module$build$src$core$block_svg ? a.getRootBlock() : a) + b;
            let d = null;
            a >= 0 && a < c.length ? d = c[a] : a < 0 ? d = c[c.length - 1] : a >= c.length && (d = c[0]);
            if (b < 0 && d instanceof BlockSvg$$module$build$src$core$block_svg) {
              let e, f;
              return (f = (e = d.lastConnectionInStack(false)) == null ? void 0 : e.getSourceBlock()) != null ? f : d;
            }
            return d;
          };
          navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy = function(a, b) {
            var c;
            let d;
            const e = a instanceof BlockSvg$$module$build$src$core$block_svg ? (d = (c = a.outputConnection) == null ? void 0 : c.targetBlock()) != null ? d : a.getSurroundParent() : a.getSourceBlock();
            if (!(e instanceof BlockSvg$$module$build$src$core$block_svg)) return null;
            c = getBlockNavigationCandidates$$module$build$src$core$keyboard_nav$block_navigation_policy(e, b > 0);
            a = c.indexOf(a);
            if (a === -1) return null;
            b = a + b;
            return b >= 0 && b < c.length ? c[b] : null;
          };
          register$$module$build$src$core$icons$registry = function(a, b) {
            register$$module$build$src$core$registry(Type$$module$build$src$core$registry.ICON, a.toString(), b);
          };
          unregister$$module$build$src$core$icons$registry = function(a) {
            unregister$$module$build$src$core$registry(Type$$module$build$src$core$registry.ICON, a);
          };
          isDraggable$$module$build$src$core$interfaces$i_draggable = function(a) {
            return a && typeof a.getRelativeToSurfaceXY === "function" && typeof a.isMovable === "function" && typeof a.startDrag === "function" && typeof a.drag === "function" && typeof a.endDrag === "function" && typeof a.revertDrag === "function";
          };
          isAutoHideable$$module$build$src$core$interfaces$i_autohideable = function(a) {
            return a && typeof a.autoHide === "function";
          };
          isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block = function(a) {
            return typeof a.getProcedureModel === "function" && typeof a.doProcedureUpdate === "function" && typeof a.isProcedureDef === "function";
          };
          isObservable$$module$build$src$core$interfaces$i_observable = function(a) {
            return a && typeof a.startPublishing === "function" && typeof a.stopPublishing === "function";
          };
          allProcedures$$module$build$src$core$procedures = function(a) {
            const b = a.getProcedureMap().getProcedures().filter((d) => !d.getReturnTypes()).map((d) => [d.getName(), d.getParameters().map((e) => e.getName()), false]);
            a.getBlocksByType("procedures_defnoreturn", false).forEach((d) => {
              !isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(d) && isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(d) && b.push(d.getProcedureDef());
            });
            const c = a.getProcedureMap().getProcedures().filter((d) => !!d.getReturnTypes()).map((d) => [d.getName(), d.getParameters().map((e) => e.getName()), true]);
            a.getBlocksByType("procedures_defreturn", false).forEach((d) => {
              !isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(d) && isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(d) && c.push(d.getProcedureDef());
            });
            b.sort(procTupleComparator$$module$build$src$core$procedures);
            c.sort(procTupleComparator$$module$build$src$core$procedures);
            return [b, c];
          };
          procTupleComparator$$module$build$src$core$procedures = function(a, b) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          };
          $.findLegalName$$module$build$src$core$procedures = function(a, b) {
            if (b.isInFlyout) return a;
            for (a = a || $.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed"; !isLegalName$$module$build$src$core$procedures(a, b.workspace, b); ) {
              const c = a.match(/^(.*?)(\d+)$/);
              a = c ? c[1] + (parseInt(c[2]) + 1) : a + "2";
            }
            return a;
          };
          isLegalName$$module$build$src$core$procedures = function(a, b, c) {
            return !isNameUsed$$module$build$src$core$procedures(a, b, c);
          };
          isNameUsed$$module$build$src$core$procedures = function(a, b, c) {
            for (const d of b.getAllBlocks(false)) if (d !== c && isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(d) && $.Names$$module$build$src$core$names.equals(d.getProcedureDef()[0], a)) return true;
            c = c && isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(c) ? c == null ? void 0 : c.getProcedureModel() : void 0;
            for (const d of b.getProcedureMap().getProcedures()) if (d !== c && $.Names$$module$build$src$core$names.equals(
              d.getName(),
              a
            )) return true;
            return false;
          };
          $.rename$$module$build$src$core$procedures = function(a) {
            var b = this.getSourceBlock();
            if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
            a = a.trim();
            const c = $.findLegalName$$module$build$src$core$procedures(a, b);
            isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(b) && !b.isInsertionMarker() && b.getProcedureModel().setName(c);
            const d = this.getValue();
            if (d !== a && d !== c) for (a = b.workspace.getAllBlocks(false), b = 0; b < a.length; b++) {
              const e = a[b];
              e.renameProcedure && e.renameProcedure(d, c);
            }
            return c;
          };
          xmlFlyoutCategory$$module$build$src$core$procedures = function(a) {
            function b(f, g) {
              for (let k = 0; k < f.length; k++) {
                var h = f[k][0];
                const l = f[k][1], m = $.createElement$$module$build$src$core$utils$xml("block");
                m.setAttribute("type", g);
                m.setAttribute("gap", "16");
                const n = $.createElement$$module$build$src$core$utils$xml("mutation");
                n.setAttribute("name", h);
                m.appendChild(n);
                for (h = 0; h < l.length; h++) {
                  const p = $.createElement$$module$build$src$core$utils$xml("arg");
                  p.setAttribute("name", l[h]);
                  n.appendChild(p);
                }
                c.push(m);
              }
            }
            const c = [];
            if (Blocks$$module$build$src$core$blocks.procedures_defnoreturn) {
              var d = $.createElement$$module$build$src$core$utils$xml("block");
              d.setAttribute("type", "procedures_defnoreturn");
              d.setAttribute("gap", "16");
              var e = $.createElement$$module$build$src$core$utils$xml("field");
              e.setAttribute("name", "NAME");
              e.appendChild($.createTextNode$$module$build$src$core$utils$xml($.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_PROCEDURE));
              d.appendChild(e);
              c.push(d);
            }
            Blocks$$module$build$src$core$blocks.procedures_defreturn && (d = $.createElement$$module$build$src$core$utils$xml("block"), d.setAttribute("type", "procedures_defreturn"), d.setAttribute("gap", "16"), e = $.createElement$$module$build$src$core$utils$xml("field"), e.setAttribute("name", "NAME"), e.appendChild($.createTextNode$$module$build$src$core$utils$xml($.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_PROCEDURE)), d.appendChild(e), c.push(d));
            Blocks$$module$build$src$core$blocks.procedures_ifreturn && (d = $.createElement$$module$build$src$core$utils$xml("block"), d.setAttribute("type", "procedures_ifreturn"), d.setAttribute("gap", "16"), c.push(d));
            c.length && c[c.length - 1].setAttribute("gap", "24");
            a = allProcedures$$module$build$src$core$procedures(a);
            b(a[0], "procedures_callnoreturn");
            b(a[1], "procedures_callreturn");
            return c;
          };
          internalFlyoutCategory$$module$build$src$core$procedures = function(a) {
            return flyoutCategory$$module$build$src$core$procedures(a, false);
          };
          flyoutCategory$$module$build$src$core$procedures = function(a, b = true) {
            function c(e, f) {
              for (const [g, h] of e) d.push({ kind: "block", type: f, gap: 16, extraState: { name: g, params: h } });
            }
            if (b) return warn$$module$build$src$core$utils$deprecation("The XML return value of Blockly.Procedures.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), xmlFlyoutCategory$$module$build$src$core$procedures(a);
            const d = [];
            Blocks$$module$build$src$core$blocks.procedures_defnoreturn && d.push({ kind: "block", type: "procedures_defnoreturn", gap: 16, fields: { NAME: $.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_PROCEDURE } });
            Blocks$$module$build$src$core$blocks.procedures_defreturn && d.push({ kind: "block", type: "procedures_defreturn", gap: 16, fields: { NAME: $.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_PROCEDURE } });
            Blocks$$module$build$src$core$blocks.procedures_ifreturn && d.push({ kind: "block", type: "procedures_ifreturn", gap: 16 });
            d.length && (d[d.length - 1].gap = 24);
            a = allProcedures$$module$build$src$core$procedures(a);
            c(a[0], "procedures_callnoreturn");
            c(a[1], "procedures_callreturn");
            return d;
          };
          updateMutatorFlyout$$module$build$src$core$procedures = function(a) {
            var b = [], c = a.getBlocksByType("procedures_mutatorarg", false);
            for (let f = 0, g; g = c[f]; f++) b.push(g.getFieldValue("NAME"));
            c = $.createElement$$module$build$src$core$utils$xml("xml");
            const d = $.createElement$$module$build$src$core$utils$xml("block");
            d.setAttribute("type", "procedures_mutatorarg");
            const e = $.createElement$$module$build$src$core$utils$xml("field");
            e.setAttribute("name", "NAME");
            b = generateUniqueNameFromOptions$$module$build$src$core$variables(
              $.DEFAULT_ARG$$module$build$src$core$procedures,
              b
            );
            b = $.createTextNode$$module$build$src$core$utils$xml(b);
            e.appendChild(b);
            d.appendChild(e);
            c.appendChild(d);
            a.updateToolbox(c);
          };
          mutatorOpenListener$$module$build$src$core$procedures = function(a) {
            if (isBubbleOpen$$module$build$src$core$events$predicates(a) && a.bubbleType === "mutator" && a.isOpen && a.blockId) {
              a = getWorkspaceById$$module$build$src$core$common(a.workspaceId).getBlockById(a.blockId);
              var b = a.type;
              if (b === "procedures_defnoreturn" || b === "procedures_defreturn") a = a.getIcon($.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE).getWorkspace(), updateMutatorFlyout$$module$build$src$core$procedures(a), a.addChangeListener(mutatorChangeListener$$module$build$src$core$procedures);
            }
          };
          mutatorChangeListener$$module$build$src$core$procedures = function(a) {
            if (isBlockCreate$$module$build$src$core$events$predicates(a) || isBlockDelete$$module$build$src$core$events$predicates(a) || isBlockChange$$module$build$src$core$events$predicates(a) || isBlockFieldIntermediateChange$$module$build$src$core$events$predicates(a)) a = getWorkspaceById$$module$build$src$core$common(a.workspaceId), updateMutatorFlyout$$module$build$src$core$procedures(a);
          };
          getCallers$$module$build$src$core$procedures = function(a, b) {
            return b.getAllBlocks(false).filter((c) => blockIsModernCallerFor$$module$build$src$core$procedures(c, a) || isLegacyProcedureCallBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(c) && $.Names$$module$build$src$core$names.equals(c.getProcedureCall(), a));
          };
          blockIsModernCallerFor$$module$build$src$core$procedures = function(a, b) {
            return isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(a) && !a.isProcedureDef() && a.getProcedureModel() && $.Names$$module$build$src$core$names.equals(a.getProcedureModel().getName(), b);
          };
          $.mutateCallers$$module$build$src$core$procedures = function(a) {
            const b = getRecordUndo$$module$build$src$core$events$utils();
            var c = a.getProcedureDef()[0];
            const d = a.mutationToDom(true);
            a = getCallers$$module$build$src$core$procedures(c, a.workspace);
            for (let f = 0, g; g = a[f]; f++) {
              c = (c = g.mutationToDom()) && domToText$$module$build$src$core$utils$xml(c);
              g.domToMutation && g.domToMutation(d);
              var e = g.mutationToDom();
              e = e && domToText$$module$build$src$core$utils$xml(e);
              c !== e && ($.setRecordUndo$$module$build$src$core$events$utils(false), fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(g, "mutation", null, c, e)), $.setRecordUndo$$module$build$src$core$events$utils(b));
            }
          };
          $.getDefinition$$module$build$src$core$procedures = function(a, b) {
            for (const c of b.getAllBlocks(false)) if (isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block(c) && c.isProcedureDef() && $.Names$$module$build$src$core$names.equals(c.getProcedureModel().getName(), a) || isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks(c) && $.Names$$module$build$src$core$names.equals(c.getProcedureDef()[0], a)) return c;
            return null;
          };
          isDynamicShape$$module$build$src$core$renderers$common$constants = function(a) {
            return a.isDynamic;
          };
          isPuzzleTab$$module$build$src$core$renderers$common$constants = function(a) {
            return a.pathDown !== void 0 && a.pathUp !== void 0;
          };
          isNotch$$module$build$src$core$renderers$common$constants = function(a) {
            return a.pathLeft !== void 0 && a.pathRight !== void 0;
          };
          register$$module$build$src$core$renderers$common$block_rendering = function(a, b) {
            register$$module$build$src$core$registry(Type$$module$build$src$core$registry.RENDERER, a, b);
          };
          unregister$$module$build$src$core$renderers$common$block_rendering = function(a) {
            unregister$$module$build$src$core$registry(Type$$module$build$src$core$registry.RENDERER, a);
          };
          init$$module$build$src$core$renderers$common$block_rendering = function(a, b, c) {
            a = new (getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.RENDERER, a))(a);
            a.init(b, c);
            return a;
          };
          stringButtonClickHandler$$module$build$src$core$variables_dynamic = function(a) {
            createVariableButtonHandler$$module$build$src$core$variables(a.getTargetWorkspace(), void 0, "String");
          };
          numberButtonClickHandler$$module$build$src$core$variables_dynamic = function(a) {
            createVariableButtonHandler$$module$build$src$core$variables(a.getTargetWorkspace(), void 0, "Number");
          };
          colourButtonClickHandler$$module$build$src$core$variables_dynamic = function(a) {
            createVariableButtonHandler$$module$build$src$core$variables(a.getTargetWorkspace(), void 0, "Colour");
          };
          internalFlyoutCategory$$module$build$src$core$variables_dynamic = function(a) {
            return flyoutCategory$$module$build$src$core$variables_dynamic(a, false);
          };
          flyoutCategory$$module$build$src$core$variables_dynamic = function(a, b = true) {
            Blocks$$module$build$src$core$blocks.variables_set_dynamic || Blocks$$module$build$src$core$blocks.variables_get_dynamic || console.warn("There are no dynamic variable blocks, but there is a dynamic variable category.");
            if (b) return warn$$module$build$src$core$utils$deprecation("The XML return value of Blockly.VariablesDynamic.flyoutCategory()", "v12", "v13", "the same method, but handle a return type of FlyoutItemInfo[] (JSON) instead."), xmlFlyoutCategory$$module$build$src$core$variables_dynamic(a);
            a.registerButtonCallback("CREATE_VARIABLE_STRING", stringButtonClickHandler$$module$build$src$core$variables_dynamic);
            a.registerButtonCallback("CREATE_VARIABLE_NUMBER", numberButtonClickHandler$$module$build$src$core$variables_dynamic);
            a.registerButtonCallback("CREATE_VARIABLE_COLOUR", colourButtonClickHandler$$module$build$src$core$variables_dynamic);
            return [
              { kind: "button", text: $.Msg$$module$build$src$core$msg.NEW_STRING_VARIABLE, callbackkey: "CREATE_VARIABLE_STRING" },
              { kind: "button", text: $.Msg$$module$build$src$core$msg.NEW_NUMBER_VARIABLE, callbackkey: "CREATE_VARIABLE_NUMBER" },
              { kind: "button", text: $.Msg$$module$build$src$core$msg.NEW_COLOUR_VARIABLE, callbackkey: "CREATE_VARIABLE_COLOUR" },
              ...jsonFlyoutCategoryBlocks$$module$build$src$core$variables(a, a.getVariableMap().getAllVariables(), false, "variables_get_dynamic", "variables_set_dynamic")
            ];
          };
          xmlFlyoutCategory$$module$build$src$core$variables_dynamic = function(a) {
            let b = [], c = document.createElement("button");
            c.setAttribute("text", $.Msg$$module$build$src$core$msg.NEW_STRING_VARIABLE);
            c.setAttribute("callbackKey", "CREATE_VARIABLE_STRING");
            b.push(c);
            c = document.createElement("button");
            c.setAttribute("text", $.Msg$$module$build$src$core$msg.NEW_NUMBER_VARIABLE);
            c.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER");
            b.push(c);
            c = document.createElement("button");
            c.setAttribute("text", $.Msg$$module$build$src$core$msg.NEW_COLOUR_VARIABLE);
            c.setAttribute("callbackKey", "CREATE_VARIABLE_COLOUR");
            b.push(c);
            a.registerButtonCallback("CREATE_VARIABLE_STRING", stringButtonClickHandler$$module$build$src$core$variables_dynamic);
            a.registerButtonCallback("CREATE_VARIABLE_NUMBER", numberButtonClickHandler$$module$build$src$core$variables_dynamic);
            a.registerButtonCallback("CREATE_VARIABLE_COLOUR", colourButtonClickHandler$$module$build$src$core$variables_dynamic);
            a = flyoutCategoryBlocks$$module$build$src$core$variables_dynamic(a);
            return b = b.concat(a);
          };
          flyoutCategoryBlocks$$module$build$src$core$variables_dynamic = function(a) {
            a = a.getVariableMap().getAllVariables();
            const b = [];
            if (a.length > 0) {
              if (Blocks$$module$build$src$core$blocks.variables_set_dynamic) {
                var c = a[a.length - 1];
                const d = $.createElement$$module$build$src$core$utils$xml("block");
                d.setAttribute("type", "variables_set_dynamic");
                d.setAttribute("gap", "24");
                d.appendChild(generateVariableFieldDom$$module$build$src$core$variables(c));
                b.push(d);
              }
              if (Blocks$$module$build$src$core$blocks.variables_get_dynamic) {
                a.sort(compareByName$$module$build$src$core$variables);
                for (let d = 0, e; e = a[d]; d++) c = $.createElement$$module$build$src$core$utils$xml("block"), c.setAttribute("type", "variables_get_dynamic"), c.setAttribute("gap", "8"), c.appendChild(generateVariableFieldDom$$module$build$src$core$variables(e)), b.push(c);
              }
            }
            return b;
          };
          resizeSvgContents$$module$build$src$core$workspace_svg = function(a) {
            a.resizeContents();
          };
          copy$$module$build$src$core$clipboard = function(a, b) {
            const c = a.toCopyData();
            stashedCopyData$$module$build$src$core$clipboard = c;
            stashedWorkspace$$module$build$src$core$clipboard = isSelectable$$module$build$src$core$interfaces$i_selectable(a) && a.workspace instanceof WorkspaceSvg$$module$build$src$core$workspace_svg ? a.workspace : null;
            stashedCoordinates$$module$build$src$core$clipboard = b;
            return c;
          };
          getLastCopiedData$$module$build$src$core$clipboard = function() {
            return stashedCopyData$$module$build$src$core$clipboard;
          };
          setLastCopiedData$$module$build$src$core$clipboard = function(a) {
            stashedCopyData$$module$build$src$core$clipboard = a;
          };
          getLastCopiedWorkspace$$module$build$src$core$clipboard = function() {
            return stashedWorkspace$$module$build$src$core$clipboard;
          };
          setLastCopiedWorkspace$$module$build$src$core$clipboard = function(a) {
            stashedWorkspace$$module$build$src$core$clipboard = a;
          };
          getLastCopiedLocation$$module$build$src$core$clipboard = function() {
            return stashedCoordinates$$module$build$src$core$clipboard;
          };
          setLastCopiedLocation$$module$build$src$core$clipboard = function(a) {
            stashedCoordinates$$module$build$src$core$clipboard = a;
          };
          paste$$module$build$src$core$clipboard = function(a, b, c) {
            return a && b ? pasteFromData$$module$build$src$core$clipboard(a, b, c) : stashedCopyData$$module$build$src$core$clipboard && stashedWorkspace$$module$build$src$core$clipboard ? pasteFromData$$module$build$src$core$clipboard(stashedCopyData$$module$build$src$core$clipboard, stashedWorkspace$$module$build$src$core$clipboard, stashedCoordinates$$module$build$src$core$clipboard) : null;
          };
          pasteFromData$$module$build$src$core$clipboard = function(a, b, c) {
            let d;
            b = b.isMutator ? b : (d = b.options.parentWorkspace) != null ? d : b;
            let e, f;
            return (f = (e = getObject$$module$build$src$core$registry(Type$$module$build$src$core$registry.PASTER, a.paster, false)) == null ? void 0 : e.paste(a, b, c)) != null ? f : null;
          };
          isCopyable$$module$build$src$core$interfaces$i_copyable = function(a) {
            return a && typeof a.toCopyData === "function";
          };
          registerEscape$$module$build$src$core$shortcut_items = function() {
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({ name: names$$module$build$src$core$shortcut_items.ESCAPE, preconditionFn(a) {
              return !a.isReadOnly();
            }, callback(a) {
              a.hideChaff();
              return true;
            }, keyCodes: [KeyCodes$$module$build$src$core$utils$keycodes.ESC] });
          };
          registerDelete$$module$build$src$core$shortcut_items = function() {
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({ name: names$$module$build$src$core$shortcut_items.DELETE, preconditionFn(a, b) {
              b = b.focusedNode;
              return !a.isReadOnly() && b != null && isDeletable$$module$build$src$core$interfaces$i_deletable(b) && b.isDeletable() && !a.isDragging() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
            }, callback(a, b, c, d) {
              b.preventDefault();
              a = d.focusedNode;
              a instanceof BlockSvg$$module$build$src$core$block_svg ? a.checkAndDelete() : isDeletable$$module$build$src$core$interfaces$i_deletable(a) && a.isDeletable() && ($.setGroup$$module$build$src$core$events$utils(true), a.dispose(), $.setGroup$$module$build$src$core$events$utils(false));
              return true;
            }, keyCodes: [KeyCodes$$module$build$src$core$utils$keycodes.DELETE, KeyCodes$$module$build$src$core$utils$keycodes.BACKSPACE] });
          };
          isCopyable$$module$build$src$core$shortcut_items = function(a) {
            return isCopyable$$module$build$src$core$interfaces$i_copyable(a) && isDeletable$$module$build$src$core$interfaces$i_deletable(a) && isDraggable$$module$build$src$core$interfaces$i_draggable(a) ? a.isCopyable ? a.isCopyable() : a instanceof BlockSvg$$module$build$src$core$block_svg || a instanceof RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment ? a.isOwnDeletable() && a.isOwnMovable() : a.isDeletable() && a.isMovable() : false;
          };
          isCuttable$$module$build$src$core$shortcut_items = function(a) {
            return isCopyable$$module$build$src$core$shortcut_items(a) && isDeletable$$module$build$src$core$interfaces$i_deletable(a) && a.isDeletable();
          };
          registerCopy$$module$build$src$core$shortcut_items = function() {
            const a = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.C, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL]), b = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.C, [KeyCodes$$module$build$src$core$utils$keycodes.META]);
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({
              name: names$$module$build$src$core$shortcut_items.COPY,
              preconditionFn(c, d) {
                d = d.focusedNode;
                c = c.isFlyout ? c.targetWorkspace : c;
                return !!d && !!c && !c.isDragging() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken() && isCopyable$$module$build$src$core$shortcut_items(d);
              },
              callback(c, d, e, f) {
                d.preventDefault();
                d = f.focusedNode;
                if (!d || !isCopyable$$module$build$src$core$interfaces$i_copyable(d) || !isCopyable$$module$build$src$core$shortcut_items(d)) return false;
                c = c.isFlyout ? c.targetWorkspace : c;
                if (!c) return false;
                d.workspace.isFlyout || c.hideChaff();
                c = isDraggable$$module$build$src$core$interfaces$i_draggable(d) && d.workspace == c ? d.getRelativeToSurfaceXY() : void 0;
                return !!copy$$module$build$src$core$clipboard(d, c);
              },
              keyCodes: [a, b]
            });
          };
          registerCut$$module$build$src$core$shortcut_items = function() {
            const a = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.X, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL]), b = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.X, [KeyCodes$$module$build$src$core$utils$keycodes.META]);
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({
              name: names$$module$build$src$core$shortcut_items.CUT,
              preconditionFn(c, d) {
                d = d.focusedNode;
                return !!d && !c.isReadOnly() && !c.isDragging() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken() && isCuttable$$module$build$src$core$shortcut_items(d);
              },
              callback(c, d, e, f) {
                c = f.focusedNode;
                if (!c || !isCuttable$$module$build$src$core$shortcut_items(c) || !isCopyable$$module$build$src$core$interfaces$i_copyable(c)) return false;
                d = isDraggable$$module$build$src$core$interfaces$i_draggable(c) ? c.getRelativeToSurfaceXY() : void 0;
                d = copy$$module$build$src$core$clipboard(
                  c,
                  d
                );
                c instanceof BlockSvg$$module$build$src$core$block_svg ? c.checkAndDelete() : isDeletable$$module$build$src$core$interfaces$i_deletable(c) && c.dispose();
                return !!d;
              },
              keyCodes: [a, b]
            });
          };
          registerPaste$$module$build$src$core$shortcut_items = function() {
            const a = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.V, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL]), b = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.V, [KeyCodes$$module$build$src$core$utils$keycodes.META]);
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({
              name: names$$module$build$src$core$shortcut_items.PASTE,
              preconditionFn() {
                var c = getLastCopiedWorkspace$$module$build$src$core$clipboard();
                if (!c || !c.rendered) return false;
                c = c.isFlyout ? c.targetWorkspace : c;
                return !!getLastCopiedData$$module$build$src$core$clipboard() && !!c && !c.isReadOnly() && !c.isDragging() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
              },
              callback(c, d) {
                c = getLastCopiedData$$module$build$src$core$clipboard();
                if (!c) return false;
                var e = getLastCopiedWorkspace$$module$build$src$core$clipboard();
                if (!e) return false;
                e = e.isFlyout ? e.targetWorkspace : e;
                if (!e || e.isReadOnly()) return false;
                if (d instanceof PointerEvent) return d = screenToWsCoordinates$$module$build$src$core$utils$svg_math(e, new Coordinate$$module$build$src$core$utils$coordinate(d.clientX, d.clientY)), !!paste$$module$build$src$core$clipboard(c, e, d);
                d = getLastCopiedLocation$$module$build$src$core$clipboard();
                if (!d) return !!paste$$module$build$src$core$clipboard(c, e);
                const { left: f, top: g, width: h, height: k } = e.getMetricsManager().getViewMetrics(true);
                if (new Rect$$module$build$src$core$utils$rect(
                  g,
                  g + k,
                  f,
                  f + h
                ).contains(d.x, d.y)) return !!paste$$module$build$src$core$clipboard(c, e);
                d = new Coordinate$$module$build$src$core$utils$coordinate(f + h / 2, g + k / 2);
                return !!paste$$module$build$src$core$clipboard(c, e, d);
              },
              keyCodes: [a, b]
            });
          };
          registerUndo$$module$build$src$core$shortcut_items = function() {
            const a = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.Z, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL]), b = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.Z, [KeyCodes$$module$build$src$core$utils$keycodes.META]);
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({
              name: names$$module$build$src$core$shortcut_items.UNDO,
              preconditionFn(c) {
                return !c.isReadOnly() && !c.isDragging() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
              },
              callback(c, d) {
                c.hideChaff();
                c.undo(false);
                d.preventDefault();
                return true;
              },
              keyCodes: [a, b]
            });
          };
          registerRedo$$module$build$src$core$shortcut_items = function() {
            const a = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.Z, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL, KeyCodes$$module$build$src$core$utils$keycodes.SHIFT]), b = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.Z, [
              KeyCodes$$module$build$src$core$utils$keycodes.META,
              KeyCodes$$module$build$src$core$utils$keycodes.SHIFT
            ]), c = ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.createSerializedKey(KeyCodes$$module$build$src$core$utils$keycodes.Y, [KeyCodes$$module$build$src$core$utils$keycodes.CTRL]);
            ShortcutRegistry$$module$build$src$core$shortcut_registry.registry.register({
              name: names$$module$build$src$core$shortcut_items.REDO,
              preconditionFn(d) {
                return !d.isDragging() && !d.isReadOnly() && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken();
              },
              callback(d, e) {
                d.hideChaff();
                d.undo(true);
                e.preventDefault();
                return true;
              },
              keyCodes: [a, b, c]
            });
          };
          registerDefaultShortcuts$$module$build$src$core$shortcut_items = function() {
            registerEscape$$module$build$src$core$shortcut_items();
            registerDelete$$module$build$src$core$shortcut_items();
            registerCopy$$module$build$src$core$shortcut_items();
            registerCut$$module$build$src$core$shortcut_items();
            registerPaste$$module$build$src$core$shortcut_items();
            registerUndo$$module$build$src$core$shortcut_items();
            registerRedo$$module$build$src$core$shortcut_items();
          };
          saveProcedure$$module$build$src$core$serialization$procedures = function(a) {
            const b = a.saveState();
            if (!a.getParameters().length) return b;
            b.parameters = a.getParameters().map((c) => c.saveState());
            return b;
          };
          loadProcedure$$module$build$src$core$serialization$procedures = function(a, b, c, d) {
            a = a.loadState(c, d);
            if (!c.parameters) return a;
            for (const [e, f] of c.parameters.entries()) a.insertParameter(b.loadState(f, d), e);
            return a;
          };
          save$$module$build$src$core$serialization$workspaces = function(a) {
            const b = /* @__PURE__ */ Object.create(null), c = getAllItems$$module$build$src$core$registry(Type$$module$build$src$core$registry.SERIALIZER, true);
            for (const d in c) {
              let e;
              const f = (e = c[d]) == null ? void 0 : e.save(a);
              f && (b[d] = f);
            }
            return b;
          };
          load$$module$build$src$core$serialization$workspaces = function(a, b, { recordUndo: c = false } = {}) {
            var d = getAllItems$$module$build$src$core$registry(Type$$module$build$src$core$registry.SERIALIZER, true);
            if (d) {
              d = Object.entries(d).sort((f, g) => g[1].priority - f[1].priority);
              var e = getRecordUndo$$module$build$src$core$events$utils();
              $.setRecordUndo$$module$build$src$core$events$utils(c);
              (c = $.getGroup$$module$build$src$core$events$utils()) || $.setGroup$$module$build$src$core$events$utils(true);
              startTextWidthCache$$module$build$src$core$utils$dom();
              b instanceof WorkspaceSvg$$module$build$src$core$workspace_svg && b.setResizesEnabled(false);
              for (const [, f] of d.reverse()) {
                let g;
                (g = f) == null || g.clear(b);
              }
              for (const [f, g] of d.reverse()) if (a[f]) {
                let h;
                (h = g) == null || h.load(a[f], b);
              }
              b instanceof WorkspaceSvg$$module$build$src$core$workspace_svg && b.setResizesEnabled(true);
              stopTextWidthCache$$module$build$src$core$utils$dom();
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.FINISHED_LOADING))(b));
              $.setGroup$$module$build$src$core$events$utils(c);
              $.setRecordUndo$$module$build$src$core$events$utils(e);
            }
          };
          inject$$module$build$src$core$inject = function(a, b) {
            let c = null;
            c = typeof a === "string" ? document.getElementById(a) || document.querySelector(a) : a;
            var d;
            if (!document.contains(c) && document !== ((d = c) == null ? void 0 : d.ownerDocument)) throw Error("Error: container is not in current document");
            a = new Options$$module$build$src$core$options(b || {});
            d = document.createElement("div");
            addClass$$module$build$src$core$utils$dom(d, "injectionDiv");
            (b == null ? 0 : b.rtl) && addClass$$module$build$src$core$utils$dom(d, "blocklyRTL");
            c.appendChild(d);
            b = createDom$$module$build$src$core$inject(d, a);
            const e = createMainWorkspace$$module$build$src$core$inject(d, b, a);
            init$$module$build$src$core$inject(e);
            setMainWorkspace$$module$build$src$core$common(e);
            svgResize$$module$build$src$core$common(e);
            d.addEventListener("focusin", function() {
              setMainWorkspace$$module$build$src$core$common(e);
            });
            conditionalBind$$module$build$src$core$browser_events(d, "keydown", null, globalShortcutHandler$$module$build$src$core$common);
            return e;
          };
          createDom$$module$build$src$core$inject = function(a, b) {
            a.setAttribute("dir", "LTR");
            inject$$module$build$src$core$css(b.hasCss, b.pathToMedia);
            const c = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.SVG, { xmlns: SVG_NS$$module$build$src$core$utils$dom, "xmlns:html": HTML_NS$$module$build$src$core$utils$dom, "xmlns:xlink": XLINK_NS$$module$build$src$core$utils$dom, version: "1.1", "class": "blocklySvg" }, a), d = createSvgElement$$module$build$src$core$utils$dom(
              Svg$$module$build$src$core$utils$svg.DEFS,
              {},
              c
            ), e = String(Math.random()).substring(2);
            b.gridPattern = Grid$$module$build$src$core$grid.createDom(e, b.gridOptions, d, a);
            return c;
          };
          createMainWorkspace$$module$build$src$core$inject = function(a, b, c) {
            c.parentWorkspace = null;
            c = new WorkspaceSvg$$module$build$src$core$workspace_svg(c);
            const d = c.options;
            c.scale = d.zoomOptions.startScale;
            b.appendChild(c.createDom("blocklyMainBackground", a));
            var e = c.getRenderer().getClassName();
            e && addClass$$module$build$src$core$utils$dom(a, e);
            (e = c.getTheme().getClassName()) && addClass$$module$build$src$core$utils$dom(a, e);
            !d.hasCategories && d.languageTree && (a = c.addFlyout(Svg$$module$build$src$core$utils$svg.SVG), insertAfter$$module$build$src$core$utils$dom(a, b));
            d.hasTrashcan && c.addTrashcan();
            d.zoomOptions && d.zoomOptions.controls && c.addZoomControls();
            c.getThemeManager().subscribe(b, "workspaceBackgroundColour", "background-color");
            c.translate(0, 0);
            c.addChangeListener(bumpIntoBoundsHandler$$module$build$src$core$bump_objects(c));
            svgResize$$module$build$src$core$common(c);
            createDom$$module$build$src$core$widgetdiv();
            createDom$$module$build$src$core$dropdowndiv();
            createDom$$module$build$src$core$tooltip();
            return c;
          };
          init$$module$build$src$core$inject = function(a) {
            const b = a.options;
            var c = a.getParentSvg();
            conditionalBind$$module$build$src$core$browser_events(c.parentNode, "contextmenu", null, function(d) {
              isTargetInput$$module$build$src$core$browser_events(d) || d.preventDefault();
            });
            c = conditionalBind$$module$build$src$core$browser_events(window, "resize", null, function() {
              hide$$module$build$src$core$tooltip();
              a.hideComponents(true);
              repositionForWindowResize$$module$build$src$core$dropdowndiv();
              repositionForWindowResize$$module$build$src$core$widgetdiv();
              svgResize$$module$build$src$core$common(a);
              bumpTopObjectsIntoBounds$$module$build$src$core$bump_objects(a);
            });
            a.setResizeHandlerWrapper(c);
            bindDocumentEvents$$module$build$src$core$inject();
            if (b.languageTree) {
              c = a.getToolbox();
              const d = a.getFlyout(true);
              c ? c.init() : d && (d.init(a), d.show(b.languageTree), typeof d.scrollToStart === "function" && d.scrollToStart());
            }
            b.hasTrashcan && a.trashcan.init();
            b.zoomOptions && b.zoomOptions.controls && a.zoomControls_.init();
            b.moveOptions && b.moveOptions.scrollbars ? (a.scrollbar = new ScrollbarPair$$module$build$src$core$scrollbar_pair(a, b.moveOptions.scrollbars === true || !!b.moveOptions.scrollbars.horizontal, b.moveOptions.scrollbars === true || !!b.moveOptions.scrollbars.vertical, "blocklyMainWorkspaceScrollbar"), a.scrollbar.resize()) : a.setMetrics({ x: 0.5, y: 0.5 });
            b.hasSounds && loadSounds$$module$build$src$core$inject(b.pathToMedia, a);
          };
          bindDocumentEvents$$module$build$src$core$inject = function() {
            documentEventsBound$$module$build$src$core$inject || (conditionalBind$$module$build$src$core$browser_events(document, "scroll", null, function() {
              const a = getAllWorkspaces$$module$build$src$core$common();
              for (let b = 0, c; c = a[b]; b++) c instanceof WorkspaceSvg$$module$build$src$core$workspace_svg && c.updateInverseScreenCTM();
            }), bind$$module$build$src$core$browser_events(document, "touchend", null, longStop$$module$build$src$core$touch), bind$$module$build$src$core$browser_events(
              document,
              "touchcancel",
              null,
              longStop$$module$build$src$core$touch
            ));
            documentEventsBound$$module$build$src$core$inject = true;
          };
          loadSounds$$module$build$src$core$inject = function(a, b) {
            function c() {
              for (; e.length; ) {
                const f = e.pop();
                f && unbind$$module$build$src$core$browser_events(f);
              }
              d.preload();
            }
            const d = b.getAudioManager();
            d.load([a + "click.mp3", a + "click.wav", a + "click.ogg"], "click");
            d.load([a + "disconnect.wav", a + "disconnect.mp3", a + "disconnect.ogg"], "disconnect");
            d.load([a + "delete.mp3", a + "delete.ogg", a + "delete.wav"], "delete");
            const e = [];
            e.push(conditionalBind$$module$build$src$core$browser_events(document, "pointermove", null, c, true));
            e.push(conditionalBind$$module$build$src$core$browser_events(document, "touchstart", null, c, true));
          };
          isFullBlockField$$module$build$src$core$contextmenu_items = function(a) {
            if (!a || !a.isSimpleReporter()) return false;
            let b;
            return (b = a.getFields().next().value) == null ? void 0 : b.isFullBlockField();
          };
          registerUndo$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.UNDO;
            }, preconditionFn(a) {
              return a.workspace.getUndoStack().length > 0 ? "enabled" : "disabled";
            }, callback(a) {
              a.workspace.undo(false);
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "undoWorkspace", weight: 1 });
          };
          registerRedo$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.REDO;
            }, preconditionFn(a) {
              return a.workspace.getRedoStack().length > 0 ? "enabled" : "disabled";
            }, callback(a) {
              a.workspace.undo(true);
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "redoWorkspace", weight: 2 });
          };
          registerCleanup$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.CLEAN_UP;
            }, preconditionFn(a) {
              return a.workspace.isMovable() ? a.workspace.getTopBlocks(false).length > 1 ? "enabled" : "disabled" : "hidden";
            }, callback(a) {
              a.workspace.cleanUp();
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "cleanWorkspace", weight: 3 });
          };
          toggleOption_$$module$build$src$core$contextmenu_items = function(a, b) {
            function c(f) {
              e--;
              f.setCollapsed(a);
              e === 0 && $.setGroup$$module$build$src$core$events$utils(false);
            }
            let d = 0, e = 0;
            $.setGroup$$module$build$src$core$events$utils(true);
            for (let f = 0; f < b.length; f++) {
              let g = b[f];
              for (; g; ) e++, setTimeout(c.bind(null, g), d), g = g.getNextBlock(), d += 10;
            }
          };
          registerCollapse$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.COLLAPSE_ALL;
            }, preconditionFn(a) {
              if (a.workspace.options.collapse) {
                a = a.workspace.getTopBlocks(false);
                for (let b = 0; b < a.length; b++) {
                  let c = a[b];
                  for (; c; ) {
                    if (!c.isCollapsed()) return "enabled";
                    c = c.getNextBlock();
                  }
                }
                return "disabled";
              }
              return "hidden";
            }, callback(a) {
              toggleOption_$$module$build$src$core$contextmenu_items(
                true,
                a.workspace.getTopBlocks(true)
              );
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "collapseWorkspace", weight: 4 });
          };
          registerExpand$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.EXPAND_ALL;
            }, preconditionFn(a) {
              if (a.workspace.options.collapse) {
                a = a.workspace.getTopBlocks(false);
                for (let b = 0; b < a.length; b++) {
                  let c = a[b];
                  for (; c; ) {
                    if (c.isCollapsed()) return "enabled";
                    c = c.getNextBlock();
                  }
                }
                return "disabled";
              }
              return "hidden";
            }, callback(a) {
              toggleOption_$$module$build$src$core$contextmenu_items(
                false,
                a.workspace.getTopBlocks(true)
              );
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "expandWorkspace", weight: 5 });
          };
          addDeletableBlocks_$$module$build$src$core$contextmenu_items = function(a, b) {
            if (a.isDeletable()) Array.prototype.push.apply(b, a.getDescendants(false));
            else {
              a = a.getChildren(false);
              for (let c = 0; c < a.length; c++) addDeletableBlocks_$$module$build$src$core$contextmenu_items(a[c], b);
            }
          };
          getDeletableBlocks_$$module$build$src$core$contextmenu_items = function(a) {
            const b = [];
            a = a.getTopBlocks(true);
            for (let c = 0; c < a.length; c++) addDeletableBlocks_$$module$build$src$core$contextmenu_items(a[c], b);
            return b;
          };
          deleteNext_$$module$build$src$core$contextmenu_items = function(a, b) {
            b ? $.setGroup$$module$build$src$core$events$utils(b) : ($.setGroup$$module$build$src$core$events$utils(true), b = $.getGroup$$module$build$src$core$events$utils());
            const c = a.shift();
            c && (c.isDeadOrDying() ? deleteNext_$$module$build$src$core$contextmenu_items(a, b) : (c.dispose(false, true), setTimeout(deleteNext_$$module$build$src$core$contextmenu_items, 10, a, b)));
            $.setGroup$$module$build$src$core$events$utils(false);
          };
          registerDeleteAll$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText(a) {
                if (!a.workspace) return "";
                a = getDeletableBlocks_$$module$build$src$core$contextmenu_items(a.workspace).length;
                return a === 1 ? $.Msg$$module$build$src$core$msg.DELETE_BLOCK : $.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${a}`);
              },
              preconditionFn(a) {
                return a.workspace ? getDeletableBlocks_$$module$build$src$core$contextmenu_items(a.workspace).length > 0 ? "enabled" : "disabled" : "disabled";
              },
              callback(a) {
                if (a.workspace) {
                  a.workspace.cancelCurrentGesture();
                  var b = getDeletableBlocks_$$module$build$src$core$contextmenu_items(a.workspace);
                  b.length < 2 ? deleteNext_$$module$build$src$core$contextmenu_items(b) : confirm$$module$build$src$core$dialog($.Msg$$module$build$src$core$msg.DELETE_ALL_BLOCKS.replace("%1", String(b.length)), function(c) {
                    c && deleteNext_$$module$build$src$core$contextmenu_items(b);
                  });
                }
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE,
              id: "workspaceDelete",
              weight: 6
            });
          };
          registerWorkspaceOptions_$$module$build$src$core$contextmenu_items = function() {
            registerUndo$$module$build$src$core$contextmenu_items();
            registerRedo$$module$build$src$core$contextmenu_items();
            registerCleanup$$module$build$src$core$contextmenu_items();
            registerCollapse$$module$build$src$core$contextmenu_items();
            registerExpand$$module$build$src$core$contextmenu_items();
            registerDeleteAll$$module$build$src$core$contextmenu_items();
          };
          registerDuplicate$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText() {
                return $.Msg$$module$build$src$core$msg.DUPLICATE_BLOCK;
              },
              preconditionFn(a) {
                a = a.block;
                return !a.isInFlyout && a.isDeletable() && a.isMovable() ? a.isDuplicatable() ? "enabled" : "disabled" : "hidden";
              },
              callback(a) {
                if (a.block) {
                  var b = a.block.toCopyData();
                  b && paste$$module$build$src$core$clipboard(b, a.block.workspace);
                }
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK,
              id: "blockDuplicate",
              weight: 1
            });
          };
          registerComment$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText(a) {
              return a.block.hasIcon(CommentIcon$$module$build$src$core$icons$comment_icon.TYPE) ? $.Msg$$module$build$src$core$msg.REMOVE_COMMENT : $.Msg$$module$build$src$core$msg.ADD_COMMENT;
            }, preconditionFn(a) {
              a = a.block;
              return !a || a.isInFlyout || !a.workspace.options.comments || a.isCollapsed() || !a.isEditable() || !a.hasIcon(CommentIcon$$module$build$src$core$icons$comment_icon.TYPE) && isFullBlockField$$module$build$src$core$contextmenu_items(a) ? "hidden" : "enabled";
            }, callback(a) {
              (a = a.block) && a.hasIcon(CommentIcon$$module$build$src$core$icons$comment_icon.TYPE) ? a.setCommentText(null) : a.setCommentText("");
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK, id: "blockComment", weight: 2 });
          };
          registerInline$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText(a) {
              return a.block.getInputsInline() ? $.Msg$$module$build$src$core$msg.EXTERNAL_INPUTS : $.Msg$$module$build$src$core$msg.INLINE_INPUTS;
            }, preconditionFn(a) {
              a = a.block;
              if (!a.isInFlyout && a.isMovable() && !a.isCollapsed()) {
                for (let b = 1; b < a.inputList.length; b++) if (!(a.inputList[b - 1] instanceof StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs || a.inputList[b] instanceof StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs)) return "enabled";
              }
              return "hidden";
            }, callback(a) {
              a.block.setInputsInline(!a.block.getInputsInline());
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK, id: "blockInline", weight: 3 });
          };
          registerCollapseExpandBlock$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText(a) {
                return a.block.isCollapsed() ? $.Msg$$module$build$src$core$msg.EXPAND_BLOCK : $.Msg$$module$build$src$core$msg.COLLAPSE_BLOCK;
              },
              preconditionFn(a) {
                a = a.block;
                return !a.isInFlyout && a.isMovable() && a.workspace.options.collapse ? "enabled" : "hidden";
              },
              callback(a) {
                a.block.setCollapsed(!a.block.isCollapsed());
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK,
              id: "blockCollapseExpand",
              weight: 4
            });
          };
          registerDisable$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText(a) {
                return a.block.hasDisabledReason(MANUALLY_DISABLED$$module$build$src$core$constants) ? $.Msg$$module$build$src$core$msg.ENABLE_BLOCK : $.Msg$$module$build$src$core$msg.DISABLE_BLOCK;
              },
              preconditionFn(a) {
                a = a.block;
                if (!a.isInFlyout && a.workspace.options.disable && a.isEditable()) {
                  var b = a.getDisabledReasons();
                  b = b.size > (b.has(MANUALLY_DISABLED$$module$build$src$core$constants) ? 1 : 0);
                  return a.getInheritedDisabled() || b ? "disabled" : "enabled";
                }
                return "hidden";
              },
              callback(a) {
                a = a.block;
                const b = $.getGroup$$module$build$src$core$events$utils();
                b || $.setGroup$$module$build$src$core$events$utils(true);
                a.setDisabledReason(!a.hasDisabledReason(MANUALLY_DISABLED$$module$build$src$core$constants), MANUALLY_DISABLED$$module$build$src$core$constants);
                $.setGroup$$module$build$src$core$events$utils(b);
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK,
              id: "blockDisable",
              weight: 5
            });
          };
          registerDelete$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText(a) {
                var b = a.block;
                a = b.getDescendants(false).length;
                (b = b.getNextBlock()) && (a -= b.getDescendants(false).length);
                return a === 1 ? $.Msg$$module$build$src$core$msg.DELETE_BLOCK : $.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${a}`);
              },
              preconditionFn(a) {
                return !a.block.isInFlyout && a.block.isDeletable() ? "enabled" : "hidden";
              },
              callback(a) {
                a.block && a.block.checkAndDelete();
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK,
              id: "blockDelete",
              weight: 6
            });
          };
          registerHelp$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText() {
              return $.Msg$$module$build$src$core$msg.HELP;
            }, preconditionFn(a) {
              a = a.block;
              return (typeof a.helpUrl === "function" ? a.helpUrl() : a.helpUrl) ? "enabled" : "hidden";
            }, callback(a) {
              a.block.showHelp();
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.BLOCK, id: "blockHelp", weight: 7 });
          };
          registerCommentDelete$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText: () => $.Msg$$module$build$src$core$msg.REMOVE_COMMENT,
              preconditionFn(a) {
                let b;
                return ((b = a.comment) == null ? 0 : b.isDeletable()) ? "enabled" : "hidden";
              },
              callback(a) {
                $.setGroup$$module$build$src$core$events$utils(true);
                let b;
                (b = a.comment) == null || b.dispose();
                $.setGroup$$module$build$src$core$events$utils(false);
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.COMMENT,
              id: "commentDelete",
              weight: 6
            });
          };
          registerCommentDuplicate$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({
              displayText: () => $.Msg$$module$build$src$core$msg.DUPLICATE_COMMENT,
              preconditionFn(a) {
                let b;
                return ((b = a.comment) == null ? 0 : b.isMovable()) ? "enabled" : "hidden";
              },
              callback(a) {
                if (a.comment) {
                  var b = a.comment.toCopyData();
                  b && paste$$module$build$src$core$clipboard(b, a.comment.workspace);
                }
              },
              scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.COMMENT,
              id: "commentDuplicate",
              weight: 1
            });
          };
          registerCommentCreate$$module$build$src$core$contextmenu_items = function() {
            ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.register({ displayText: () => $.Msg$$module$build$src$core$msg.ADD_COMMENT, preconditionFn: (a) => {
              let b;
              return ((b = a.workspace) == null ? 0 : b.isMutator) ? "hidden" : "enabled";
            }, callback: (a, b, c, d) => {
              if (a = a.workspace) $.setGroup$$module$build$src$core$events$utils(true), b = new RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment(a), b.setPlaceholderText($.Msg$$module$build$src$core$msg.WORKSPACE_COMMENT_DEFAULT_TEXT), b.moveTo(screenToWsCoordinates$$module$build$src$core$utils$svg_math(a, new Coordinate$$module$build$src$core$utils$coordinate(d.x, d.y))), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(b), $.setGroup$$module$build$src$core$events$utils(false);
            }, scopeType: ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType.WORKSPACE, id: "commentCreate", weight: 8 });
          };
          registerBlockOptions_$$module$build$src$core$contextmenu_items = function() {
            registerDuplicate$$module$build$src$core$contextmenu_items();
            registerComment$$module$build$src$core$contextmenu_items();
            registerInline$$module$build$src$core$contextmenu_items();
            registerCollapseExpandBlock$$module$build$src$core$contextmenu_items();
            registerDisable$$module$build$src$core$contextmenu_items();
            registerDelete$$module$build$src$core$contextmenu_items();
            registerHelp$$module$build$src$core$contextmenu_items();
          };
          registerCommentOptions$$module$build$src$core$contextmenu_items = function() {
            registerCommentDuplicate$$module$build$src$core$contextmenu_items();
            registerCommentDelete$$module$build$src$core$contextmenu_items();
            registerCommentCreate$$module$build$src$core$contextmenu_items();
          };
          registerDefaultOptions$$module$build$src$core$contextmenu_items = function() {
            registerWorkspaceOptions_$$module$build$src$core$contextmenu_items();
            registerBlockOptions_$$module$build$src$core$contextmenu_items();
          };
          isPaster$$module$build$src$core$interfaces$i_paster = function(a) {
            return a && typeof a.paste === "function";
          };
          isRenderedElement$$module$build$src$core$interfaces$i_rendered_element = function(a) {
            return a && typeof a.getSvgRoot === "function";
          };
          isSelectableToolboxItem$$module$build$src$core$interfaces$i_selectable_toolbox_item = function(a) {
            return a.isSelectable();
          };
          hideChaff$$module$build$src$core$blockly = function(a) {
            getMainWorkspace$$module$build$src$core$common().hideChaff(a);
          };
          isFocusableTree$$module$build$src$core$interfaces$i_focusable_tree = function(a) {
            return a && typeof a.getRootFocusableNode === "function" && typeof a.getRestoredFocusableNode === "function" && typeof a.getNestedTrees === "function" && typeof a.lookUpFocusableNode === "function" && typeof a.onTreeFocus === "function" && typeof a.onTreeBlur === "function";
          };
          $jscomp = $jscomp || {};
          $jscomp.scope = {};
          $jscomp.ASSUME_ES5 = false;
          $jscomp.ASSUME_ES6 = false;
          $jscomp.ASSUME_ES2020 = false;
          $jscomp.ASSUME_NO_NATIVE_MAP = false;
          $jscomp.ASSUME_NO_NATIVE_SET = false;
          $jscomp.ISOLATE_POLYFILLS = false;
          $jscomp.FORCE_POLYFILL_PROMISE = false;
          $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false;
          $jscomp.INSTRUMENT_ASYNC_CONTEXT = true;
          $jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == "function" ? Object.create : function(a) {
            var b = function() {
            };
            b.prototype = a;
            return new b();
          };
          $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(a, b, c) {
            if (a == Array.prototype || a == Object.prototype) return a;
            a[b] = c.value;
            return a;
          };
          $jscomp.getGlobal = function(a) {
            a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
            for (var b = 0; b < a.length; ++b) {
              var c = a[b];
              if (c && c.Math == Math) return c;
            }
            throw Error("Cannot find global object");
          };
          $jscomp.global = $jscomp.ASSUME_ES2020 ? globalThis : $jscomp.getGlobal(this);
          $jscomp.IS_SYMBOL_NATIVE = typeof Symbol === "function" && typeof Symbol("x") === "symbol";
          $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
          $jscomp.polyfills = {};
          $jscomp.propertyToPolyfillSymbol = {};
          $jscomp.POLYFILL_PREFIX = "$jscp$";
          var $jscomp$lookupPolyfilledValue = function(a, b, c) {
            if (!c || a != null) {
              c = $jscomp.propertyToPolyfillSymbol[b];
              if (c == null) return a[b];
              c = a[c];
              return c !== void 0 ? c : a[b];
            }
          };
          $jscomp.polyfill = function(a, b, c, d) {
            b && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(a, b, c, d) : $jscomp.polyfillUnisolated(a, b, c, d));
          };
          $jscomp.polyfillUnisolated = function(a, b, c, d) {
            c = $jscomp.global;
            a = a.split(".");
            for (d = 0; d < a.length - 1; d++) {
              var e = a[d];
              if (!(e in c)) return;
              c = c[e];
            }
            a = a[a.length - 1];
            d = c[a];
            b = b(d);
            b != d && b != null && $jscomp.defineProperty(c, a, { configurable: true, writable: true, value: b });
          };
          $jscomp.polyfillIsolated = function(a, b, c, d) {
            var e = a.split(".");
            a = e.length === 1;
            d = e[0];
            d = !a && d in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
            for (var f = 0; f < e.length - 1; f++) {
              var g = e[f];
              if (!(g in d)) return;
              d = d[g];
            }
            e = e[e.length - 1];
            c = $jscomp.IS_SYMBOL_NATIVE && c === "es6" ? d[e] : null;
            b = b(c);
            b != null && (a ? $jscomp.defineProperty($jscomp.polyfills, e, { configurable: true, writable: true, value: b }) : b !== c && ($jscomp.propertyToPolyfillSymbol[e] === void 0 && (c = Math.random() * 1e9 >>> 0, $jscomp.propertyToPolyfillSymbol[e] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(e) : $jscomp.POLYFILL_PREFIX + c + "$" + e), $jscomp.defineProperty(d, $jscomp.propertyToPolyfillSymbol[e], { configurable: true, writable: true, value: b })));
          };
          $jscomp.getConstructImplementation = function() {
            function a() {
              function c() {
              }
              new c();
              Reflect.construct(c, [], function() {
              });
              return new c() instanceof c;
            }
            if ($jscomp.TRUST_ES6_POLYFILLS && typeof Reflect != "undefined" && Reflect.construct) {
              if (a()) return Reflect.construct;
              var b = Reflect.construct;
              return function(c, d, e) {
                c = b(c, d);
                e && Reflect.setPrototypeOf(c, e.prototype);
                return c;
              };
            }
            return function(c, d, e) {
              e === void 0 && (e = c);
              e = $jscomp.objectCreate(e.prototype || Object.prototype);
              return Function.prototype.apply.call(c, e, d) || e;
            };
          };
          $jscomp.construct = { valueOf: $jscomp.getConstructImplementation }.valueOf();
          $jscomp.underscoreProtoCanBeSet = function() {
            var a = { a: true }, b = {};
            try {
              return b.__proto__ = a, b.a;
            } catch (c) {
            }
            return false;
          };
          $jscomp.setPrototypeOf = $jscomp.ASSUME_ES6 || $jscomp.TRUST_ES6_POLYFILLS && typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(a, b) {
            a.__proto__ = b;
            if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
            return a;
          } : null;
          $jscomp.inherits = function(a, b) {
            a.prototype = $jscomp.objectCreate(b.prototype);
            a.prototype.constructor = a;
            if ($jscomp.ASSUME_ES6 || $jscomp.setPrototypeOf) {
              var c = $jscomp.setPrototypeOf;
              c(a, b);
            } else for (c in b) if (c != "prototype") if (Object.defineProperties) {
              var d = Object.getOwnPropertyDescriptor(b, c);
              d && Object.defineProperty(a, c, d);
            } else a[c] = b[c];
            a.superClass_ = b.prototype;
          };
          $jscomp.arrayIteratorImpl = function(a) {
            var b = 0;
            return function() {
              return b < a.length ? { done: false, value: a[b++] } : { done: true };
            };
          };
          $jscomp.arrayIterator = function(a) {
            return { next: $jscomp.arrayIteratorImpl(a) };
          };
          $jscomp.makeIterator = function(a) {
            var b = typeof Symbol != "undefined" && Symbol.iterator && a[Symbol.iterator];
            if (b) return b.call(a);
            if (typeof a.length == "number") return $jscomp.arrayIterator(a);
            throw Error(String(a) + " is not an iterable or ArrayLike");
          };
          $jscomp.arrayFromIterator = function(a) {
            for (var b, c = []; !(b = a.next()).done; ) c.push(b.value);
            return c;
          };
          $jscomp.arrayFromIterable = function(a) {
            return a instanceof Array ? a : $jscomp.arrayFromIterator($jscomp.makeIterator(a));
          };
          $jscomp.generator = {};
          $jscomp.generator.ensureIteratorResultIsObject_ = function(a) {
            if (!(a instanceof Object)) throw new TypeError("Iterator result " + a + " is not an object");
          };
          $jscomp.generator.Context = function() {
            this.isRunning_ = false;
            this.yieldAllIterator_ = null;
            this.yieldResult = void 0;
            this.nextAddress = 1;
            this.finallyAddress_ = this.catchAddress_ = 0;
            this.finallyContexts_ = this.abruptCompletion_ = null;
          };
          $jscomp.generator.Context.prototype.start_ = function() {
            if (this.isRunning_) throw new TypeError("Generator is already running");
            this.isRunning_ = true;
          };
          $jscomp.generator.Context.prototype.stop_ = function() {
            this.isRunning_ = false;
          };
          $jscomp.generator.Context.prototype.jumpToErrorHandler_ = function() {
            this.nextAddress = this.catchAddress_ || this.finallyAddress_;
          };
          $jscomp.generator.Context.prototype.next_ = function(a) {
            this.yieldResult = a;
          };
          $jscomp.generator.Context.prototype.throw_ = function(a) {
            this.abruptCompletion_ = { exception: a, isException: true };
            this.jumpToErrorHandler_();
          };
          $jscomp.generator.Context.prototype.return = function(a) {
            this.abruptCompletion_ = { return: a };
            this.nextAddress = this.finallyAddress_;
          };
          $jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function(a) {
            this.abruptCompletion_ = { jumpTo: a };
            this.nextAddress = this.finallyAddress_;
          };
          $jscomp.generator.Context.prototype.yield = function(a, b) {
            this.nextAddress = b;
            return { value: a };
          };
          $jscomp.generator.Context.prototype.yieldAll = function(a, b) {
            a = $jscomp.makeIterator(a);
            var c = a.next();
            $jscomp.generator.ensureIteratorResultIsObject_(c);
            if (c.done) this.yieldResult = c.value, this.nextAddress = b;
            else return this.yieldAllIterator_ = a, this.yield(c.value, b);
          };
          $jscomp.generator.Context.prototype.jumpTo = function(a) {
            this.nextAddress = a;
          };
          $jscomp.generator.Context.prototype.jumpToEnd = function() {
            this.nextAddress = 0;
          };
          $jscomp.generator.Context.prototype.setCatchFinallyBlocks = function(a, b) {
            this.catchAddress_ = a;
            b != void 0 && (this.finallyAddress_ = b);
          };
          $jscomp.generator.Context.prototype.setFinallyBlock = function(a) {
            this.catchAddress_ = 0;
            this.finallyAddress_ = a || 0;
          };
          $jscomp.generator.Context.prototype.leaveTryBlock = function(a, b) {
            this.nextAddress = a;
            this.catchAddress_ = b || 0;
          };
          $jscomp.generator.Context.prototype.enterCatchBlock = function(a) {
            this.catchAddress_ = a || 0;
            a = this.abruptCompletion_.exception;
            this.abruptCompletion_ = null;
            return a;
          };
          $jscomp.generator.Context.prototype.enterFinallyBlock = function(a, b, c) {
            c ? this.finallyContexts_[c] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_];
            this.catchAddress_ = a || 0;
            this.finallyAddress_ = b || 0;
          };
          $jscomp.generator.Context.prototype.leaveFinallyBlock = function(a, b) {
            b = this.finallyContexts_.splice(b || 0)[0];
            if (b = this.abruptCompletion_ = this.abruptCompletion_ || b) {
              if (b.isException) return this.jumpToErrorHandler_();
              b.jumpTo != void 0 && this.finallyAddress_ < b.jumpTo ? (this.nextAddress = b.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_;
            } else this.nextAddress = a;
          };
          $jscomp.generator.Context.prototype.forIn = function(a) {
            return new $jscomp.generator.Context.PropertyIterator(a);
          };
          $jscomp.generator.Context.PropertyIterator = function(a) {
            this.object_ = a;
            this.properties_ = [];
            for (var b in a) this.properties_.push(b);
            this.properties_.reverse();
          };
          $jscomp.generator.Context.PropertyIterator.prototype.getNext = function() {
            for (; this.properties_.length > 0; ) {
              var a = this.properties_.pop();
              if (a in this.object_) return a;
            }
            return null;
          };
          $jscomp.generator.Engine_ = function(a) {
            this.context_ = new $jscomp.generator.Context();
            this.program_ = a;
          };
          $jscomp.generator.Engine_.prototype.next_ = function(a) {
            this.context_.start_();
            if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_.next, a, this.context_.next_);
            this.context_.next_(a);
            return this.nextStep_();
          };
          $jscomp.generator.Engine_.prototype.return_ = function(a) {
            this.context_.start_();
            var b = this.context_.yieldAllIterator_;
            if (b) return this.yieldAllStep_("return" in b ? b["return"] : function(c) {
              return { value: c, done: true };
            }, a, this.context_.return);
            this.context_.return(a);
            return this.nextStep_();
          };
          $jscomp.generator.Engine_.prototype.throw_ = function(a) {
            this.context_.start_();
            if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"], a, this.context_.next_);
            this.context_.throw_(a);
            return this.nextStep_();
          };
          $jscomp.generator.Engine_.prototype.yieldAllStep_ = function(a, b, c) {
            try {
              var d = a.call(this.context_.yieldAllIterator_, b);
              $jscomp.generator.ensureIteratorResultIsObject_(d);
              if (!d.done) return this.context_.stop_(), d;
              var e = d.value;
            } catch (f) {
              return this.context_.yieldAllIterator_ = null, this.context_.throw_(f), this.nextStep_();
            }
            this.context_.yieldAllIterator_ = null;
            c.call(this.context_, e);
            return this.nextStep_();
          };
          $jscomp.generator.Engine_.prototype.nextStep_ = function() {
            for (; this.context_.nextAddress; ) try {
              var a = this.program_(this.context_);
              if (a) return this.context_.stop_(), { value: a.value, done: false };
            } catch (b) {
              this.context_.yieldResult = void 0, this.context_.throw_(b);
            }
            this.context_.stop_();
            if (this.context_.abruptCompletion_) {
              a = this.context_.abruptCompletion_;
              this.context_.abruptCompletion_ = null;
              if (a.isException) throw a.exception;
              return { value: a.return, done: true };
            }
            return { value: void 0, done: true };
          };
          $jscomp.generator.Generator_ = function(a) {
            this.next = function(b) {
              return a.next_(b);
            };
            this.throw = function(b) {
              return a.throw_(b);
            };
            this.return = function(b) {
              return a.return_(b);
            };
            this[Symbol.iterator] = function() {
              return this;
            };
          };
          $jscomp.generator.createGenerator = function(a, b) {
            b = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(b));
            $jscomp.setPrototypeOf && a.prototype && $jscomp.setPrototypeOf(b, a.prototype);
            return b;
          };
          $jscomp.asyncExecutePromiseGenerator = function(a) {
            function b(d) {
              return a.next(d);
            }
            function c(d) {
              return a.throw(d);
            }
            return new Promise(function(d, e) {
              function f(g) {
                g.done ? d(g.value) : Promise.resolve(g.value).then(b, c).then(f, e);
              }
              f(a.next());
            });
          };
          $jscomp.asyncExecutePromiseGeneratorFunction = function(a) {
            return $jscomp.asyncExecutePromiseGenerator(a());
          };
          $jscomp.asyncExecutePromiseGeneratorProgram = function(a) {
            return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(a)));
          };
          $jscomp.polyfill("globalThis", function(a) {
            return a || $jscomp.global;
          }, "es_2020", "es3");
          $jscomp.polyfill("Array.prototype.includes", function(a) {
            return a ? a : function(b, c) {
              var d = this;
              d instanceof String && (d = String(d));
              var e = d.length;
              c = c || 0;
              for (c < 0 && (c = Math.max(c + e, 0)); c < e; c++) {
                var f = d[c];
                if (f === b || Object.is(f, b)) return true;
              }
              return false;
            };
          }, "es7", "es3");
          $jscomp.checkEs6ConformanceViaProxy = function() {
            try {
              var a = {}, b = Object.create(new $jscomp.global.Proxy(a, { get: function(c, d, e) {
                return c == a && d == "q" && e == b;
              } }));
              return b.q === true;
            } catch (c) {
              return false;
            }
          };
          $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = false;
          $jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
          $jscomp.initSymbol = function() {
          };
          $jscomp.iteratorPrototype = function(a) {
            a = { next: a };
            a[Symbol.iterator] = function() {
              return this;
            };
            return a;
          };
          $jscomp.owns = function(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
          };
          $jscomp.MapEntry = function() {
          };
          $jscomp.polyfill("Set.prototype.difference", function(a) {
            return a ? a : function(b) {
              $jscomp.checkIsSetInstance(this);
              $jscomp.checkIsSetLike(b);
              var c = $jscomp.getSmallerAndLargerSets(this, b);
              b = new Set(this);
              var d = c.smallerSetIterator;
              c = c.largerSet;
              for (var e = d.next(); !e.done; ) c.has(e.value) && b.delete(e.value), e = d.next();
              return b;
            };
          }, "es_next", "es6");
          $jscomp.checkIsSetLike = function(a) {
            if (typeof a !== "object" || a === null || typeof a.size !== "number" || a.size < 0 || typeof a.keys !== "function" || typeof a.has !== "function") throw new TypeError("Argument must be set-like");
          };
          $jscomp.checkIsValidIterator = function(a) {
            if (typeof a !== "object" || a === null || typeof a.next !== "function") throw new TypeError("Invalid iterator.");
            return a;
          };
          $jscomp.getSmallerAndLargerSets = function(a, b) {
            return a.size <= b.size ? { smallerSetIterator: a.keys(), largerSet: b } : { smallerSetIterator: $jscomp.checkIsValidIterator(b.keys()), largerSet: a };
          };
          $jscomp.checkIsSetInstance = function(a) {
            if (!(a instanceof Set)) throw new TypeError("Method must be called on an instance of Set.");
          };
          $jscomp.iteratorFromArray = function(a, b) {
            if ($jscomp.ASSUME_ES6) return a[Symbol.iterator]();
            a instanceof String && (a += "");
            var c = 0, d = false, e = { next: function() {
              if (!d && c < a.length) {
                var f = c++;
                return { value: b(f, a[f]), done: false };
              }
              d = true;
              return { done: true, value: void 0 };
            } };
            e[Symbol.iterator] = function() {
              return e;
            };
            return e;
          };
          $jscomp.polyfill("Array.prototype.values", function(a) {
            return a ? a : function() {
              return $jscomp.iteratorFromArray(this, function(b, c) {
                return c;
              });
            };
          }, "es8", "es3");
          $jscomp.polyfill("Array.prototype.flatMap", function(a) {
            return a ? a : function(b, c) {
              var d = [];
              Array.prototype.forEach.call(this, function(e, f) {
                e = b.call(c, e, f, this);
                Array.isArray(e) ? d.push.apply(d, e) : d.push(e);
              });
              return d;
            };
          }, "es9", "es5");
          $jscomp.polyfill("Array.prototype.flat", function(a) {
            return a ? a : function(b) {
              b = b === void 0 ? 1 : b;
              var c = [];
              Array.prototype.forEach.call(this, function(d) {
                Array.isArray(d) && b > 0 ? (d = Array.prototype.flat.call(d, b - 1), c.push.apply(c, d)) : c.push(d);
              });
              return c;
            };
          }, "es9", "es5");
          $jscomp.polyfill("Object.entries", function(a) {
            return a ? a : function(b) {
              var c = [], d;
              for (d in b) $jscomp.owns(b, d) && c.push([d, b[d]]);
              return c;
            };
          }, "es8", "es3");
          $jscomp.polyfill("Object.values", function(a) {
            return a ? a : function(b) {
              var c = [], d;
              for (d in b) $jscomp.owns(b, d) && c.push(b[d]);
              return c;
            };
          }, "es8", "es3");
          var typeMap$$module$build$src$core$registry = /* @__PURE__ */ Object.create(null), TEST_ONLY$$module$build$src$core$registry = { typeMap: typeMap$$module$build$src$core$registry }, nameMap$$module$build$src$core$registry = /* @__PURE__ */ Object.create(null), DEFAULT$$module$build$src$core$registry = "default", Type$$module$build$src$core$registry = class {
            constructor(a) {
              this.name = a;
            }
            toString() {
              return this.name;
            }
          };
          Type$$module$build$src$core$registry.CONNECTION_CHECKER = new Type$$module$build$src$core$registry("connectionChecker");
          Type$$module$build$src$core$registry.CONNECTION_PREVIEWER = new Type$$module$build$src$core$registry("connectionPreviewer");
          Type$$module$build$src$core$registry.CURSOR = new Type$$module$build$src$core$registry("cursor");
          Type$$module$build$src$core$registry.EVENT = new Type$$module$build$src$core$registry("event");
          Type$$module$build$src$core$registry.FIELD = new Type$$module$build$src$core$registry("field");
          Type$$module$build$src$core$registry.INPUT = new Type$$module$build$src$core$registry("input");
          Type$$module$build$src$core$registry.RENDERER = new Type$$module$build$src$core$registry("renderer");
          Type$$module$build$src$core$registry.TOOLBOX = new Type$$module$build$src$core$registry("toolbox");
          Type$$module$build$src$core$registry.THEME = new Type$$module$build$src$core$registry("theme");
          Type$$module$build$src$core$registry.TOOLBOX_ITEM = new Type$$module$build$src$core$registry("toolboxItem");
          Type$$module$build$src$core$registry.FLYOUTS_VERTICAL_TOOLBOX = new Type$$module$build$src$core$registry("flyoutsVerticalToolbox");
          Type$$module$build$src$core$registry.FLYOUTS_HORIZONTAL_TOOLBOX = new Type$$module$build$src$core$registry("flyoutsHorizontalToolbox");
          Type$$module$build$src$core$registry.FLYOUT_INFLATER = new Type$$module$build$src$core$registry("flyoutInflater");
          Type$$module$build$src$core$registry.METRICS_MANAGER = new Type$$module$build$src$core$registry("metricsManager");
          Type$$module$build$src$core$registry.BLOCK_DRAGGER = new Type$$module$build$src$core$registry("blockDragger");
          Type$$module$build$src$core$registry.SERIALIZER = new Type$$module$build$src$core$registry("serializer");
          Type$$module$build$src$core$registry.ICON = new Type$$module$build$src$core$registry("icon");
          Type$$module$build$src$core$registry.PASTER = new Type$$module$build$src$core$registry("paster");
          Type$$module$build$src$core$registry.VARIABLE_MODEL = new Type$$module$build$src$core$registry("variableModel");
          Type$$module$build$src$core$registry.VARIABLE_MAP = new Type$$module$build$src$core$registry("variableMap");
          var module$build$src$core$registry = { DEFAULT: DEFAULT$$module$build$src$core$registry, TEST_ONLY: TEST_ONLY$$module$build$src$core$registry };
          module$build$src$core$registry.Type = Type$$module$build$src$core$registry;
          module$build$src$core$registry.getAllItems = getAllItems$$module$build$src$core$registry;
          module$build$src$core$registry.getClass = getClass$$module$build$src$core$registry;
          module$build$src$core$registry.getClassFromOptions = getClassFromOptions$$module$build$src$core$registry;
          module$build$src$core$registry.getObject = getObject$$module$build$src$core$registry;
          module$build$src$core$registry.hasItem = hasItem$$module$build$src$core$registry;
          module$build$src$core$registry.register = register$$module$build$src$core$registry;
          module$build$src$core$registry.unregister = unregister$$module$build$src$core$registry;
          var Blocks$$module$build$src$core$blocks = /* @__PURE__ */ Object.create(null), module$build$src$core$blocks = { Blocks: Blocks$$module$build$src$core$blocks };
          var LONGPRESS$$module$build$src$core$touch = 750, TOUCH_ENABLED$$module$build$src$core$touch = "ontouchstart" in globalThis || !!(globalThis.document && document.documentElement && "ontouchstart" in document.documentElement) || !(!globalThis.navigator || !globalThis.navigator.maxTouchPoints && !globalThis.navigator.msMaxTouchPoints), touchIdentifier_$$module$build$src$core$touch = null, TOUCH_MAP$$module$build$src$core$touch = {
            mousedown: ["pointerdown"],
            mouseenter: ["pointerenter"],
            mouseleave: ["pointerleave"],
            mousemove: ["pointermove"],
            mouseout: ["pointerout"],
            mouseover: ["pointerover"],
            mouseup: ["pointerup", "pointercancel"],
            touchend: ["pointerup"],
            touchcancel: ["pointercancel"]
          }, longPid_$$module$build$src$core$touch = 0, module$build$src$core$touch = { TOUCH_ENABLED: TOUCH_ENABLED$$module$build$src$core$touch, TOUCH_MAP: TOUCH_MAP$$module$build$src$core$touch };
          module$build$src$core$touch.checkTouchIdentifier = checkTouchIdentifier$$module$build$src$core$touch;
          module$build$src$core$touch.clearTouchIdentifier = clearTouchIdentifier$$module$build$src$core$touch;
          module$build$src$core$touch.getTouchIdentifierFromEvent = getTouchIdentifierFromEvent$$module$build$src$core$touch;
          module$build$src$core$touch.longStart = longStart$$module$build$src$core$touch;
          module$build$src$core$touch.longStop = longStop$$module$build$src$core$touch;
          module$build$src$core$touch.shouldHandleEvent = shouldHandleEvent$$module$build$src$core$touch;
          var rawUserAgent$$module$build$src$core$utils$useragent, isJavaFx$$module$build$src$core$utils$useragent, isWebKit$$module$build$src$core$utils$useragent, isGecko$$module$build$src$core$utils$useragent, isAndroid$$module$build$src$core$utils$useragent, isIPad$$module$build$src$core$utils$useragent, isIPhone$$module$build$src$core$utils$useragent, isMac$$module$build$src$core$utils$useragent, isTablet$$module$build$src$core$utils$useragent, isMobile$$module$build$src$core$utils$useragent;
          (function(a) {
            function b(d) {
              return c.includes(d.toUpperCase());
            }
            rawUserAgent$$module$build$src$core$utils$useragent = a;
            const c = rawUserAgent$$module$build$src$core$utils$useragent.toUpperCase();
            isJavaFx$$module$build$src$core$utils$useragent = b("JavaFX");
            isWebKit$$module$build$src$core$utils$useragent = b("WebKit");
            isGecko$$module$build$src$core$utils$useragent = b("Gecko") && !isWebKit$$module$build$src$core$utils$useragent;
            isAndroid$$module$build$src$core$utils$useragent = b("Android");
            a = globalThis.navigator && globalThis.navigator.maxTouchPoints;
            isIPad$$module$build$src$core$utils$useragent = b("iPad") || b("Macintosh") && a > 0;
            isIPhone$$module$build$src$core$utils$useragent = b("iPhone") && !isIPad$$module$build$src$core$utils$useragent;
            isMac$$module$build$src$core$utils$useragent = b("Macintosh");
            isTablet$$module$build$src$core$utils$useragent = isIPad$$module$build$src$core$utils$useragent || isAndroid$$module$build$src$core$utils$useragent && !b("Mobile") || b("Silk");
            isMobile$$module$build$src$core$utils$useragent = !isTablet$$module$build$src$core$utils$useragent && (isIPhone$$module$build$src$core$utils$useragent || isAndroid$$module$build$src$core$utils$useragent);
          })(globalThis.navigator && globalThis.navigator.userAgent || "");
          var raw$$module$build$src$core$utils$useragent = rawUserAgent$$module$build$src$core$utils$useragent, JavaFx$$module$build$src$core$utils$useragent = isJavaFx$$module$build$src$core$utils$useragent, GECKO$$module$build$src$core$utils$useragent = isGecko$$module$build$src$core$utils$useragent, ANDROID$$module$build$src$core$utils$useragent = isAndroid$$module$build$src$core$utils$useragent, IPAD$$module$build$src$core$utils$useragent = isIPad$$module$build$src$core$utils$useragent, IPHONE$$module$build$src$core$utils$useragent = isIPhone$$module$build$src$core$utils$useragent, MAC$$module$build$src$core$utils$useragent = isMac$$module$build$src$core$utils$useragent, MOBILE$$module$build$src$core$utils$useragent = isMobile$$module$build$src$core$utils$useragent, module$build$src$core$utils$useragent = {
            ANDROID: ANDROID$$module$build$src$core$utils$useragent,
            GECKO: GECKO$$module$build$src$core$utils$useragent,
            IPAD: IPAD$$module$build$src$core$utils$useragent,
            IPHONE: IPHONE$$module$build$src$core$utils$useragent,
            JavaFx: JavaFx$$module$build$src$core$utils$useragent,
            MAC: MAC$$module$build$src$core$utils$useragent,
            MOBILE: MOBILE$$module$build$src$core$utils$useragent,
            raw: raw$$module$build$src$core$utils$useragent
          };
          var LINE_MODE_MULTIPLIER$$module$build$src$core$browser_events = 40, PAGE_MODE_MULTIPLIER$$module$build$src$core$browser_events = 125, module$build$src$core$browser_events = {};
          module$build$src$core$browser_events.bind = bind$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.conditionalBind = conditionalBind$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.getScrollDeltaPixels = getScrollDeltaPixels$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.isRightButton = isRightButton$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.isTargetInput = isTargetInput$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.mouseToSvg = mouseToSvg$$module$build$src$core$browser_events;
          module$build$src$core$browser_events.unbind = unbind$$module$build$src$core$browser_events;
          var EventType$$module$build$src$core$events$type;
          (function(a) {
            a.BLOCK_CREATE = "create";
            a.BLOCK_DELETE = "delete";
            a.BLOCK_CHANGE = "change";
            a.BLOCK_FIELD_INTERMEDIATE_CHANGE = "block_field_intermediate_change";
            a.BLOCK_MOVE = "move";
            a.VAR_CREATE = "var_create";
            a.VAR_DELETE = "var_delete";
            a.VAR_RENAME = "var_rename";
            a.VAR_TYPE_CHANGE = "var_type_change";
            a.UI = "ui";
            a.BLOCK_DRAG = "drag";
            a.SELECTED = "selected";
            a.CLICK = "click";
            a.MARKER_MOVE = "marker_move";
            a.BUBBLE_OPEN = "bubble_open";
            a.TRASHCAN_OPEN = "trashcan_open";
            a.TOOLBOX_ITEM_SELECT = "toolbox_item_select";
            a.THEME_CHANGE = "theme_change";
            a.VIEWPORT_CHANGE = "viewport_change";
            a.COMMENT_CREATE = "comment_create";
            a.COMMENT_DELETE = "comment_delete";
            a.COMMENT_CHANGE = "comment_change";
            a.COMMENT_MOVE = "comment_move";
            a.COMMENT_RESIZE = "comment_resize";
            a.COMMENT_DRAG = "comment_drag";
            a.COMMENT_COLLAPSE = "comment_collapse";
            a.FINISHED_LOADING = "finished_loading";
          })(EventType$$module$build$src$core$events$type || (EventType$$module$build$src$core$events$type = {}));
          var BUMP_EVENTS$$module$build$src$core$events$type = [EventType$$module$build$src$core$events$type.BLOCK_CREATE, EventType$$module$build$src$core$events$type.BLOCK_MOVE, EventType$$module$build$src$core$events$type.COMMENT_CREATE, EventType$$module$build$src$core$events$type.COMMENT_MOVE], module$build$src$core$events$type = { BUMP_EVENTS: BUMP_EVENTS$$module$build$src$core$events$type };
          module$build$src$core$events$type.EventType = EventType$$module$build$src$core$events$type;
          var soup$$module$build$src$core$utils$idgenerator = "!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", internal$$module$build$src$core$utils$idgenerator = { genUid: () => {
            const a = soup$$module$build$src$core$utils$idgenerator.length, b = [];
            for (let c = 0; c < 20; c++) b[c] = soup$$module$build$src$core$utils$idgenerator.charAt(Math.random() * a);
            return b.join("");
          } }, TEST_ONLY$$module$build$src$core$utils$idgenerator = internal$$module$build$src$core$utils$idgenerator, nextId$$module$build$src$core$utils$idgenerator = 0, module$build$src$core$utils$idgenerator = { TEST_ONLY: internal$$module$build$src$core$utils$idgenerator };
          module$build$src$core$utils$idgenerator.genUid = genUid$$module$build$src$core$utils$idgenerator;
          module$build$src$core$utils$idgenerator.getNextUniqueId = getNextUniqueId$$module$build$src$core$utils$idgenerator;
          var module$build$src$core$events$predicates = {};
          module$build$src$core$events$predicates.isBlockChange = isBlockChange$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBlockCreate = isBlockCreate$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBlockDelete = isBlockDelete$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBlockDrag = isBlockDrag$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBlockFieldIntermediateChange = isBlockFieldIntermediateChange$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBlockMove = isBlockMove$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isBubbleOpen = isBubbleOpen$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isClick = isClick$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentChange = isCommentChange$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentCollapse = isCommentCollapse$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentCreate = isCommentCreate$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentDelete = isCommentDelete$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentDrag = isCommentDrag$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentMove = isCommentMove$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isCommentResize = isCommentResize$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isFinishedLoading = isFinishedLoading$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isSelected = isSelected$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isThemeChange = isThemeChange$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isToolboxItemSelect = isToolboxItemSelect$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isTrashcanOpen = isTrashcanOpen$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isVarCreate = isVarCreate$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isVarDelete = isVarDelete$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isVarRename = isVarRename$$module$build$src$core$events$predicates;
          module$build$src$core$events$predicates.isViewportChange = isViewportChange$$module$build$src$core$events$predicates;
          var group$$module$build$src$core$events$utils = "", recordUndo$$module$build$src$core$events$utils = true, disabled$$module$build$src$core$events$utils = 0, ORPHANED_BLOCK_DISABLED_REASON$$module$build$src$core$events$utils = "ORPHANED_BLOCK", FIRE_QUEUE$$module$build$src$core$events$utils = [], TEST_ONLY$$module$build$src$core$events$utils = {
            FIRE_QUEUE: FIRE_QUEUE$$module$build$src$core$events$utils,
            enqueueEvent: enqueueEvent$$module$build$src$core$events$utils,
            fireNow: fireNow$$module$build$src$core$events$utils,
            fireInternal: fireInternal$$module$build$src$core$events$utils,
            setGroupInternal: setGroupInternal$$module$build$src$core$events$utils
          }, module$build$src$core$events$utils = { TEST_ONLY: TEST_ONLY$$module$build$src$core$events$utils };
          module$build$src$core$events$utils.clearPendingUndo = clearPendingUndo$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.disable = $.disable$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.disableOrphans = disableOrphans$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.enable = $.enable$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.filter = filter$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.fire = fire$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.fromJson = fromJson$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.get = get$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.getDescendantIds = getDescendantIds$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.getGroup = $.getGroup$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.getRecordUndo = getRecordUndo$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.isEnabled = isEnabled$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.setGroup = $.setGroup$$module$build$src$core$events$utils;
          module$build$src$core$events$utils.setRecordUndo = $.setRecordUndo$$module$build$src$core$events$utils;
          var SVG_NS$$module$build$src$core$utils$dom = "http://www.w3.org/2000/svg", HTML_NS$$module$build$src$core$utils$dom = "http://www.w3.org/1999/xhtml", XLINK_NS$$module$build$src$core$utils$dom = "http://www.w3.org/1999/xlink", NodeType$$module$build$src$core$utils$dom;
          (function(a) {
            a[a.ELEMENT_NODE = 1] = "ELEMENT_NODE";
            a[a.TEXT_NODE = 3] = "TEXT_NODE";
            a[a.COMMENT_NODE = 8] = "COMMENT_NODE";
          })(NodeType$$module$build$src$core$utils$dom || (NodeType$$module$build$src$core$utils$dom = {}));
          var cacheWidths$$module$build$src$core$utils$dom = null, cacheReference$$module$build$src$core$utils$dom = 0, canvasContext$$module$build$src$core$utils$dom = null, module$build$src$core$utils$dom = { HTML_NS: HTML_NS$$module$build$src$core$utils$dom };
          module$build$src$core$utils$dom.NodeType = NodeType$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.SVG_NS = SVG_NS$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.XLINK_NS = XLINK_NS$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.addClass = addClass$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.createSvgElement = createSvgElement$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.getFastTextWidth = getFastTextWidth$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.getFastTextWidthWithSizeString = getFastTextWidthWithSizeString$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.getTextWidth = getTextWidth$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.hasClass = hasClass$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.insertAfter = insertAfter$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.measureFontMetrics = measureFontMetrics$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.removeClass = removeClass$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.removeClasses = removeClasses$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.removeNode = removeNode$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.setCssTransform = setCssTransform$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.startTextWidthCache = startTextWidthCache$$module$build$src$core$utils$dom;
          module$build$src$core$utils$dom.stopTextWidthCache = stopTextWidthCache$$module$build$src$core$utils$dom;
          var FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser = class {
            static findFocusedNode(a) {
              var b = a.getRootFocusableNode();
              if (!b.canBeFocused()) return null;
              var c = b.getFocusableElement();
              if (hasClass$$module$build$src$core$utils$dom(c, FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.ACTIVE_CLASS_NAME) || hasClass$$module$build$src$core$utils$dom(c, FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.PASSIVE_CSS_CLASS_NAME)) return b;
              b = c.querySelector(this.ACTIVE_FOCUS_NODE_CSS_SELECTOR);
              if (b instanceof HTMLElement || b instanceof SVGElement) {
                if (b = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(b, a)) return b;
              }
              c = c.querySelector(this.PASSIVE_FOCUS_NODE_CSS_SELECTOR);
              if (c instanceof HTMLElement || c instanceof SVGElement) {
                if (a = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(c, a)) return a;
              }
              return null;
            }
            static findFocusableNodeFor(a, b) {
              if (!a.id || a.id === "null" || b.getNestedTrees().map((e) => FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(a, e)).findIndex((e) => !!e) !== -1) return null;
              var c = b.getRootFocusableNode();
              if (c.canBeFocused() && a === c.getFocusableElement()) return c;
              var d;
              if (c = (d = b.lookUpFocusableNode(a.id)) != null ? d : null) return c;
              d = a.parentElement;
              return !c && d ? FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(d, b) : null;
            }
          };
          FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.ACTIVE_CLASS_NAME = "blocklyActiveFocus";
          FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.PASSIVE_CSS_CLASS_NAME = "blocklyPassiveFocus";
          FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.ACTIVE_FOCUS_NODE_CSS_SELECTOR = `.${FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.ACTIVE_CLASS_NAME}`;
          FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.PASSIVE_FOCUS_NODE_CSS_SELECTOR = `.${FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.PASSIVE_CSS_CLASS_NAME}`;
          var module$build$src$core$utils$focusable_tree_traverser = {};
          module$build$src$core$utils$focusable_tree_traverser.FocusableTreeTraverser = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser;
          var TreeRegistration$$module$build$src$core$focus_manager = class {
            constructor(a, b) {
              this.tree = a;
              this.rootShouldBeAutoTabbable = b;
            }
          }, FocusManager$$module$build$src$core$focus_manager = class {
            constructor(a) {
              this.previouslyFocusedNode = this.focusedNode = null;
              this.registeredTrees = [];
              this.isUpdatingFocusedNode = this.recentlyLostAllFocus = this.lockFocusStateChanges = this.currentlyHoldsEphemeralFocus = false;
              const b = (c) => {
                if (!this.isUpdatingFocusedNode) {
                  this.recentlyLostAllFocus = !c;
                  var d = null;
                  if (c instanceof HTMLElement || c instanceof SVGElement) {
                    for (var e of this.registeredTrees) if (d = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(c, e.tree)) break;
                  }
                  if (d && d.canBeFocused()) {
                    c = d.getFocusableTree();
                    let f;
                    e = (f = this.focusedNode) == null ? void 0 : f.getFocusableTree();
                    d === c.getRootFocusableNode() && c !== e ? this.focusTree(c) : this.focusNode(d);
                  } else this.defocusCurrentFocusedNode();
                }
              };
              a("focusin", (c) => {
                c instanceof FocusEvent && b(document.activeElement);
              });
              a("focusout", (c) => {
                c instanceof FocusEvent && b(c.relatedTarget);
              });
            }
            registerTree(a, b = false) {
              this.ensureManagerIsUnlocked();
              if (this.isRegistered(a)) throw Error(`Attempted to re-register already registered tree: ${a}.`);
              this.registeredTrees.push(new TreeRegistration$$module$build$src$core$focus_manager(a, b));
              const c = a.getRootFocusableNode().getFocusableElement();
              if (!c.id || c.id === "null") throw Error(`Attempting to register a tree with a root element that has an invalid ID: ${a}.`);
              b && (c.tabIndex = 0);
            }
            isRegistered(a) {
              return !!this.lookUpRegistration(a);
            }
            lookUpRegistration(a) {
              let b;
              return (b = this.registeredTrees.find((c) => c.tree === a)) != null ? b : null;
            }
            unregisterTree(a) {
              this.ensureManagerIsUnlocked();
              if (!this.isRegistered(a)) throw Error(`Attempted to unregister not registered tree: ${a}.`);
              var b = this.registeredTrees.findIndex((e) => e.tree === a);
              const c = this.registeredTrees[b];
              this.registeredTrees.splice(b, 1);
              b = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusedNode(a);
              const d = a.getRootFocusableNode();
              b && this.removeHighlight(b);
              this.focusedNode !== b && this.focusedNode !== d || this.updateFocusedNode(null);
              this.removeHighlight(d);
              c.rootShouldBeAutoTabbable && a.getRootFocusableNode().getFocusableElement().removeAttribute("tabindex");
            }
            getFocusedTree() {
              let a, b;
              return (b = (a = this.focusedNode) == null ? void 0 : a.getFocusableTree()) != null ? b : null;
            }
            getFocusedNode() {
              return this.focusedNode;
            }
            focusTree(a) {
              this.ensureManagerIsUnlocked();
              if (!this.isRegistered(a)) throw Error(`Attempted to focus unregistered tree: ${a}.`);
              const b = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusedNode(a), c = a.getRestoredFocusableNode(b);
              a = a.getRootFocusableNode();
              let d;
              this.focusNode((d = c != null ? c : b) != null ? d : a);
            }
            focusNode(a) {
              this.ensureManagerIsUnlocked();
              const b = !this.currentlyHoldsEphemeralFocus;
              b && (this.isUpdatingFocusedNode = true);
              var c, d = ((c = this.focusedNode) == null ? void 0 : c.getFocusableElement()) !== document.activeElement;
              if (this.focusedNode !== a || d) if (a.canBeFocused()) {
                c = a.getFocusableTree();
                if (!this.isRegistered(c)) throw Error(`Attempted to focus unregistered node: ${a}.`);
                d = a.getFocusableElement();
                d.id && d.id !== "null" || console.warn("Trying to focus a node that has an invalid ID.");
                var e = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusableNodeFor(d, c);
                d = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser.findFocusedNode(c);
                var f = a;
                if (e !== a) {
                  f = c.getRestoredFocusableNode(d);
                  a = c.getRootFocusableNode();
                  var g;
                  f = (g = f != null ? f : d) != null ? g : a;
                }
                a = this.focusedNode;
                g = a == null ? void 0 : a.getFocusableTree();
                a && this.passivelyFocusNode(a, c);
                c = c.getRootFocusableNode();
                d && this.removeHighlight(d);
                c !== f && this.removeHighlight(c);
                this.currentlyHoldsEphemeralFocus || this.activelyFocusNode(f, g != null ? g : null);
                this.updateFocusedNode(f);
              } else console.warn("Trying to focus a node that can't be focused.");
              b && (this.isUpdatingFocusedNode = false);
            }
            takeEphemeralFocus(a) {
              this.ensureManagerIsUnlocked();
              if (this.currentlyHoldsEphemeralFocus) throw Error(`Attempted to take ephemeral focus when it's already held, with new element: ${a}.`);
              this.currentlyHoldsEphemeralFocus = true;
              this.focusedNode && this.passivelyFocusNode(this.focusedNode, null);
              a.focus({ preventScroll: true });
              let b = false;
              return () => {
                if (b) throw Error(`Attempted to finish ephemeral focus twice for element: ${a}.`);
                b = true;
                this.currentlyHoldsEphemeralFocus = false;
                if (this.focusedNode) {
                  this.activelyFocusNode(this.focusedNode, null);
                  const c = this.focusedNode;
                  setTimeout(() => {
                    !this.focusedNode && this.previouslyFocusedNode === c && this.recentlyLostAllFocus && this.focusNode(c);
                  }, 0);
                }
              };
            }
            ephemeralFocusTaken() {
              return this.currentlyHoldsEphemeralFocus;
            }
            ensureManagerIsUnlocked() {
              if (this.lockFocusStateChanges) throw Error("FocusManager state changes cannot happen in a tree/node focus/blur callback.");
            }
            updateFocusedNode(a) {
              this.previouslyFocusedNode = this.focusedNode;
              this.focusedNode = a;
            }
            defocusCurrentFocusedNode() {
              this.focusedNode && !this.currentlyHoldsEphemeralFocus && (this.passivelyFocusNode(this.focusedNode, null), this.updateFocusedNode(null));
            }
            activelyFocusNode(a, b) {
              this.lockFocusStateChanges = true;
              const c = a.getFocusableTree(), d = a.getFocusableElement();
              let e;
              const f = (e = this.lookUpRegistration(c)) == null ? void 0 : e.rootShouldBeAutoTabbable;
              c !== b && (c.onTreeFocus(a, b), f && (c.getRootFocusableNode().getFocusableElement().tabIndex = -1));
              a.onNodeFocus();
              this.lockFocusStateChanges = false;
              f && a === c.getRootFocusableNode() || d.hasAttribute("tabindex") || (d.tabIndex = -1);
              this.setNodeToVisualActiveFocus(a);
              d.focus({ preventScroll: true });
            }
            passivelyFocusNode(a, b) {
              this.lockFocusStateChanges = true;
              const c = a.getFocusableTree();
              if (c !== b) {
                c.onTreeBlur(b);
                let d;
                if ((d = this.lookUpRegistration(c)) == null ? 0 : d.rootShouldBeAutoTabbable) c.getRootFocusableNode().getFocusableElement().tabIndex = 0;
              }
              a.onNodeBlur();
              this.lockFocusStateChanges = false;
              c !== b && this.setNodeToVisualPassiveFocus(a);
            }
            setNodeToVisualActiveFocus(a) {
              a = a.getFocusableElement();
              addClass$$module$build$src$core$utils$dom(a, FocusManager$$module$build$src$core$focus_manager.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME);
              removeClass$$module$build$src$core$utils$dom(a, FocusManager$$module$build$src$core$focus_manager.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME);
            }
            setNodeToVisualPassiveFocus(a) {
              a = a.getFocusableElement();
              removeClass$$module$build$src$core$utils$dom(a, FocusManager$$module$build$src$core$focus_manager.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME);
              addClass$$module$build$src$core$utils$dom(
                a,
                FocusManager$$module$build$src$core$focus_manager.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME
              );
            }
            removeHighlight(a) {
              a = a.getFocusableElement();
              removeClass$$module$build$src$core$utils$dom(a, FocusManager$$module$build$src$core$focus_manager.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME);
              removeClass$$module$build$src$core$utils$dom(a, FocusManager$$module$build$src$core$focus_manager.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME);
            }
            static getFocusManager() {
              FocusManager$$module$build$src$core$focus_manager.focusManager || (FocusManager$$module$build$src$core$focus_manager.focusManager = new FocusManager$$module$build$src$core$focus_manager(document.addEventListener));
              return FocusManager$$module$build$src$core$focus_manager.focusManager;
            }
          };
          FocusManager$$module$build$src$core$focus_manager.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME = "blocklyActiveFocus";
          FocusManager$$module$build$src$core$focus_manager.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME = "blocklyPassiveFocus";
          FocusManager$$module$build$src$core$focus_manager.focusManager = null;
          var module$build$src$core$focus_manager = {};
          module$build$src$core$focus_manager.FocusManager = FocusManager$$module$build$src$core$focus_manager;
          module$build$src$core$focus_manager.getFocusManager = $.getFocusManager$$module$build$src$core$focus_manager;
          var module$build$src$core$interfaces$i_focusable_node = {};
          module$build$src$core$interfaces$i_focusable_node.isFocusableNode = isFocusableNode$$module$build$src$core$interfaces$i_focusable_node;
          var module$build$src$core$interfaces$i_selectable = {};
          module$build$src$core$interfaces$i_selectable.isSelectable = isSelectable$$module$build$src$core$interfaces$i_selectable;
          var module$build$src$core$utils$object = {};
          module$build$src$core$utils$object.deepMerge = deepMerge$$module$build$src$core$utils$object;
          var ShortcutRegistry$$module$build$src$core$shortcut_registry = class {
            constructor() {
              this.shortcuts = /* @__PURE__ */ new Map();
              this.keyMap = /* @__PURE__ */ new Map();
              this.reset();
            }
            reset() {
              this.shortcuts.clear();
              this.keyMap.clear();
            }
            register(a, b) {
              if (this.shortcuts.get(a.name) && !b) throw Error(`Shortcut named "${a.name}" already exists.`);
              this.shortcuts.set(a.name, a);
              b = a.keyCodes;
              if (b == null ? 0 : b.length) for (const c of b) this.addKeyMapping(c, a.name, !!a.allowCollision);
            }
            unregister(a) {
              if (!this.shortcuts.get(a)) return console.warn(`Keyboard shortcut named "${a}" not found.`), false;
              this.removeAllKeyMappings(a);
              this.shortcuts.delete(a);
              return true;
            }
            addKeyMapping(a, b, c) {
              a = `${a}`;
              const d = this.keyMap.get(a);
              if (d && !c) throw Error(`Shortcut named "${b}" collides with shortcuts "${d}"`);
              d && c ? d.unshift(b) : this.keyMap.set(a, [b]);
            }
            removeKeyMapping(a, b, c) {
              const d = this.keyMap.get(a);
              if (!d) return c || console.warn(`No keyboard shortcut named "${b}" registered with key code "${a}"`), false;
              const e = d.indexOf(b);
              if (e > -1) return d.splice(e, 1), d.length === 0 && this.keyMap.delete(a), true;
              c || console.warn(`No keyboard shortcut named "${b}" registered with key code "${a}"`);
              return false;
            }
            removeAllKeyMappings(a) {
              for (const b of this.keyMap.keys()) this.removeKeyMapping(b, a, true);
            }
            setKeyMap(a) {
              this.keyMap.clear();
              for (const b in a) this.keyMap.set(b, a[b]);
            }
            getKeyMap() {
              const a = /* @__PURE__ */ Object.create(null);
              for (const [b, c] of this.keyMap) a[b] = c;
              return a;
            }
            getRegistry() {
              const a = /* @__PURE__ */ Object.create(null);
              for (const [b, c] of this.shortcuts) a[b] = c;
              return deepMerge$$module$build$src$core$utils$object(/* @__PURE__ */ Object.create(null), a);
            }
            onKeyDown(a, b) {
              var c = this.serializeKeyEvent(b);
              c = this.getShortcutNamesByKeyCode(c);
              if (!c) return false;
              for (const d of c) {
                c = this.shortcuts.get(d);
                let e;
                if (!c || c.preconditionFn && !c.preconditionFn(a, { focusedNode: (e = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode()) != null ? e : void 0 })) continue;
                let f, g, h;
                if ((g = (f = c).callback) == null ? 0 : g.call(f, a, b, c, { focusedNode: (h = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode()) != null ? h : void 0 })) return true;
              }
              return false;
            }
            getShortcutNamesByKeyCode(a) {
              let b;
              return ((b = this.keyMap.get(a)) == null ? void 0 : b.slice()) || [];
            }
            getKeyCodesByShortcutName(a) {
              const b = [];
              for (const [c, d] of this.keyMap) d.indexOf(a) > -1 && b.push(c);
              return b;
            }
            serializeKeyEvent(a) {
              let b = "";
              for (const c in ShortcutRegistry$$module$build$src$core$shortcut_registry.modifierKeys) a.getModifierState(c) && (b !== "" && (b += "+"), b += c);
              b !== "" && a.keyCode ? b += "+" + a.keyCode : a.keyCode && (b = String(a.keyCode));
              return b;
            }
            checkModifiers(a) {
              for (const b of a) if (!(b in ShortcutRegistry$$module$build$src$core$shortcut_registry.modifierKeys)) throw Error(b + " is not a valid modifier key.");
            }
            createSerializedKey(a, b) {
              let c = "";
              if (b) {
                this.checkModifiers(b);
                for (const d in ShortcutRegistry$$module$build$src$core$shortcut_registry.modifierKeys) b.includes(ShortcutRegistry$$module$build$src$core$shortcut_registry.modifierKeys[d]) && (c !== "" && (c += "+"), c += d);
              }
              c !== "" && a ? c += "+" + a : a && (c = `${a}`);
              return c;
            }
          };
          ShortcutRegistry$$module$build$src$core$shortcut_registry.registry = new ShortcutRegistry$$module$build$src$core$shortcut_registry();
          (function(a) {
            a = a.modifierKeys || (a.modifierKeys = {});
            a[a.Shift = 16] = "Shift";
            a[a.Control = 17] = "Control";
            a[a.Alt = 18] = "Alt";
            a[a.Meta = 91] = "Meta";
          })(ShortcutRegistry$$module$build$src$core$shortcut_registry || (ShortcutRegistry$$module$build$src$core$shortcut_registry = {}));
          var module$build$src$core$shortcut_registry = {};
          module$build$src$core$shortcut_registry.ShortcutRegistry = ShortcutRegistry$$module$build$src$core$shortcut_registry;
          var WorkspaceDB_$$module$build$src$core$common = /* @__PURE__ */ Object.create(null), mainWorkspace$$module$build$src$core$common, parentContainer$$module$build$src$core$common, draggingConnections$$module$build$src$core$common = [], TEST_ONLY$$module$build$src$core$common = { defineBlocksWithJsonArrayInternal: defineBlocksWithJsonArrayInternal$$module$build$src$core$common }, module$build$src$core$common = { TEST_ONLY: TEST_ONLY$$module$build$src$core$common };
          module$build$src$core$common.createBlockDefinitionsFromJsonArray = $.createBlockDefinitionsFromJsonArray$$module$build$src$core$common;
          module$build$src$core$common.defineBlocks = $.defineBlocks$$module$build$src$core$common;
          module$build$src$core$common.defineBlocksWithJsonArray = defineBlocksWithJsonArray$$module$build$src$core$common;
          module$build$src$core$common.draggingConnections = draggingConnections$$module$build$src$core$common;
          module$build$src$core$common.fireSelectedEvent = fireSelectedEvent$$module$build$src$core$common;
          module$build$src$core$common.getAllWorkspaces = getAllWorkspaces$$module$build$src$core$common;
          module$build$src$core$common.getBlockTypeCounts = getBlockTypeCounts$$module$build$src$core$common;
          module$build$src$core$common.getMainWorkspace = getMainWorkspace$$module$build$src$core$common;
          module$build$src$core$common.getParentContainer = getParentContainer$$module$build$src$core$common;
          module$build$src$core$common.getSelected = getSelected$$module$build$src$core$common;
          module$build$src$core$common.getWorkspaceById = getWorkspaceById$$module$build$src$core$common;
          module$build$src$core$common.globalShortcutHandler = globalShortcutHandler$$module$build$src$core$common;
          module$build$src$core$common.registerWorkspace = registerWorkspace$$module$build$src$core$common;
          module$build$src$core$common.setMainWorkspace = setMainWorkspace$$module$build$src$core$common;
          module$build$src$core$common.setParentContainer = setParentContainer$$module$build$src$core$common;
          module$build$src$core$common.setSelected = setSelected$$module$build$src$core$common;
          module$build$src$core$common.svgResize = svgResize$$module$build$src$core$common;
          module$build$src$core$common.unregisterWorkpace = unregisterWorkpace$$module$build$src$core$common;
          var Abstract$$module$build$src$core$events$events_abstract = class {
            constructor() {
              this.workspaceId = void 0;
              this.isUiEvent = false;
              this.type = "";
              this.group = $.getGroup$$module$build$src$core$events$utils();
              this.recordUndo = getRecordUndo$$module$build$src$core$events$utils();
            }
            toJson() {
              return { type: this.type, group: this.group };
            }
            static fromJson(a, b, c) {
              c.isBlank = false;
              c.group = a.group || "";
              c.workspaceId = b.id;
              return c;
            }
            isNull() {
              return false;
            }
            run(a) {
            }
            getEventWorkspace_() {
              let a;
              this.workspaceId && (a = getWorkspaceById$$module$build$src$core$common(this.workspaceId));
              if (!a) throw Error("Workspace is null. Event must have been generated from real Blockly events.");
              return a;
            }
          }, module$build$src$core$events$events_abstract = {};
          module$build$src$core$events$events_abstract.Abstract = Abstract$$module$build$src$core$events$events_abstract;
          var UiBase$$module$build$src$core$events$events_ui_base = class extends Abstract$$module$build$src$core$events$events_abstract {
            constructor(a) {
              super();
              this.recordUndo = false;
              this.isUiEvent = true;
              this.isBlank = typeof a === "undefined";
              this.workspaceId = a ? a : "";
            }
          }, module$build$src$core$events$events_ui_base = {};
          module$build$src$core$events$events_ui_base.UiBase = UiBase$$module$build$src$core$events$events_ui_base;
          var Click$$module$build$src$core$events$events_click = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c) {
              b = a ? a.workspace.id : b;
              b === null && (b = void 0);
              super(b);
              this.type = EventType$$module$build$src$core$events$type.CLICK;
              this.blockId = a ? a.id : void 0;
              this.targetType = c;
            }
            toJson() {
              const a = super.toJson();
              if (!this.targetType) throw Error("The click target type is undefined. Either pass a block to the constructor, or call fromJson");
              a.targetType = this.targetType;
              a.blockId = this.blockId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new Click$$module$build$src$core$events$events_click());
              b.targetType = a.targetType;
              b.blockId = a.blockId;
              return b;
            }
          }, ClickTarget$$module$build$src$core$events$events_click;
          (function(a) {
            a.BLOCK = "block";
            a.WORKSPACE = "workspace";
            a.ZOOM_CONTROLS = "zoom_controls";
          })(ClickTarget$$module$build$src$core$events$events_click || (ClickTarget$$module$build$src$core$events$events_click = {}));
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.CLICK, Click$$module$build$src$core$events$events_click);
          var module$build$src$core$events$events_click = {};
          module$build$src$core$events$events_click.Click = Click$$module$build$src$core$events$events_click;
          module$build$src$core$events$events_click.ClickTarget = ClickTarget$$module$build$src$core$events$events_click;
          var module$build$src$core$utils$array = {};
          module$build$src$core$utils$array.removeElem = removeElem$$module$build$src$core$utils$array;
          var Capability$$module$build$src$core$component_manager = class {
            constructor(a) {
              this.name = a;
            }
            toString() {
              return this.name;
            }
          };
          Capability$$module$build$src$core$component_manager.POSITIONABLE = new Capability$$module$build$src$core$component_manager("positionable");
          Capability$$module$build$src$core$component_manager.DRAG_TARGET = new Capability$$module$build$src$core$component_manager("drag_target");
          Capability$$module$build$src$core$component_manager.DELETE_AREA = new Capability$$module$build$src$core$component_manager("delete_area");
          Capability$$module$build$src$core$component_manager.AUTOHIDEABLE = new Capability$$module$build$src$core$component_manager("autohideable");
          var ComponentManager$$module$build$src$core$component_manager = class {
            constructor() {
              this.componentData = /* @__PURE__ */ new Map();
              this.capabilityToComponentIds = /* @__PURE__ */ new Map();
            }
            addComponent(a, b) {
              const c = a.component.id;
              if (!b && this.componentData.has(c)) {
                var d;
                throw Error('Plugin "' + c + '" with capabilities "' + ((d = this.componentData.get(c)) == null ? void 0 : d.capabilities) + '" already added.');
              }
              this.componentData.set(c, a);
              b = [];
              for (d = 0; d < a.capabilities.length; d++) {
                const e = String(a.capabilities[d]).toLowerCase();
                b.push(e);
                if (this.capabilityToComponentIds.has(e)) {
                  let f;
                  (f = this.capabilityToComponentIds.get(e)) == null || f.push(c);
                } else this.capabilityToComponentIds.set(e, [c]);
              }
              this.componentData.get(c).capabilities = b;
            }
            removeComponent(a) {
              const b = this.componentData.get(a);
              if (b) {
                for (let c = 0; c < b.capabilities.length; c++) {
                  const d = String(b.capabilities[c]).toLowerCase();
                  removeElem$$module$build$src$core$utils$array(this.capabilityToComponentIds.get(d), a);
                }
                this.componentData.delete(a);
              }
            }
            addCapability(a, b) {
              if (!this.getComponent(a)) throw Error('Cannot add capability, "' + b + '". Plugin "' + a + '" has not been added to the ComponentManager');
              if (this.hasCapability(a, b)) console.warn('Plugin "' + a + 'already has capability "' + b + '"');
              else {
                b = `${b}`.toLowerCase();
                var c;
                (c = this.componentData.get(a)) == null || c.capabilities.push(b);
                var d;
                (d = this.capabilityToComponentIds.get(b)) == null || d.push(a);
              }
            }
            removeCapability(a, b) {
              if (!this.getComponent(a)) throw Error('Cannot remove capability, "' + b + '". Plugin "' + a + '" has not been added to the ComponentManager');
              this.hasCapability(a, b) ? (b = `${b}`.toLowerCase(), removeElem$$module$build$src$core$utils$array(
                this.componentData.get(a).capabilities,
                b
              ), removeElem$$module$build$src$core$utils$array(this.capabilityToComponentIds.get(b), a)) : console.warn('Plugin "' + a + `doesn't have capability "` + b + '" to remove');
            }
            hasCapability(a, b) {
              b = `${b}`.toLowerCase();
              return this.componentData.has(a) && this.componentData.get(a).capabilities.includes(b);
            }
            getComponent(a) {
              let b;
              return (b = this.componentData.get(a)) == null ? void 0 : b.component;
            }
            getComponents(a, b) {
              a = `${a}`.toLowerCase();
              a = this.capabilityToComponentIds.get(a);
              if (!a) return [];
              const c = [];
              if (b) {
                const d = [];
                a.forEach((e) => {
                  d.push(this.componentData.get(e));
                });
                d.sort(function(e, f) {
                  return e.weight - f.weight;
                });
                d.forEach(function(e) {
                  c.push(e.component);
                });
              } else a.forEach((d) => {
                c.push(this.componentData.get(d).component);
              });
              return c;
            }
          };
          ComponentManager$$module$build$src$core$component_manager.Capability = Capability$$module$build$src$core$component_manager;
          (function(a) {
            a = a.ComponentWeight || (a.ComponentWeight = {});
            a[a.TOOLBOX_WEIGHT = 0] = "TOOLBOX_WEIGHT";
            a[a.FLYOUT_WEIGHT = 1] = "FLYOUT_WEIGHT";
            a[a.TRASHCAN_WEIGHT = 2] = "TRASHCAN_WEIGHT";
            a[a.ZOOM_CONTROLS_WEIGHT = 3] = "ZOOM_CONTROLS_WEIGHT";
          })(ComponentManager$$module$build$src$core$component_manager || (ComponentManager$$module$build$src$core$component_manager = {}));
          var ComponentWeight$$module$build$src$core$component_manager = ComponentManager$$module$build$src$core$component_manager.ComponentWeight, module$build$src$core$component_manager = {};
          module$build$src$core$component_manager.ComponentManager = ComponentManager$$module$build$src$core$component_manager;
          module$build$src$core$component_manager.ComponentWeight = ComponentWeight$$module$build$src$core$component_manager;
          var injected$$module$build$src$core$css = false, content$$module$build$src$core$css = `
.blocklySvg {
  background-color: #fff;
  outline: none;
  overflow: hidden;  /* IE overflows by default. */
  position: absolute;
  display: block;
}

.blocklyWidgetDiv {
  display: none;
  position: absolute;
  z-index: 99999;  /* big value for bootstrap3 compatibility */
}

.injectionDiv {
  height: 100%;
  position: relative;
  overflow: hidden;  /* So blocks in drag surface disappear at edges */
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}

.blocklyBlockCanvas.blocklyCanvasTransitioning,
.blocklyBubbleCanvas.blocklyCanvasTransitioning {
  transition: transform .5s;
}

.blocklyEmboss {
  filter: var(--blocklyEmbossFilter);
}

.blocklyTooltipDiv {
  background-color: #ffffc7;
  border: 1px solid #ddc;
  box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);
  color: #000;
  display: none;
  font: 9pt sans-serif;
  opacity: .9;
  padding: 2px;
  position: absolute;
  z-index: 100000;  /* big value for bootstrap3 compatibility */
}

.blocklyDropDownDiv {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1000;
  display: none;
  border: 1px solid;
  border-color: #dadce0;
  background-color: #fff;
  border-radius: 2px;
  padding: 4px;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv:focus {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownContent {
  max-height: 300px;  /* @todo: spec for maximum height. */
}

.blocklyDropDownArrow {
  position: absolute;
  left: 0;
  top: 0;
  width: 16px;
  height: 16px;
  z-index: -1;
  background-color: inherit;
  border-color: inherit;
  border-top: 1px solid;
  border-left: 1px solid;
  border-top-left-radius: 4px;
  border-color: inherit;
}

.blocklyHighlighted>.blocklyPath {
  filter: var(--blocklyEmbossFilter);
}

.blocklyHighlightedConnectionPath {
  fill: none;
  stroke: #fc3;
  stroke-width: 4px;
}

.blocklyPathLight {
  fill: none;
  stroke-linecap: round;
  stroke-width: 1;
}

.blocklySelected>.blocklyPathLight {
  display: none;
}

.blocklyDraggable {
  cursor: grab;
  cursor: -webkit-grab;
}

.blocklyDragging {
  cursor: grabbing;
  cursor: -webkit-grabbing;
  /* Drag surface disables events to not block the toolbox, so we have to
   * reenable them here for the cursor values to work. */
  pointer-events: auto;
}

  /* Changes cursor on mouse down. Not effective in Firefox because of
     https://bugzilla.mozilla.org/show_bug.cgi?id=771241 */
.blocklyDraggable:active {
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

.blocklyDragging.blocklyDraggingDelete,
.blocklyDragging.blocklyDraggingDelete .blocklyField {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyDragging>.blocklyPath,
.blocklyDragging>.blocklyPathLight {
  fill-opacity: .8;
  stroke-opacity: .8;
}

.blocklyDragging>.blocklyPathDark {
  display: none;
}

.blocklyDisabledPattern>.blocklyPath {
  fill: var(--blocklyDisabledPattern);
  fill-opacity: .5;
  stroke-opacity: .5;
}

.blocklyDisabled>.blocklyPathLight,
.blocklyDisabled>.blocklyPathDark {
  display: none;
}

.blocklyInsertionMarker>.blocklyPath,
.blocklyInsertionMarker>.blocklyPathLight,
.blocklyInsertionMarker>.blocklyPathDark {
  fill-opacity: .2;
  stroke: none;
}

.blocklyNonEditableField>text {
  pointer-events: none;
}

.blocklyFlyout {
  position: absolute;
  z-index: 20;
}

.blocklyText text {
  cursor: default;
}

/*
  Don't allow users to select text.  It gets annoying when trying to
  drag a block and selected text moves instead.
*/
.blocklySvg text {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  cursor: inherit;
}

.blocklyIconGroup {
  cursor: default;
}

.blocklyIconGroup:not(:hover):not(:focus),
.blocklyIconGroupReadonly {
  opacity: .6;
}

.blocklyIconShape {
  fill: #00f;
  stroke: #fff;
  stroke-width: 1px;
}

.blocklyIconSymbol {
  fill: #fff;
}

.blocklyMinimalBody {
  margin: 0;
  padding: 0;
  height: 100%;
}

.blocklyHtmlInput {
  border: none;
  border-radius: 4px;
  height: 100%;
  margin: 0;
  outline: none;
  padding: 0;
  width: 100%;
  text-align: center;
  display: block;
  box-sizing: border-box;
}

/* Remove the increase and decrease arrows on the field number editor */
input.blocklyHtmlInput[type=number]::-webkit-inner-spin-button,
input.blocklyHtmlInput[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type=number] {
  -moz-appearance: textfield;
}

.blocklyMainBackground {
  stroke-width: 1;
  stroke: #c6c6c6;  /* Equates to #ddd due to border being off-pixel. */
}

.blocklyMutatorBackground {
  fill: #fff;
  stroke: #ddd;
  stroke-width: 1;
}

.blocklyFlyoutBackground {
  fill: #ddd;
  fill-opacity: .8;
}

.blocklyMainWorkspaceScrollbar {
  z-index: 20;
}

.blocklyFlyoutScrollbar {
  z-index: 30;
}

.blocklyScrollbarHorizontal,
.blocklyScrollbarVertical {
  position: absolute;
  outline: none;
}

.blocklyScrollbarBackground {
  opacity: 0;
  pointer-events: none;
}

.blocklyScrollbarHandle {
  fill: #ccc;
}

.blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyScrollbarHandle:hover {
  fill: #bbb;
}

/* Darken flyout scrollbars due to being on a grey background. */
/* By contrast, workspace scrollbars are on a white background. */
.blocklyFlyout .blocklyScrollbarHandle {
  fill: #bbb;
}

.blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyFlyout .blocklyScrollbarHandle:hover {
  fill: #aaa;
}

.blocklyInvalidInput {
  background: #faa;
}

.blocklyVerticalMarker {
  stroke-width: 3px;
  fill: rgba(255,255,255,.5);
  pointer-events: none;
}

.blocklyComputeCanvas {
  position: absolute;
  width: 0;
  height: 0;
}

.blocklyNoPointerEvents {
  pointer-events: none;
}

.blocklyContextMenu {
  border-radius: 4px;
  max-height: 100%;
}

.blocklyDropdownMenu {
  border-radius: 2px;
  padding: 0 !important;
}

.blocklyDropdownMenu .blocklyMenuItem {
  /* 28px on the left for icon or checkbox. */
  padding-left: 28px;
}

/* BiDi override for the resting state. */
.blocklyDropdownMenu .blocklyMenuItemRtl {
  /* Flip left/right padding for BiDi. */
  padding-left: 5px;
  padding-right: 28px;
}

.blocklyWidgetDiv .blocklyMenu {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  background: #fff;
  border: 1px solid transparent;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
  font: normal 13px Arial, sans-serif;
  margin: 0;
  outline: none;
  padding: 4px 0;
  position: absolute;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

.blocklyWidgetDiv .blocklyMenu:focus {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv .blocklyMenu {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  background: inherit;  /* Compatibility with gapi, reset from goog-menu */
  border: inherit;  /* Compatibility with gapi, reset from goog-menu */
  font: normal 13px "Helvetica Neue", Helvetica, sans-serif;
  outline: none;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

/* State: resting. */
.blocklyMenuItem {
  border: none;
  color: #000;
  cursor: pointer;
  list-style: none;
  margin: 0;
  /* 7em on the right for shortcut. */
  min-width: 7em;
  padding: 6px 15px;
  white-space: nowrap;
}

/* State: disabled. */
.blocklyMenuItemDisabled {
  color: #ccc;
  cursor: inherit;
}

/* State: hover. */
.blocklyMenuItemHighlight {
  background-color: rgba(0,0,0,.1);
}

/* State: selected/checked. */
.blocklyMenuItemCheckbox {
  height: 16px;
  position: absolute;
  width: 16px;
}

.blocklyMenuItemSelected .blocklyMenuItemCheckbox {
  background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;
  float: left;
  margin-left: -24px;
  position: static;  /* Scroll with the menu. */
}

.blocklyMenuItemRtl .blocklyMenuItemCheckbox {
  float: right;
  margin-right: -24px;
}

.blocklyMenuSeparator {
  background-color: #ccc;
  height: 1px;
  border: 0;
  margin-left: 4px;
  margin-right: 4px;
}

.blocklyBlockDragSurface, .blocklyAnimationLayer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: visible !important;
  z-index: 80;
  pointer-events: none;
}

.blocklyField {
  cursor: default;
}

.blocklyInputField {
  cursor: text;
}

.blocklyDragging .blocklyField,
.blocklyDragging .blocklyIconGroup {
  cursor: grabbing;
}

.blocklyActiveFocus:is(
  .blocklyFlyout,
  .blocklyWorkspace,
  .blocklyField,
  .blocklyPath,
  .blocklyHighlightedConnectionPath,
  .blocklyComment,
  .blocklyBubble,
  .blocklyIconGroup,
  .blocklyTextarea
) {
  outline: none;
}
`, module$build$src$core$css = {};
          module$build$src$core$css.inject = inject$$module$build$src$core$css;
          module$build$src$core$css.register = register$$module$build$src$core$css;
          var Coordinate$$module$build$src$core$utils$coordinate = class {
            constructor(a, b) {
              this.x = a;
              this.y = b;
            }
            clone() {
              return new Coordinate$$module$build$src$core$utils$coordinate(this.x, this.y);
            }
            scale(a) {
              this.x *= a;
              this.y *= a;
              return this;
            }
            translate(a, b) {
              this.x += a;
              this.y += b;
              return this;
            }
            static equals(a, b) {
              return a === b ? true : a && b ? a.x === b.x && a.y === b.y : false;
            }
            static distance(a, b) {
              const c = a.x - b.x;
              a = a.y - b.y;
              return Math.sqrt(c * c + a * a);
            }
            static magnitude(a) {
              return Math.sqrt(a.x * a.x + a.y * a.y);
            }
            static difference(a, b) {
              return new Coordinate$$module$build$src$core$utils$coordinate(a.x - b.x, a.y - b.y);
            }
            static sum(a, b) {
              return new Coordinate$$module$build$src$core$utils$coordinate(a.x + b.x, a.y + b.y);
            }
          }, module$build$src$core$utils$coordinate = {};
          module$build$src$core$utils$coordinate.Coordinate = Coordinate$$module$build$src$core$utils$coordinate;
          var Svg$$module$build$src$core$utils$svg = class {
            constructor(a) {
              this.tagName = a;
            }
            toString() {
              return this.tagName;
            }
          };
          Svg$$module$build$src$core$utils$svg.ANIMATE = new Svg$$module$build$src$core$utils$svg("animate");
          Svg$$module$build$src$core$utils$svg.CIRCLE = new Svg$$module$build$src$core$utils$svg("circle");
          Svg$$module$build$src$core$utils$svg.CLIPPATH = new Svg$$module$build$src$core$utils$svg("clipPath");
          Svg$$module$build$src$core$utils$svg.DEFS = new Svg$$module$build$src$core$utils$svg("defs");
          Svg$$module$build$src$core$utils$svg.FECOMPOSITE = new Svg$$module$build$src$core$utils$svg("feComposite");
          Svg$$module$build$src$core$utils$svg.FECOMPONENTTRANSFER = new Svg$$module$build$src$core$utils$svg("feComponentTransfer");
          Svg$$module$build$src$core$utils$svg.FEFLOOD = new Svg$$module$build$src$core$utils$svg("feFlood");
          Svg$$module$build$src$core$utils$svg.FEFUNCA = new Svg$$module$build$src$core$utils$svg("feFuncA");
          Svg$$module$build$src$core$utils$svg.FEGAUSSIANBLUR = new Svg$$module$build$src$core$utils$svg("feGaussianBlur");
          Svg$$module$build$src$core$utils$svg.FEPOINTLIGHT = new Svg$$module$build$src$core$utils$svg("fePointLight");
          Svg$$module$build$src$core$utils$svg.FESPECULARLIGHTING = new Svg$$module$build$src$core$utils$svg("feSpecularLighting");
          Svg$$module$build$src$core$utils$svg.FILTER = new Svg$$module$build$src$core$utils$svg("filter");
          Svg$$module$build$src$core$utils$svg.FOREIGNOBJECT = new Svg$$module$build$src$core$utils$svg("foreignObject");
          Svg$$module$build$src$core$utils$svg.G = new Svg$$module$build$src$core$utils$svg("g");
          Svg$$module$build$src$core$utils$svg.IMAGE = new Svg$$module$build$src$core$utils$svg("image");
          Svg$$module$build$src$core$utils$svg.LINE = new Svg$$module$build$src$core$utils$svg("line");
          Svg$$module$build$src$core$utils$svg.PATH = new Svg$$module$build$src$core$utils$svg("path");
          Svg$$module$build$src$core$utils$svg.PATTERN = new Svg$$module$build$src$core$utils$svg("pattern");
          Svg$$module$build$src$core$utils$svg.POLYGON = new Svg$$module$build$src$core$utils$svg("polygon");
          Svg$$module$build$src$core$utils$svg.RECT = new Svg$$module$build$src$core$utils$svg("rect");
          Svg$$module$build$src$core$utils$svg.SVG = new Svg$$module$build$src$core$utils$svg("svg");
          Svg$$module$build$src$core$utils$svg.TEXT = new Svg$$module$build$src$core$utils$svg("text");
          Svg$$module$build$src$core$utils$svg.TSPAN = new Svg$$module$build$src$core$utils$svg("tspan");
          var module$build$src$core$utils$svg = {};
          module$build$src$core$utils$svg.Svg = Svg$$module$build$src$core$utils$svg;
          var Rect$$module$build$src$core$utils$rect = class {
            constructor(a, b, c, d) {
              this.top = a;
              this.bottom = b;
              this.left = c;
              this.right = d;
            }
            static from(a) {
              return new Rect$$module$build$src$core$utils$rect(a.y, a.y + a.height, a.x, a.x + a.width);
            }
            clone() {
              return new Rect$$module$build$src$core$utils$rect(this.top, this.bottom, this.left, this.right);
            }
            getHeight() {
              return this.bottom - this.top;
            }
            getWidth() {
              return this.right - this.left;
            }
            getOrigin() {
              return new Coordinate$$module$build$src$core$utils$coordinate(this.left, this.top);
            }
            contains(a, b) {
              return a >= this.left && a <= this.right && b >= this.top && b <= this.bottom;
            }
            intersects(a) {
              return this.left <= a.right && this.right >= a.left && this.bottom >= a.top && this.top <= a.bottom;
            }
            static equals(a, b) {
              return a === b ? true : a && b ? a.top === b.top && a.bottom === b.bottom && a.left === b.left && a.right === b.right : false;
            }
            static createFromPoint(a, b, c) {
              const d = a.x;
              a = a.y;
              return new Rect$$module$build$src$core$utils$rect(a, a + c, d, d + b);
            }
          }, module$build$src$core$utils$rect = {};
          module$build$src$core$utils$rect.Rect = Rect$$module$build$src$core$utils$rect;
          var Size$$module$build$src$core$utils$size = class {
            constructor(a, b) {
              this.width = a;
              this.height = b;
            }
            static equals(a, b) {
              return a === b ? true : a && b ? a.width === b.width && a.height === b.height : false;
            }
            static max(a, b) {
              return new Size$$module$build$src$core$utils$size(Math.max(a.width, b.width), Math.max(a.height, b.height));
            }
            static min(a, b) {
              return new Size$$module$build$src$core$utils$size(Math.min(a.width, b.width), Math.min(a.height, b.height));
            }
          }, module$build$src$core$utils$size = {};
          module$build$src$core$utils$size.Size = Size$$module$build$src$core$utils$size;
          var TEST_ONLY$$module$build$src$core$utils$style = { getSizeInternal: getSizeInternal$$module$build$src$core$utils$style }, module$build$src$core$utils$style = { TEST_ONLY: TEST_ONLY$$module$build$src$core$utils$style };
          module$build$src$core$utils$style.getBorderBox = getBorderBox$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.getComputedStyle = getComputedStyle$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.getContainerOffsetToScrollInto = getContainerOffsetToScrollInto$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.getPageOffset = getPageOffset$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.getSize = getSize$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.getViewportPageOffset = getViewportPageOffset$$module$build$src$core$utils$style;
          module$build$src$core$utils$style.scrollIntoContainerView = scrollIntoContainerView$$module$build$src$core$utils$style;
          var XY_REGEX$$module$build$src$core$utils$svg_math = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*)?/, XY_STYLE_REGEX$$module$build$src$core$utils$svg_math = /transform:\s*translate(?:3d)?\(\s*([-+\d.e]+)\s*px([ ,]\s*([-+\d.e]+)\s*px)?/, TEST_ONLY$$module$build$src$core$utils$svg_math = { XY_REGEX: XY_REGEX$$module$build$src$core$utils$svg_math, XY_STYLE_REGEX: XY_STYLE_REGEX$$module$build$src$core$utils$svg_math }, module$build$src$core$utils$svg_math = { TEST_ONLY: TEST_ONLY$$module$build$src$core$utils$svg_math };
          module$build$src$core$utils$svg_math.getDocumentScroll = getDocumentScroll$$module$build$src$core$utils$svg_math;
          module$build$src$core$utils$svg_math.getInjectionDivXY = getInjectionDivXY$$module$build$src$core$utils$svg_math;
          module$build$src$core$utils$svg_math.getRelativeXY = getRelativeXY$$module$build$src$core$utils$svg_math;
          module$build$src$core$utils$svg_math.getViewportBBox = getViewportBBox$$module$build$src$core$utils$svg_math;
          module$build$src$core$utils$svg_math.screenToWsCoordinates = screenToWsCoordinates$$module$build$src$core$utils$svg_math;
          module$build$src$core$utils$svg_math.wsToScreenCoordinates = wsToScreenCoordinates$$module$build$src$core$utils$svg_math;
          var Scrollbar$$module$build$src$core$scrollbar = class {
            constructor(a, b, c, d, e) {
              this.workspace = a;
              this.horizontal = b;
              this.oldHostMetrics = null;
              this.ratio = 1;
              this.origin = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.startDragHandle = this.handlePosition = this.handleLength = this.scrollbarLength = this.startDragMouse = 0;
              this.containerVisible = this.isHandleVisible = true;
              this.position = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.onMouseMoveWrapper_ = this.onMouseUpWrapper_ = null;
              this.pair = c || false;
              this.margin = e !== void 0 ? e : Scrollbar$$module$build$src$core$scrollbar.DEFAULT_SCROLLBAR_MARGIN;
              a = "blocklyScrollbar" + (this.horizontal ? "Horizontal" : "Vertical");
              d && (a += " " + d);
              this.outerSvg = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.SVG, { "class": a });
              d = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {}, this.outerSvg);
              this.svgBackground = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.RECT,
                { "class": "blocklyScrollbarBackground" },
                d
              );
              a = Math.floor((Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness - 5) / 2);
              this.svgHandle = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyScrollbarHandle", rx: a, ry: a }, d);
              this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarColour", "fill");
              this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarOpacity", "fill-opacity");
              insertAfter$$module$build$src$core$utils$dom(
                this.outerSvg,
                this.workspace.getParentSvg()
              );
              this.setInitialThickness();
              b ? (this.lengthAttribute_ = "width", this.positionAttribute_ = "x") : (this.lengthAttribute_ = "height", this.positionAttribute_ = "y");
              this.onMouseDownBarWrapper_ = conditionalBind$$module$build$src$core$browser_events(this.svgBackground, "pointerdown", this, this.onMouseDownBar);
              this.onMouseDownHandleWrapper_ = conditionalBind$$module$build$src$core$browser_events(this.svgHandle, "pointerdown", this, this.onMouseDownHandle);
            }
            setInitialThickness() {
              const a = Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness;
              this.horizontal ? (this.svgBackground.setAttribute("height", String(a)), this.outerSvg.setAttribute("height", String(a)), this.svgHandle.setAttribute("height", String(a - 5)), this.svgHandle.setAttribute("y", "2.5")) : (this.svgBackground.setAttribute("width", String(a)), this.outerSvg.setAttribute("width", String(a)), this.svgHandle.setAttribute("width", String(a - 5)), this.svgHandle.setAttribute("x", "2.5"));
            }
            dispose() {
              this.cleanUp();
              unbind$$module$build$src$core$browser_events(this.onMouseDownBarWrapper_);
              unbind$$module$build$src$core$browser_events(this.onMouseDownHandleWrapper_);
              removeNode$$module$build$src$core$utils$dom(this.outerSvg);
              this.workspace.getThemeManager().unsubscribe(this.svgHandle);
            }
            constrainHandleLength(a) {
              return a = a <= 0 || isNaN(a) ? 0 : Math.min(a, this.scrollbarLength);
            }
            setHandleLength(a) {
              this.handleLength = a;
              this.svgHandle.setAttribute(this.lengthAttribute_, String(this.handleLength));
            }
            constrainHandlePosition(a) {
              return a = a <= 0 || isNaN(a) ? 0 : Math.min(a, this.scrollbarLength - this.handleLength);
            }
            setHandlePosition(a) {
              this.handlePosition = a;
              this.svgHandle.setAttribute(
                this.positionAttribute_,
                String(this.handlePosition)
              );
            }
            setScrollbarLength(a) {
              this.scrollbarLength = a;
              this.outerSvg.setAttribute(this.lengthAttribute_, String(this.scrollbarLength));
              this.svgBackground.setAttribute(this.lengthAttribute_, String(this.scrollbarLength));
            }
            setPosition(a, b) {
              this.position.x = a;
              this.position.y = b;
              setCssTransform$$module$build$src$core$utils$dom(this.outerSvg, "translate(" + (this.position.x + this.origin.x) + "px," + (this.position.y + this.origin.y) + "px)");
            }
            resize(a) {
              if (!a && (a = this.workspace.getMetrics(), !a)) return;
              this.oldHostMetrics && Scrollbar$$module$build$src$core$scrollbar.metricsAreEquivalent(a, this.oldHostMetrics) || (this.horizontal ? this.resizeHorizontal(a) : this.resizeVertical(a), this.oldHostMetrics = a, this.updateMetrics());
            }
            requiresViewResize(a) {
              return this.oldHostMetrics ? this.oldHostMetrics.viewWidth !== a.viewWidth || this.oldHostMetrics.viewHeight !== a.viewHeight || this.oldHostMetrics.absoluteLeft !== a.absoluteLeft || this.oldHostMetrics.absoluteTop !== a.absoluteTop : true;
            }
            resizeHorizontal(a) {
              this.requiresViewResize(a) ? this.resizeViewHorizontal(a) : this.resizeContentHorizontal(a);
            }
            resizeViewHorizontal(a) {
              var b = a.viewWidth - this.margin * 2;
              this.pair && (b -= Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness);
              this.setScrollbarLength(Math.max(0, b));
              b = a.absoluteLeft + this.margin;
              this.pair && this.workspace.RTL && (b += Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness);
              this.setPosition(b, a.absoluteTop + a.viewHeight - Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness - this.margin);
              this.resizeContentHorizontal(a);
            }
            resizeContentHorizontal(a) {
              if (a.viewWidth >= a.scrollWidth) this.setHandleLength(this.scrollbarLength), this.setHandlePosition(0), this.pair || this.setVisible(false);
              else {
                this.pair || this.setVisible(true);
                var b = this.scrollbarLength * a.viewWidth / a.scrollWidth;
                b = this.constrainHandleLength(b);
                this.setHandleLength(b);
                b = a.scrollWidth - a.viewWidth;
                var c = this.scrollbarLength - this.handleLength;
                a = (a.viewLeft - a.scrollLeft) / b * c;
                a = this.constrainHandlePosition(a);
                this.setHandlePosition(a);
                this.ratio = c / b;
              }
            }
            resizeVertical(a) {
              this.requiresViewResize(a) ? this.resizeViewVertical(a) : this.resizeContentVertical(a);
            }
            resizeViewVertical(a) {
              let b = a.viewHeight - this.margin * 2;
              this.pair && (b -= Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness);
              this.setScrollbarLength(Math.max(0, b));
              this.setPosition(this.workspace.RTL ? a.absoluteLeft + this.margin : a.absoluteLeft + a.viewWidth - Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness - this.margin, a.absoluteTop + this.margin);
              this.resizeContentVertical(a);
            }
            resizeContentVertical(a) {
              if (a.viewHeight >= a.scrollHeight) this.setHandleLength(this.scrollbarLength), this.setHandlePosition(0), this.pair || this.setVisible(false);
              else {
                this.pair || this.setVisible(true);
                var b = this.scrollbarLength * a.viewHeight / a.scrollHeight;
                b = this.constrainHandleLength(b);
                this.setHandleLength(b);
                b = a.scrollHeight - a.viewHeight;
                var c = this.scrollbarLength - this.handleLength;
                a = (a.viewTop - a.scrollTop) / b * c;
                a = this.constrainHandlePosition(a);
                this.setHandlePosition(a);
                this.ratio = c / b;
              }
            }
            isVisible() {
              return this.isHandleVisible;
            }
            setContainerVisible(a) {
              const b = a !== this.containerVisible;
              this.containerVisible = a;
              b && this.updateDisplay_();
            }
            setVisible(a) {
              if (this.pair) throw Error("Unable to toggle visibility of paired scrollbars.");
              this.setVisibleInternal(a);
            }
            setVisibleInternal(a) {
              const b = a !== this.isVisible();
              this.isHandleVisible = a;
              b && this.updateDisplay_();
            }
            updateDisplay_() {
              this.containerVisible && this.isVisible() ? this.outerSvg.setAttribute("display", "block") : this.outerSvg.setAttribute("display", "none");
            }
            onMouseDownBar(a) {
              this.workspace.markFocused();
              clearTouchIdentifier$$module$build$src$core$touch();
              this.cleanUp();
              if (isRightButton$$module$build$src$core$browser_events(a)) a.stopPropagation();
              else {
                var b = mouseToSvg$$module$build$src$core$browser_events(a, this.workspace.getParentSvg(), this.workspace.getInverseScreenCTM());
                b = this.horizontal ? b.x : b.y;
                var c = getInjectionDivXY$$module$build$src$core$utils$svg_math(this.svgHandle);
                c = this.horizontal ? c.x : c.y;
                var d = this.handlePosition, e = this.handleLength * 0.95;
                b <= c ? d -= e : b >= c + this.handleLength && (d += e);
                this.setHandlePosition(this.constrainHandlePosition(d));
                this.updateMetrics();
                a.stopPropagation();
                a.preventDefault();
              }
            }
            onMouseDownHandle(a) {
              this.workspace.markFocused();
              this.cleanUp();
              isRightButton$$module$build$src$core$browser_events(a) ? a.stopPropagation() : (this.startDragHandle = this.handlePosition, this.startDragMouse = this.horizontal ? a.clientX : a.clientY, this.onMouseUpWrapper_ = conditionalBind$$module$build$src$core$browser_events(document, "pointerup", this, this.onMouseUpHandle), this.onMouseMoveWrapper_ = conditionalBind$$module$build$src$core$browser_events(
                document,
                "pointermove",
                this,
                this.onMouseMoveHandle
              ), a.stopPropagation(), a.preventDefault());
            }
            onMouseMoveHandle(a) {
              this.setHandlePosition(this.constrainHandlePosition(this.startDragHandle + ((this.horizontal ? a.clientX : a.clientY) - this.startDragMouse)));
              this.updateMetrics();
            }
            onMouseUpHandle() {
              clearTouchIdentifier$$module$build$src$core$touch();
              this.cleanUp();
            }
            cleanUp() {
              this.workspace.hideChaff(true);
              this.onMouseUpWrapper_ && (unbind$$module$build$src$core$browser_events(this.onMouseUpWrapper_), this.onMouseUpWrapper_ = null);
              this.onMouseMoveWrapper_ && (unbind$$module$build$src$core$browser_events(this.onMouseMoveWrapper_), this.onMouseMoveWrapper_ = null);
            }
            getRatio_() {
              let a = this.handlePosition / (this.scrollbarLength - this.handleLength);
              isNaN(a) && (a = 0);
              return a;
            }
            updateMetrics() {
              const a = this.getRatio_();
              this.horizontal ? this.workspace.setMetrics({ x: a }) : this.workspace.setMetrics({ y: a });
            }
            set(a, b) {
              this.setHandlePosition(this.constrainHandlePosition(a * this.ratio));
              (b || b === void 0) && this.updateMetrics();
            }
            setOrigin(a, b) {
              this.origin = new Coordinate$$module$build$src$core$utils$coordinate(
                a,
                b
              );
            }
            static metricsAreEquivalent(a, b) {
              return a.viewWidth === b.viewWidth && a.viewHeight === b.viewHeight && a.viewLeft === b.viewLeft && a.viewTop === b.viewTop && a.absoluteTop === b.absoluteTop && a.absoluteLeft === b.absoluteLeft && a.scrollWidth === b.scrollWidth && a.scrollHeight === b.scrollHeight && a.scrollLeft === b.scrollLeft && a.scrollTop === b.scrollTop;
            }
          };
          Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness = TOUCH_ENABLED$$module$build$src$core$touch ? 25 : 15;
          Scrollbar$$module$build$src$core$scrollbar.DEFAULT_SCROLLBAR_MARGIN = 0.5;
          var module$build$src$core$scrollbar = {};
          module$build$src$core$scrollbar.Scrollbar = Scrollbar$$module$build$src$core$scrollbar;
          var domParser$$module$build$src$core$utils$xml = { parseFromString: function() {
            throw Error("DOMParser was not found in the global scope and was not properly injected using injectDependencies");
          } }, xmlSerializer$$module$build$src$core$utils$xml = { serializeToString: function() {
            throw Error("XMLSerializer was not foundin the global scope and was not properly injected using injectDependencies");
          } }, { document: document$$module$build$src$core$utils$xml, DOMParser: DOMParser$$module$build$src$core$utils$xml, XMLSerializer: XMLSerializer$$module$build$src$core$utils$xml } = globalThis;
          DOMParser$$module$build$src$core$utils$xml && (domParser$$module$build$src$core$utils$xml = new DOMParser$$module$build$src$core$utils$xml());
          XMLSerializer$$module$build$src$core$utils$xml && (xmlSerializer$$module$build$src$core$utils$xml = new XMLSerializer$$module$build$src$core$utils$xml());
          var NAME_SPACE$$module$build$src$core$utils$xml = "https://developers.google.com/blockly/xml", INVALID_CONTROL_CHARS$$module$build$src$core$utils$xml = /[\x00-\x09\x0B\x0C\x0E-\x1F]/g, module$build$src$core$utils$xml = { NAME_SPACE: NAME_SPACE$$module$build$src$core$utils$xml };
          module$build$src$core$utils$xml.createElement = $.createElement$$module$build$src$core$utils$xml;
          module$build$src$core$utils$xml.createTextNode = $.createTextNode$$module$build$src$core$utils$xml;
          module$build$src$core$utils$xml.domToText = domToText$$module$build$src$core$utils$xml;
          module$build$src$core$utils$xml.injectDependencies = injectDependencies$$module$build$src$core$utils$xml;
          module$build$src$core$utils$xml.textToDom = $.textToDom$$module$build$src$core$utils$xml;
          var CATEGORY_TOOLBOX_KIND$$module$build$src$core$utils$toolbox = "categoryToolbox", FLYOUT_TOOLBOX_KIND$$module$build$src$core$utils$toolbox = "flyoutToolbox", Position$$module$build$src$core$utils$toolbox;
          (function(a) {
            a[a.TOP = 0] = "TOP";
            a[a.BOTTOM = 1] = "BOTTOM";
            a[a.LEFT = 2] = "LEFT";
            a[a.RIGHT = 3] = "RIGHT";
          })(Position$$module$build$src$core$utils$toolbox || (Position$$module$build$src$core$utils$toolbox = {}));
          var TEST_ONLY$$module$build$src$core$utils$toolbox = { hasCategoriesInternal: hasCategoriesInternal$$module$build$src$core$utils$toolbox }, module$build$src$core$utils$toolbox = {};
          module$build$src$core$utils$toolbox.Position = Position$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.TEST_ONLY = TEST_ONLY$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.convertFlyoutDefToJsonArray = convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.convertToolboxDefToJson = convertToolboxDefToJson$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.hasCategories = hasCategories$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.isCategoryCollapsible = isCategoryCollapsible$$module$build$src$core$utils$toolbox;
          module$build$src$core$utils$toolbox.parseToolboxTree = parseToolboxTree$$module$build$src$core$utils$toolbox;
          var verticalPosition$$module$build$src$core$positionable_helpers;
          (function(a) {
            a[a.TOP = 0] = "TOP";
            a[a.BOTTOM = 1] = "BOTTOM";
          })(verticalPosition$$module$build$src$core$positionable_helpers || (verticalPosition$$module$build$src$core$positionable_helpers = {}));
          var horizontalPosition$$module$build$src$core$positionable_helpers;
          (function(a) {
            a[a.LEFT = 0] = "LEFT";
            a[a.RIGHT = 1] = "RIGHT";
          })(horizontalPosition$$module$build$src$core$positionable_helpers || (horizontalPosition$$module$build$src$core$positionable_helpers = {}));
          var bumpDirection$$module$build$src$core$positionable_helpers;
          (function(a) {
            a[a.UP = 0] = "UP";
            a[a.DOWN = 1] = "DOWN";
          })(bumpDirection$$module$build$src$core$positionable_helpers || (bumpDirection$$module$build$src$core$positionable_helpers = {}));
          var module$build$src$core$positionable_helpers = {};
          module$build$src$core$positionable_helpers.bumpDirection = bumpDirection$$module$build$src$core$positionable_helpers;
          module$build$src$core$positionable_helpers.bumpPositionRect = bumpPositionRect$$module$build$src$core$positionable_helpers;
          module$build$src$core$positionable_helpers.getCornerOppositeToolbox = getCornerOppositeToolbox$$module$build$src$core$positionable_helpers;
          module$build$src$core$positionable_helpers.getStartPositionRect = getStartPositionRect$$module$build$src$core$positionable_helpers;
          module$build$src$core$positionable_helpers.horizontalPosition = horizontalPosition$$module$build$src$core$positionable_helpers;
          module$build$src$core$positionable_helpers.verticalPosition = verticalPosition$$module$build$src$core$positionable_helpers;
          var SPRITE$$module$build$src$core$sprites = { width: 96, height: 124, url: "sprites.png" }, module$build$src$core$sprites = { SPRITE: SPRITE$$module$build$src$core$sprites };
          var ZoomControls$$module$build$src$core$zoom_controls = class {
            constructor(a) {
              this.workspace = a;
              this.id = "zoomControls";
              this.boundEvents = [];
              this.zoomResetGroup = this.zoomOutGroup = this.zoomInGroup = null;
              this.HEIGHT = this.WIDTH = 32;
              this.SMALL_SPACING = 2;
              this.LARGE_SPACING = 11;
              this.MARGIN_HORIZONTAL = this.MARGIN_VERTICAL = 20;
              this.svgGroup = null;
              this.top = this.left = 0;
              this.initialized = false;
            }
            createDom() {
              this.svgGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {});
              const a = String(Math.random()).substring(2);
              this.createZoomOutSvg(a);
              this.createZoomInSvg(a);
              this.workspace.isMovable() && this.createZoomResetSvg(a);
              return this.svgGroup;
            }
            init() {
              this.workspace.getComponentManager().addComponent({ component: this, weight: ComponentManager$$module$build$src$core$component_manager.ComponentWeight.ZOOM_CONTROLS_WEIGHT, capabilities: [ComponentManager$$module$build$src$core$component_manager.Capability.POSITIONABLE] });
              this.initialized = true;
            }
            dispose() {
              this.workspace.getComponentManager().removeComponent("zoomControls");
              this.svgGroup && removeNode$$module$build$src$core$utils$dom(this.svgGroup);
              for (const a of this.boundEvents) unbind$$module$build$src$core$browser_events(a);
              this.boundEvents.length = 0;
            }
            getBoundingRectangle() {
              let a = this.SMALL_SPACING + 2 * this.HEIGHT;
              this.zoomResetGroup && (a += this.LARGE_SPACING + this.HEIGHT);
              return new Rect$$module$build$src$core$utils$rect(this.top, this.top + a, this.left, this.left + this.WIDTH);
            }
            position(a, b) {
              if (this.initialized) {
                var c = getCornerOppositeToolbox$$module$build$src$core$positionable_helpers(
                  this.workspace,
                  a
                ), d = this.SMALL_SPACING + 2 * this.HEIGHT;
                this.zoomResetGroup && (d += this.LARGE_SPACING + this.HEIGHT);
                a = getStartPositionRect$$module$build$src$core$positionable_helpers(c, new Size$$module$build$src$core$utils$size(this.WIDTH, d), this.MARGIN_HORIZONTAL, this.MARGIN_VERTICAL, a, this.workspace);
                c = c.vertical;
                b = bumpPositionRect$$module$build$src$core$positionable_helpers(a, this.MARGIN_VERTICAL, c === verticalPosition$$module$build$src$core$positionable_helpers.TOP ? bumpDirection$$module$build$src$core$positionable_helpers.DOWN : bumpDirection$$module$build$src$core$positionable_helpers.UP, b);
                if (c === verticalPosition$$module$build$src$core$positionable_helpers.TOP) {
                  var e = this.SMALL_SPACING + this.HEIGHT, f;
                  (f = this.zoomInGroup) == null || f.setAttribute("transform", "translate(0, " + e + ")");
                  this.zoomResetGroup && this.zoomResetGroup.setAttribute("transform", "translate(0, " + (e + this.LARGE_SPACING + this.HEIGHT) + ")");
                } else {
                  f = this.zoomResetGroup ? this.LARGE_SPACING + this.HEIGHT : 0;
                  let h;
                  (h = this.zoomInGroup) == null || h.setAttribute("transform", "translate(0, " + f + ")");
                  f = f + this.SMALL_SPACING + this.HEIGHT;
                  (e = this.zoomOutGroup) == null || e.setAttribute("transform", "translate(0, " + f + ")");
                }
                this.top = b.top;
                this.left = b.left;
                var g;
                (g = this.svgGroup) == null || g.setAttribute("transform", "translate(" + this.left + "," + this.top + ")");
              }
            }
            createZoomOutSvg(a) {
              this.zoomOutGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyZoom blocklyZoomOut" }, this.svgGroup);
              const b = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.CLIPPATH,
                { id: "blocklyZoomoutClipPath" + a },
                this.zoomOutGroup
              );
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { width: 32, height: 32 }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { width: SPRITE$$module$build$src$core$sprites.width, height: SPRITE$$module$build$src$core$sprites.height, x: -64, y: -92, "clip-path": "url(#blocklyZoomoutClipPath" + a + ")" }, this.zoomOutGroup).setAttributeNS(
                XLINK_NS$$module$build$src$core$utils$dom,
                "xlink:href",
                this.workspace.options.pathToMedia + SPRITE$$module$build$src$core$sprites.url
              );
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(this.zoomOutGroup, "pointerdown", null, this.zoom.bind(this, -1)));
            }
            createZoomInSvg(a) {
              this.zoomInGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyZoom blocklyZoomIn" }, this.svgGroup);
              const b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CLIPPATH, { id: "blocklyZoominClipPath" + a }, this.zoomInGroup);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { width: 32, height: 32 }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { width: SPRITE$$module$build$src$core$sprites.width, height: SPRITE$$module$build$src$core$sprites.height, x: -32, y: -92, "clip-path": "url(#blocklyZoominClipPath" + a + ")" }, this.zoomInGroup).setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", this.workspace.options.pathToMedia + SPRITE$$module$build$src$core$sprites.url);
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(this.zoomInGroup, "pointerdown", null, this.zoom.bind(this, 1)));
            }
            zoom(a, b) {
              this.workspace.markFocused();
              this.workspace.zoomCenter(a);
              this.fireZoomEvent();
              clearTouchIdentifier$$module$build$src$core$touch();
              b.stopPropagation();
              b.preventDefault();
            }
            createZoomResetSvg(a) {
              this.zoomResetGroup = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.G,
                { "class": "blocklyZoom blocklyZoomReset" },
                this.svgGroup
              );
              const b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CLIPPATH, { id: "blocklyZoomresetClipPath" + a }, this.zoomResetGroup);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { width: 32, height: 32 }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { width: SPRITE$$module$build$src$core$sprites.width, height: SPRITE$$module$build$src$core$sprites.height, y: -92, "clip-path": "url(#blocklyZoomresetClipPath" + a + ")" }, this.zoomResetGroup).setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", this.workspace.options.pathToMedia + SPRITE$$module$build$src$core$sprites.url);
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(this.zoomResetGroup, "pointerdown", null, this.resetZoom.bind(this)));
            }
            resetZoom(a) {
              this.workspace.markFocused();
              const b = Math.log(this.workspace.options.zoomOptions.startScale / this.workspace.scale) / Math.log(this.workspace.options.zoomOptions.scaleSpeed);
              this.workspace.beginCanvasTransition();
              this.workspace.zoomCenter(b);
              this.workspace.scrollCenter();
              setTimeout(this.workspace.endCanvasTransition.bind(this.workspace), 500);
              this.fireZoomEvent();
              clearTouchIdentifier$$module$build$src$core$touch();
              a.stopPropagation();
              a.preventDefault();
            }
            fireZoomEvent() {
              const a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.CLICK))(null, this.workspace.id, "zoom_controls");
              fire$$module$build$src$core$events$utils(a);
            }
          };
          register$$module$build$src$core$css("\n.blocklyZoom>image, .blocklyZoom>svg>image {\n  opacity: .4;\n}\n\n.blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {\n  opacity: .6;\n}\n\n.blocklyZoom>image:active, .blocklyZoom>svg>image:active {\n  opacity: .8;\n}\n");
          var module$build$src$core$zoom_controls = {};
          module$build$src$core$zoom_controls.ZoomControls = ZoomControls$$module$build$src$core$zoom_controls;
          var VARIABLES$$module$build$src$core$serialization$priorities = 100, PROCEDURES$$module$build$src$core$serialization$priorities = 75, BLOCKS$$module$build$src$core$serialization$priorities = 50, WORKSPACE_COMMENTS$$module$build$src$core$serialization$priorities = 25, module$build$src$core$serialization$priorities = {
            BLOCKS: BLOCKS$$module$build$src$core$serialization$priorities,
            PROCEDURES: PROCEDURES$$module$build$src$core$serialization$priorities,
            VARIABLES: VARIABLES$$module$build$src$core$serialization$priorities,
            WORKSPACE_COMMENTS: WORKSPACE_COMMENTS$$module$build$src$core$serialization$priorities
          };
          var module$build$src$core$serialization$registry = {};
          module$build$src$core$serialization$registry.register = register$$module$build$src$core$serialization$registry;
          module$build$src$core$serialization$registry.unregister = unregister$$module$build$src$core$serialization$registry;
          var saveComment$$module$build$src$core$serialization$workspace_comments = save$$module$build$src$core$serialization$workspace_comments, WorkspaceCommentSerializer$$module$build$src$core$serialization$workspace_comments = class {
            constructor() {
              this.priority = WORKSPACE_COMMENTS$$module$build$src$core$serialization$priorities;
            }
            save(a) {
              const b = [];
              for (const c of a.getTopComments()) (a = save$$module$build$src$core$serialization$workspace_comments(c, { addCoordinates: true, saveIds: true })) && b.push(a);
              return b.length ? b : null;
            }
            load(a, b) {
              for (const c of a) append$$module$build$src$core$serialization$workspace_comments(c, b, { recordUndo: getRecordUndo$$module$build$src$core$events$utils() });
            }
            clear(a) {
              for (const b of a.getTopComments()) b.dispose();
            }
          };
          register$$module$build$src$core$serialization$registry("workspaceComments", new WorkspaceCommentSerializer$$module$build$src$core$serialization$workspace_comments());
          var module$build$src$core$serialization$workspace_comments = {};
          module$build$src$core$serialization$workspace_comments.WorkspaceCommentSerializer = WorkspaceCommentSerializer$$module$build$src$core$serialization$workspace_comments;
          module$build$src$core$serialization$workspace_comments.append = append$$module$build$src$core$serialization$workspace_comments;
          module$build$src$core$serialization$workspace_comments.save = save$$module$build$src$core$serialization$workspace_comments;
          var module$build$src$core$clipboard$registry = {};
          module$build$src$core$clipboard$registry.register = register$$module$build$src$core$clipboard$registry;
          module$build$src$core$clipboard$registry.unregister = unregister$$module$build$src$core$clipboard$registry;
          var WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster = class {
            paste(a, b, c) {
              a = a.commentState;
              c && (a.x = c.x, a.y = c.y);
              $.disable$$module$build$src$core$events$utils();
              let d;
              try {
                d = append$$module$build$src$core$serialization$workspace_comments(a, b), moveCommentToNotConflict$$module$build$src$core$clipboard$workspace_comment_paster(d);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
              if (!d) return null;
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_CREATE))(d));
              $.getFocusManager$$module$build$src$core$focus_manager().focusNode(d);
              return d;
            }
          };
          WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster.TYPE = "workspace-comment";
          register$$module$build$src$core$clipboard$registry(WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster.TYPE, new WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster());
          var module$build$src$core$clipboard$workspace_comment_paster = {};
          module$build$src$core$clipboard$workspace_comment_paster.WorkspaceCommentPaster = WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster;
          var DEFAULT_SNAP_RADIUS$$module$build$src$core$config, module$build$src$core$config;
          DEFAULT_SNAP_RADIUS$$module$build$src$core$config = 28;
          $.config$$module$build$src$core$config = { dragRadius: 5, flyoutDragRadius: 10, snapRadius: DEFAULT_SNAP_RADIUS$$module$build$src$core$config, connectingSnapRadius: DEFAULT_SNAP_RADIUS$$module$build$src$core$config, currentConnectionPreference: 8, bumpDelay: 250 };
          module$build$src$core$config = { config: $.config$$module$build$src$core$config };
          var ARIA_PREFIX$$module$build$src$core$utils$aria = "aria-", ROLE_ATTRIBUTE$$module$build$src$core$utils$aria = "role", Role$$module$build$src$core$utils$aria;
          (function(a) {
            a.GRID = "grid";
            a.GRIDCELL = "gridcell";
            a.GROUP = "group";
            a.LISTBOX = "listbox";
            a.MENU = "menu";
            a.MENUITEM = "menuitem";
            a.MENUITEMCHECKBOX = "menuitemcheckbox";
            a.OPTION = "option";
            a.PRESENTATION = "presentation";
            a.ROW = "row";
            a.TREE = "tree";
            a.TREEITEM = "treeitem";
            a.SEPARATOR = "separator";
            a.STATUS = "status";
          })(Role$$module$build$src$core$utils$aria || (Role$$module$build$src$core$utils$aria = {}));
          var State$$module$build$src$core$utils$aria;
          (function(a) {
            a.ACTIVEDESCENDANT = "activedescendant";
            a.COLCOUNT = "colcount";
            a.DISABLED = "disabled";
            a.EXPANDED = "expanded";
            a.INVALID = "invalid";
            a.LABEL = "label";
            a.LABELLEDBY = "labelledby";
            a.LEVEL = "level";
            a.ORIENTATION = "orientation";
            a.POSINSET = "posinset";
            a.ROWCOUNT = "rowcount";
            a.SELECTED = "selected";
            a.SETSIZE = "setsize";
            a.VALUEMAX = "valuemax";
            a.VALUEMIN = "valuemin";
            a.LIVE = "live";
            a.HIDDEN = "hidden";
          })(State$$module$build$src$core$utils$aria || (State$$module$build$src$core$utils$aria = {}));
          var module$build$src$core$utils$aria = {};
          module$build$src$core$utils$aria.Role = Role$$module$build$src$core$utils$aria;
          module$build$src$core$utils$aria.State = State$$module$build$src$core$utils$aria;
          module$build$src$core$utils$aria.setRole = setRole$$module$build$src$core$utils$aria;
          module$build$src$core$utils$aria.setState = setState$$module$build$src$core$utils$aria;
          var MenuItem$$module$build$src$core$menuitem = class {
            constructor(a, b) {
              this.content = a;
              this.opt_value = b;
              this.enabled = true;
              this.element = null;
              this.rightToLeft = false;
              this.roleName = null;
              this.highlight = this.checked = this.checkable = false;
              this.actionHandler = null;
            }
            createDom() {
              const a = document.createElement("div");
              a.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.element = a;
              a.className = "blocklyMenuItem " + (this.enabled ? "" : "blocklyMenuItemDisabled ") + (this.checked ? "blocklyMenuItemSelected " : "") + (this.highlight ? "blocklyMenuItemHighlight " : "") + (this.rightToLeft ? "blocklyMenuItemRtl " : "");
              const b = document.createElement("div");
              b.className = "blocklyMenuItemContent";
              if (this.checkable) {
                var c = document.createElement("div");
                c.className = "blocklyMenuItemCheckbox ";
                b.appendChild(c);
              }
              c = this.content;
              typeof this.content === "string" && (c = document.createTextNode(this.content));
              b.appendChild(c);
              a.appendChild(b);
              this.roleName && setRole$$module$build$src$core$utils$aria(a, this.roleName);
              setState$$module$build$src$core$utils$aria(
                a,
                State$$module$build$src$core$utils$aria.SELECTED,
                this.checkable && this.checked || false
              );
              setState$$module$build$src$core$utils$aria(a, State$$module$build$src$core$utils$aria.DISABLED, !this.enabled);
              return a;
            }
            dispose() {
              this.element = null;
            }
            getElement() {
              return this.element;
            }
            getId() {
              return this.element.id;
            }
            getValue() {
              let a;
              return (a = this.opt_value) != null ? a : null;
            }
            setRightToLeft(a) {
              this.rightToLeft = a;
            }
            setRole(a) {
              this.roleName = a;
            }
            setCheckable(a) {
              this.checkable = a;
            }
            setChecked(a) {
              this.checked = a;
            }
            setHighlighted(a) {
              this.highlight = a;
              const b = this.getElement();
              b && this.isEnabled() && (a ? addClass$$module$build$src$core$utils$dom(b, "blocklyMenuItemHighlight") : removeClass$$module$build$src$core$utils$dom(b, "blocklyMenuItemHighlight"));
            }
            isEnabled() {
              return this.enabled;
            }
            setEnabled(a) {
              this.enabled = a;
            }
            performAction(a) {
              this.isEnabled() && this.actionHandler && this.actionHandler(this, a);
            }
            onAction(a, b) {
              this.actionHandler = a.bind(b);
            }
          }, module$build$src$core$menuitem = {};
          module$build$src$core$menuitem.MenuItem = MenuItem$$module$build$src$core$menuitem;
          var Menu$$module$build$src$core$menu = class {
            constructor() {
              this.menuItems = [];
              this.roleName = this.element = this.onKeyDownHandler = this.pointerLeaveHandler = this.pointerEnterHandler = this.clickHandler = this.pointerMoveHandler = this.highlightedItem = this.openingCoords = null;
            }
            addChild(a) {
              this.menuItems.push(a);
            }
            render(a) {
              const b = document.createElement("div");
              b.className = "blocklyMenu";
              b.tabIndex = 0;
              this.roleName && setRole$$module$build$src$core$utils$aria(b, this.roleName);
              this.element = b;
              for (let c = 0, d; d = this.menuItems[c]; c++) b.appendChild(d.createDom());
              this.pointerMoveHandler = conditionalBind$$module$build$src$core$browser_events(b, "pointermove", this, this.handlePointerMove, true);
              this.clickHandler = conditionalBind$$module$build$src$core$browser_events(b, "pointerup", this, this.handleClick, true);
              this.pointerEnterHandler = conditionalBind$$module$build$src$core$browser_events(b, "pointerenter", this, this.handlePointerEnter, true);
              this.pointerLeaveHandler = conditionalBind$$module$build$src$core$browser_events(b, "pointerleave", this, this.handlePointerLeave, true);
              this.onKeyDownHandler = conditionalBind$$module$build$src$core$browser_events(b, "keydown", this, this.handleKeyEvent);
              a.appendChild(b);
              return b;
            }
            getElement() {
              return this.element;
            }
            focus() {
              const a = this.getElement();
              a && a.focus({ preventScroll: true });
            }
            blur() {
              const a = this.getElement();
              a && a.blur();
            }
            setRole(a) {
              this.roleName = a;
            }
            dispose() {
              this.pointerMoveHandler && (unbind$$module$build$src$core$browser_events(this.pointerMoveHandler), this.pointerMoveHandler = null);
              this.clickHandler && (unbind$$module$build$src$core$browser_events(this.clickHandler), this.clickHandler = null);
              this.pointerEnterHandler && (unbind$$module$build$src$core$browser_events(this.pointerEnterHandler), this.pointerEnterHandler = null);
              this.pointerLeaveHandler && (unbind$$module$build$src$core$browser_events(this.pointerLeaveHandler), this.pointerLeaveHandler = null);
              this.onKeyDownHandler && (unbind$$module$build$src$core$browser_events(this.onKeyDownHandler), this.onKeyDownHandler = null);
              for (let a = 0, b; b = this.menuItems[a]; a++) b.dispose();
              this.element = null;
            }
            getMenuItem(a) {
              const b = this.getElement();
              for (; a && a !== b; ) {
                if (a.classList.contains("blocklyMenuItem")) {
                  const c = this.getMenuItems();
                  for (let d = 0, e; e = c[d]; d++) if (e.getElement() === a) return e;
                }
                a = a.parentElement;
              }
              return null;
            }
            setHighlighted(a) {
              var b = this.highlightedItem;
              b && (b.setHighlighted(false), this.highlightedItem = null);
              if (a) {
                a.setHighlighted(true);
                this.highlightedItem = a;
                b = this.getElement();
                const c = a.getElement();
                b && c && (scrollIntoContainerView$$module$build$src$core$utils$style(c, b), setState$$module$build$src$core$utils$aria(
                  b,
                  State$$module$build$src$core$utils$aria.ACTIVEDESCENDANT,
                  a.getId()
                ));
              }
            }
            highlightNext() {
              const a = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
              this.highlightHelper(a, 1);
            }
            highlightPrevious() {
              const a = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
              this.highlightHelper(a < 0 ? this.menuItems.length : a, -1);
            }
            highlightFirst() {
              this.highlightHelper(-1, 1);
            }
            highlightLast() {
              this.highlightHelper(this.menuItems.length, -1);
            }
            highlightHelper(a, b) {
              a += b;
              let c;
              const d = this.getMenuItems();
              for (; c = d[a]; ) {
                if (c.isEnabled()) {
                  this.setHighlighted(c);
                  break;
                }
                a += b;
              }
            }
            handlePointerMove(a) {
              Math.max(Math.abs(a.movementX), Math.abs(a.movementY)) !== 0 && (a = this.getMenuItem(a.target)) && (a.isEnabled() ? this.highlightedItem !== a && this.setHighlighted(a) : this.setHighlighted(null));
            }
            handleClick(a) {
              var b = this.openingCoords;
              this.openingCoords = null;
              if (b && typeof a.clientX === "number") {
                const c = new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY);
                if (Coordinate$$module$build$src$core$utils$coordinate.distance(b, c) < 1) return;
              }
              (b = this.getMenuItem(a.target)) && b.performAction(a);
            }
            handlePointerEnter(a) {
              this.focus();
            }
            handlePointerLeave(a) {
              this.getElement() && this.setHighlighted(null);
            }
            handleKeyEvent(a) {
              if (this.menuItems.length && !(a.shiftKey || a.ctrlKey || a.metaKey || a.altKey)) {
                var b = this.highlightedItem;
                switch (a.key) {
                  case "Enter":
                  case " ":
                    b && b.performAction(a);
                    break;
                  case "ArrowUp":
                    this.highlightPrevious();
                    break;
                  case "ArrowDown":
                    this.highlightNext();
                    break;
                  case "PageUp":
                  case "Home":
                    this.highlightFirst();
                    break;
                  case "PageDown":
                  case "End":
                    this.highlightLast();
                    break;
                  default:
                    return;
                }
                a.preventDefault();
                a.stopPropagation();
              }
            }
            getSize() {
              const a = this.getElement(), b = getSize$$module$build$src$core$utils$style(a);
              b.height = a.scrollHeight;
              return b;
            }
            getMenuItems() {
              return this.menuItems.filter((a) => a instanceof MenuItem$$module$build$src$core$menuitem);
            }
          }, module$build$src$core$menu = {};
          module$build$src$core$menu.Menu = Menu$$module$build$src$core$menu;
          var MenuSeparator$$module$build$src$core$menu_separator = class {
            constructor() {
              this.element = null;
            }
            createDom() {
              this.element = document.createElement("hr");
              this.element.className = "blocklyMenuSeparator";
              setRole$$module$build$src$core$utils$aria(this.element, Role$$module$build$src$core$utils$aria.SEPARATOR);
              return this.element;
            }
            dispose() {
              let a;
              (a = this.element) == null || a.remove();
              this.element = null;
            }
          }, module$build$src$core$menu_separator = {};
          module$build$src$core$menu_separator.MenuSeparator = MenuSeparator$$module$build$src$core$menu_separator;
          var COLLAPSED_INPUT_NAME$$module$build$src$core$constants = "_TEMP_COLLAPSED_INPUT", COLLAPSED_FIELD_NAME$$module$build$src$core$constants = "_TEMP_COLLAPSED_FIELD", MANUALLY_DISABLED$$module$build$src$core$constants = "MANUALLY_DISABLED", module$build$src$core$constants = { COLLAPSED_FIELD_NAME: COLLAPSED_FIELD_NAME$$module$build$src$core$constants, COLLAPSED_INPUT_NAME: COLLAPSED_INPUT_NAME$$module$build$src$core$constants, MANUALLY_DISABLED: MANUALLY_DISABLED$$module$build$src$core$constants };
          (function(a) {
            a[a.VALUE = 1] = "VALUE";
            a[a.STATEMENT = 3] = "STATEMENT";
            a[a.DUMMY = 5] = "DUMMY";
            a[a.CUSTOM = 6] = "CUSTOM";
            a[a.END_ROW = 7] = "END_ROW";
          })($.inputTypes$$module$build$src$core$inputs$input_types || ($.inputTypes$$module$build$src$core$inputs$input_types = {}));
          var module$build$src$core$inputs$input_types = {};
          module$build$src$core$inputs$input_types.inputTypes = $.inputTypes$$module$build$src$core$inputs$input_types;
          var module$build$src$core$interfaces$i_serializable = {};
          module$build$src$core$interfaces$i_serializable.isSerializable = isSerializable$$module$build$src$core$interfaces$i_serializable;
          var rootBlocks$$module$build$src$core$render_management = /* @__PURE__ */ new Set(), dirtyBlocks$$module$build$src$core$render_management = /* @__PURE__ */ new WeakSet(), eventGroups$$module$build$src$core$render_management = /* @__PURE__ */ new WeakMap(), afterRendersPromise$$module$build$src$core$render_management = null, afterRendersResolver$$module$build$src$core$render_management = null, animationRequestId$$module$build$src$core$render_management = 0, module$build$src$core$render_management = {};
          module$build$src$core$render_management.finishQueuedRenders = finishQueuedRenders$$module$build$src$core$render_management;
          module$build$src$core$render_management.queueRender = queueRender$$module$build$src$core$render_management;
          module$build$src$core$render_management.triggerQueuedRenders = triggerQueuedRenders$$module$build$src$core$render_management;
          var setLocale$$module$build$src$core$msg, module$build$src$core$msg;
          $.Msg$$module$build$src$core$msg = /* @__PURE__ */ Object.create(null);
          setLocale$$module$build$src$core$msg = function(a) {
            Object.keys(a).forEach(function(b) {
              $.Msg$$module$build$src$core$msg[b] = a[b];
            });
          };
          module$build$src$core$msg = { Msg: $.Msg$$module$build$src$core$msg, setLocale: setLocale$$module$build$src$core$msg };
          var CLASS_NAME$$module$build$src$core$toast = "blocklyToast", MESSAGE_CLASS_NAME$$module$build$src$core$toast = "blocklyToastMessage", CLOSE_BUTTON_CLASS_NAME$$module$build$src$core$toast = "blocklyToastCloseButton", Toast$$module$build$src$core$toast = class {
            static show(a, b) {
              if (b.oncePerSession && b.id) {
                if (this.shownIds.has(b.id)) return;
                this.shownIds.add(b.id);
              }
              this.hide(a);
              const c = this.createDom(a, b);
              requestAnimationFrame(() => {
                c.style.bottom = "2rem";
              });
            }
            static createDom(a, b) {
              const { message: c, duration: d = 5, assertiveness: e = Toast$$module$build$src$core$toast.Assertiveness.POLITE } = b, f = document.createElement("div");
              a.getInjectionDiv().appendChild(f);
              f.dataset.toastId = b.id;
              f.className = CLASS_NAME$$module$build$src$core$toast;
              setRole$$module$build$src$core$utils$aria(f, Role$$module$build$src$core$utils$aria.STATUS);
              setState$$module$build$src$core$utils$aria(f, State$$module$build$src$core$utils$aria.LIVE, e);
              b = f.appendChild(document.createElement("div"));
              b.className = MESSAGE_CLASS_NAME$$module$build$src$core$toast;
              b.innerText = c;
              b = f.appendChild(document.createElement("button"));
              b.className = CLOSE_BUTTON_CLASS_NAME$$module$build$src$core$toast;
              setState$$module$build$src$core$utils$aria(b, State$$module$build$src$core$utils$aria.LABEL, $.Msg$$module$build$src$core$msg.CLOSE);
              var g = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.SVG, { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none" }, b);
              setState$$module$build$src$core$utils$aria(g, State$$module$build$src$core$utils$aria.HIDDEN, true);
              createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.RECT,
                { x: 19.7782, y: 2.80762, width: 2, height: 24, transform: "rotate(45, 19.7782, 2.80762)", fill: "black" },
                g
              );
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { x: 2.80762, y: 4.22183, width: 2, height: 24, transform: "rotate(-45, 2.80762, 4.22183)", fill: "black" }, g);
              b.addEventListener("click", () => {
                f.remove();
                a.markFocused();
              });
              let h;
              b = () => {
                h = setTimeout(() => f.remove(), d * 1e3);
              };
              g = () => clearTimeout(h);
              f.addEventListener("focusin", g);
              f.addEventListener("focusout", b);
              f.addEventListener(
                "mouseenter",
                g
              );
              f.addEventListener("mousemove", g);
              f.addEventListener("mouseleave", b);
              b();
              return f;
            }
            static hide(a, b) {
              a = a.getInjectionDiv().querySelector(`.${CLASS_NAME$$module$build$src$core$toast}`);
              a instanceof HTMLElement && (!b || b === a.dataset.toastId) && a.remove();
            }
          };
          Toast$$module$build$src$core$toast.shownIds = /* @__PURE__ */ new Set();
          (function(a) {
            a = a.Assertiveness || (a.Assertiveness = {});
            a.ASSERTIVE = "assertive";
            a.POLITE = "polite";
          })(Toast$$module$build$src$core$toast || (Toast$$module$build$src$core$toast = {}));
          register$$module$build$src$core$css(`
.${CLASS_NAME$$module$build$src$core$toast} {
  font-size: 1.2rem;
  position: absolute;
  bottom: -10rem;
  right: 2rem;
  padding: 1rem;
  color: black;
  background-color: white;
  border: 2px solid black;
  border-radius: 0.4rem;
  z-index: 999;
  display: flex;
  align-items: center;
  gap: 0.8rem;
  line-height: 1.5;
  transition: bottom 0.3s ease-out;
}

.${CLASS_NAME$$module$build$src$core$toast} .${MESSAGE_CLASS_NAME$$module$build$src$core$toast} {
  maxWidth: 18rem;
}

.${CLASS_NAME$$module$build$src$core$toast} .${CLOSE_BUTTON_CLASS_NAME$$module$build$src$core$toast} {
  margin: 0;
  padding: 0.2rem;
  background-color: transparent;
  color: black;
  border: none;
  cursor: pointer;
}
`);
          var module$build$src$core$toast = {};
          module$build$src$core$toast.Toast = Toast$$module$build$src$core$toast;
          var defaultAlert$$module$build$src$core$dialog = function(a, b) {
            window.alert(a);
            b && b();
          }, alertImplementation$$module$build$src$core$dialog = defaultAlert$$module$build$src$core$dialog, defaultConfirm$$module$build$src$core$dialog = function(a, b) {
            b(window.confirm(a));
          }, confirmImplementation$$module$build$src$core$dialog = defaultConfirm$$module$build$src$core$dialog, defaultPrompt$$module$build$src$core$dialog = function(a, b, c) {
            c(window.prompt(a, b));
          }, promptImplementation$$module$build$src$core$dialog = defaultPrompt$$module$build$src$core$dialog, defaultToast$$module$build$src$core$dialog = Toast$$module$build$src$core$toast.show.bind(Toast$$module$build$src$core$toast), toastImplementation$$module$build$src$core$dialog = defaultToast$$module$build$src$core$dialog, module$build$src$core$dialog = {};
          module$build$src$core$dialog.alert = alert$$module$build$src$core$dialog;
          module$build$src$core$dialog.confirm = confirm$$module$build$src$core$dialog;
          module$build$src$core$dialog.prompt = prompt$$module$build$src$core$dialog;
          module$build$src$core$dialog.setAlert = setAlert$$module$build$src$core$dialog;
          module$build$src$core$dialog.setConfirm = setConfirm$$module$build$src$core$dialog;
          module$build$src$core$dialog.setPrompt = setPrompt$$module$build$src$core$dialog;
          module$build$src$core$dialog.setToast = setToast$$module$build$src$core$dialog;
          module$build$src$core$dialog.toast = toast$$module$build$src$core$dialog;
          var module$build$src$core$interfaces$i_legacy_procedure_blocks = {};
          module$build$src$core$interfaces$i_legacy_procedure_blocks.isLegacyProcedureCallBlock = isLegacyProcedureCallBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks;
          module$build$src$core$interfaces$i_legacy_procedure_blocks.isLegacyProcedureDefBlock = isLegacyProcedureDefBlock$$module$build$src$core$interfaces$i_legacy_procedure_blocks;
          var module$build$src$core$interfaces$i_variable_backed_parameter_model = {};
          module$build$src$core$interfaces$i_variable_backed_parameter_model.isVariableBackedParameterModel = isVariableBackedParameterModel$$module$build$src$core$interfaces$i_variable_backed_parameter_model;
          var previousWarnings$$module$build$src$core$utils$deprecation = /* @__PURE__ */ new Set(), module$build$src$core$utils$deprecation = {};
          module$build$src$core$utils$deprecation.warn = warn$$module$build$src$core$utils$deprecation;
          var CATEGORY_NAME$$module$build$src$core$variables = "VARIABLE", VAR_LETTER_OPTIONS$$module$build$src$core$variables = "ijkmnopqrstuvwxyzabcdefgh", TEST_ONLY$$module$build$src$core$variables = { generateUniqueNameInternal: generateUniqueNameInternal$$module$build$src$core$variables }, module$build$src$core$variables = { CATEGORY_NAME: CATEGORY_NAME$$module$build$src$core$variables, TEST_ONLY: TEST_ONLY$$module$build$src$core$variables, VAR_LETTER_OPTIONS: VAR_LETTER_OPTIONS$$module$build$src$core$variables };
          module$build$src$core$variables.allDeveloperVariables = $.allDeveloperVariables$$module$build$src$core$variables;
          module$build$src$core$variables.allUsedVarModels = $.allUsedVarModels$$module$build$src$core$variables;
          module$build$src$core$variables.compareByName = compareByName$$module$build$src$core$variables;
          module$build$src$core$variables.createVariableButtonHandler = createVariableButtonHandler$$module$build$src$core$variables;
          module$build$src$core$variables.deleteVariable = $.deleteVariable$$module$build$src$core$variables;
          module$build$src$core$variables.flyoutCategory = flyoutCategory$$module$build$src$core$variables;
          module$build$src$core$variables.flyoutCategoryBlocks = flyoutCategoryBlocks$$module$build$src$core$variables;
          module$build$src$core$variables.generateUniqueName = generateUniqueName$$module$build$src$core$variables;
          module$build$src$core$variables.generateUniqueNameFromOptions = generateUniqueNameFromOptions$$module$build$src$core$variables;
          module$build$src$core$variables.generateVariableFieldDom = generateVariableFieldDom$$module$build$src$core$variables;
          module$build$src$core$variables.getAddedVariables = getAddedVariables$$module$build$src$core$variables;
          module$build$src$core$variables.getOrCreateVariablePackage = $.getOrCreateVariablePackage$$module$build$src$core$variables;
          module$build$src$core$variables.getVariable = $.getVariable$$module$build$src$core$variables;
          module$build$src$core$variables.getVariableUsesById = getVariableUsesById$$module$build$src$core$variables;
          module$build$src$core$variables.internalFlyoutCategory = internalFlyoutCategory$$module$build$src$core$variables;
          module$build$src$core$variables.jsonFlyoutCategoryBlocks = jsonFlyoutCategoryBlocks$$module$build$src$core$variables;
          module$build$src$core$variables.nameUsedWithAnyType = nameUsedWithAnyType$$module$build$src$core$variables;
          module$build$src$core$variables.nameUsedWithConflictingParam = nameUsedWithConflictingParam$$module$build$src$core$variables;
          module$build$src$core$variables.promptName = promptName$$module$build$src$core$variables;
          module$build$src$core$variables.renameVariable = $.renameVariable$$module$build$src$core$variables;
          var DeserializationError$$module$build$src$core$serialization$exceptions = class extends Error {
          }, MissingBlockType$$module$build$src$core$serialization$exceptions = class extends DeserializationError$$module$build$src$core$serialization$exceptions {
            constructor(a) {
              super("Expected to find a 'type' property, defining the block type");
              this.state = a;
            }
          }, MissingConnection$$module$build$src$core$serialization$exceptions = class extends DeserializationError$$module$build$src$core$serialization$exceptions {
            constructor(a, b, c) {
              super(`The block ${b.toDevString()} is missing a(n) ${a}
connection`);
              this.block = b;
              this.state = c;
            }
          }, BadConnectionCheck$$module$build$src$core$serialization$exceptions = class extends DeserializationError$$module$build$src$core$serialization$exceptions {
            constructor(a, b, c, d) {
              super(`The block ${c.toDevString()} could not connect its
${b} to its parent, because: ${a}`);
              this.childBlock = c;
              this.childState = d;
            }
          }, RealChildOfShadow$$module$build$src$core$serialization$exceptions = class extends DeserializationError$$module$build$src$core$serialization$exceptions {
            constructor(a) {
              super("Encountered a real block which is defined as a child of a shadow\nblock. It is an invariant of Blockly that shadow blocks only have shadow\nchildren");
              this.state = a;
            }
          }, UnregisteredIcon$$module$build$src$core$serialization$exceptions = class extends DeserializationError$$module$build$src$core$serialization$exceptions {
            constructor(a, b, c) {
              super(`Cannot add an icon of type '${a}' to the block ${b.toDevString()}, because there is no icon registered with type '${a}'. Make sure that all of your icons have been registered.`);
              this.block = b;
              this.state = c;
            }
          }, module$build$src$core$serialization$exceptions = {};
          module$build$src$core$serialization$exceptions.BadConnectionCheck = BadConnectionCheck$$module$build$src$core$serialization$exceptions;
          module$build$src$core$serialization$exceptions.DeserializationError = DeserializationError$$module$build$src$core$serialization$exceptions;
          module$build$src$core$serialization$exceptions.MissingBlockType = MissingBlockType$$module$build$src$core$serialization$exceptions;
          module$build$src$core$serialization$exceptions.MissingConnection = MissingConnection$$module$build$src$core$serialization$exceptions;
          module$build$src$core$serialization$exceptions.RealChildOfShadow = RealChildOfShadow$$module$build$src$core$serialization$exceptions;
          module$build$src$core$serialization$exceptions.UnregisteredIcon = UnregisteredIcon$$module$build$src$core$serialization$exceptions;
          var saveBlock$$module$build$src$core$serialization$blocks = save$$module$build$src$core$serialization$blocks, BlockSerializer$$module$build$src$core$serialization$blocks = class {
            constructor() {
              this.priority = BLOCKS$$module$build$src$core$serialization$priorities;
            }
            save(a) {
              const b = [];
              for (const c of a.getTopBlocks(false)) (a = save$$module$build$src$core$serialization$blocks(c, { addCoordinates: true, doFullSerialization: false })) && b.push(a);
              return b.length ? { languageVersion: 0, blocks: b } : null;
            }
            load(a, b) {
              a = a.blocks;
              for (const c of a) append$$module$build$src$core$serialization$blocks(
                c,
                b,
                { recordUndo: getRecordUndo$$module$build$src$core$events$utils() }
              );
            }
            clear(a) {
              for (const b of a.getTopBlocks(false)) b.dispose(false);
            }
          };
          register$$module$build$src$core$serialization$registry("blocks", new BlockSerializer$$module$build$src$core$serialization$blocks());
          var module$build$src$core$serialization$blocks = {};
          module$build$src$core$serialization$blocks.BlockSerializer = BlockSerializer$$module$build$src$core$serialization$blocks;
          module$build$src$core$serialization$blocks.append = append$$module$build$src$core$serialization$blocks;
          module$build$src$core$serialization$blocks.appendInternal = appendInternal$$module$build$src$core$serialization$blocks;
          module$build$src$core$serialization$blocks.save = save$$module$build$src$core$serialization$blocks;
          var IconType$$module$build$src$core$icons$icon_types = class {
            constructor(a) {
              this.name = a;
            }
            toString() {
              return this.name;
            }
            equals(a) {
              return this.name === a.toString();
            }
          };
          IconType$$module$build$src$core$icons$icon_types.MUTATOR = new IconType$$module$build$src$core$icons$icon_types("mutator");
          IconType$$module$build$src$core$icons$icon_types.WARNING = new IconType$$module$build$src$core$icons$icon_types("warning");
          IconType$$module$build$src$core$icons$icon_types.COMMENT = new IconType$$module$build$src$core$icons$icon_types("comment");
          var module$build$src$core$icons$icon_types = {};
          module$build$src$core$icons$icon_types.IconType = IconType$$module$build$src$core$icons$icon_types;
          var module$build$src$core$interfaces$i_has_bubble = {};
          module$build$src$core$interfaces$i_has_bubble.hasBubble = hasBubble$$module$build$src$core$interfaces$i_has_bubble;
          var BlockBase$$module$build$src$core$events$events_block_base = class extends Abstract$$module$build$src$core$events$events_abstract {
            constructor(a) {
              super();
              this.isBlank = !a;
              a && (this.blockId = a.id, this.workspaceId = a.workspace.id);
            }
            toJson() {
              const a = super.toJson();
              if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              a.blockId = this.blockId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockBase$$module$build$src$core$events$events_block_base());
              b.blockId = a.blockId;
              return b;
            }
          }, module$build$src$core$events$events_block_base = {};
          module$build$src$core$events$events_block_base.BlockBase = BlockBase$$module$build$src$core$events$events_block_base;
          var BlockChange$$module$build$src$core$events$events_block_change = class extends BlockBase$$module$build$src$core$events$events_block_base {
            constructor(a, b, c, d, e) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_CHANGE;
              a && (this.element = b, this.name = c || void 0, this.oldValue = d, this.newValue = e);
            }
            toJson() {
              const a = super.toJson();
              if (!this.element) throw Error("The changed element is undefined. Either pass an element to the constructor, or call fromJson");
              a.element = this.element;
              a.name = this.name;
              a.oldValue = this.oldValue;
              a.newValue = this.newValue;
              this.disabledReason && (a.disabledReason = this.disabledReason);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockChange$$module$build$src$core$events$events_block_change());
              b.element = a.element;
              b.name = a.name;
              b.oldValue = a.oldValue;
              b.newValue = a.newValue;
              a.disabledReason !== void 0 && (b.disabledReason = a.disabledReason);
              return b;
            }
            setDisabledReason(a) {
              if (this.element !== "disabled") throw Error('Cannot set the disabled reason for a BlockChange event if the element is not "disabled".');
              this.disabledReason = a;
            }
            isNull() {
              return this.oldValue === this.newValue;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              b = b.getBlockById(this.blockId);
              if (!b) throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
              const c = b.getIcon(IconType$$module$build$src$core$icons$icon_types.MUTATOR);
              c && hasBubble$$module$build$src$core$interfaces$i_has_bubble(c) && c.bubbleIsVisible() && c.setBubbleVisible(false);
              a = a ? this.newValue : this.oldValue;
              switch (this.element) {
                case "field":
                  (b = b.getField(this.name)) ? b.setValue(a) : console.warn("Can't set non-existent field: " + this.name);
                  break;
                case "comment":
                  b.setCommentText(a || null);
                  break;
                case "collapsed":
                  b.setCollapsed(!!a);
                  break;
                case "disabled":
                  var d;
                  b.setDisabledReason(!!a, (d = this.disabledReason) != null ? d : MANUALLY_DISABLED$$module$build$src$core$constants);
                  break;
                case "inline":
                  b.setInputsInline(!!a);
                  break;
                case "mutation":
                  d = BlockChange$$module$build$src$core$events$events_block_change.getExtraBlockState_(b);
                  b.loadExtraState ? b.loadExtraState(JSON.parse(a || "{}")) : b.domToMutation && b.domToMutation($.textToDom$$module$build$src$core$utils$xml(a || "<mutation/>"));
                  fire$$module$build$src$core$events$utils(new BlockChange$$module$build$src$core$events$events_block_change(b, "mutation", null, d, a));
                  break;
                default:
                  console.warn("Unknown change type: " + this.element);
              }
            }
            static getExtraBlockState_(a) {
              return a.saveExtraState ? (a = a.saveExtraState(true)) ? JSON.stringify(a) : "" : a.mutationToDom ? (a = a.mutationToDom()) ? domToText$$module$build$src$core$xml(a) : "" : "";
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_CHANGE, BlockChange$$module$build$src$core$events$events_block_change);
          var module$build$src$core$events$events_block_change = {};
          module$build$src$core$events$events_block_change.BlockChange = BlockChange$$module$build$src$core$events$events_block_change;
          var module$build$src$core$utils$math = {};
          module$build$src$core$utils$math.clamp = clamp$$module$build$src$core$utils$math;
          module$build$src$core$utils$math.toDegrees = toDegrees$$module$build$src$core$utils$math;
          module$build$src$core$utils$math.toRadians = toRadians$$module$build$src$core$utils$math;
          var ARROW_SIZE$$module$build$src$core$dropdowndiv = 16, BORDER_SIZE$$module$build$src$core$dropdowndiv = 1, ARROW_HORIZONTAL_PADDING$$module$build$src$core$dropdowndiv = 12, PADDING_Y$$module$build$src$core$dropdowndiv = 16, ANIMATION_TIME$$module$build$src$core$dropdowndiv = 0.25, animateOutTimer$$module$build$src$core$dropdowndiv = null, onHide$$module$build$src$core$dropdowndiv = null, renderedClassName$$module$build$src$core$dropdowndiv = "", themeClassName$$module$build$src$core$dropdowndiv = "", div$$module$build$src$core$dropdowndiv, content$$module$build$src$core$dropdowndiv, arrow$$module$build$src$core$dropdowndiv, boundsElement$$module$build$src$core$dropdowndiv = null, owner$$module$build$src$core$dropdowndiv = null, positionToField$$module$build$src$core$dropdowndiv = null, returnEphemeralFocus$$module$build$src$core$dropdowndiv = null, keydownListener$$module$build$src$core$dropdowndiv = null, internal$$module$build$src$core$dropdowndiv = { getBoundsInfo: function() {
            const a = getPageOffset$$module$build$src$core$utils$style(boundsElement$$module$build$src$core$dropdowndiv), b = getSize$$module$build$src$core$utils$style(boundsElement$$module$build$src$core$dropdowndiv);
            return { left: a.x, right: a.x + b.width, top: a.y, bottom: a.y + b.height, width: b.width, height: b.height };
          }, getPositionMetrics: function(a, b, c, d) {
            const e = internal$$module$build$src$core$dropdowndiv.getBoundsInfo(), f = getSize$$module$build$src$core$utils$style(div$$module$build$src$core$dropdowndiv);
            return b + f.height < e.bottom ? getPositionBelowMetrics$$module$build$src$core$dropdowndiv(a, b, e, f) : d - f.height > e.top ? getPositionAboveMetrics$$module$build$src$core$dropdowndiv(
              c,
              d,
              e,
              f
            ) : b + f.height < document.documentElement.clientHeight ? getPositionBelowMetrics$$module$build$src$core$dropdowndiv(a, b, e, f) : d - f.height > document.documentElement.clientTop ? getPositionAboveMetrics$$module$build$src$core$dropdowndiv(c, d, e, f) : getPositionTopOfPageMetrics$$module$build$src$core$dropdowndiv(a, e, f);
          } }, TEST_ONLY$$module$build$src$core$dropdowndiv = internal$$module$build$src$core$dropdowndiv, module$build$src$core$dropdowndiv = {
            ANIMATION_TIME: ANIMATION_TIME$$module$build$src$core$dropdowndiv,
            ARROW_HORIZONTAL_PADDING: ARROW_HORIZONTAL_PADDING$$module$build$src$core$dropdowndiv,
            ARROW_SIZE: ARROW_SIZE$$module$build$src$core$dropdowndiv,
            BORDER_SIZE: BORDER_SIZE$$module$build$src$core$dropdowndiv,
            PADDING_Y: PADDING_Y$$module$build$src$core$dropdowndiv,
            TEST_ONLY: internal$$module$build$src$core$dropdowndiv
          };
          module$build$src$core$dropdowndiv.clearContent = clearContent$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.createDom = createDom$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.getContentDiv = getContentDiv$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.getOwner = getOwner$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.getPositionX = getPositionX$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.hide = hide$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.hideIfOwner = hideIfOwner$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.hideWithoutAnimation = hideWithoutAnimation$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.isVisible = isVisible$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.repositionForWindowResize = repositionForWindowResize$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.setBoundsElement = setBoundsElement$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.setColour = setColour$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.show = show$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.showPositionedByBlock = showPositionedByBlock$$module$build$src$core$dropdowndiv;
          module$build$src$core$dropdowndiv.showPositionedByField = showPositionedByField$$module$build$src$core$dropdowndiv;
          var module$build$src$core$utils$string = {};
          module$build$src$core$utils$string.commonWordPrefix = commonWordPrefix$$module$build$src$core$utils$string;
          module$build$src$core$utils$string.commonWordSuffix = commonWordSuffix$$module$build$src$core$utils$string;
          module$build$src$core$utils$string.isNumber = $.isNumber$$module$build$src$core$utils$string;
          module$build$src$core$utils$string.shortestStringLength = shortestStringLength$$module$build$src$core$utils$string;
          module$build$src$core$utils$string.wrap = $.wrap$$module$build$src$core$utils$string;
          var customTooltip$$module$build$src$core$tooltip = void 0, visible$$module$build$src$core$tooltip = false, blocked$$module$build$src$core$tooltip = false, LIMIT$$module$build$src$core$tooltip = 50, mouseOutPid$$module$build$src$core$tooltip = 0, showPid$$module$build$src$core$tooltip = 0, lastX$$module$build$src$core$tooltip = 0, lastY$$module$build$src$core$tooltip = 0, element$$module$build$src$core$tooltip = null, poisonedElement$$module$build$src$core$tooltip = null, OFFSET_X$$module$build$src$core$tooltip = 0, OFFSET_Y$$module$build$src$core$tooltip = 10, RADIUS_OK$$module$build$src$core$tooltip = 10, HOVER_MS$$module$build$src$core$tooltip = 750, MARGINS$$module$build$src$core$tooltip = 5, containerDiv$$module$build$src$core$tooltip = null, module$build$src$core$tooltip = { HOVER_MS: HOVER_MS$$module$build$src$core$tooltip, LIMIT: LIMIT$$module$build$src$core$tooltip, MARGINS: MARGINS$$module$build$src$core$tooltip, OFFSET_X: OFFSET_X$$module$build$src$core$tooltip, OFFSET_Y: OFFSET_Y$$module$build$src$core$tooltip, RADIUS_OK: RADIUS_OK$$module$build$src$core$tooltip };
          module$build$src$core$tooltip.bindMouseEvents = bindMouseEvents$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.block = block$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.createDom = createDom$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.dispose = dispose$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.getCustomTooltip = getCustomTooltip$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.getDiv = getDiv$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.getTooltipOfObject = getTooltipOfObject$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.hide = hide$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.isVisible = isVisible$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.setCustomTooltip = setCustomTooltip$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.unbindMouseEvents = unbindMouseEvents$$module$build$src$core$tooltip;
          module$build$src$core$tooltip.unblock = unblock$$module$build$src$core$tooltip;
          var hsvSaturation$$module$build$src$core$utils$colour = 0.45, hsvValue$$module$build$src$core$utils$colour = 0.65, names$$module$build$src$core$utils$colour = { aqua: "#00ffff", black: "#000000", blue: "#0000ff", fuchsia: "#ff00ff", gray: "#808080", green: "#008000", lime: "#00ff00", maroon: "#800000", navy: "#000080", olive: "#808000", purple: "#800080", red: "#ff0000", silver: "#c0c0c0", teal: "#008080", white: "#ffffff", yellow: "#ffff00" }, module$build$src$core$utils$colour = {};
          module$build$src$core$utils$colour.blend = blend$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.getHsvSaturation = getHsvSaturation$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.getHsvValue = getHsvValue$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.hexToRgb = hexToRgb$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.hsvToHex = hsvToHex$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.hueToHex = hueToHex$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.names = names$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.parse = parse$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.rgbToHex = rgbToHex$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.setHsvSaturation = setHsvSaturation$$module$build$src$core$utils$colour;
          module$build$src$core$utils$colour.setHsvValue = setHsvValue$$module$build$src$core$utils$colour;
          var module$build$src$core$utils$parsing = {};
          module$build$src$core$utils$parsing.checkMessageReferences = checkMessageReferences$$module$build$src$core$utils$parsing;
          module$build$src$core$utils$parsing.parseBlockColour = parseBlockColour$$module$build$src$core$utils$parsing;
          module$build$src$core$utils$parsing.replaceMessageReferences = replaceMessageReferences$$module$build$src$core$utils$parsing;
          module$build$src$core$utils$parsing.tokenizeInterpolation = tokenizeInterpolation$$module$build$src$core$utils$parsing;
          var Field$$module$build$src$core$field = class {
            get size_() {
              return this.size;
            }
            set size_(a) {
              this.size = a;
            }
            constructor(a, b, c) {
              this.DEFAULT_VALUE = null;
              this.name = void 0;
              this.tooltip = this.validator_ = null;
              this.size = new Size$$module$build$src$core$utils$size(0, 0);
              this.constants_ = this.mouseDownWrapper = this.textContent_ = this.textElement_ = this.borderRect_ = this.fieldGroup_ = null;
              this.disposed = false;
              this.maxDisplayLength = 50;
              this.sourceBlock_ = null;
              this.enabled_ = this.visible_ = this.isDirty_ = true;
              this.suffixField = this.prefixField = this.clickTarget_ = null;
              this.EDITABLE = true;
              this.SERIALIZABLE = false;
              this.id_ = null;
              this.value_ = "DEFAULT_VALUE" in new.target.prototype ? new.target.prototype.DEFAULT_VALUE : this.DEFAULT_VALUE;
              this.size_ = new Size$$module$build$src$core$utils$size(0, 0);
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (c && this.configure_(c), this.setValue(a), b && this.setValidator(b));
            }
            configure_(a) {
              a.tooltip && this.setTooltip(replaceMessageReferences$$module$build$src$core$utils$parsing(a.tooltip));
            }
            setSourceBlock(a) {
              if (this.sourceBlock_) throw Error("Field already bound to a block");
              this.sourceBlock_ = a;
              if (a.id.includes("_field")) throw Error(`Field ID indicator is contained in block ID. This may cause problems with focus: ${a.id}.`);
              this.id_ = `${a.id}_field_${getNextUniqueId$$module$build$src$core$utils$idgenerator()}`;
            }
            getConstants() {
              !this.constants_ && this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && this.sourceBlock_.workspace.rendered && (this.constants_ = this.sourceBlock_.workspace.getRenderer().getConstants());
              return this.constants_;
            }
            getSourceBlock() {
              return this.sourceBlock_;
            }
            init() {
              if (!this.fieldGroup_) {
                var a = this.id_;
                if (!a) throw Error("Expected ID to be defined prior to init.");
                this.fieldGroup_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { id: a });
                this.isVisible() || (this.fieldGroup_.style.display = "none");
                this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_);
                this.initView();
                this.updateEditable();
                this.setTooltip(this.tooltip);
                this.bindEvents_();
                this.initModel();
                this.applyColour();
              }
            }
            initView() {
              this.createBorderRect_();
              this.createTextElement_();
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyField");
            }
            initModel() {
            }
            isFullBlockField() {
              return !this.borderRect_;
            }
            createBorderRect_() {
              this.borderRect_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { rx: this.getConstants().FIELD_BORDER_RECT_RADIUS, ry: this.getConstants().FIELD_BORDER_RECT_RADIUS, x: 0, y: 0, height: this.size_.height, width: this.size_.width, "class": "blocklyFieldRect" }, this.fieldGroup_);
            }
            createTextElement_() {
              this.textElement_ = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.TEXT,
                { "class": "blocklyText blocklyFieldText" },
                this.fieldGroup_
              );
              this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.textElement_.setAttribute("dominant-baseline", "central");
              this.textContent_ = document.createTextNode("");
              this.textElement_.appendChild(this.textContent_);
            }
            bindEvents_() {
              const a = this.getClickTarget_();
              if (!a) throw Error("A click target has not been set.");
              bindMouseEvents$$module$build$src$core$tooltip(a);
              this.mouseDownWrapper = conditionalBind$$module$build$src$core$browser_events(
                a,
                "pointerdown",
                this,
                this.onMouseDown_
              );
            }
            fromXml(a) {
              this.setValue(a.textContent);
            }
            toXml(a) {
              a.textContent = this.getValue();
              return a;
            }
            saveState(a) {
              a = this.saveLegacyState(Field$$module$build$src$core$field);
              return a !== null ? a : this.getValue();
            }
            loadState(a) {
              this.loadLegacyState(Field$$module$build$src$core$field, a) || this.setValue(a);
            }
            saveLegacyState(a) {
              return a.prototype.saveState === this.saveState && a.prototype.toXml !== this.toXml ? (a = $.createElement$$module$build$src$core$utils$xml("field"), a.setAttribute("name", this.name || ""), domToText$$module$build$src$core$utils$xml(this.toXml(a)).replace(' xmlns="https://developers.google.com/blockly/xml"', "")) : null;
            }
            loadLegacyState(a, b) {
              return a.prototype.loadState === this.loadState && a.prototype.fromXml !== this.fromXml ? (this.fromXml($.textToDom$$module$build$src$core$utils$xml(b)), true) : false;
            }
            dispose() {
              hideIfOwner$$module$build$src$core$dropdowndiv(this);
              hideIfOwner$$module$build$src$core$widgetdiv(this);
              let a;
              ((a = this.getSourceBlock()) == null ? 0 : a.isDeadOrDying()) || removeNode$$module$build$src$core$utils$dom(this.fieldGroup_);
              this.disposed = true;
            }
            updateEditable() {
              const a = this.fieldGroup_, b = this.getSourceBlock();
              this.EDITABLE && a && b && (this.enabled_ && b.isEditable() ? (addClass$$module$build$src$core$utils$dom(a, "blocklyEditableField"), removeClass$$module$build$src$core$utils$dom(a, "blocklyNonEditableField")) : (addClass$$module$build$src$core$utils$dom(a, "blocklyNonEditableField"), removeClass$$module$build$src$core$utils$dom(a, "blocklyEditableField")));
            }
            setEnabled(a) {
              this.enabled_ = a;
              this.updateEditable();
            }
            isEnabled() {
              return this.enabled_;
            }
            isClickable() {
              return this.enabled_ && !!this.sourceBlock_ && this.sourceBlock_.isEditable() && this.showEditor_ !== Field$$module$build$src$core$field.prototype.showEditor_;
            }
            isClickableInFlyout(a) {
              return !a;
            }
            isCurrentlyEditable() {
              return this.enabled_ && this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable();
            }
            isSerializable() {
              let a = false;
              this.name && (this.SERIALIZABLE ? a = true : this.EDITABLE && (console.warn("Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization."), a = true));
              return a;
            }
            isVisible() {
              return this.visible_;
            }
            setVisible(a) {
              if (this.visible_ !== a) {
                this.visible_ = a;
                var b = this.fieldGroup_;
                b && (b.style.display = a ? "block" : "none");
              }
            }
            setValidator(a) {
              this.validator_ = a;
            }
            getValidator() {
              return this.validator_;
            }
            getSvgRoot() {
              return this.fieldGroup_;
            }
            getBorderRect() {
              if (!this.borderRect_) throw Error(`The border rectangle is ${this.borderRect_}.`);
              return this.borderRect_;
            }
            getTextElement() {
              if (!this.textElement_) throw Error(`The text element is ${this.textElement_}.`);
              return this.textElement_;
            }
            getTextContent() {
              if (!this.textContent_) throw Error(`The text content is ${this.textContent_}.`);
              return this.textContent_;
            }
            applyColour() {
            }
            render_() {
              this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_());
              this.updateSize_();
            }
            showEditor(a) {
              this.isClickable() && this.showEditor_(a);
            }
            showEditor_(a) {
            }
            repositionForWindowResize() {
              return false;
            }
            updateSize_(a) {
              const b = this.getConstants();
              a = a !== void 0 ? a : this.isFullBlockField() ? 0 : this.getConstants().FIELD_BORDER_RECT_X_PADDING;
              let c = a * 2, d = b.FIELD_TEXT_HEIGHT, e = 0;
              this.textElement_ && (e = getTextWidth$$module$build$src$core$utils$dom(this.textElement_), c += e);
              this.isFullBlockField() || (d = Math.max(d, b.FIELD_BORDER_RECT_HEIGHT));
              this.size_ = new Size$$module$build$src$core$utils$size(c, d);
              this.positionTextElement_(a, e);
              this.positionBorderRect_();
            }
            positionTextElement_(a, b) {
              if (this.textElement_) {
                var c = this.getConstants(), d = this.size_.height / 2, e;
                this.textElement_.setAttribute("x", String(((e = this.getSourceBlock()) == null ? 0 : e.RTL) ? this.size_.width - b - a : a));
                this.textElement_.setAttribute("y", String(c.FIELD_TEXT_BASELINE_CENTER ? d : d - c.FIELD_TEXT_HEIGHT / 2 + c.FIELD_TEXT_BASELINE));
              }
            }
            positionBorderRect_() {
              this.borderRect_ && (this.borderRect_.setAttribute("width", String(this.size_.width)), this.borderRect_.setAttribute("height", String(this.size_.height)), this.borderRect_.setAttribute("rx", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)), this.borderRect_.setAttribute("ry", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)));
            }
            getSize() {
              if (!this.isVisible()) return new Size$$module$build$src$core$utils$size(0, 0);
              this.isDirty_ && (this.render_(), this.isDirty_ = false);
              return this.size_;
            }
            getScaledBBox() {
              let a;
              var b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              if (this.isFullBlockField()) {
                var c = this.sourceBlock_.getHeightWidth();
                const d = b.workspace.scale;
                a = this.getAbsoluteXY_();
                b = (c.width + 1) * d;
                c = (c.height + 1) * d;
                GECKO$$module$build$src$core$utils$useragent ? (a.x += 1.5 * d, a.y += 1.5 * d) : (a.x -= 0.5 * d, a.y -= 0.5 * d);
              } else c = this.borderRect_.getBoundingClientRect(), a = getPageOffset$$module$build$src$core$utils$style(this.borderRect_), b = c.width, c = c.height;
              return new Rect$$module$build$src$core$utils$rect(
                a.y,
                a.y + c,
                a.x,
                a.x + b
              );
            }
            onLocationChange(a) {
            }
            getDisplayText_() {
              let a = this.getText();
              a.length > this.maxDisplayLength && (a = a.substring(0, this.maxDisplayLength - 2) + "\u2026");
              a = a.replace(/\s/g, Field$$module$build$src$core$field.NBSP);
              this.sourceBlock_ && this.sourceBlock_.RTL && (a += "\u200F");
              return a;
            }
            getText() {
              const a = this.getText_();
              return a !== null ? String(a) : String(this.getValue());
            }
            getText_() {
              return null;
            }
            markDirty() {
              this.isDirty_ = true;
              this.constants_ = null;
            }
            forceRerender() {
              this.isDirty_ = true;
              this.sourceBlock_ && this.sourceBlock_.rendered && this.sourceBlock_.queueRender();
            }
            setValue(a, b = true) {
              if (a !== null) {
                var c = $.getGroup$$module$build$src$core$events$utils();
                c || $.setGroup$$module$build$src$core$events$utils(true);
                try {
                  const k = this.doClassValidation_(a), l = this.processValidation(a, k, b);
                  if (!(l instanceof Error)) {
                    var d, e = (d = this.getValidator()) == null ? void 0 : d.call(this, l), f = this.processValidation(l, e, b);
                    if (!(f instanceof Error)) {
                      var g = this.sourceBlock_;
                      if (!g || !g.disposed) {
                        var h = this.getValue();
                        h === f ? this.doValueUpdate_(f) : (this.doValueUpdate_(f), b && g && isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(g, "field", this.name || null, h, f)), this.isDirty_ && this.forceRerender());
                      }
                    }
                  }
                } finally {
                  $.setGroup$$module$build$src$core$events$utils(c);
                }
              }
            }
            processValidation(a, b, c) {
              return b === null ? (this.doValueInvalid_(a, c), this.isDirty_ && this.forceRerender(), Error()) : b === void 0 ? a : b;
            }
            getValue() {
              return this.value_;
            }
            doClassValidation_(a) {
              return a === null || a === void 0 ? null : a;
            }
            doValueUpdate_(a) {
              this.value_ = a;
              this.isDirty_ = true;
            }
            doValueInvalid_(a, b) {
            }
            onMouseDown_(a) {
              this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && (a = this.sourceBlock_.workspace.getGesture(a)) && a.setStartField(this);
            }
            setTooltip(a) {
              a || a === "" || (a = this.sourceBlock_);
              const b = this.getClickTarget_();
              b ? b.tooltip = a : this.tooltip = a;
            }
            getTooltip() {
              const a = this.getClickTarget_();
              return a ? getTooltipOfObject$$module$build$src$core$tooltip(a) : getTooltipOfObject$$module$build$src$core$tooltip({ tooltip: this.tooltip });
            }
            getClickTarget_() {
              return this.clickTarget_ || this.getSvgRoot();
            }
            getAbsoluteXY_() {
              return getPageOffset$$module$build$src$core$utils$style(this.getClickTarget_());
            }
            referencesVariables() {
              return false;
            }
            refreshVariableName() {
            }
            getParentInput() {
              let a = null;
              const b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              const c = b.inputList;
              for (let d = 0; d < b.inputList.length; d++) {
                const e = c[d], f = e.fieldRow;
                for (let g = 0; g < f.length; g++) if (f[g] === this) {
                  a = e;
                  break;
                }
              }
              return a;
            }
            getFlipRtl() {
              return false;
            }
            onShortcut(a) {
              return false;
            }
            getFocusableElement() {
              if (!this.fieldGroup_) throw Error("This field currently has no representative DOM element.");
              return this.fieldGroup_;
            }
            getFocusableTree() {
              const a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              return a.workspace;
            }
            onNodeFocus() {
              const a = this.getSourceBlock();
              a.workspace.scrollBoundsIntoView(a.getBoundingRectangleWithoutChildren());
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
            static fromJson(a) {
              throw Error("Attempted to instantiate a field from the registry that hasn't defined a 'fromJson' method.");
            }
          };
          Field$$module$build$src$core$field.NBSP = "\xA0";
          Field$$module$build$src$core$field.SKIP_SETUP = Symbol("SKIP_SETUP");
          var UnattachedFieldError$$module$build$src$core$field = class extends Error {
            constructor() {
              super("The field has not yet been attached to its input. Call appendField to attach it.");
            }
          }, module$build$src$core$field = {};
          module$build$src$core$field.Field = Field$$module$build$src$core$field;
          module$build$src$core$field.UnattachedFieldError = UnattachedFieldError$$module$build$src$core$field;
          var owner$$module$build$src$core$widgetdiv = null, ownerWorkspace$$module$build$src$core$widgetdiv = null, dispose$$module$build$src$core$widgetdiv = null, containerClassName$$module$build$src$core$widgetdiv = "blocklyWidgetDiv", rendererClassName$$module$build$src$core$widgetdiv = "", themeClassName$$module$build$src$core$widgetdiv = "", containerDiv$$module$build$src$core$widgetdiv, returnEphemeralFocus$$module$build$src$core$widgetdiv = null, module$build$src$core$widgetdiv = {};
          module$build$src$core$widgetdiv.createDom = createDom$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.getDiv = getDiv$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.hide = hide$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.hideIfOwner = hideIfOwner$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.hideIfOwnerIsInWorkspace = hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.isVisible = isVisible$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.positionWithAnchor = positionWithAnchor$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.repositionForWindowResize = repositionForWindowResize$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.show = show$$module$build$src$core$widgetdiv;
          module$build$src$core$widgetdiv.testOnly_setDiv = testOnly_setDiv$$module$build$src$core$widgetdiv;
          var currentBlock$$module$build$src$core$contextmenu = null, dummyOwner$$module$build$src$core$contextmenu = {}, menu_$$module$build$src$core$contextmenu = null, module$build$src$core$contextmenu = {};
          module$build$src$core$contextmenu.callbackFactory = $.callbackFactory$$module$build$src$core$contextmenu;
          module$build$src$core$contextmenu.dispose = dispose$$module$build$src$core$contextmenu;
          module$build$src$core$contextmenu.getCurrentBlock = getCurrentBlock$$module$build$src$core$contextmenu;
          module$build$src$core$contextmenu.hide = hide$$module$build$src$core$contextmenu;
          module$build$src$core$contextmenu.setCurrentBlock = setCurrentBlock$$module$build$src$core$contextmenu;
          module$build$src$core$contextmenu.show = show$$module$build$src$core$contextmenu;
          var ContextMenuRegistry$$module$build$src$core$contextmenu_registry = class {
            constructor() {
              this.registeredItems = /* @__PURE__ */ new Map();
              this.reset();
            }
            reset() {
              this.registeredItems.clear();
            }
            register(a) {
              if (this.registeredItems.has(a.id)) throw Error('Menu item with ID "' + a.id + '" is already registered.');
              this.registeredItems.set(a.id, a);
            }
            unregister(a) {
              if (!this.registeredItems.has(a)) throw Error('Menu item with ID "' + a + '" not found.');
              this.registeredItems.delete(a);
            }
            getItem(a) {
              let b;
              return (b = this.registeredItems.get(a)) != null ? b : null;
            }
            getContextMenuOptions(a, b) {
              const c = [];
              for (const d of this.registeredItems.values()) {
                if (d.scopeType) {
                  if (d.scopeType === ScopeType$$module$build$src$core$contextmenu_registry.BLOCK && !a.block) continue;
                  if (d.scopeType === ScopeType$$module$build$src$core$contextmenu_registry.COMMENT && !a.comment) continue;
                  if (d.scopeType === ScopeType$$module$build$src$core$contextmenu_registry.WORKSPACE && !a.workspace) continue;
                }
                let e;
                e = { scope: a, weight: d.weight };
                if (d.separator) e = Object.assign({}, e, { separator: true });
                else {
                  const f = d.preconditionFn(a, b);
                  if (f === "hidden") continue;
                  const g = typeof d.displayText === "function" ? d.displayText(a) : d.displayText;
                  e = Object.assign({}, e, { text: g, callback: d.callback, enabled: f === "enabled" });
                }
                c.push(e);
              }
              c.sort(function(d, e) {
                return d.weight - e.weight;
              });
              return c;
            }
          };
          (function(a) {
            var b = a.ScopeType || (a.ScopeType = {});
            b.BLOCK = "block";
            b.WORKSPACE = "workspace";
            b.COMMENT = "comment";
            a.registry = new a();
          })(ContextMenuRegistry$$module$build$src$core$contextmenu_registry || (ContextMenuRegistry$$module$build$src$core$contextmenu_registry = {}));
          var ScopeType$$module$build$src$core$contextmenu_registry = ContextMenuRegistry$$module$build$src$core$contextmenu_registry.ScopeType, module$build$src$core$contextmenu_registry = {};
          module$build$src$core$contextmenu_registry.ContextMenuRegistry = ContextMenuRegistry$$module$build$src$core$contextmenu_registry;
          module$build$src$core$contextmenu_registry.ScopeType = ScopeType$$module$build$src$core$contextmenu_registry;
          var BLOCK$$module$build$src$core$layers = 50, BUBBLE$$module$build$src$core$layers = 100, module$build$src$core$layers = { BLOCK: BLOCK$$module$build$src$core$layers, BUBBLE: BUBBLE$$module$build$src$core$layers };
          var CommentDragStrategy$$module$build$src$core$dragging$comment_drag_strategy = class {
            constructor(a) {
              this.comment = a;
              this.startLoc = null;
              this.workspace = a.workspace;
            }
            isMovable() {
              return this.comment.isOwnMovable() && !this.comment.isDeadOrDying() && !this.workspace.isReadOnly();
            }
            startDrag() {
              this.fireDragStartEvent();
              this.startLoc = this.comment.getRelativeToSurfaceXY();
              this.workspace.setResizesEnabled(false);
              let a;
              (a = this.workspace.getLayerManager()) == null || a.moveToDragLayer(this.comment);
              this.comment.setDragging(true);
            }
            drag(a) {
              this.comment.moveDuringDrag(a);
            }
            endDrag() {
              this.fireDragEndEvent();
              this.fireMoveEvent();
              let a;
              (a = this.workspace.getLayerManager()) == null || a.moveOffDragLayer(this.comment, BLOCK$$module$build$src$core$layers);
              this.comment.setDragging(false);
              this.comment.snapToGrid();
              this.workspace.setResizesEnabled(true);
            }
            fireDragStartEvent() {
              const a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_DRAG))(this.comment, true);
              fire$$module$build$src$core$events$utils(a);
            }
            fireDragEndEvent() {
              const a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_DRAG))(
                this.comment,
                false
              );
              fire$$module$build$src$core$events$utils(a);
            }
            fireMoveEvent() {
              if (!this.comment.isDeadOrDying()) {
                var a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_MOVE))(this.comment);
                a.setReason(["drag"]);
                a.oldCoordinate_ = this.startLoc;
                a.recordNew();
                fire$$module$build$src$core$events$utils(a);
              }
            }
            revertDrag() {
              this.startLoc && this.comment.moveDuringDrag(this.startLoc);
            }
          }, module$build$src$core$dragging$comment_drag_strategy = {};
          module$build$src$core$dragging$comment_drag_strategy.CommentDragStrategy = CommentDragStrategy$$module$build$src$core$dragging$comment_drag_strategy;
          var workspaceToDragDelta$$module$build$src$core$utils$drag = /* @__PURE__ */ new WeakMap(), module$build$src$core$utils$drag = {};
          module$build$src$core$utils$drag.move = move$$module$build$src$core$utils$drag;
          module$build$src$core$utils$drag.start = start$$module$build$src$core$utils$drag;
          var CommentBarButton$$module$build$src$core$comments$comment_bar_button = class {
            constructor(a, b, c, d) {
              this.id = a;
              this.workspace = b;
              this.container = c;
              this.commentView = d;
            }
            isVisible() {
              return this.icon.checkVisibility();
            }
            getCommentView() {
              return this.commentView;
            }
            getSize(a = false) {
              var b = this.icon.getBBox();
              b = Rect$$module$build$src$core$utils$rect.from(b);
              a && (a = this.getMargin(), b.left -= a, b.top -= a, b.bottom += a, b.right += a);
              return b;
            }
            getMargin() {
              return (this.container.getBBox().height - this.icon.getBBox().height) / 2;
            }
            getFocusableElement() {
              return this.icon;
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              const a = this.getCommentView();
              var b = a.getRelativeToSurfaceXY();
              const c = a.getSize();
              b = new Rect$$module$build$src$core$utils$rect(b.y, b.y + c.height, b.x, b.x + c.width);
              a.workspace.scrollBoundsIntoView(b);
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return this.isVisible();
            }
          }, module$build$src$core$comments$comment_bar_button = {};
          module$build$src$core$comments$comment_bar_button.CommentBarButton = CommentBarButton$$module$build$src$core$comments$comment_bar_button;
          var COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$collapse_comment_bar_button = "_collapse_bar_button", CollapseCommentBarButton$$module$build$src$core$comments$collapse_comment_bar_button = class extends CommentBarButton$$module$build$src$core$comments$comment_bar_button {
            constructor(a, b, c, d) {
              super(a, b, c, d);
              this.id = a;
              this.workspace = b;
              this.container = c;
              this.commentView = d;
              this.icon = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.IMAGE,
                { "class": "blocklyFoldoutIcon", href: `${this.workspace.options.pathToMedia}foldout-icon.svg`, id: `${this.id}${COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$collapse_comment_bar_button}` },
                this.container
              );
              this.bindId = conditionalBind$$module$build$src$core$browser_events(this.icon, "pointerdown", this, this.performAction.bind(this));
            }
            dispose() {
              unbind$$module$build$src$core$browser_events(this.bindId);
            }
            reposition() {
              const a = this.getMargin();
              this.icon.setAttribute("y", `${a}`);
              this.icon.setAttribute(
                "x",
                `${a}`
              );
            }
            performAction(a) {
              clearTouchIdentifier$$module$build$src$core$touch();
              this.getCommentView().bringToFront();
              a && a instanceof PointerEvent && isRightButton$$module$build$src$core$browser_events(a) ? a.stopPropagation() : (this.getCommentView().setCollapsed(!this.getCommentView().isCollapsed()), this.workspace.hideChaff(), a == null || a.stopPropagation());
            }
          }, module$build$src$core$comments$collapse_comment_bar_button = { COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER: COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$collapse_comment_bar_button };
          module$build$src$core$comments$collapse_comment_bar_button.CollapseCommentBarButton = CollapseCommentBarButton$$module$build$src$core$comments$collapse_comment_bar_button;
          var COMMENT_EDITOR_FOCUS_IDENTIFIER$$module$build$src$core$comments$comment_editor = "_comment_textarea_", CommentEditor$$module$build$src$core$comments$comment_editor = class {
            constructor(a, b, c) {
              this.workspace = a;
              this.onFinishEditing = c;
              this.textChangeListeners = [];
              this.text = "";
              this.foreignObject = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FOREIGNOBJECT, { "class": "blocklyCommentForeignObject" });
              a = document.createElementNS(HTML_NS$$module$build$src$core$utils$dom, "body");
              a.setAttribute("xmlns", HTML_NS$$module$build$src$core$utils$dom);
              a.className = "blocklyMinimalBody";
              this.textArea = document.createElementNS(HTML_NS$$module$build$src$core$utils$dom, "textarea");
              this.textArea.setAttribute("tabindex", "-1");
              this.textArea.setAttribute("dir", this.workspace.RTL ? "RTL" : "LTR");
              addClass$$module$build$src$core$utils$dom(this.textArea, "blocklyCommentText");
              addClass$$module$build$src$core$utils$dom(this.textArea, "blocklyTextarea");
              addClass$$module$build$src$core$utils$dom(
                this.textArea,
                "blocklyText"
              );
              a.appendChild(this.textArea);
              this.foreignObject.appendChild(a);
              b && (this.id = b + COMMENT_EDITOR_FOCUS_IDENTIFIER$$module$build$src$core$comments$comment_editor, this.textArea.setAttribute("id", this.id));
              conditionalBind$$module$build$src$core$browser_events(this.textArea, "change", this, this.onTextChange);
              conditionalBind$$module$build$src$core$browser_events(this.textArea, "pointerdown", this, (d) => {
                d.stopPropagation();
                $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this);
                clearTouchIdentifier$$module$build$src$core$touch();
              });
              conditionalBind$$module$build$src$core$browser_events(this.textArea, "wheel", this, (d) => {
                d.stopPropagation();
              });
              conditionalBind$$module$build$src$core$browser_events(this.textArea, "keydown", this, this.handleKeyDown);
            }
            getDom() {
              return this.foreignObject;
            }
            getText() {
              return this.text;
            }
            setText(a) {
              this.textArea.value = a;
              this.onTextChange();
            }
            onTextChange() {
              const a = this.text;
              this.text = this.textArea.value;
              for (let b = this.textChangeListeners.length - 1; b >= 0; b--) this.textChangeListeners[b](a, this.text);
            }
            handleKeyDown(a) {
              if (a.key === "Escape" || a.key === "Enter" && (a.ctrlKey || a.metaKey)) {
                if (this.onFinishEditing) this.onFinishEditing();
                a.stopPropagation();
              }
            }
            addTextChangeListener(a) {
              this.textChangeListeners.push(a);
            }
            removeTextChangeListener(a) {
              this.textChangeListeners.splice(this.textChangeListeners.indexOf(a), 1);
            }
            setPlaceholderText(a) {
              this.textArea.placeholder = a;
            }
            setEditable(a) {
              a ? this.textArea.removeAttribute("readonly") : this.textArea.setAttribute("readonly", "true");
            }
            updateSize(a, b) {
              this.foreignObject.setAttribute("height", `${a.height - b.height}`);
              this.foreignObject.setAttribute("width", `${a.width}`);
              this.foreignObject.setAttribute("y", `${b.height}`);
              this.workspace.RTL && this.foreignObject.setAttribute("x", `${-a.width}`);
            }
            getFocusableElement() {
              return this.textArea;
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              const a = Rect$$module$build$src$core$utils$rect.from(this.foreignObject.getBoundingClientRect());
              this.workspace.scrollBoundsIntoView(Rect$$module$build$src$core$utils$rect.createFromPoint(screenToWsCoordinates$$module$build$src$core$utils$svg_math(
                this.workspace,
                a.getOrigin()
              ), a.getWidth(), a.getHeight()));
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return this.id ? true : false;
            }
          }, module$build$src$core$comments$comment_editor = { COMMENT_EDITOR_FOCUS_IDENTIFIER: COMMENT_EDITOR_FOCUS_IDENTIFIER$$module$build$src$core$comments$comment_editor };
          module$build$src$core$comments$comment_editor.CommentEditor = CommentEditor$$module$build$src$core$comments$comment_editor;
          var COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$delete_comment_bar_button = "_delete_bar_button", DeleteCommentBarButton$$module$build$src$core$comments$delete_comment_bar_button = class extends CommentBarButton$$module$build$src$core$comments$comment_bar_button {
            constructor(a, b, c, d) {
              super(a, b, c, d);
              this.id = a;
              this.workspace = b;
              this.container = c;
              this.commentView = d;
              this.icon = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, {
                "class": "blocklyDeleteIcon",
                href: `${this.workspace.options.pathToMedia}delete-icon.svg`,
                id: `${this.id}${COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$delete_comment_bar_button}`
              }, c);
              this.bindId = conditionalBind$$module$build$src$core$browser_events(this.icon, "pointerdown", this, this.performAction.bind(this));
            }
            dispose() {
              unbind$$module$build$src$core$browser_events(this.bindId);
            }
            reposition() {
              const a = this.getMargin();
              this.icon.setAttribute("x", "0");
              const b = this.container.getBBox();
              this.icon.setAttribute(
                "y",
                `${a}`
              );
              this.icon.setAttribute("x", `${b.width - this.getSize(true).getWidth()}`);
            }
            performAction(a) {
              clearTouchIdentifier$$module$build$src$core$touch();
              a && a instanceof PointerEvent && isRightButton$$module$build$src$core$browser_events(a) ? a.stopPropagation() : (this.getCommentView().dispose(), a == null || a.stopPropagation(), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.workspace));
            }
          }, module$build$src$core$comments$delete_comment_bar_button = { COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER: COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$delete_comment_bar_button };
          module$build$src$core$comments$delete_comment_bar_button.DeleteCommentBarButton = DeleteCommentBarButton$$module$build$src$core$comments$delete_comment_bar_button;
          var CommentView$$module$build$src$core$comments$comment_view = class {
            constructor(a, b) {
              this.workspace = a;
              this.commentId = b;
              this.collapsed = false;
              this.editable = true;
              this.location = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.sizeChangeListeners = [];
              this.disposeListeners = [];
              this.collapseChangeListeners = [];
              this.resizePointerMoveListener = this.resizePointerUpListener = null;
              this.disposed = this.disposing = false;
              this.svgRoot = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.G,
                { "class": "blocklyComment blocklyEditable blocklyDraggable" }
              );
              this.highlightRect = this.createHighlightRect(this.svgRoot);
              ({ topBarGroup: this.topBarGroup, topBarBackground: this.topBarBackground, deleteButton: this.deleteButton, foldoutButton: this.foldoutButton, textPreview: this.textPreview, textPreviewNode: this.textPreviewNode } = this.createTopBar(this.svgRoot));
              this.commentEditor = this.createTextArea();
              this.resizeHandle = this.createResizeHandle(this.svgRoot, a);
              let c;
              (c = a.getLayerManager()) == null || c.append(
                this,
                BLOCK$$module$build$src$core$layers
              );
              this.size = CommentView$$module$build$src$core$comments$comment_view.defaultCommentSize;
              this.setSizeWithoutFiringEvents(this.size);
              this.moveTo(new Coordinate$$module$build$src$core$utils$coordinate(0, 0));
            }
            createHighlightRect(a) {
              return createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyCommentHighlight" }, a);
            }
            createTopBar(a) {
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.G,
                { "class": "blocklyCommentTopbar" },
                a
              );
              const b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyCommentTopbarBackground" }, a), c = new DeleteCommentBarButton$$module$build$src$core$comments$delete_comment_bar_button(this.commentId, this.workspace, a, this), d = new CollapseCommentBarButton$$module$build$src$core$comments$collapse_comment_bar_button(this.commentId, this.workspace, a, this);
              this.addDisposeListener(() => {
                c.dispose();
                d.dispose();
              });
              const e = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.TEXT,
                { "class": "blocklyCommentPreview blocklyCommentText blocklyText" },
                a
              ), f = document.createTextNode("");
              e.appendChild(f);
              return { topBarGroup: a, topBarBackground: b, deleteButton: c, foldoutButton: d, textPreview: e, textPreviewNode: f };
            }
            createTextArea() {
              const a = new CommentEditor$$module$build$src$core$comments$comment_editor(this.workspace, this.commentId, () => this.svgRoot.focus());
              this.svgRoot.appendChild(a.getDom());
              a.addTextChangeListener((b, c) => {
                this.updateTextPreview(c);
                this.setSize(this.size);
              });
              return a;
            }
            getEditorFocusableNode() {
              return this.commentEditor;
            }
            createResizeHandle(a, b) {
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { "class": "blocklyResizeHandle", href: `${b.options.pathToMedia}resize-handle.svg` }, a);
              conditionalBind$$module$build$src$core$browser_events(a, "pointerdown", this, this.onResizePointerDown);
              return a;
            }
            getSvgRoot() {
              return this.svgRoot;
            }
            getSize() {
              return this.collapsed ? this.topBarBackground.getBBox() : this.size;
            }
            setSizeWithoutFiringEvents(a) {
              const b = this.topBarBackground.getBBox(), c = this.textPreview.getBBox(), d = this.resizeHandle.getBBox();
              this.size = a = Size$$module$build$src$core$utils$size.max(a, this.calcMinSize(b));
              this.svgRoot.setAttribute("height", `${a.height}`);
              this.svgRoot.setAttribute("width", `${a.width}`);
              this.updateHighlightRect(a);
              this.updateTopBarSize(a);
              this.commentEditor.updateSize(a, b);
              this.deleteButton.reposition();
              this.foldoutButton.reposition();
              this.updateTextPreviewSize(a, b, c);
              this.updateResizeHandlePosition(a, d);
            }
            setSize(a) {
              const b = this.preResizeSize || this.size;
              this.setSizeWithoutFiringEvents(a);
              this.onSizeChange(
                b,
                this.size
              );
            }
            calcMinSize(a) {
              var b;
              this.updateTextPreview((b = this.commentEditor.getText()) != null ? b : "");
              let c = b = getTextWidth$$module$build$src$core$utils$dom(this.textPreview);
              this.foldoutButton.isVisible() ? c += this.foldoutButton.getSize(true).getWidth() : b && (c += 4);
              this.deleteButton.isVisible() ? c += this.deleteButton.getSize(true).getWidth() : b && (c += 4);
              return new Size$$module$build$src$core$utils$size(c, a.height + 20);
            }
            updateHighlightRect(a) {
              this.highlightRect.setAttribute("height", `${a.height}`);
              this.highlightRect.setAttribute(
                "width",
                `${a.width}`
              );
              this.workspace.RTL && this.highlightRect.setAttribute("x", `${-a.width}`);
            }
            updateTopBarSize(a) {
              this.topBarBackground.setAttribute("width", `${a.width}`);
            }
            updateTextPreviewSize(a, b, c) {
              b = (b.height - c.height) / 2;
              const d = this.foldoutButton.getSize(true), e = this.deleteButton.getSize(true);
              a = a.width - d.getWidth() - e.getWidth();
              this.textPreview.setAttribute("x", `${(this.workspace.RTL ? -1 : 1) * d.getWidth()}`);
              this.textPreview.setAttribute("y", `${b + c.height / 2}`);
              this.textPreview.setAttribute("width", `${a}`);
            }
            updateResizeHandlePosition(a, b) {
              this.resizeHandle.setAttribute("y", `${a.height - b.height}`);
              this.resizeHandle.setAttribute("x", `${a.width - b.width}`);
            }
            onSizeChange(a, b) {
              for (let c = this.sizeChangeListeners.length - 1; c >= 0; c--) this.sizeChangeListeners[c](a, b);
            }
            addSizeChangeListener(a) {
              this.sizeChangeListeners.push(a);
            }
            removeSizeChangeListener(a) {
              this.sizeChangeListeners.splice(this.sizeChangeListeners.indexOf(a), 1);
            }
            onResizePointerDown(a) {
              this.isEditable() && (this.bringToFront(), isRightButton$$module$build$src$core$browser_events(a) || (this.preResizeSize = this.getSize(), start$$module$build$src$core$utils$drag(this.workspace, a, new Coordinate$$module$build$src$core$utils$coordinate(this.workspace.RTL ? -this.getSize().width : this.getSize().width, this.getSize().height)), this.resizePointerUpListener = conditionalBind$$module$build$src$core$browser_events(document, "pointerup", this, this.onResizePointerUp), this.resizePointerMoveListener = conditionalBind$$module$build$src$core$browser_events(document, "pointermove", this, this.onResizePointerMove), this.workspace.hideChaff()), a.stopPropagation());
            }
            onResizePointerUp(a) {
              clearTouchIdentifier$$module$build$src$core$touch();
              this.resizePointerUpListener && (unbind$$module$build$src$core$browser_events(this.resizePointerUpListener), this.resizePointerUpListener = null);
              this.resizePointerMoveListener && (unbind$$module$build$src$core$browser_events(this.resizePointerMoveListener), this.resizePointerMoveListener = null);
              this.setSize(this.size);
              this.preResizeSize = void 0;
            }
            onResizePointerMove(a) {
              a = move$$module$build$src$core$utils$drag(
                this.workspace,
                a
              );
              this.setSizeWithoutFiringEvents(new Size$$module$build$src$core$utils$size(this.workspace.RTL ? -a.x : a.x, a.y));
            }
            isCollapsed() {
              return this.collapsed;
            }
            setCollapsed(a) {
              (this.collapsed = a) ? addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyCollapsed") : removeClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyCollapsed");
              this.setSizeWithoutFiringEvents(this.size);
              this.onCollapse();
            }
            onCollapse() {
              for (let a = this.collapseChangeListeners.length - 1; a >= 0; a--) this.collapseChangeListeners[a](this.collapsed);
            }
            addOnCollapseListener(a) {
              this.collapseChangeListeners.push(a);
            }
            removeOnCollapseListener(a) {
              this.collapseChangeListeners.splice(
                this.collapseChangeListeners.indexOf(a),
                1
              );
            }
            isEditable() {
              return this.editable;
            }
            setEditable(a) {
              (this.editable = a) ? (addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyEditable"), removeClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyReadonly")) : (removeClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyEditable"), addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyReadonly"));
              this.commentEditor.setEditable(a);
            }
            getRelativeToSurfaceXY() {
              return this.location;
            }
            moveTo(a) {
              this.location = a;
              this.svgRoot.setAttribute(
                "transform",
                `translate(${a.x}, ${a.y})`
              );
            }
            getText() {
              return this.commentEditor.getText();
            }
            setText(a) {
              this.commentEditor.setText(a);
            }
            setPlaceholderText(a) {
              this.commentEditor.setPlaceholderText(a);
            }
            addTextChangeListener(a) {
              this.commentEditor.addTextChangeListener(a);
            }
            removeTextChangeListener(a) {
              this.commentEditor.removeTextChangeListener(a);
            }
            updateTextPreview(a) {
              this.textPreviewNode.textContent = this.truncateText(a);
            }
            truncateText(a) {
              return a.length >= 12 ? `${a.substring(0, 9)}...` : a;
            }
            bringToFront() {
              const a = this.svgRoot.parentNode, b = a.childNodes;
              b[b.length - 1] !== this.svgRoot && a.appendChild(this.svgRoot);
            }
            onDeleteDown(a) {
              clearTouchIdentifier$$module$build$src$core$touch();
              isRightButton$$module$build$src$core$browser_events(a) || this.dispose();
              a.stopPropagation();
            }
            dispose() {
              this.disposing = true;
              removeNode$$module$build$src$core$utils$dom(this.svgRoot);
              for (let a = this.disposeListeners.length - 1; a >= 0; a--) this.disposeListeners[a]();
              this.disposeListeners.length = 0;
              this.disposed = true;
            }
            isDisposed() {
              return this.disposed;
            }
            isDeadOrDying() {
              return this.disposing || this.disposed;
            }
            addDisposeListener(a) {
              this.disposeListeners.push(a);
            }
            removeDisposeListener(a) {
              this.disposeListeners.splice(this.disposeListeners.indexOf(a), 1);
            }
            getCommentBarButtons() {
              return [this.foldoutButton, this.deleteButton];
            }
          };
          CommentView$$module$build$src$core$comments$comment_view.defaultCommentSize = new Size$$module$build$src$core$utils$size(120, 100);
          register$$module$build$src$core$css("\n.injectionDiv {\n  --commentFillColour: #FFFCC7;\n  --commentBorderColour: #F2E49B;\n}\n\n.blocklyComment .blocklyTextarea {\n  background-color: var(--commentFillColour);\n  border: 1px solid var(--commentBorderColour);\n  box-sizing: border-box;\n  display: block;\n  outline: 0;\n  padding: 5px;\n  resize: none;\n  width: 100%;\n  height: 100%;\n}\n\n.blocklyReadonly.blocklyComment .blocklyTextarea {\n  cursor: inherit;\n}\n\n.blocklyDeleteIcon {\n  width: 20px;\n  height: 20px;\n  display: none;\n  cursor: pointer;\n}\n\n.blocklyFoldoutIcon {\n  width: 20px;\n  height: 20px;\n  transform-origin: 12px 12px;\n  cursor: pointer;\n}\n.blocklyResizeHandle {\n  width: 12px;\n  height: 12px;\n  cursor: se-resize;\n}\n.blocklyReadonly.blocklyComment .blocklyResizeHandle {\n  cursor: inherit;\n}\n\n.blocklyCommentTopbarBackground {\n  fill: var(--commentBorderColour);\n  height: 24px;\n}\n\n.blocklyComment .blocklyCommentPreview.blocklyText {\n  fill: #000;\n  dominant-baseline: middle;\n  visibility: hidden;\n}\n\n.blocklyCollapsed.blocklyComment .blocklyCommentPreview {\n  visibility: visible;\n}\n\n.blocklyCollapsed.blocklyComment .blocklyCommentForeignObject,\n.blocklyCollapsed.blocklyComment .blocklyResizeHandle {\n  display: none;\n}\n\n.blocklyCollapsed.blocklyComment .blocklyFoldoutIcon {\n  transform: rotate(-90deg);\n}\n\n.blocklyRTL .blocklyCommentTopbar {\n  transform: scale(-1, 1);\n}\n\n.blocklyRTL .blocklyCommentForeignObject {\n  direction: rtl;\n}\n\n.blocklyRTL .blocklyCommentPreview {\n  /* Revert the scale and control RTL using direction instead. */\n  transform: scale(-1, 1);\n  direction: rtl;\n}\n\n.blocklyRTL .blocklyResizeHandle {\n  transform: scale(-1, 1);\n  cursor: sw-resize;\n}\n\n.blocklyCommentHighlight {\n  fill: none;\n}\n\n.blocklyCommentText.blocklyActiveFocus {\n  border-color: #fc3;\n  border-width: 2px;\n}\n\n.blocklySelected .blocklyCommentHighlight {\n  stroke: #fc3;\n  stroke-width: 3px;\n}\n\n.blocklyCollapsed.blocklySelected .blocklyCommentHighlight {\n  stroke: none;\n}\n\n.blocklyCollapsed.blocklySelected .blocklyCommentTopbarBackground {\n  stroke: #fc3;\n  stroke-width: 3px;\n}\n");
          var module$build$src$core$comments$comment_view = {};
          module$build$src$core$comments$comment_view.CommentView = CommentView$$module$build$src$core$comments$comment_view;
          var WorkspaceComment$$module$build$src$core$comments$workspace_comment = class {
            constructor(a, b) {
              this.workspace = a;
              this.text = "";
              this.collapsed = false;
              this.deletable = this.movable = this.editable = true;
              this.location = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.disposing = this.disposed = false;
              this.id = b && !a.getCommentById(b) ? b : genUid$$module$build$src$core$utils$idgenerator();
              this.size = CommentView$$module$build$src$core$comments$comment_view.defaultCommentSize;
              a.addTopComment(this);
              this.fireCreateEvent();
            }
            fireCreateEvent() {
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_CREATE))(this));
            }
            fireDeleteEvent() {
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_DELETE))(this));
            }
            fireChangeEvent(a, b) {
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_CHANGE))(
                this,
                a,
                b
              ));
            }
            fireCollapseEvent(a) {
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_COLLAPSE))(this, a));
            }
            setText(a) {
              const b = this.text;
              this.text = a;
              this.fireChangeEvent(b, a);
            }
            getText() {
              return this.text;
            }
            setSize(a) {
              const b = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_RESIZE))(this);
              this.size = a;
              b.recordCurrentSizeAsNewSize();
              fire$$module$build$src$core$events$utils(b);
            }
            getSize() {
              return this.size;
            }
            setCollapsed(a) {
              this.collapsed = a;
              this.fireCollapseEvent(a);
            }
            isCollapsed() {
              return this.collapsed;
            }
            setEditable(a) {
              this.editable = a;
            }
            isEditable() {
              return this.isOwnEditable() && !this.workspace.isReadOnly();
            }
            isOwnEditable() {
              return this.editable;
            }
            setMovable(a) {
              this.movable = a;
            }
            isMovable() {
              return this.isOwnMovable() && !this.workspace.isReadOnly() && !this.workspace.isFlyout;
            }
            isOwnMovable() {
              return this.movable;
            }
            setDeletable(a) {
              this.deletable = a;
            }
            isDeletable() {
              return this.isOwnDeletable() && !this.isDeadOrDying() && !this.workspace.isReadOnly() && !this.workspace.isFlyout;
            }
            isOwnDeletable() {
              return this.deletable;
            }
            moveTo(a, b) {
              const c = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.COMMENT_MOVE))(this);
              b && c.setReason(b);
              this.location = a;
              c.recordNew();
              fire$$module$build$src$core$events$utils(c);
            }
            getRelativeToSurfaceXY() {
              return this.location;
            }
            dispose() {
              this.disposing = true;
              this.fireDeleteEvent();
              this.workspace.removeTopComment(this);
              this.disposed = true;
            }
            isDisposed() {
              return this.disposed;
            }
            isDeadOrDying() {
              return this.disposing || this.disposed;
            }
          }, module$build$src$core$comments$workspace_comment = {};
          module$build$src$core$comments$workspace_comment.WorkspaceComment = WorkspaceComment$$module$build$src$core$comments$workspace_comment;
          var RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment = class extends WorkspaceComment$$module$build$src$core$comments$workspace_comment {
            constructor(a, b) {
              super(a, b);
              this.dragStrategy = new CommentDragStrategy$$module$build$src$core$dragging$comment_drag_strategy(this);
              this.workspace = a;
              this.view = new CommentView$$module$build$src$core$comments$comment_view(a, this.id);
              this.view.setSize(this.getSize());
              this.view.setEditable(this.isEditable());
              this.view.getSvgRoot().setAttribute(
                "data-id",
                this.id
              );
              this.view.getSvgRoot().setAttribute("id", this.id);
              this.addModelUpdateBindings();
              conditionalBind$$module$build$src$core$browser_events(this.view.getSvgRoot(), "pointerdown", this, this.startGesture);
            }
            addModelUpdateBindings() {
              this.view.addTextChangeListener((a, b) => void super.setText(b));
              this.view.addSizeChangeListener((a, b) => void super.setSize(b));
              this.view.addOnCollapseListener(() => void super.setCollapsed(this.view.isCollapsed()));
              this.view.addDisposeListener(() => {
                this.isDeadOrDying() || this.dispose();
              });
            }
            setText(a) {
              this.view.setText(a);
            }
            setPlaceholderText(a) {
              this.view.setPlaceholderText(a);
            }
            setSize(a) {
              this.view.setSize(a);
            }
            setCollapsed(a) {
              this.view.setCollapsed(a);
            }
            setEditable(a) {
              super.setEditable(a);
              this.view.setEditable(this.isEditable());
            }
            getSvgRoot() {
              return this.view.getSvgRoot();
            }
            getSize() {
              return super.getSize();
            }
            getBoundingRectangle() {
              const a = this.getRelativeToSurfaceXY();
              var b, c;
              const d = (c = (b = this.view) == null ? void 0 : b.getSize()) != null ? c : this.getSize();
              this.workspace.RTL ? (b = a.x - d.width, c = a.x) : (b = a.x, c = a.x + d.width);
              return new Rect$$module$build$src$core$utils$rect(a.y, a.y + d.height, b, c);
            }
            moveBy(a, b, c) {
              const d = this.getRelativeToSurfaceXY();
              a = new Coordinate$$module$build$src$core$utils$coordinate(d.x + a, d.y + b);
              this.moveTo(a, c);
            }
            moveTo(a, b) {
              super.moveTo(a, b);
              this.view.moveTo(a);
            }
            moveDuringDrag(a) {
              this.location = a;
              this.view.moveTo(a);
            }
            setDragging(a) {
              a ? addClass$$module$build$src$core$utils$dom(this.getSvgRoot(), "blocklyDragging") : removeClass$$module$build$src$core$utils$dom(this.getSvgRoot(), "blocklyDragging");
            }
            dispose() {
              this.disposing = true;
              const a = $.getFocusManager$$module$build$src$core$focus_manager();
              a.getFocusedNode() === this && setTimeout(() => a.focusTree(this.workspace), 0);
              this.view.isDeadOrDying() || this.view.dispose();
              super.dispose();
            }
            startGesture(a) {
              const b = this.workspace.getGesture(a);
              b && (b.handleCommentStart(a, this), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this));
            }
            setDeleteStyle(a) {
              a ? addClass$$module$build$src$core$utils$dom(this.getSvgRoot(), "blocklyDraggingDelete") : removeClass$$module$build$src$core$utils$dom(this.getSvgRoot(), "blocklyDraggingDelete");
            }
            isCopyable() {
              return this.isOwnMovable() && this.isOwnDeletable();
            }
            isMovable() {
              return this.dragStrategy.isMovable();
            }
            startDrag() {
              this.dragStrategy.startDrag();
            }
            drag(a) {
              this.dragStrategy.drag(a);
            }
            endDrag() {
              this.dragStrategy.endDrag();
            }
            revertDrag() {
              this.dragStrategy.revertDrag();
            }
            select() {
              addClass$$module$build$src$core$utils$dom(
                this.getSvgRoot(),
                "blocklySelected"
              );
              fireSelectedEvent$$module$build$src$core$common(this);
            }
            unselect() {
              removeClass$$module$build$src$core$utils$dom(this.getSvgRoot(), "blocklySelected");
              fireSelectedEvent$$module$build$src$core$common(null);
            }
            toCopyData() {
              return { paster: WorkspaceCommentPaster$$module$build$src$core$clipboard$workspace_comment_paster.TYPE, commentState: save$$module$build$src$core$serialization$workspace_comments(this, { addCoordinates: true, saveIds: false }) };
            }
            showContextMenu(a) {
              const b = ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.getContextMenuOptions({
                comment: this,
                focusedNode: this
              }, a);
              let c;
              c = a instanceof PointerEvent ? new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY) : wsToScreenCoordinates$$module$build$src$core$utils$svg_math(this.workspace, this.getRelativeToSurfaceXY()).translate(10, 10);
              show$$module$build$src$core$contextmenu(a, b, this.workspace.RTL, this.workspace, c);
            }
            snapToGrid() {
              if (!this.isDeadOrDying()) {
                var a = this.workspace.getGrid();
                if (a != null && a.shouldSnap()) {
                  var b = this.getRelativeToSurfaceXY();
                  a = a.alignXY(b);
                  a !== b && this.moveTo(
                    a,
                    ["snap"]
                  );
                }
              }
            }
            getEditorFocusableNode() {
              return this.view.getEditorFocusableNode();
            }
            getFocusableElement() {
              return this.getSvgRoot();
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              this.select();
              let a;
              (a = this.workspace.getLayerManager()) == null || a.append(this, BLOCK$$module$build$src$core$layers);
              this.workspace.scrollBoundsIntoView(this.getBoundingRectangle());
            }
            onNodeBlur() {
              this.unselect();
            }
            canBeFocused() {
              return true;
            }
          }, module$build$src$core$comments$rendered_workspace_comment = {};
          module$build$src$core$comments$rendered_workspace_comment.RenderedWorkspaceComment = RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment;
          var module$build$src$core$xml = {};
          module$build$src$core$xml.appendDomToWorkspace = appendDomToWorkspace$$module$build$src$core$xml;
          module$build$src$core$xml.blockToDom = blockToDom$$module$build$src$core$xml;
          module$build$src$core$xml.blockToDomWithXY = blockToDomWithXY$$module$build$src$core$xml;
          module$build$src$core$xml.clearWorkspaceAndLoadFromXml = clearWorkspaceAndLoadFromXml$$module$build$src$core$xml;
          module$build$src$core$xml.deleteNext = deleteNext$$module$build$src$core$xml;
          module$build$src$core$xml.domToBlock = $.domToBlock$$module$build$src$core$xml;
          module$build$src$core$xml.domToBlockInternal = domToBlockInternal$$module$build$src$core$xml;
          module$build$src$core$xml.domToPrettyText = domToPrettyText$$module$build$src$core$xml;
          module$build$src$core$xml.domToText = domToText$$module$build$src$core$xml;
          module$build$src$core$xml.domToVariables = domToVariables$$module$build$src$core$xml;
          module$build$src$core$xml.domToWorkspace = $.domToWorkspace$$module$build$src$core$xml;
          module$build$src$core$xml.loadWorkspaceComment = loadWorkspaceComment$$module$build$src$core$xml;
          module$build$src$core$xml.saveWorkspaceComment = saveWorkspaceComment$$module$build$src$core$xml;
          module$build$src$core$xml.variablesToDom = variablesToDom$$module$build$src$core$xml;
          module$build$src$core$xml.workspaceToDom = workspaceToDom$$module$build$src$core$xml;
          var BlockCreate$$module$build$src$core$events$events_block_create = class extends BlockBase$$module$build$src$core$events$events_block_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_CREATE;
              a && (a.isShadow() && (this.recordUndo = false), this.xml = blockToDomWithXY$$module$build$src$core$xml(a), this.ids = getDescendantIds$$module$build$src$core$events$utils(a), this.json = save$$module$build$src$core$serialization$blocks(a, { addCoordinates: true }));
            }
            toJson() {
              const a = super.toJson();
              if (!this.xml) throw Error("The block XML is undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.json) throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
              a.xml = domToText$$module$build$src$core$xml(this.xml);
              a.ids = this.ids;
              a.json = this.json;
              this.recordUndo || (a.recordUndo = this.recordUndo);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockCreate$$module$build$src$core$events$events_block_create());
              b.xml = $.textToDom$$module$build$src$core$utils$xml(a.xml);
              b.ids = a.ids;
              b.json = a.json;
              a.recordUndo !== void 0 && (b.recordUndo = a.recordUndo);
              return b;
            }
            run(a) {
              const b = this.getEventWorkspace_();
              if (!this.json) throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
              if (!allShadowBlocks$$module$build$src$core$events$events_block_create(b, this.ids)) if (a) append$$module$build$src$core$serialization$blocks(this.json, b);
              else for (a = 0; a < this.ids.length; a++) {
                const c = this.ids[a], d = b.getBlockById(c);
                d ? d.dispose(false) : c === this.blockId && console.warn("Can't uncreate non-existent block: " + c);
              }
            }
          }, allShadowBlocks$$module$build$src$core$events$events_block_create = function(a, b) {
            return b.map((c) => a.getBlockById(c)).filter((c) => c && c.isShadow()).length === b.length;
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_CREATE, BlockCreate$$module$build$src$core$events$events_block_create);
          var module$build$src$core$events$events_block_create = {};
          module$build$src$core$events$events_block_create.BlockCreate = BlockCreate$$module$build$src$core$events$events_block_create;
          var ThemeChange$$module$build$src$core$events$events_theme_change = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b) {
              super(b);
              this.type = EventType$$module$build$src$core$events$type.THEME_CHANGE;
              this.themeName = a;
            }
            toJson() {
              const a = super.toJson();
              if (!this.themeName) throw Error("The theme name is undefined. Either pass a theme name to the constructor, or call fromJson");
              a.themeName = this.themeName;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new ThemeChange$$module$build$src$core$events$events_theme_change());
              b.themeName = a.themeName;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.THEME_CHANGE, ThemeChange$$module$build$src$core$events$events_theme_change);
          var module$build$src$core$events$events_theme_change = {};
          module$build$src$core$events$events_theme_change.ThemeChange = ThemeChange$$module$build$src$core$events$events_theme_change;
          var ViewportChange$$module$build$src$core$events$events_viewport = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c, d, e) {
              super(d);
              this.type = EventType$$module$build$src$core$events$type.VIEWPORT_CHANGE;
              this.viewTop = a;
              this.viewLeft = b;
              this.scale = c;
              this.oldScale = e;
            }
            toJson() {
              const a = super.toJson();
              if (this.viewTop === void 0) throw Error("The view top is undefined. Either pass a value to the constructor, or call fromJson");
              if (this.viewLeft === void 0) throw Error("The view left is undefined. Either pass a value to the constructor, or call fromJson");
              if (this.scale === void 0) throw Error("The scale is undefined. Either pass a value to the constructor, or call fromJson");
              if (this.oldScale === void 0) throw Error("The old scale is undefined. Either pass a value to the constructor, or call fromJson");
              a.viewTop = this.viewTop;
              a.viewLeft = this.viewLeft;
              a.scale = this.scale;
              a.oldScale = this.oldScale;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new ViewportChange$$module$build$src$core$events$events_viewport());
              b.viewTop = a.viewTop;
              b.viewLeft = a.viewLeft;
              b.scale = a.scale;
              b.oldScale = a.oldScale;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.VIEWPORT_CHANGE, ViewportChange$$module$build$src$core$events$events_viewport);
          var module$build$src$core$events$events_viewport = {};
          module$build$src$core$events$events_viewport.ViewportChange = ViewportChange$$module$build$src$core$events$events_viewport;
          var TEST_ONLY$$module$build$src$core$field_registry = { fromJsonInternal: fromJsonInternal$$module$build$src$core$field_registry }, module$build$src$core$field_registry = { TEST_ONLY: TEST_ONLY$$module$build$src$core$field_registry };
          module$build$src$core$field_registry.fromJson = $.fromJson$$module$build$src$core$field_registry;
          module$build$src$core$field_registry.register = register$$module$build$src$core$field_registry;
          module$build$src$core$field_registry.unregister = unregister$$module$build$src$core$field_registry;
          var FieldDropdown$$module$build$src$core$field_dropdown = class extends Field$$module$build$src$core$field {
            constructor(a, b, c) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.svgArrow = this.arrow = this.imageElement = this.menu_ = this.selectedMenuItem = null;
              this.SERIALIZABLE = true;
              this.clickTarget_ = this.suffixField = this.prefixField = this.generatedOptions = null;
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (this.setOptions(a), c && this.configure_(c), b && this.setValidator(b));
            }
            fromXml(a) {
              this.isOptionListDynamic() && this.getOptions(false);
              this.setValue(a.textContent);
            }
            loadState(a) {
              this.loadLegacyState(FieldDropdown$$module$build$src$core$field_dropdown, a) || (this.isOptionListDynamic() && this.getOptions(false), this.setValue(a));
            }
            initView() {
              this.shouldAddBorderRect_() ? this.createBorderRect_() : this.clickTarget_ = this.sourceBlock_.getSvgRoot();
              this.createTextElement_();
              this.imageElement = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, {}, this.fieldGroup_);
              this.getConstants().FIELD_DROPDOWN_SVG_ARROW ? this.createSVGArrow_() : this.createTextArrow_();
              this.borderRect_ && addClass$$module$build$src$core$utils$dom(this.borderRect_, "blocklyDropdownRect");
              this.fieldGroup_ && (addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyField"), addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyDropdownField"));
            }
            shouldAddBorderRect_() {
              let a;
              return !this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW && !((a = this.getSourceBlock()) == null ? 0 : a.isShadow());
            }
            createTextArrow_() {
              this.arrow = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.TSPAN, {}, this.textElement_);
              let a;
              this.arrow.appendChild(document.createTextNode(((a = this.getSourceBlock()) == null ? 0 : a.RTL) ? FieldDropdown$$module$build$src$core$field_dropdown.ARROW_CHAR + " " : " " + FieldDropdown$$module$build$src$core$field_dropdown.ARROW_CHAR));
              this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.arrow.setAttribute("dominant-baseline", "central");
              let b;
              ((b = this.getSourceBlock()) == null ? 0 : b.RTL) ? this.getTextElement().insertBefore(this.arrow, this.textContent_) : this.getTextElement().appendChild(this.arrow);
            }
            createSVGArrow_() {
              this.svgArrow = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { height: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px", width: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px" }, this.fieldGroup_);
              this.svgArrow.setAttributeNS(
                XLINK_NS$$module$build$src$core$utils$dom,
                "xlink:href",
                this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI
              );
            }
            showEditor_(a) {
              var b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              this.dropdownCreate();
              this.menu_ && (this.menu_.openingCoords = a && typeof a.clientX === "number" ? new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY) : null, clearContent$$module$build$src$core$dropdowndiv(), a = this.menu_.render(getContentDiv$$module$build$src$core$dropdowndiv()), addClass$$module$build$src$core$utils$dom(
                a,
                "blocklyDropdownMenu"
              ), this.getConstants().FIELD_DROPDOWN_COLOURED_DIV && (b = b.getColour(), a = this.sourceBlock_.getColourTertiary(), setColour$$module$build$src$core$dropdowndiv(b, a)), showPositionedByField$$module$build$src$core$dropdowndiv(this, this.dropdownDispose_.bind(this)), getContentDiv$$module$build$src$core$dropdowndiv().style.height = `${this.menu_.getSize().height}px`, this.menu_.focus(), this.selectedMenuItem && this.menu_.setHighlighted(this.selectedMenuItem), this.applyColour());
            }
            dropdownCreate() {
              const a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              const b = new Menu$$module$build$src$core$menu();
              b.setRole(Role$$module$build$src$core$utils$aria.LISTBOX);
              this.menu_ = b;
              const c = this.getOptions(false);
              this.selectedMenuItem = null;
              for (let e = 0; e < c.length; e++) {
                var d = c[e];
                if (d === FieldDropdown$$module$build$src$core$field_dropdown.SEPARATOR) {
                  b.addChild(new MenuSeparator$$module$build$src$core$menu_separator());
                  continue;
                }
                const [f, g] = d;
                isImageProperties$$module$build$src$core$field_dropdown(f) ? (d = new Image(f.width, f.height), d.src = f.src, d.alt = f.alt) : d = f;
                d = new MenuItem$$module$build$src$core$menuitem(d, g);
                d.setRole(Role$$module$build$src$core$utils$aria.OPTION);
                d.setRightToLeft(a.RTL);
                d.setCheckable(true);
                b.addChild(d);
                d.setChecked(g === this.value_);
                g === this.value_ && (this.selectedMenuItem = d);
                d.onAction(this.handleMenuActionEvent, this);
              }
            }
            dropdownDispose_() {
              this.menu_ && this.menu_.dispose();
              this.selectedMenuItem = this.menu_ = null;
              this.applyColour();
            }
            handleMenuActionEvent(a) {
              hideIfOwner$$module$build$src$core$dropdowndiv(
                this,
                true
              );
              this.onItemSelected_(this.menu_, a);
            }
            onItemSelected_(a, b) {
              this.setValue(b.getValue());
            }
            isOptionListDynamic() {
              return typeof this.menuGenerator_ === "function";
            }
            getOptions(a) {
              if (!this.menuGenerator_) throw TypeError("A menu generator was never defined.");
              if (Array.isArray(this.menuGenerator_)) return this.menuGenerator_;
              if (a && this.generatedOptions) return this.generatedOptions;
              this.generatedOptions = this.menuGenerator_();
              this.validateOptions(this.generatedOptions);
              return this.generatedOptions;
            }
            setOptions(a) {
              Array.isArray(a) ? (this.validateOptions(a), a = this.trimOptions(a), this.menuGenerator_ = a.options, this.prefixField = a.prefix || null, this.suffixField = a.suffix || null) : this.menuGenerator_ = a;
              this.selectedOption = this.getOptions(false)[0];
              this.setValue(this.selectedOption[1]);
            }
            doClassValidation_(a) {
              return this.getOptions(true).some((b) => b[1] === a) ? a : (this.sourceBlock_ && console.warn("Cannot set the dropdown's value to an unavailable option. Block type: " + this.sourceBlock_.type + ", Field name: " + this.name + ", Value: " + a), null);
            }
            doValueUpdate_(a) {
              super.doValueUpdate_(a);
              a = this.getOptions(true);
              for (let b = 0, c; c = a[b]; b++) c[1] === this.value_ && (this.selectedOption = c);
            }
            applyColour() {
              const a = this.sourceBlock_;
              this.borderRect_ && (this.borderRect_.setAttribute("stroke", a.getColourTertiary()), this.menu_ ? this.borderRect_.setAttribute("fill", a.getColourTertiary()) : this.borderRect_.setAttribute("fill", "transparent"));
              a && this.arrow && (a.isShadow() ? this.arrow.style.fill = a.getColourSecondary() : this.arrow.style.fill = a.getColour());
            }
            render_() {
              this.getTextContent().nodeValue = "";
              this.imageElement.style.display = "none";
              const a = this.selectedOption && this.selectedOption[0];
              isImageProperties$$module$build$src$core$field_dropdown(a) ? this.renderSelectedImage(a) : this.renderSelectedText();
              this.positionBorderRect_();
            }
            renderSelectedImage(a) {
              const b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              this.imageElement.style.display = "";
              this.imageElement.setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", a.src);
              this.imageElement.setAttribute("height", String(a.height));
              this.imageElement.setAttribute("width", String(a.width));
              const c = Number(a.height);
              a = Number(a.width);
              var d = !!this.borderRect_;
              const e = Math.max(d ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, c + FieldDropdown$$module$build$src$core$field_dropdown.IMAGE_Y_PADDING);
              d = d ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
              let f;
              f = this.svgArrow ? this.positionSVGArrow(a + d, e / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2) : getTextWidth$$module$build$src$core$utils$dom(this.arrow);
              this.size_ = new Size$$module$build$src$core$utils$size(a + f + d * 2, e);
              let g = 0;
              b.RTL ? this.imageElement.setAttribute("x", `${d + f}`) : (g = a + f, this.getTextElement().setAttribute("text-anchor", "end"), this.imageElement.setAttribute("x", `${d}`));
              this.imageElement.setAttribute("y", String(e / 2 - c / 2));
              this.positionTextElement_(g + d, a + f);
            }
            renderSelectedText() {
              this.getTextContent().nodeValue = this.getDisplayText_();
              var a = this.getTextElement();
              addClass$$module$build$src$core$utils$dom(a, "blocklyDropdownText");
              a.setAttribute("text-anchor", "start");
              var b = !!this.borderRect_;
              a = Math.max(b ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, this.getConstants().FIELD_TEXT_HEIGHT);
              const c = getTextWidth$$module$build$src$core$utils$dom(this.getTextElement());
              b = b ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
              let d = 0;
              this.svgArrow && (d = this.positionSVGArrow(c + b, a / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2));
              this.size_ = new Size$$module$build$src$core$utils$size(c + d + b * 2, a);
              this.positionTextElement_(b, c);
            }
            positionSVGArrow(a, b) {
              if (!this.svgArrow) return 0;
              const c = this.getSourceBlock();
              if (!c) throw new UnattachedFieldError$$module$build$src$core$field();
              const d = this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0, e = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING, f = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;
              this.svgArrow.setAttribute("transform", "translate(" + (c.RTL ? d : a + e) + "," + b + ")");
              return f + e;
            }
            getText_() {
              if (!this.selectedOption) return null;
              const a = this.selectedOption[0];
              if (isImageProperties$$module$build$src$core$field_dropdown(a)) return a.alt;
              if (typeof HTMLElement !== "undefined" && a instanceof HTMLElement) {
                let b, c;
                return (c = (b = a.title) != null ? b : a.ariaLabel) != null ? c : a.innerText;
              }
              if (typeof a === "string") return a;
              console.warn("Can't get text for existing dropdown option. If you're using HTMLElement dropdown options in node, ensure you're using jsdom-global or similar.");
              return null;
            }
            static fromJson(a) {
              if (!a.options) throw Error("options are required for the dropdown field. The options property must be assigned an array of [humanReadableValue, languageNeutralValue] tuples.");
              return new this(a.options, void 0, a);
            }
            trimOptions(a) {
              let b = false;
              const c = a.map((g) => {
                if (g === FieldDropdown$$module$build$src$core$field_dropdown.SEPARATOR) return b = true, g;
                const [h, k] = g;
                if (typeof h === "string") return [replaceMessageReferences$$module$build$src$core$utils$parsing(h), k];
                b = true;
                return [isImageProperties$$module$build$src$core$field_dropdown(h) ? Object.assign({}, h, { alt: replaceMessageReferences$$module$build$src$core$utils$parsing(h.alt) }) : h, k];
              });
              if (b || a.length < 2) return { options: c };
              var d = c.map(([g]) => g), e = shortestStringLength$$module$build$src$core$utils$string(d);
              a = commonWordPrefix$$module$build$src$core$utils$string(d, e);
              const f = commonWordSuffix$$module$build$src$core$utils$string(d, e);
              if (!a && !f || e <= a + f) return { options: c };
              e = a ? d[0].substring(0, a - 1) : void 0;
              d = f ? d[0].substr(1 - f) : void 0;
              return { options: this.applyTrim(c, a, f), prefix: e, suffix: d };
            }
            applyTrim(a, b, c) {
              return a.map(([d, e]) => [d.substring(b, d.length - c), e]);
            }
            validateOptions(a) {
              if (!Array.isArray(a)) throw TypeError("FieldDropdown options must be an array.");
              if (!a.length) throw TypeError("FieldDropdown options must not be an empty array.");
              let b = false;
              for (let c = 0; c < a.length; c++) {
                const d = a[c];
                Array.isArray(d) || d === FieldDropdown$$module$build$src$core$field_dropdown.SEPARATOR ? typeof d[1] !== "string" ? (b = true, console.error(`Invalid option[${c}]: Each FieldDropdown option id must be a string.
          Found ${d[1]} in: ${d}`)) : !d[0] || typeof d[0] === "string" || isImageProperties$$module$build$src$core$field_dropdown(d[0]) || typeof HTMLElement !== "undefined" && d[0] instanceof HTMLElement || (b = true, console.error(`Invalid option[${c}]: Each FieldDropdown option must have a string
          label, image description, or HTML element. Found ${d[0]} in: ${d}`)) : (b = true, console.error(`Invalid option[${c}]: Each FieldDropdown option must be an array or
          the string literal 'separator'. Found: ${d}`));
              }
              if (b) throw TypeError("Found invalid FieldDropdown options.");
            }
          };
          FieldDropdown$$module$build$src$core$field_dropdown.SEPARATOR = "separator";
          FieldDropdown$$module$build$src$core$field_dropdown.ARROW_CHAR = "\u25BE";
          FieldDropdown$$module$build$src$core$field_dropdown.IMAGE_Y_OFFSET = 5;
          FieldDropdown$$module$build$src$core$field_dropdown.IMAGE_Y_PADDING = FieldDropdown$$module$build$src$core$field_dropdown.IMAGE_Y_OFFSET * 2;
          register$$module$build$src$core$field_registry("field_dropdown", FieldDropdown$$module$build$src$core$field_dropdown);
          var module$build$src$core$field_dropdown = {};
          module$build$src$core$field_dropdown.FieldDropdown = FieldDropdown$$module$build$src$core$field_dropdown;
          var Theme$$module$build$src$core$theme = class {
            constructor(a, b, c, d) {
              this.name = a;
              this.startHats = false;
              this.blockStyles = b || /* @__PURE__ */ Object.create(null);
              this.categoryStyles = c || /* @__PURE__ */ Object.create(null);
              this.componentStyles = d || /* @__PURE__ */ Object.create(null);
              this.fontStyle = /* @__PURE__ */ Object.create(null);
              register$$module$build$src$core$registry(Type$$module$build$src$core$registry.THEME, a, this, true);
            }
            getClassName() {
              return this.name + "-theme";
            }
            setBlockStyle(a, b) {
              this.blockStyles[a] = b;
            }
            setCategoryStyle(a, b) {
              this.categoryStyles[a] = b;
            }
            getComponentStyle(a) {
              a = this.componentStyles[a];
              if (!a) return null;
              if (typeof a === "string") {
                const b = this.getComponentStyle(a);
                if (b) return b;
              }
              return `${a}`;
            }
            setComponentStyle(a, b) {
              this.componentStyles[a] = b;
            }
            setFontStyle(a) {
              this.fontStyle = a;
            }
            setStartHats(a) {
              this.startHats = a;
            }
            static defineTheme(a, b) {
              a = a.toLowerCase();
              const c = new Theme$$module$build$src$core$theme(a);
              let d = b.base;
              if (d) {
                if (typeof d === "string") {
                  let e;
                  d = (e = getObject$$module$build$src$core$registry(Type$$module$build$src$core$registry.THEME, d)) != null ? e : void 0;
                }
                d instanceof Theme$$module$build$src$core$theme && (deepMerge$$module$build$src$core$utils$object(c, d), c.name = a);
              }
              deepMerge$$module$build$src$core$utils$object(c.blockStyles, b.blockStyles);
              deepMerge$$module$build$src$core$utils$object(c.categoryStyles, b.categoryStyles);
              deepMerge$$module$build$src$core$utils$object(c.componentStyles, b.componentStyles);
              deepMerge$$module$build$src$core$utils$object(c.fontStyle, b.fontStyle);
              b.startHats !== null && (c.startHats = b.startHats);
              return c;
            }
          }, module$build$src$core$theme = {};
          module$build$src$core$theme.Theme = Theme$$module$build$src$core$theme;
          var defaultBlockStyles$$module$build$src$core$theme$classic = { colour_blocks: { colourPrimary: "20" }, list_blocks: { colourPrimary: "260" }, logic_blocks: { colourPrimary: "210" }, loop_blocks: { colourPrimary: "120" }, math_blocks: { colourPrimary: "230" }, procedure_blocks: { colourPrimary: "290" }, text_blocks: { colourPrimary: "160" }, variable_blocks: { colourPrimary: "330" }, variable_dynamic_blocks: { colourPrimary: "310" }, hat_blocks: { colourPrimary: "330", hat: "cap" } }, categoryStyles$$module$build$src$core$theme$classic = {
            colour_category: { colour: "20" },
            list_category: { colour: "260" },
            logic_category: { colour: "210" },
            loop_category: { colour: "120" },
            math_category: { colour: "230" },
            procedure_category: { colour: "290" },
            text_category: { colour: "160" },
            variable_category: { colour: "330" },
            variable_dynamic_category: { colour: "310" }
          }, Classic$$module$build$src$core$theme$classic = new Theme$$module$build$src$core$theme("classic", defaultBlockStyles$$module$build$src$core$theme$classic, categoryStyles$$module$build$src$core$theme$classic), module$build$src$core$theme$classic = { Classic: Classic$$module$build$src$core$theme$classic };
          var Options$$module$build$src$core$options = class {
            constructor(a) {
              this.gridPattern = null;
              this.getMetrics = this.setMetrics = void 0;
              let b = null, c = false;
              var d = false, e = false, f = false, g = false, h = false;
              const k = !!a.readOnly;
              if (!k) {
                var l;
                b = convertToolboxDefToJson$$module$build$src$core$utils$toolbox((l = a.toolbox) != null ? l : null);
                c = hasCategories$$module$build$src$core$utils$toolbox(b);
                d = a.trashcan;
                d = d === void 0 ? c : d;
                e = a.collapse;
                e = e === void 0 ? c : e;
                f = a.comments;
                f = f === void 0 ? c : f;
                g = a.disable;
                g = g === void 0 ? c : g;
                h = a.sounds;
                h = h === void 0 ? true : h;
              }
              l = a.maxTrashcanContents;
              d ? l === void 0 && (l = 32) : l = 0;
              const m = !!a.rtl;
              let n = a.horizontalLayout;
              n === void 0 && (n = false);
              var p = a.toolboxPosition !== "end";
              p = n ? p ? Position$$module$build$src$core$utils$toolbox.TOP : Position$$module$build$src$core$utils$toolbox.BOTTOM : p === m ? Position$$module$build$src$core$utils$toolbox.RIGHT : Position$$module$build$src$core$utils$toolbox.LEFT;
              let r = a.css;
              r === void 0 && (r = true);
              let q = "https://blockly-demo.appspot.com/static/media/";
              a.media && (q = a.media.endsWith("/") ? a.media : a.media + "/");
              const u = a.oneBasedIndex, y = a.renderer || "geras", z = a.plugins || {};
              let t = a.modalInputs;
              t === void 0 && (t = true);
              this.RTL = m;
              this.oneBasedIndex = u === void 0 ? true : u;
              this.collapse = e;
              this.comments = f;
              this.disable = g;
              this.readOnly = k;
              this.maxBlocks = a.maxBlocks || Infinity;
              let v;
              this.maxInstances = (v = a.maxInstances) != null ? v : null;
              this.modalInputs = t;
              this.pathToMedia = q;
              this.hasCategories = c;
              this.moveOptions = Options$$module$build$src$core$options.parseMoveOptions(a, c);
              this.hasScrollbars = !!this.moveOptions.scrollbars;
              this.hasTrashcan = d;
              this.maxTrashcanContents = l;
              this.hasSounds = h;
              this.hasCss = r;
              this.horizontalLayout = n;
              this.languageTree = b;
              this.gridOptions = Options$$module$build$src$core$options.parseGridOptions(a);
              this.zoomOptions = Options$$module$build$src$core$options.parseZoomOptions(a);
              this.toolboxPosition = p;
              this.theme = Options$$module$build$src$core$options.parseThemeOptions(a);
              this.renderer = y;
              let w;
              this.rendererOverrides = (w = a.rendererOverrides) != null ? w : null;
              let x;
              this.parentWorkspace = (x = a.parentWorkspace) != null ? x : null;
              this.plugins = z;
            }
            static parseMoveOptions(a, b) {
              const c = a.move || {}, d = {};
              c.scrollbars === void 0 && a.scrollbars === void 0 ? d.scrollbars = b : typeof c.scrollbars === "object" ? (d.scrollbars = { horizontal: !!c.scrollbars.horizontal, vertical: !!c.scrollbars.vertical }, d.scrollbars.horizontal && d.scrollbars.vertical ? d.scrollbars = true : d.scrollbars.horizontal || d.scrollbars.vertical || (d.scrollbars = false)) : d.scrollbars = !!c.scrollbars || !!a.scrollbars;
              d.wheel = d.scrollbars && c.wheel !== void 0 ? !!c.wheel : typeof d.scrollbars === "object";
              d.drag = d.scrollbars ? c.drag === void 0 ? true : !!c.drag : false;
              return d;
            }
            static parseZoomOptions(a) {
              a = a.zoom || {};
              const b = {};
              b.controls = a.controls === void 0 ? false : !!a.controls;
              b.wheel = a.wheel === void 0 ? false : !!a.wheel;
              b.startScale = a.startScale === void 0 ? 1 : Number(a.startScale);
              b.maxScale = a.maxScale === void 0 ? 3 : Number(a.maxScale);
              b.minScale = a.minScale === void 0 ? 0.3 : Number(a.minScale);
              b.scaleSpeed = a.scaleSpeed === void 0 ? 1.2 : Number(a.scaleSpeed);
              b.pinch = a.pinch === void 0 ? b.wheel || b.controls : !!a.pinch;
              return b;
            }
            static parseGridOptions(a) {
              a = a.grid || {};
              const b = {};
              b.spacing = Number(a.spacing) || 0;
              b.colour = a.colour || "#888";
              b.length = a.length === void 0 ? 1 : Number(a.length);
              b.snap = b.spacing > 0 && !!a.snap;
              return b;
            }
            static parseThemeOptions(a) {
              a = a.theme || Classic$$module$build$src$core$theme$classic;
              return typeof a === "string" ? getObject$$module$build$src$core$registry(Type$$module$build$src$core$registry.THEME, a) : a instanceof Theme$$module$build$src$core$theme ? a : Theme$$module$build$src$core$theme.defineTheme(a.name || "builtin" + getNextUniqueId$$module$build$src$core$utils$idgenerator(), a);
            }
          }, module$build$src$core$options = {};
          module$build$src$core$options.Options = Options$$module$build$src$core$options;
          var BubbleDragStrategy$$module$build$src$core$dragging$bubble_drag_strategy = class {
            constructor(a, b) {
              this.bubble = a;
              this.workspace = b;
              this.startLoc = null;
            }
            isMovable() {
              return true;
            }
            startDrag() {
              this.startLoc = this.bubble.getRelativeToSurfaceXY();
              this.workspace.setResizesEnabled(false);
              let a;
              (a = this.workspace.getLayerManager()) == null || a.moveToDragLayer(this.bubble);
              this.bubble.setDragging && this.bubble.setDragging(true);
            }
            drag(a) {
              this.bubble.moveDuringDrag(a);
            }
            endDrag() {
              this.workspace.setResizesEnabled(true);
              let a;
              (a = this.workspace.getLayerManager()) == null || a.moveOffDragLayer(this.bubble, BUBBLE$$module$build$src$core$layers);
              this.bubble.setDragging(false);
            }
            revertDrag() {
              this.startLoc && this.bubble.moveDuringDrag(this.startLoc);
            }
          }, module$build$src$core$dragging$bubble_drag_strategy = {};
          module$build$src$core$dragging$bubble_drag_strategy.BubbleDragStrategy = BubbleDragStrategy$$module$build$src$core$dragging$bubble_drag_strategy;
          var _a$$module$build$src$core$bubbles$bubble, Bubble$$module$build$src$core$bubbles$bubble = class {
            constructor(a, b, c, d, e) {
              this.workspace = a;
              this.anchor = b;
              this.ownerRect = c;
              this.owner = e;
              this.size = new Size$$module$build$src$core$utils$size(0, 0);
              this.colour = "#ffffff";
              this.disposed = false;
              this.relativeLeft = this.relativeTop = 0;
              this.dragStrategy = new BubbleDragStrategy$$module$build$src$core$dragging$bubble_drag_strategy(this, this.workspace);
              this.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.svgRoot = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyBubble" }, a.getBubbleCanvas());
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyEmboss" }, this.svgRoot);
              this.tail = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyBubbleTail" }, a);
              this.background = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.RECT,
                { "class": "blocklyDraggable", x: 0, y: 0, rx: _a$$module$build$src$core$bubbles$bubble.BORDER_WIDTH, ry: _a$$module$build$src$core$bubbles$bubble.BORDER_WIDTH },
                a
              );
              this.contentContainer = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {}, this.svgRoot);
              this.focusableElement = d != null ? d : this.svgRoot;
              this.focusableElement.setAttribute("id", this.id);
              conditionalBind$$module$build$src$core$browser_events(this.background, "pointerdown", this, this.onMouseDown);
              conditionalBind$$module$build$src$core$browser_events(
                this.focusableElement,
                "keydown",
                this,
                this.onKeyDown
              );
            }
            dispose() {
              removeNode$$module$build$src$core$utils$dom(this.svgRoot);
              this.disposed = true;
            }
            setAnchorLocation(a, b = false) {
              this.anchor = a;
              b ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor();
              this.renderTail();
            }
            setPositionRelativeToAnchor(a, b) {
              this.relativeLeft = a;
              this.relativeTop = b;
              this.positionRelativeToAnchor();
              this.renderTail();
            }
            getSize() {
              return this.size;
            }
            setSize(a, b = false) {
              a.width = Math.max(a.width, _a$$module$build$src$core$bubbles$bubble.MIN_SIZE);
              a.height = Math.max(
                a.height,
                _a$$module$build$src$core$bubbles$bubble.MIN_SIZE
              );
              this.size = a;
              this.background.setAttribute("width", `${a.width}`);
              this.background.setAttribute("height", `${a.height}`);
              b ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor();
              this.renderTail();
            }
            getColour() {
              return this.colour;
            }
            setColour(a) {
              this.colour = a;
              this.tail.setAttribute("fill", a);
              this.background.setAttribute("fill", a);
            }
            onMouseDown(a) {
              let b;
              (b = this.workspace.getGesture(a)) == null || b.handleBubbleStart(a, this);
              $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this);
            }
            onKeyDown(a) {
              a.key === "Escape" && this.owner && (this.owner.setBubbleVisible(false), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.owner));
            }
            positionRelativeToAnchor() {
              let a = this.anchor.x;
              a = this.workspace.RTL ? a - (this.relativeLeft + this.size.width) : a + this.relativeLeft;
              this.moveTo(a, this.relativeTop + this.anchor.y);
            }
            moveTo(a, b) {
              this.svgRoot.setAttribute("transform", `translate(${a}, ${b})`);
            }
            positionByRect(a = new Rect$$module$build$src$core$utils$rect(0, 0, 0, 0)) {
              var b = this.workspace.getMetricsManager().getViewMetrics(true), c = this.getOptimalRelativeLeft(b), d = this.getOptimalRelativeTop(b);
              const e = { x: c, y: -this.size.height - this.workspace.getRenderer().getConstants().MIN_BLOCK_HEIGHT }, f = { x: -this.size.width - 30, y: d };
              d = { x: a.getWidth(), y: d };
              var g = { x: c, y: a.getHeight() };
              c = a.getWidth() < a.getHeight() ? d : g;
              a = a.getWidth() < a.getHeight() ? g : d;
              d = this.getOverlap(e, b);
              g = this.getOverlap(f, b);
              const h = this.getOverlap(c, b);
              b = this.getOverlap(a, b);
              b = Math.max(d, g, h, b);
              d === b ? (this.relativeLeft = e.x, this.relativeTop = e.y) : g === b ? (this.relativeLeft = f.x, this.relativeTop = f.y) : h === b ? (this.relativeLeft = c.x, this.relativeTop = c.y) : (this.relativeLeft = a.x, this.relativeTop = a.y);
              this.positionRelativeToAnchor();
            }
            getOverlap(a, b) {
              var c = this.workspace.RTL ? this.anchor.x - a.x - this.size.width : a.x + this.anchor.x;
              a = a.y + this.anchor.y;
              return Math.max(0, Math.min(1, (Math.min(c + this.size.width, b.left + b.width) - Math.max(c, b.left)) * (Math.min(a + this.size.height, b.top + b.height) - Math.max(a, b.top)) / (this.size.width * this.size.height)));
            }
            getOptimalRelativeLeft(a) {
              let b = -this.size.width / 4;
              if (this.size.width > a.width) return b;
              a = this.getWorkspaceViewRect(a);
              if (this.workspace.RTL) {
                var c = this.anchor.x - b;
                c - this.size.width < a.left ? b = -(a.left - this.anchor.x + this.size.width) : c > a.right && (b = -(a.right - this.anchor.x));
              } else {
                c = b + this.anchor.x;
                const d = c + this.size.width;
                c < a.left ? b = a.left - this.anchor.x : d > a.right && (b = a.right - this.anchor.x - this.size.width);
              }
              return b;
            }
            getOptimalRelativeTop(a) {
              let b = -this.size.height / 4;
              if (this.size.height > a.height) return b;
              const c = this.anchor.y + b, d = c + this.size.height;
              a = this.getWorkspaceViewRect(a);
              c < a.top ? b = a.top - this.anchor.y : d > a.bottom && (b = a.bottom - this.anchor.y - this.size.height);
              return b;
            }
            getWorkspaceViewRect(a) {
              const b = a.top;
              let c = a.top + a.height, d = a.left;
              a = a.left + a.width;
              c -= this.getScrollbarThickness();
              this.workspace.RTL ? d -= this.getScrollbarThickness() : a -= this.getScrollbarThickness();
              return new Rect$$module$build$src$core$utils$rect(b, c, d, a);
            }
            getScrollbarThickness() {
              return Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness / this.workspace.scale;
            }
            renderTail() {
              const a = [];
              var b = this.size.width / 2, c = this.size.height / 2, d = -this.relativeLeft, e = -this.relativeTop;
              if (b === d && c === e) a.push("M " + b + "," + c);
              else {
                e -= c;
                d -= b;
                this.workspace.RTL && (d *= -1);
                var f = Math.sqrt(e * e + d * d), g = Math.acos(d / f);
                e < 0 && (g = 2 * Math.PI - g);
                var h = g + Math.PI / 2;
                h > Math.PI * 2 && (h -= Math.PI * 2);
                var k = Math.sin(h);
                const m = Math.cos(h);
                let n = (this.size.width + this.size.height) / _a$$module$build$src$core$bubbles$bubble.TAIL_THICKNESS;
                n = Math.min(n, this.size.width, this.size.height) / 4;
                h = 1 - _a$$module$build$src$core$bubbles$bubble.ANCHOR_RADIUS / f;
                d = b + h * d;
                e = c + h * e;
                h = b + n * m;
                const p = c + n * k;
                b -= n * m;
                c -= n * k;
                k = toRadians$$module$build$src$core$utils$math(this.workspace.RTL ? -_a$$module$build$src$core$bubbles$bubble.TAIL_ANGLE : _a$$module$build$src$core$bubbles$bubble.TAIL_ANGLE);
                k = g + k;
                k > Math.PI * 2 && (k -= Math.PI * 2);
                g = Math.sin(k) * f / _a$$module$build$src$core$bubbles$bubble.TAIL_BEND;
                f = Math.cos(k) * f / _a$$module$build$src$core$bubbles$bubble.TAIL_BEND;
                a.push("M" + h + "," + p);
                a.push("C" + (h + f) + "," + (p + g) + " " + d + "," + e + " " + d + "," + e);
                a.push("C" + d + "," + e + " " + (b + f) + "," + (c + g) + " " + b + "," + c);
              }
              a.push("z");
              let l;
              (l = this.tail) == null || l.setAttribute("d", a.join(" "));
            }
            bringToFront() {
              let a;
              const b = (a = this.svgRoot) == null ? void 0 : a.parentNode;
              return this.svgRoot && (b == null ? void 0 : b.lastChild) !== this.svgRoot ? (b == null || b.appendChild(this.svgRoot), true) : false;
            }
            getRelativeToSurfaceXY() {
              return new Coordinate$$module$build$src$core$utils$coordinate(this.workspace.RTL ? -this.relativeLeft + this.anchor.x - this.size.width : this.anchor.x + this.relativeLeft, this.anchor.y + this.relativeTop);
            }
            getSvgRoot() {
              return this.svgRoot;
            }
            moveDuringDrag(a) {
              this.moveTo(
                a.x,
                a.y
              );
              this.relativeLeft = this.workspace.RTL ? this.anchor.x - a.x - this.size.width : a.x - this.anchor.x;
              this.relativeTop = a.y - this.anchor.y;
              this.renderTail();
            }
            setDragging(a) {
            }
            setDeleteStyle(a) {
            }
            isDeletable() {
              return false;
            }
            showContextMenu(a) {
            }
            isMovable() {
              return true;
            }
            startDrag() {
              this.dragStrategy.startDrag();
            }
            drag(a) {
              this.dragStrategy.drag(a);
            }
            endDrag() {
              this.dragStrategy.endDrag();
            }
            revertDrag() {
              this.dragStrategy.revertDrag();
            }
            select() {
              fireSelectedEvent$$module$build$src$core$common(this);
            }
            unselect() {
              fireSelectedEvent$$module$build$src$core$common(null);
            }
            getFocusableElement() {
              return this.focusableElement;
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              this.select();
              this.bringToFront();
              var a = this.getRelativeToSurfaceXY();
              const b = this.getSize();
              a = new Rect$$module$build$src$core$utils$rect(a.y, a.y + b.height, a.x, a.x + b.width);
              this.workspace.scrollBoundsIntoView(a);
            }
            onNodeBlur() {
              this.unselect();
            }
            canBeFocused() {
              return true;
            }
            getOwner() {
              return this.owner;
            }
          };
          _a$$module$build$src$core$bubbles$bubble = Bubble$$module$build$src$core$bubbles$bubble;
          Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH = 6;
          Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER = _a$$module$build$src$core$bubbles$bubble.BORDER_WIDTH * 2;
          Bubble$$module$build$src$core$bubbles$bubble.MIN_SIZE = _a$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER;
          Bubble$$module$build$src$core$bubbles$bubble.TAIL_THICKNESS = 1;
          Bubble$$module$build$src$core$bubbles$bubble.TAIL_ANGLE = 20;
          Bubble$$module$build$src$core$bubbles$bubble.TAIL_BEND = 4;
          Bubble$$module$build$src$core$bubbles$bubble.ANCHOR_RADIUS = 8;
          var module$build$src$core$bubbles$bubble = {};
          module$build$src$core$bubbles$bubble.Bubble = Bubble$$module$build$src$core$bubbles$bubble;
          var MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble = class extends Bubble$$module$build$src$core$bubbles$bubble {
            constructor(a, b, c, d) {
              super(b, c, d);
              this.workspace = b;
              this.anchor = c;
              this.ownerRect = d;
              this.autoLayout = true;
              b = new Options$$module$build$src$core$options(a);
              this.validateWorkspaceOptions(b);
              this.svgDialog = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.SVG,
                { x: Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH, y: Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH },
                this.contentContainer
              );
              a.parentWorkspace = this.workspace;
              this.miniWorkspace = this.newWorkspaceSvg(new Options$$module$build$src$core$options(a));
              this.miniWorkspace.internalIsMutator = true;
              a = this.miniWorkspace.createDom("blocklyMutatorBackground");
              this.svgDialog.appendChild(a);
              b.languageTree && (a.insertBefore(this.miniWorkspace.addFlyout(Svg$$module$build$src$core$utils$svg.G), this.miniWorkspace.getCanvas()), a = this.miniWorkspace.getFlyout(), a == null || a.init(this.miniWorkspace), a == null || a.show(b.languageTree));
              addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyMiniWorkspaceBubble");
              this.miniWorkspace.addChangeListener(this.onWorkspaceChange.bind(this));
              let e, f;
              (e = this.miniWorkspace.getFlyout()) == null || (f = e.getWorkspace()) == null || f.addChangeListener(this.onWorkspaceChange.bind(this));
              this.updateBubbleSize();
            }
            dispose() {
              this.miniWorkspace.dispose();
              super.dispose();
            }
            getWorkspace() {
              return this.miniWorkspace;
            }
            addWorkspaceChangeListener(a) {
              this.miniWorkspace.addChangeListener(a);
            }
            validateWorkspaceOptions(a) {
              if (a.hasCategories) throw Error("The miniworkspace bubble does not support toolboxes with categories");
              if (a.hasTrashcan) throw Error("The miniworkspace bubble does not support trashcans");
              if (a.zoomOptions.controls || a.zoomOptions.wheel || a.zoomOptions.pinch) throw Error("The miniworkspace bubble does not support zooming");
              if (a.moveOptions.scrollbars || a.moveOptions.wheel || a.moveOptions.drag) throw Error("The miniworkspace bubble does not scrolling/moving the workspace");
              if (a.horizontalLayout) throw Error("The miniworkspace bubble does not support horizontal layouts");
            }
            onWorkspaceChange() {
              this.bumpBlocksIntoBounds();
              this.updateBubbleSize();
            }
            bumpBlocksIntoBounds() {
              if (!this.miniWorkspace.isDragging() || this.miniWorkspace.keyboardMoveInProgress) for (const a of this.miniWorkspace.getTopBlocks(false)) {
                const b = a.getRelativeToSurfaceXY();
                b.y < 20 && a.moveBy(0, 20 - b.y);
                if (a.RTL) {
                  let c = -20;
                  const d = this.miniWorkspace.getFlyout();
                  d && (c -= d.getWidth());
                  b.x > c && a.moveBy(c - b.x, 0);
                } else b.x < 20 && a.moveBy(20 - b.x, 0);
              }
            }
            updateBubbleSize() {
              if (!this.miniWorkspace.isDragging() || this.miniWorkspace.keyboardMoveInProgress) {
                this.autoLayout && (this.autoLayout = !this.miniWorkspace.keyboardMoveInProgress);
                var a = this.getSize(), b = this.calculateWorkspaceSize();
                Math.abs(a.width - b.width) < MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MINIMUM_VIEW_CHANGE && Math.abs(a.height - b.height) < MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MINIMUM_VIEW_CHANGE || (this.svgDialog.setAttribute("width", `${b.width}px`), this.svgDialog.setAttribute("height", `${b.height}px`), this.miniWorkspace.setCachedParentSvgSize(b.width, b.height), this.miniWorkspace.RTL && this.miniWorkspace.getCanvas().setAttribute("transform", `translate(${b.width}, 0)`), this.setSize(new Size$$module$build$src$core$utils$size(b.width + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER, b.height + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER), this.autoLayout), this.miniWorkspace.resize(), this.miniWorkspace.recordDragTargets());
              }
            }
            calculateWorkspaceSize() {
              var a = this.miniWorkspace.getCanvas().getBBox();
              let b = a.width + MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MARGIN;
              a = a.height + MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MARGIN;
              const c = this.miniWorkspace.getFlyout();
              if (c) {
                const d = c.getWorkspace().getMetricsManager().getScrollMetrics();
                a = Math.max(a, d.height + 20);
                b += c.getWidth();
              }
              return new Size$$module$build$src$core$utils$size(b, a);
            }
            updateBlockStyles() {
              for (var a of this.miniWorkspace.getAllBlocks(false)) a.setStyle(a.getStyleName());
              let b;
              if (a = (b = this.miniWorkspace.getFlyout()) == null ? void 0 : b.getWorkspace()) for (const c of a.getAllBlocks(false)) c.setStyle(c.getStyleName());
            }
            moveDuringDrag(a) {
              super.moveDuringDrag(a);
              this.autoLayout = false;
            }
            moveTo(a, b) {
              super.moveTo(a, b);
              this.miniWorkspace.recordDragTargets();
            }
            newWorkspaceSvg(a) {
              throw Error("The implementation of newWorkspaceSvg should be monkey-patched in by blockly.ts");
            }
          };
          MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MINIMUM_VIEW_CHANGE = 10;
          MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.MARGIN = Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER * 3;
          var module$build$src$core$bubbles$mini_workspace_bubble = {};
          module$build$src$core$bubbles$mini_workspace_bubble.MiniWorkspaceBubble = MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble;
          var Icon$$module$build$src$core$icons$icon = class {
            constructor(a) {
              this.sourceBlock = a;
              this.offsetInBlock = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.workspaceLocation = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.svgRoot = null;
              this.tooltip = a;
              this.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
            }
            getType() {
              throw Error("Icons must implement getType");
            }
            initView(a) {
              if (!this.svgRoot) {
                var b = this.sourceBlock;
                this.svgRoot = createSvgElement$$module$build$src$core$utils$dom(
                  Svg$$module$build$src$core$utils$svg.G,
                  { "class": "blocklyIconGroup", id: this.id }
                );
                b.getSvgRoot().appendChild(this.svgRoot);
                this.updateSvgRootOffset();
                conditionalBind$$module$build$src$core$browser_events(this.svgRoot, "pointerdown", this, a);
                this.svgRoot.tooltip = this;
                bindMouseEvents$$module$build$src$core$tooltip(this.svgRoot);
              }
            }
            dispose() {
              unbindMouseEvents$$module$build$src$core$tooltip(this.svgRoot);
              removeNode$$module$build$src$core$utils$dom(this.svgRoot);
            }
            getWeight() {
              return -1;
            }
            getSize() {
              return new Size$$module$build$src$core$utils$size(0, 0);
            }
            setTooltip(a) {
              this.tooltip = a != null ? a : this.sourceBlock;
            }
            getTooltip() {
              return this.tooltip;
            }
            applyColour() {
            }
            updateEditable() {
            }
            updateCollapsed() {
              this.svgRoot && (this.sourceBlock.isCollapsed() ? this.svgRoot.style.display = "none" : this.svgRoot.style.display = "block", hasBubble$$module$build$src$core$interfaces$i_has_bubble(this) && this.setBubbleVisible(false));
            }
            hideForInsertionMarker() {
              this.svgRoot && (this.svgRoot.style.display = "none");
            }
            isShownWhenCollapsed() {
              return false;
            }
            setOffsetInBlock(a) {
              this.offsetInBlock = a;
              this.updateSvgRootOffset();
            }
            updateSvgRootOffset() {
              let a;
              (a = this.svgRoot) == null || a.setAttribute("transform", `translate(${this.offsetInBlock.x}, ${this.offsetInBlock.y})`);
            }
            onLocationChange(a) {
              this.workspaceLocation = Coordinate$$module$build$src$core$utils$coordinate.sum(a, this.offsetInBlock);
            }
            onClick() {
            }
            isClickableInFlyout(a) {
              return true;
            }
            getFocusableElement() {
              const a = this.svgRoot;
              if (!a) throw Error("Attempting to focus uninitialized icon.");
              return a;
            }
            getFocusableTree() {
              return this.sourceBlock.workspace;
            }
            onNodeFocus() {
              var a = this.sourceBlock.getBoundingRectangle();
              a = new Rect$$module$build$src$core$utils$rect(a.top + this.offsetInBlock.y, a.top + this.offsetInBlock.y + this.getSize().height, a.left + this.offsetInBlock.x, a.left + this.offsetInBlock.x + this.getSize().width);
              this.sourceBlock.workspace.scrollBoundsIntoView(a);
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
            getSourceBlock() {
              return this.sourceBlock;
            }
          }, module$build$src$core$icons$icon = {};
          module$build$src$core$icons$icon.Icon = Icon$$module$build$src$core$icons$icon;
          var SIZE$$module$build$src$core$icons$mutator_icon, WORKSPACE_MARGIN$$module$build$src$core$icons$mutator_icon;
          SIZE$$module$build$src$core$icons$mutator_icon = 17;
          WORKSPACE_MARGIN$$module$build$src$core$icons$mutator_icon = 16;
          $.MutatorIcon$$module$build$src$core$icons$mutator_icon = class extends Icon$$module$build$src$core$icons$icon {
            constructor(a, b) {
              super(b);
              this.flyoutBlockTypes = a;
              this.sourceBlock = b;
              this.saveConnectionsListener = this.updateWorkspacePid = this.rootBlock = this.miniWorkspaceBubble = null;
            }
            getType() {
              return $.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE;
            }
            initView(a) {
              this.svgRoot || (super.initView(a), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, {
                "class": "blocklyIconShape",
                rx: "4",
                ry: "4",
                height: "16",
                width: "16"
              }, this.svgRoot), createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.PATH,
                { "class": "blocklyIconSymbol", d: "m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 -0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z" },
                this.svgRoot
              ), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CIRCLE, { "class": "blocklyIconShape", r: "2.7", cx: "8", cy: "8" }, this.svgRoot), addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyMutatorIcon"));
            }
            dispose() {
              super.dispose();
              let a;
              (a = this.miniWorkspaceBubble) == null || a.dispose();
            }
            getWeight() {
              return $.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT;
            }
            getSize() {
              return new Size$$module$build$src$core$utils$size(
                SIZE$$module$build$src$core$icons$mutator_icon,
                SIZE$$module$build$src$core$icons$mutator_icon
              );
            }
            applyColour() {
              super.applyColour();
              let a;
              (a = this.miniWorkspaceBubble) == null || a.setColour(this.sourceBlock.getColour());
              let b;
              (b = this.miniWorkspaceBubble) == null || b.updateBlockStyles();
            }
            updateCollapsed() {
              super.updateCollapsed();
              this.sourceBlock.isCollapsed() && this.setBubbleVisible(false);
            }
            onLocationChange(a) {
              super.onLocationChange(a);
              let b;
              (b = this.miniWorkspaceBubble) == null || b.setAnchorLocation(this.getAnchorLocation());
            }
            onClick() {
              super.onClick();
              this.sourceBlock.isEditable() && this.setBubbleVisible(!this.bubbleIsVisible());
            }
            isClickableInFlyout() {
              return false;
            }
            bubbleIsVisible() {
              return !!this.miniWorkspaceBubble;
            }
            setBubbleVisible(a) {
              const b = this;
              return (0, $jscomp.asyncExecutePromiseGeneratorFunction)(function* () {
                if (b.bubbleIsVisible() !== a) {
                  yield finishQueuedRenders$$module$build$src$core$render_management();
                  if (a) {
                    b.miniWorkspaceBubble = new MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble(
                      b.getMiniWorkspaceConfig(),
                      b.sourceBlock.workspace,
                      b.getAnchorLocation(),
                      b.getBubbleOwnerRect()
                    );
                    b.applyColour();
                    b.createRootBlock();
                    b.addSaveConnectionsListener();
                    let c;
                    (c = b.miniWorkspaceBubble) == null || c.addWorkspaceChangeListener(b.createMiniWorkspaceChangeListener());
                  } else {
                    let c;
                    (c = b.miniWorkspaceBubble) == null || c.dispose();
                    b.miniWorkspaceBubble = null;
                    b.saveConnectionsListener && b.sourceBlock.workspace.removeChangeListener(b.saveConnectionsListener);
                    b.saveConnectionsListener = null;
                  }
                  fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BUBBLE_OPEN))(
                    b.sourceBlock,
                    a,
                    "mutator"
                  ));
                }
              });
            }
            getBubble() {
              return this.miniWorkspaceBubble;
            }
            getMiniWorkspaceConfig() {
              let a;
              const b = { disable: false, media: this.sourceBlock.workspace.options.pathToMedia, rtl: this.sourceBlock.RTL, renderer: this.sourceBlock.workspace.options.renderer, rendererOverrides: (a = this.sourceBlock.workspace.options.rendererOverrides) != null ? a : void 0 };
              this.flyoutBlockTypes.length && (b.toolbox = { kind: "flyoutToolbox", contents: this.flyoutBlockTypes.map((c) => ({ kind: "block", type: c })) });
              return b;
            }
            getAnchorLocation() {
              const a = SIZE$$module$build$src$core$icons$mutator_icon / 2;
              return Coordinate$$module$build$src$core$utils$coordinate.sum(this.workspaceLocation, new Coordinate$$module$build$src$core$utils$coordinate(a, a));
            }
            getBubbleOwnerRect() {
              const a = this.sourceBlock.getSvgRoot().getBBox();
              return new Rect$$module$build$src$core$utils$rect(a.y, a.y + a.height, a.x, a.x + a.width);
            }
            createRootBlock() {
              if (!this.sourceBlock.decompose) throw Error("Blocks with mutator icons must include a decompose method");
              this.rootBlock = this.sourceBlock.decompose(this.miniWorkspaceBubble.getWorkspace());
              for (var a of this.rootBlock.getDescendants(false)) a.queueRender();
              this.rootBlock.setMovable(false);
              this.rootBlock.setDeletable(false);
              let b, c, d, e;
              a = (e = (b = this.miniWorkspaceBubble) == null ? void 0 : (c = b.getWorkspace()) == null ? void 0 : (d = c.getFlyout()) == null ? void 0 : d.getWidth()) != null ? e : 0;
              this.rootBlock.moveBy(this.rootBlock.RTL ? -(a + WORKSPACE_MARGIN$$module$build$src$core$icons$mutator_icon) : WORKSPACE_MARGIN$$module$build$src$core$icons$mutator_icon, WORKSPACE_MARGIN$$module$build$src$core$icons$mutator_icon);
            }
            addSaveConnectionsListener() {
              this.sourceBlock.saveConnections && this.rootBlock && (this.saveConnectionsListener = () => {
                this.sourceBlock.saveConnections && this.rootBlock && this.sourceBlock.saveConnections(this.rootBlock);
              }, this.saveConnectionsListener(), this.sourceBlock.workspace.addChangeListener(this.saveConnectionsListener));
            }
            createMiniWorkspaceChangeListener() {
              return (a) => {
                $.MutatorIcon$$module$build$src$core$icons$mutator_icon.isIgnorableMutatorEvent(a) || this.updateWorkspacePid || (this.updateWorkspacePid = setTimeout(
                  () => {
                    this.updateWorkspacePid = null;
                    this.recomposeSourceBlock();
                  },
                  0
                ));
              };
            }
            static isIgnorableMutatorEvent(a) {
              return a.isUiEvent || isBlockCreate$$module$build$src$core$events$predicates(a) || isBlockChange$$module$build$src$core$events$predicates(a) && a.element === "disabled";
            }
            recomposeSourceBlock() {
              if (this.rootBlock) {
                if (!this.sourceBlock.compose) throw Error("Blocks with mutator icons must include a compose method");
                var a = $.getGroup$$module$build$src$core$events$utils();
                a || $.setGroup$$module$build$src$core$events$utils(true);
                var b = BlockChange$$module$build$src$core$events$events_block_change.getExtraBlockState_(this.sourceBlock);
                this.sourceBlock.compose(this.rootBlock);
                var c = BlockChange$$module$build$src$core$events$events_block_change.getExtraBlockState_(this.sourceBlock);
                b !== c && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this.sourceBlock, "mutation", null, b, c));
                $.setGroup$$module$build$src$core$events$utils(a);
              }
            }
            getWorkspace() {
              let a;
              return (a = this.miniWorkspaceBubble) == null ? void 0 : a.getWorkspace();
            }
          };
          $.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE = IconType$$module$build$src$core$icons$icon_types.MUTATOR;
          $.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT = 1;
          var module$build$src$core$icons$mutator_icon = {};
          module$build$src$core$icons$mutator_icon.MutatorIcon = $.MutatorIcon$$module$build$src$core$icons$mutator_icon;
          var allExtensions$$module$build$src$core$extensions = /* @__PURE__ */ Object.create(null), TEST_ONLY$$module$build$src$core$extensions = { allExtensions: allExtensions$$module$build$src$core$extensions };
          $.register$$module$build$src$core$extensions("parent_tooltip_when_inline", extensionParentTooltip$$module$build$src$core$extensions);
          var module$build$src$core$extensions = { TEST_ONLY: TEST_ONLY$$module$build$src$core$extensions };
          module$build$src$core$extensions.apply = apply$$module$build$src$core$extensions;
          module$build$src$core$extensions.buildTooltipForDropdown = $.buildTooltipForDropdown$$module$build$src$core$extensions;
          module$build$src$core$extensions.buildTooltipWithFieldText = $.buildTooltipWithFieldText$$module$build$src$core$extensions;
          module$build$src$core$extensions.isRegistered = isRegistered$$module$build$src$core$extensions;
          module$build$src$core$extensions.register = $.register$$module$build$src$core$extensions;
          module$build$src$core$extensions.registerMixin = $.registerMixin$$module$build$src$core$extensions;
          module$build$src$core$extensions.registerMutator = $.registerMutator$$module$build$src$core$extensions;
          module$build$src$core$extensions.runAfterPageLoad = runAfterPageLoad$$module$build$src$core$extensions;
          module$build$src$core$extensions.unregister = unregister$$module$build$src$core$extensions;
          var KeyCodes$$module$build$src$core$utils$keycodes;
          (function(a) {
            a[a.WIN_KEY_FF_LINUX = 0] = "WIN_KEY_FF_LINUX";
            a[a.MAC_ENTER = 3] = "MAC_ENTER";
            a[a.BACKSPACE = 8] = "BACKSPACE";
            a[a.TAB = 9] = "TAB";
            a[a.NUM_CENTER = 12] = "NUM_CENTER";
            a[a.ENTER = 13] = "ENTER";
            a[a.SHIFT = 16] = "SHIFT";
            a[a.CTRL = 17] = "CTRL";
            a[a.ALT = 18] = "ALT";
            a[a.PAUSE = 19] = "PAUSE";
            a[a.CAPS_LOCK = 20] = "CAPS_LOCK";
            a[a.ESC = 27] = "ESC";
            a[a.SPACE = 32] = "SPACE";
            a[a.PAGE_UP = 33] = "PAGE_UP";
            a[a.PAGE_DOWN = 34] = "PAGE_DOWN";
            a[a.END = 35] = "END";
            a[a.HOME = 36] = "HOME";
            a[a.LEFT = 37] = "LEFT";
            a[a.UP = 38] = "UP";
            a[a.RIGHT = 39] = "RIGHT";
            a[a.DOWN = 40] = "DOWN";
            a[a.PLUS_SIGN = 43] = "PLUS_SIGN";
            a[a.PRINT_SCREEN = 44] = "PRINT_SCREEN";
            a[a.INSERT = 45] = "INSERT";
            a[a.DELETE = 46] = "DELETE";
            a[a.ZERO = 48] = "ZERO";
            a[a.ONE = 49] = "ONE";
            a[a.TWO = 50] = "TWO";
            a[a.THREE = 51] = "THREE";
            a[a.FOUR = 52] = "FOUR";
            a[a.FIVE = 53] = "FIVE";
            a[a.SIX = 54] = "SIX";
            a[a.SEVEN = 55] = "SEVEN";
            a[a.EIGHT = 56] = "EIGHT";
            a[a.NINE = 57] = "NINE";
            a[a.FF_SEMICOLON = 59] = "FF_SEMICOLON";
            a[a.FF_EQUALS = 61] = "FF_EQUALS";
            a[a.FF_DASH = 173] = "FF_DASH";
            a[a.FF_HASH = 163] = "FF_HASH";
            a[a.QUESTION_MARK = 63] = "QUESTION_MARK";
            a[a.AT_SIGN = 64] = "AT_SIGN";
            a[a.A = 65] = "A";
            a[a.B = 66] = "B";
            a[a.C = 67] = "C";
            a[a.D = 68] = "D";
            a[a.E = 69] = "E";
            a[a.F = 70] = "F";
            a[a.G = 71] = "G";
            a[a.H = 72] = "H";
            a[a.I = 73] = "I";
            a[a.J = 74] = "J";
            a[a.K = 75] = "K";
            a[a.L = 76] = "L";
            a[a.M = 77] = "M";
            a[a.N = 78] = "N";
            a[a.O = 79] = "O";
            a[a.P = 80] = "P";
            a[a.Q = 81] = "Q";
            a[a.R = 82] = "R";
            a[a.S = 83] = "S";
            a[a.T = 84] = "T";
            a[a.U = 85] = "U";
            a[a.V = 86] = "V";
            a[a.W = 87] = "W";
            a[a.X = 88] = "X";
            a[a.Y = 89] = "Y";
            a[a.Z = 90] = "Z";
            a[a.META = 91] = "META";
            a[a.WIN_KEY_RIGHT = 92] = "WIN_KEY_RIGHT";
            a[a.CONTEXT_MENU = 93] = "CONTEXT_MENU";
            a[a.NUM_ZERO = 96] = "NUM_ZERO";
            a[a.NUM_ONE = 97] = "NUM_ONE";
            a[a.NUM_TWO = 98] = "NUM_TWO";
            a[a.NUM_THREE = 99] = "NUM_THREE";
            a[a.NUM_FOUR = 100] = "NUM_FOUR";
            a[a.NUM_FIVE = 101] = "NUM_FIVE";
            a[a.NUM_SIX = 102] = "NUM_SIX";
            a[a.NUM_SEVEN = 103] = "NUM_SEVEN";
            a[a.NUM_EIGHT = 104] = "NUM_EIGHT";
            a[a.NUM_NINE = 105] = "NUM_NINE";
            a[a.NUM_MULTIPLY = 106] = "NUM_MULTIPLY";
            a[a.NUM_PLUS = 107] = "NUM_PLUS";
            a[a.NUM_MINUS = 109] = "NUM_MINUS";
            a[a.NUM_PERIOD = 110] = "NUM_PERIOD";
            a[a.NUM_DIVISION = 111] = "NUM_DIVISION";
            a[a.F1 = 112] = "F1";
            a[a.F2 = 113] = "F2";
            a[a.F3 = 114] = "F3";
            a[a.F4 = 115] = "F4";
            a[a.F5 = 116] = "F5";
            a[a.F6 = 117] = "F6";
            a[a.F7 = 118] = "F7";
            a[a.F8 = 119] = "F8";
            a[a.F9 = 120] = "F9";
            a[a.F10 = 121] = "F10";
            a[a.F11 = 122] = "F11";
            a[a.F12 = 123] = "F12";
            a[a.NUMLOCK = 144] = "NUMLOCK";
            a[a.SCROLL_LOCK = 145] = "SCROLL_LOCK";
            a[a.FIRST_MEDIA_KEY = 166] = "FIRST_MEDIA_KEY";
            a[a.LAST_MEDIA_KEY = 183] = "LAST_MEDIA_KEY";
            a[a.SEMICOLON = 186] = "SEMICOLON";
            a[a.DASH = 189] = "DASH";
            a[a.EQUALS = 187] = "EQUALS";
            a[a.COMMA = 188] = "COMMA";
            a[a.PERIOD = 190] = "PERIOD";
            a[a.SLASH = 191] = "SLASH";
            a[a.APOSTROPHE = 192] = "APOSTROPHE";
            a[a.TILDE = 192] = "TILDE";
            a[a.SINGLE_QUOTE = 222] = "SINGLE_QUOTE";
            a[a.OPEN_SQUARE_BRACKET = 219] = "OPEN_SQUARE_BRACKET";
            a[a.BACKSLASH = 220] = "BACKSLASH";
            a[a.CLOSE_SQUARE_BRACKET = 221] = "CLOSE_SQUARE_BRACKET";
            a[a.WIN_KEY = 224] = "WIN_KEY";
            a[a.MAC_FF_META = 224] = "MAC_FF_META";
            a[a.MAC_WK_CMD_LEFT = 91] = "MAC_WK_CMD_LEFT";
            a[a.MAC_WK_CMD_RIGHT = 93] = "MAC_WK_CMD_RIGHT";
            a[a.WIN_IME = 229] = "WIN_IME";
            a[a.VK_NONAME = 252] = "VK_NONAME";
            a[a.PHANTOM = 255] = "PHANTOM";
          })(KeyCodes$$module$build$src$core$utils$keycodes || (KeyCodes$$module$build$src$core$utils$keycodes = {}));
          var module$build$src$core$utils$keycodes = {};
          module$build$src$core$utils$keycodes.KeyCodes = KeyCodes$$module$build$src$core$utils$keycodes;
          var module$build$src$core$utils$svg_paths = {};
          module$build$src$core$utils$svg_paths.arc = arc$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.curve = curve$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.line = line$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.lineOnAxis = lineOnAxis$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.lineTo = lineTo$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.moveBy = moveBy$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.moveTo = moveTo$$module$build$src$core$utils$svg_paths;
          module$build$src$core$utils$svg_paths.point = point$$module$build$src$core$utils$svg_paths;
          var module$build$src$core$utils = {};
          module$build$src$core$utils.Coordinate = Coordinate$$module$build$src$core$utils$coordinate;
          module$build$src$core$utils.KeyCodes = KeyCodes$$module$build$src$core$utils$keycodes;
          module$build$src$core$utils.Rect = Rect$$module$build$src$core$utils$rect;
          module$build$src$core$utils.Size = Size$$module$build$src$core$utils$size;
          module$build$src$core$utils.Svg = Svg$$module$build$src$core$utils$svg;
          module$build$src$core$utils.aria = module$build$src$core$utils$aria;
          module$build$src$core$utils.array = module$build$src$core$utils$array;
          module$build$src$core$utils.browserEvents = module$build$src$core$browser_events;
          module$build$src$core$utils.colour = module$build$src$core$utils$colour;
          module$build$src$core$utils.deprecation = module$build$src$core$utils$deprecation;
          module$build$src$core$utils.dom = module$build$src$core$utils$dom;
          module$build$src$core$utils.extensions = module$build$src$core$extensions;
          module$build$src$core$utils.idGenerator = module$build$src$core$utils$idgenerator;
          module$build$src$core$utils.math = module$build$src$core$utils$math;
          module$build$src$core$utils.object = module$build$src$core$utils$object;
          module$build$src$core$utils.parsing = module$build$src$core$utils$parsing;
          module$build$src$core$utils.string = module$build$src$core$utils$string;
          module$build$src$core$utils.style = module$build$src$core$utils$style;
          module$build$src$core$utils.svgMath = module$build$src$core$utils$svg_math;
          module$build$src$core$utils.svgPaths = module$build$src$core$utils$svg_paths;
          module$build$src$core$utils.toolbox = module$build$src$core$utils$toolbox;
          module$build$src$core$utils.userAgent = module$build$src$core$utils$useragent;
          module$build$src$core$utils.xml = module$build$src$core$utils$xml;
          var TextInputBubble$$module$build$src$core$bubbles$textinput_bubble = class extends Bubble$$module$build$src$core$bubbles$bubble {
            constructor(a, b, c, d) {
              super(a, b, c, void 0, d);
              this.workspace = a;
              this.anchor = b;
              this.ownerRect = c;
              this.owner = d;
              this.resizePointerMoveListener = this.resizePointerUpListener = null;
              this.sizeChangeListeners = [];
              this.locationChangeListeners = [];
              this.DEFAULT_SIZE = new Size$$module$build$src$core$utils$size(160 + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER, 80 + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER);
              this.MIN_SIZE = new Size$$module$build$src$core$utils$size(45 + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER, 20 + Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER);
              this.editable = true;
              addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyTextInputBubble");
              this.editor = new CommentEditor$$module$build$src$core$comments$comment_editor(a, this.id, () => {
                $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this);
              });
              this.contentContainer.appendChild(this.editor.getDom());
              this.resizeGroup = this.createResizeHandle(this.svgRoot, a);
              this.setSize(this.DEFAULT_SIZE, true);
            }
            getText() {
              return this.editor.getText();
            }
            setText(a) {
              this.editor.setText(a);
            }
            setEditable(a) {
              this.editable = a;
              this.editor.setEditable(a);
            }
            isEditable() {
              return this.editable;
            }
            addTextChangeListener(a) {
              this.editor.addTextChangeListener(a);
            }
            addSizeChangeListener(a) {
              this.sizeChangeListeners.push(a);
            }
            addLocationChangeListener(a) {
              this.locationChangeListeners.push(a);
            }
            createResizeHandle(a, b) {
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.IMAGE,
                { "class": "blocklyResizeHandle", href: `${b.options.pathToMedia}resize-handle.svg` },
                a
              );
              conditionalBind$$module$build$src$core$browser_events(a, "pointerdown", this, this.onResizePointerDown);
              return a;
            }
            setSize(a, b = false) {
              a.width = Math.max(a.width, this.MIN_SIZE.width);
              a.height = Math.max(a.height, this.MIN_SIZE.height);
              const c = a.width - Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER, d = a.height - Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER;
              this.editor.updateSize(new Size$$module$build$src$core$utils$size(
                c,
                d
              ), new Size$$module$build$src$core$utils$size(0, 0));
              this.editor.getDom().setAttribute("x", `${Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER / 2}`);
              this.editor.getDom().setAttribute("y", `${Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER / 2}`);
              this.resizeGroup.setAttribute("y", `${d}`);
              this.workspace.RTL ? this.resizeGroup.setAttribute("x", `${-Bubble$$module$build$src$core$bubbles$bubble.DOUBLE_BORDER}`) : this.resizeGroup.setAttribute("x", `${c}`);
              super.setSize(a, b);
              this.onSizeChange();
            }
            getSize() {
              return super.getSize();
            }
            moveDuringDrag(a) {
              super.moveDuringDrag(a);
              this.onLocationChange();
            }
            setPositionRelativeToAnchor(a, b) {
              super.setPositionRelativeToAnchor(a, b);
              this.onLocationChange();
            }
            positionByRect(a = new Rect$$module$build$src$core$utils$rect(0, 0, 0, 0)) {
              super.positionByRect(a);
              this.onLocationChange();
            }
            onResizePointerDown(a) {
              this.bringToFront();
              isRightButton$$module$build$src$core$browser_events(a) || (start$$module$build$src$core$utils$drag(this.workspace, a, new Coordinate$$module$build$src$core$utils$coordinate(
                this.workspace.RTL ? -this.getSize().width : this.getSize().width,
                this.getSize().height
              )), this.resizePointerUpListener = conditionalBind$$module$build$src$core$browser_events(document, "pointerup", this, this.onResizePointerUp), this.resizePointerMoveListener = conditionalBind$$module$build$src$core$browser_events(document, "pointermove", this, this.onResizePointerMove), this.workspace.hideChaff());
              a.stopPropagation();
            }
            onResizePointerUp(a) {
              clearTouchIdentifier$$module$build$src$core$touch();
              this.resizePointerUpListener && (unbind$$module$build$src$core$browser_events(this.resizePointerUpListener), this.resizePointerUpListener = null);
              this.resizePointerMoveListener && (unbind$$module$build$src$core$browser_events(this.resizePointerMoveListener), this.resizePointerMoveListener = null);
            }
            onResizePointerMove(a) {
              a = move$$module$build$src$core$utils$drag(this.workspace, a);
              this.setSize(new Size$$module$build$src$core$utils$size(this.workspace.RTL ? -a.x : a.x, a.y), false);
              this.onSizeChange();
            }
            onSizeChange() {
              for (const a of this.sizeChangeListeners) a();
            }
            onLocationChange() {
              for (const a of this.locationChangeListeners) a();
            }
            getEditor() {
              return this.editor;
            }
          };
          register$$module$build$src$core$css("\n.blocklyTextInputBubble .blocklyTextarea {\n  background-color: var(--commentFillColour);\n  border: 0;\n  box-sizing: border-box;\n  display: block;\n  outline: 0;\n  padding: 5px;\n  resize: none;\n  width: 100%;\n  height: 100%;\n}\n");
          var module$build$src$core$bubbles$textinput_bubble = {};
          module$build$src$core$bubbles$textinput_bubble.TextInputBubble = TextInputBubble$$module$build$src$core$bubbles$textinput_bubble;
          var ConnectionType$$module$build$src$core$connection_type;
          (function(a) {
            a[a.INPUT_VALUE = 1] = "INPUT_VALUE";
            a[a.OUTPUT_VALUE = 2] = "OUTPUT_VALUE";
            a[a.NEXT_STATEMENT = 3] = "NEXT_STATEMENT";
            a[a.PREVIOUS_STATEMENT = 4] = "PREVIOUS_STATEMENT";
          })(ConnectionType$$module$build$src$core$connection_type || (ConnectionType$$module$build$src$core$connection_type = {}));
          var module$build$src$core$connection_type = {};
          module$build$src$core$connection_type.ConnectionType = ConnectionType$$module$build$src$core$connection_type;
          var ConnectionDB$$module$build$src$core$connection_db = class {
            constructor(a) {
              this.connectionChecker = a;
              this.connections = [];
            }
            addConnection(a, b) {
              b = this.calculateIndexForYPos(b);
              this.connections.splice(b, 0, a);
            }
            findIndexOfConnection(a, b) {
              if (!this.connections.length) return -1;
              const c = this.calculateIndexForYPos(b);
              if (c >= this.connections.length) return -1;
              b = a.y;
              let d = c;
              for (; d >= 0 && this.connections[d].y === b; ) {
                if (this.connections[d] === a) return d;
                d--;
              }
              for (d = c; d < this.connections.length && this.connections[d].y === b; ) {
                if (this.connections[d] === a) return d;
                d++;
              }
              return -1;
            }
            calculateIndexForYPos(a) {
              if (!this.connections.length) return 0;
              let b = 0, c = this.connections.length;
              for (; b < c; ) {
                const d = Math.floor((b + c) / 2);
                if (this.connections[d].y < a) b = d + 1;
                else if (this.connections[d].y > a) c = d;
                else {
                  b = d;
                  break;
                }
              }
              return b;
            }
            removeConnection(a, b) {
              a = this.findIndexOfConnection(a, b);
              if (a === -1) throw Error("Unable to find connection in connectionDB.");
              this.connections.splice(a, 1);
            }
            getNeighbours(a, b) {
              function c(l) {
                const m = e - d[l].x, n = f - d[l].y;
                Math.sqrt(m * m + n * n) <= b && k.push(d[l]);
                return n < b;
              }
              const d = this.connections, e = a.x, f = a.y;
              a = 0;
              let g = d.length - 2, h = g;
              for (; a < h; ) d[h].y < f ? a = h : g = h, h = Math.floor((a + g) / 2);
              const k = [];
              g = a = h;
              if (d.length) {
                for (; a >= 0 && c(a); ) a--;
                do
                  g++;
                while (g < d.length && c(g));
              }
              return k;
            }
            isInYRange(a, b, c) {
              return Math.abs(this.connections[a].y - b) <= c;
            }
            searchForClosest(a, b, c) {
              if (!this.connections.length) return { connection: null, radius: b };
              const d = a.y, e = a.x;
              a.x = e + c.x;
              a.y = d + c.y;
              var f = this.calculateIndexForYPos(a.y);
              c = null;
              let g = b, h, k = f - 1;
              for (; k >= 0 && this.isInYRange(k, a.y, b); ) h = this.connections[k], this.connectionChecker.canConnect(a, h, true, g) && (c = h, g = h.distanceFrom(a)), k--;
              for (; f < this.connections.length && this.isInYRange(f, a.y, b); ) h = this.connections[f], this.connectionChecker.canConnect(a, h, true, g) && (c = h, g = h.distanceFrom(a)), f++;
              a.x = e;
              a.y = d;
              return { connection: c, radius: g };
            }
            static init(a) {
              const b = [];
              b[ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE] = new ConnectionDB$$module$build$src$core$connection_db(a);
              b[ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE] = new ConnectionDB$$module$build$src$core$connection_db(a);
              b[ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT] = new ConnectionDB$$module$build$src$core$connection_db(a);
              b[ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT] = new ConnectionDB$$module$build$src$core$connection_db(a);
              return b;
            }
          }, module$build$src$core$connection_db = {};
          module$build$src$core$connection_db.ConnectionDB = ConnectionDB$$module$build$src$core$connection_db;
          var Selected$$module$build$src$core$events$events_selected = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c) {
              super(c);
              this.type = EventType$$module$build$src$core$events$type.SELECTED;
              this.oldElementId = a != null ? a : void 0;
              this.newElementId = b != null ? b : void 0;
            }
            toJson() {
              const a = super.toJson();
              a.oldElementId = this.oldElementId;
              a.newElementId = this.newElementId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new Selected$$module$build$src$core$events$events_selected());
              b.oldElementId = a.oldElementId;
              b.newElementId = a.newElementId;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.SELECTED, Selected$$module$build$src$core$events$events_selected);
          var module$build$src$core$events$events_selected = {};
          module$build$src$core$events$events_selected.Selected = Selected$$module$build$src$core$events$events_selected;
          var BlockDelete$$module$build$src$core$events$events_block_delete = class extends BlockBase$$module$build$src$core$events$events_block_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_DELETE;
              if (a) {
                if (a.getParent()) throw Error("Connected blocks cannot be deleted.");
                a.isShadow() && (this.recordUndo = false);
                this.oldXml = blockToDomWithXY$$module$build$src$core$xml(a);
                this.ids = getDescendantIds$$module$build$src$core$events$utils(a);
                this.wasShadow = a.isShadow();
                this.oldJson = save$$module$build$src$core$serialization$blocks(a, { addCoordinates: true });
              }
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldXml) throw Error("The old block XML is undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
              if (this.wasShadow === void 0) throw Error("Whether the block was a shadow is undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.oldJson) throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
              a.oldXml = domToText$$module$build$src$core$xml(this.oldXml);
              a.ids = this.ids;
              a.wasShadow = this.wasShadow;
              a.oldJson = this.oldJson;
              this.recordUndo || (a.recordUndo = this.recordUndo);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockDelete$$module$build$src$core$events$events_block_delete());
              b.oldXml = $.textToDom$$module$build$src$core$utils$xml(a.oldXml);
              b.ids = a.ids;
              b.wasShadow = a.wasShadow || b.oldXml.tagName.toLowerCase() === "shadow";
              b.oldJson = a.oldJson;
              a.recordUndo !== void 0 && (b.recordUndo = a.recordUndo);
              return b;
            }
            run(a) {
              const b = this.getEventWorkspace_();
              if (!this.ids) throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
              if (!this.oldJson) throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
              if (a) for (a = 0; a < this.ids.length; a++) {
                const c = this.ids[a], d = b.getBlockById(c);
                d ? d.dispose(false) : c === this.blockId && console.warn("Can't delete non-existent block: " + c);
              }
              else append$$module$build$src$core$serialization$blocks(
                this.oldJson,
                b
              );
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_DELETE, BlockDelete$$module$build$src$core$events$events_block_delete);
          var module$build$src$core$events$events_block_delete = {};
          module$build$src$core$events$events_block_delete.BlockDelete = BlockDelete$$module$build$src$core$events$events_block_delete;
          var Connection$$module$build$src$core$connection = class {
            constructor(a, b) {
              this.type = b;
              this.targetConnection = null;
              this.disposed = false;
              this.shadowDom = this.check = null;
              this.y = this.x = 0;
              this.shadowState = null;
              this.sourceBlock_ = a;
              if (a.id.includes("_connection")) throw Error(`Connection ID indicator is contained in block ID. This will cause problems with focus: ${a.id}.`);
              this.id = `${a.id}_connection_${getNextUniqueId$$module$build$src$core$utils$idgenerator()}`;
            }
            connect_(a) {
              const b = ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE, c = this.getSourceBlock();
              var d = a.getSourceBlock();
              a.isConnected() && a.disconnectInternal(false);
              let e;
              if (this.isConnected()) {
                const g = this.stashShadowState(), h = this.targetBlock();
                h.isShadow() ? h.dispose(false) : (this.disconnectInternal(), e = h);
                this.applyShadowState(g);
              }
              let f;
              isEnabled$$module$build$src$core$events$utils() && (f = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_MOVE))(d), f.setReason(["connect"]));
              connectReciprocally$$module$build$src$core$connection(
                this,
                a
              );
              d.setParent(c);
              f && (f.recordNew(), fire$$module$build$src$core$events$utils(f));
              if (e && (a = this.type === b ? e.outputConnection : e.previousConnection)) if (d = Connection$$module$build$src$core$connection.getConnectionForOrphanedConnection(d, a)) a.connect(d);
              else a.onFailedConnect(this);
            }
            dispose() {
              if (this.isConnected()) {
                this.isSuperior() && this.setShadowStateInternal();
                const a = this.targetBlock();
                a && !a.isDeadOrDying() && a.unplug();
              }
              this.disposed = true;
            }
            getSourceBlock() {
              return this.sourceBlock_;
            }
            isSuperior() {
              return this.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE || this.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT;
            }
            isConnected() {
              return !!this.targetConnection;
            }
            getConnectionChecker() {
              return this.sourceBlock_.workspace.connectionChecker;
            }
            onFailedConnect(a) {
            }
            connect(a) {
              if (this.targetConnection === a) return true;
              if (this.getConnectionChecker().canConnect(this, a, false)) {
                const b = $.getGroup$$module$build$src$core$events$utils();
                b || $.setGroup$$module$build$src$core$events$utils(true);
                this.isSuperior() ? this.connect_(a) : a.connect_(this);
                $.setGroup$$module$build$src$core$events$utils(b);
              }
              return this.isConnected();
            }
            disconnect() {
              this.disconnectInternal();
            }
            disconnectInternal(a = true) {
              const { parentConnection: b, childConnection: c } = this.getParentAndChildConnections();
              if (!b || !c) throw Error("Source connection not connected.");
              const d = $.getGroup$$module$build$src$core$events$utils();
              d || $.setGroup$$module$build$src$core$events$utils(true);
              let e;
              isEnabled$$module$build$src$core$events$utils() && (e = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_MOVE))(c.getSourceBlock()), e.setReason(["disconnect"]));
              const f = this.targetConnection;
              f && (f.targetConnection = null);
              this.targetConnection = null;
              a && c.getSourceBlock().setParent(null);
              e && (e.recordNew(), fire$$module$build$src$core$events$utils(e));
              c.getSourceBlock().isShadow() || b.respawnShadow_();
              $.setGroup$$module$build$src$core$events$utils(d);
            }
            getParentAndChildConnections() {
              return this.targetConnection ? this.isSuperior() ? { parentConnection: this, childConnection: this.targetConnection } : { parentConnection: this.targetConnection, childConnection: this } : {};
            }
            respawnShadow_() {
              this.createShadowBlock(true);
            }
            reconnect(a, b) {
              if (this.getSourceBlock().isDeadOrDying()) return false;
              var c;
              b = (c = a.getInput(b)) == null ? void 0 : c.connection;
              c = this.targetBlock();
              return c && c !== a || !b || b.targetConnection === this ? false : (b.isConnected() && b.disconnect(), b.connect(this), true);
            }
            targetBlock() {
              if (this.isConnected()) {
                let a, b;
                return (b = (a = this.targetConnection) == null ? void 0 : a.getSourceBlock()) != null ? b : null;
              }
              return null;
            }
            onCheckChanged_() {
              !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(
                this,
                this.targetConnection,
                false
              ) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug();
            }
            setCheck(a) {
              a ? (Array.isArray(a) || (a = [a]), this.check = a, this.onCheckChanged_()) : this.check = null;
              return this;
            }
            getCheck() {
              return this.check;
            }
            setShadowDom(a) {
              this.setShadowStateInternal({ shadowDom: a });
            }
            getShadowDom(a) {
              return a && this.targetBlock().isShadow() ? blockToDom$$module$build$src$core$xml(this.targetBlock()) : this.shadowDom;
            }
            setShadowState(a) {
              this.setShadowStateInternal({ shadowState: a });
            }
            getShadowState(a) {
              return a && this.targetBlock() && this.targetBlock().isShadow() ? save$$module$build$src$core$serialization$blocks(this.targetBlock()) : this.shadowState;
            }
            neighbours(a) {
              return [];
            }
            getParentInput() {
              let a = null;
              const b = this.sourceBlock_.inputList;
              for (let c = 0; c < b.length; c++) if (b[c].connection === this) {
                a = b[c];
                break;
              }
              return a;
            }
            toString() {
              const a = this.sourceBlock_;
              if (!a) return "Orphan Connection";
              if (a.outputConnection === this) var b = "Output Connection of ";
              else if (a.previousConnection === this) b = "Previous Connection of ";
              else if (a.nextConnection === this) b = "Next Connection of ";
              else {
                b = null;
                for (let c = 0, d; d = a.inputList[c]; c++) if (d.connection === this) {
                  b = d;
                  break;
                }
                if (b) b = 'Input "' + b.name + '" connection on ';
                else return console.warn("Connection not actually connected to sourceBlock_"), "Orphan Connection";
              }
              return b + a.toDevString();
            }
            stashShadowState() {
              const a = this.getShadowDom(true), b = this.getShadowState(true);
              this.shadowState = this.shadowDom = null;
              return { shadowDom: a, shadowState: b };
            }
            applyShadowState({ shadowDom: a, shadowState: b }) {
              this.shadowDom = a;
              this.shadowState = b;
            }
            setShadowStateInternal({ shadowDom: a = null, shadowState: b = null } = {}) {
              this.shadowDom = a;
              this.shadowState = b;
              this.getSourceBlock().isDeadOrDying() || ((a = this.targetBlock()) ? a.isShadow() ? (a.dispose(false), this.respawnShadow_(), this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock())) : (a = this.createShadowBlock(false), this.serializeShadow(a), a && a.dispose(false)) : (this.respawnShadow_(), this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock())));
            }
            createShadowBlock(a) {
              var b = this.getSourceBlock();
              const c = this.getShadowState(), d = this.getShadowDom();
              if (b.isDeadOrDying() || !c && !d) return null;
              if (c) return b = appendInternal$$module$build$src$core$serialization$blocks(c, b.workspace, { parentConnection: a ? this : void 0, isShadow: true, recordUndo: false });
              if (d) {
                b = domToBlockInternal$$module$build$src$core$xml(d, b.workspace);
                if (a) if (this.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE) {
                  if (!b.outputConnection) throw Error("Shadow block is missing an output connection");
                  if (!this.connect(b.outputConnection)) throw Error("Could not connect shadow block to connection");
                } else if (this.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT) {
                  if (!b.previousConnection) throw Error("Shadow block is missing previous connection");
                  if (!this.connect(b.previousConnection)) throw Error("Could not connect shadow block to connection");
                } else throw Error("Cannot connect a shadow block to a previous/output connection");
                return b;
              }
              return null;
            }
            serializeShadow(a) {
              a && (this.shadowDom = blockToDom$$module$build$src$core$xml(a), this.shadowState = save$$module$build$src$core$serialization$blocks(a));
            }
            static getConnectionForOrphanedConnection(a, b) {
              if (b.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE) return getConnectionForOrphanedOutput$$module$build$src$core$connection(a, b.getSourceBlock());
              a = a.lastConnectionInStack(true);
              const c = b.getConnectionChecker();
              return a && c.canConnect(b, a, false) ? a : null;
            }
          };
          Connection$$module$build$src$core$connection.CAN_CONNECT = 0;
          Connection$$module$build$src$core$connection.REASON_SELF_CONNECTION = 1;
          Connection$$module$build$src$core$connection.REASON_WRONG_TYPE = 2;
          Connection$$module$build$src$core$connection.REASON_TARGET_NULL = 3;
          Connection$$module$build$src$core$connection.REASON_CHECKS_FAILED = 4;
          Connection$$module$build$src$core$connection.REASON_DIFFERENT_WORKSPACES = 5;
          Connection$$module$build$src$core$connection.REASON_SHADOW_PARENT = 6;
          Connection$$module$build$src$core$connection.REASON_DRAG_CHECKS_FAILED = 7;
          Connection$$module$build$src$core$connection.REASON_PREVIOUS_AND_OUTPUT = 8;
          var module$build$src$core$connection = {};
          module$build$src$core$connection.Connection = Connection$$module$build$src$core$connection;
          var DuplicateIconType$$module$build$src$core$icons$exceptions = class extends Error {
            constructor(a) {
              super(`Tried to append an icon of type ${a.getType()} when an icon of that type already exists on the block. Use getIcon to access the existing icon.`);
              this.icon = a;
            }
          }, module$build$src$core$icons$exceptions = {};
          module$build$src$core$icons$exceptions.DuplicateIconType = DuplicateIconType$$module$build$src$core$icons$exceptions;
          (function(a) {
            a[a.LEFT = -1] = "LEFT";
            a[a.CENTRE = 0] = "CENTRE";
            a[a.RIGHT = 1] = "RIGHT";
          })($.Align$$module$build$src$core$inputs$align || ($.Align$$module$build$src$core$inputs$align = {}));
          var module$build$src$core$inputs$align = {};
          module$build$src$core$inputs$align.Align = $.Align$$module$build$src$core$inputs$align;
          var FieldLabel$$module$build$src$core$field_label = class extends Field$$module$build$src$core$field {
            constructor(a, b, c) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.class = null;
              this.EDITABLE = false;
              this.maxDisplayLength = Infinity;
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (c ? this.configure_(c) : this.class = b || null, this.setValue(a));
            }
            configure_(a) {
              super.configure_(a);
              a.class && (this.class = a.class);
            }
            initView() {
              this.createTextElement_();
              this.class && addClass$$module$build$src$core$utils$dom(
                this.getTextElement(),
                this.class
              );
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyLabelField");
            }
            doClassValidation_(a) {
              return a === null || a === void 0 ? null : `${a}`;
            }
            setClass(a) {
              this.textElement_ && (this.class && removeClass$$module$build$src$core$utils$dom(this.textElement_, this.class), a && addClass$$module$build$src$core$utils$dom(this.textElement_, a));
              this.class = a;
            }
            static fromJson(a) {
              return new this(replaceMessageReferences$$module$build$src$core$utils$parsing(a.text), void 0, a);
            }
          };
          register$$module$build$src$core$field_registry("field_label", FieldLabel$$module$build$src$core$field_label);
          FieldLabel$$module$build$src$core$field_label.prototype.DEFAULT_VALUE = "";
          var module$build$src$core$field_label = {};
          module$build$src$core$field_label.FieldLabel = FieldLabel$$module$build$src$core$field_label;
          var COLLAPSE_CHARS$$module$build$src$core$internal_constants = 30, OPPOSITE_TYPE$$module$build$src$core$internal_constants = [];
          OPPOSITE_TYPE$$module$build$src$core$internal_constants[ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE] = ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE;
          OPPOSITE_TYPE$$module$build$src$core$internal_constants[ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE] = ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE;
          OPPOSITE_TYPE$$module$build$src$core$internal_constants[ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT] = ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT;
          OPPOSITE_TYPE$$module$build$src$core$internal_constants[ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT] = ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT;
          var RENAME_VARIABLE_ID$$module$build$src$core$internal_constants = "RENAME_VARIABLE_ID", DELETE_VARIABLE_ID$$module$build$src$core$internal_constants = "DELETE_VARIABLE_ID", module$build$src$core$internal_constants = { COLLAPSE_CHARS: COLLAPSE_CHARS$$module$build$src$core$internal_constants, DELETE_VARIABLE_ID: DELETE_VARIABLE_ID$$module$build$src$core$internal_constants, OPPOSITE_TYPE: OPPOSITE_TYPE$$module$build$src$core$internal_constants, RENAME_VARIABLE_ID: RENAME_VARIABLE_ID$$module$build$src$core$internal_constants };
          var BUMP_RANDOMNESS$$module$build$src$core$rendered_connection = 10, RenderedConnection$$module$build$src$core$rendered_connection = class extends Connection$$module$build$src$core$connection {
            constructor(a, b) {
              super(a, b);
              this.highlighted = false;
              this.targetConnection = null;
              this.db = a.workspace.connectionDBList[b];
              this.dbOpposite = a.workspace.connectionDBList[OPPOSITE_TYPE$$module$build$src$core$internal_constants[b]];
              this.offsetInBlock = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.trackedState = RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.WILL_TRACK;
            }
            dispose() {
              super.dispose();
              this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED && this.db.removeConnection(this, this.y);
              let a, b;
              (b = (a = this.sourceBlock_.pathObject).removeConnectionHighlight) == null || b.call(a, this);
            }
            getSourceBlock() {
              return super.getSourceBlock();
            }
            targetBlock() {
              return super.targetBlock();
            }
            distanceFrom(a) {
              const b = this.x - a.x;
              a = this.y - a.y;
              return Math.sqrt(b * b + a * a);
            }
            bumpAwayFrom(a, b = false) {
              if (!this.sourceBlock_.workspace.isDragging()) {
                var c = $.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * BUMP_RANDOMNESS$$module$build$src$core$rendered_connection), d = $.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * BUMP_RANDOMNESS$$module$build$src$core$rendered_connection), e = a.sourceBlock_.getRootBlock(), f = this.sourceBlock_.getRootBlock();
                if (!e.isInFlyout && !f.isInFlyout) {
                  var g = true;
                  if (f.isMovable()) e.isMovable() && b && (d = -d);
                  else if (e.isMovable()) g = false, c = -c, d = -d;
                  else return;
                  b = g ? a : this;
                  a = g ? this : a;
                  e = g ? f : e;
                  e.RTL && (c = -c);
                  e.moveBy(b.x + c - a.x, b.y + d - a.y, ["bump"]);
                }
              }
            }
            moveTo(a, b) {
              let c = false;
              this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.WILL_TRACK ? (this.db.addConnection(this, b), this.trackedState = RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED, c = true) : this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED && (this.db.removeConnection(this, this.y), this.db.addConnection(this, b), c = true);
              this.x = a;
              this.y = b;
              return c;
            }
            moveBy(a, b) {
              return this.moveTo(this.x + a, this.y + b);
            }
            moveToOffset(a) {
              return this.moveTo(a.x + this.offsetInBlock.x, a.y + this.offsetInBlock.y);
            }
            setOffsetInBlock(a, b) {
              this.offsetInBlock.x = a;
              this.offsetInBlock.y = b;
            }
            getOffsetInBlock() {
              return this.offsetInBlock;
            }
            tightenEfficiently() {
              var a = this.targetConnection;
              const b = this.targetBlock();
              a && b && (a = Coordinate$$module$build$src$core$utils$coordinate.difference(
                this.offsetInBlock,
                a.offsetInBlock
              ), b.translate(a.x, a.y));
            }
            closest(a, b) {
              return this.dbOpposite.searchForClosest(this, a, b);
            }
            highlight() {
              this.highlighted = true;
              const a = this.findHighlightSvg();
              a && (a.style.display = "");
            }
            unhighlight() {
              this.highlighted = false;
              const a = this.findHighlightSvg();
              a && (a.style.display = "none");
            }
            isHighlighted() {
              return this.highlighted;
            }
            setTracking(a) {
              a && this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED || !a && this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.UNTRACKED || this.sourceBlock_.isInFlyout || (a ? (this.db.addConnection(this, this.y), this.trackedState = RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED) : (this.trackedState === RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.TRACKED && this.db.removeConnection(this, this.y), this.trackedState = RenderedConnection$$module$build$src$core$rendered_connection.TrackedState.UNTRACKED));
            }
            stopTrackingAll() {
              this.setTracking(false);
              if (this.targetConnection) {
                const a = this.targetBlock().getDescendants(false);
                for (let b = 0; b < a.length; b++) {
                  const c = a[b], d = c.getConnections_(true);
                  for (let e = 0; e < d.length; e++) d[e].setTracking(false);
                  for (const e of c.getIcons()) hasBubble$$module$build$src$core$interfaces$i_has_bubble(e) && e.setBubbleVisible(false);
                }
              }
            }
            startTrackingAll() {
              this.setTracking(true);
              let a = [];
              if (this.type !== ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE && this.type !== ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT) return a;
              const b = this.targetBlock();
              if (b) {
                let c;
                b.isCollapsed() ? (c = [], b.outputConnection && c.push(b.outputConnection), b.nextConnection && c.push(b.nextConnection), b.previousConnection && c.push(b.previousConnection)) : c = b.getConnections_(true);
                for (let d = 0; d < c.length; d++) a.push(...c[d].startTrackingAll());
                a.length || (a = [b]);
              }
              return a;
            }
            onFailedConnect(a) {
              const b = this.getSourceBlock();
              if (getRecordUndo$$module$build$src$core$events$utils()) {
                const c = $.getGroup$$module$build$src$core$events$utils();
                setTimeout(function() {
                  b.isDisposed() || b.getParent() || ($.setGroup$$module$build$src$core$events$utils(c), this.bumpAwayFrom(a), $.setGroup$$module$build$src$core$events$utils(false));
                }.bind(this), $.config$$module$build$src$core$config.bumpDelay);
              }
            }
            disconnectInternal(a = true) {
              const { parentConnection: b, childConnection: c } = this.getParentAndChildConnections();
              if (b && c) {
                var d = $.getGroup$$module$build$src$core$events$utils();
                d || $.setGroup$$module$build$src$core$events$utils(true);
                var e = b.getSourceBlock(), f = c.getSourceBlock();
                super.disconnectInternal(a);
                e.queueRender();
                f.updateDisabled();
                f.queueRender();
                f.getSvgRoot().style.display = "block";
                $.setGroup$$module$build$src$core$events$utils(d);
              }
            }
            respawnShadow_() {
              super.respawnShadow_();
              const a = this.targetBlock();
              a && (a.initSvg(), a.queueRender());
            }
            neighbours(a) {
              return this.dbOpposite.getNeighbours(this, a);
            }
            connect_(a) {
              super.connect_(a);
              var b = this.getSourceBlock();
              a = a.getSourceBlock();
              b.updateDisabled();
              a.updateDisabled();
              a.queueRender();
              if (b = b.getInputWithBlock(a)) b = b.isVisible(), a.getSvgRoot().style.display = b ? "block" : "none";
            }
            onCheckChanged_() {
              !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, false) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug();
            }
            setCheck(a) {
              super.setCheck(a);
              this.sourceBlock_.queueRender();
              return this;
            }
            showContextMenu(a) {
              const b = ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.getContextMenuOptions({ focusedNode: this }, a);
              if (b.length) {
                var c = this.getSourceBlock(), d = c.workspace;
                if (a instanceof PointerEvent) var e = new Coordinate$$module$build$src$core$utils$coordinate(
                  a.clientX,
                  a.clientY
                );
                else e = new Coordinate$$module$build$src$core$utils$coordinate(this.x, this.y), e = wsToScreenCoordinates$$module$build$src$core$utils$svg_math(d, e).translate(c.RTL ? -5 : 5, 5);
                show$$module$build$src$core$contextmenu(a, b, c.RTL, d, e);
              }
            }
            getFocusableElement() {
              const a = this.findHighlightSvg();
              if (a) return a;
              throw Error("No highlight SVG found corresponding to this connection.");
            }
            getFocusableTree() {
              return this.getSourceBlock().workspace;
            }
            onNodeFocus() {
              this.highlight();
              this.getSourceBlock().workspace.scrollBoundsIntoView(this.getSourceBlock().getBoundingRectangleWithoutChildren());
            }
            onNodeBlur() {
              this.unhighlight();
            }
            canBeFocused() {
              return true;
            }
            findHighlightSvg() {
              return document.getElementById(this.id);
            }
          };
          (function(a) {
            a = a.TrackedState || (a.TrackedState = {});
            a[a.WILL_TRACK = -1] = "WILL_TRACK";
            a[a.UNTRACKED = 0] = "UNTRACKED";
            a[a.TRACKED = 1] = "TRACKED";
          })(RenderedConnection$$module$build$src$core$rendered_connection || (RenderedConnection$$module$build$src$core$rendered_connection = {}));
          var TrackedState$$module$build$src$core$rendered_connection = RenderedConnection$$module$build$src$core$rendered_connection.TrackedState, module$build$src$core$rendered_connection = {};
          module$build$src$core$rendered_connection.RenderedConnection = RenderedConnection$$module$build$src$core$rendered_connection;
          module$build$src$core$rendered_connection.TrackedState = TrackedState$$module$build$src$core$rendered_connection;
          var Input$$module$build$src$core$inputs$input = class {
            constructor(a, b) {
              this.name = a;
              this.sourceBlock = b;
              this.fieldRow = [];
              this.align = $.Align$$module$build$src$core$inputs$align.LEFT;
              this.visible = true;
              this.type = $.inputTypes$$module$build$src$core$inputs$input_types.CUSTOM;
              this.connection = null;
            }
            getSourceBlock() {
              return this.sourceBlock;
            }
            appendField(a, b) {
              this.insertFieldAt(this.fieldRow.length, a, b);
              return this;
            }
            insertFieldAt(a, b, c) {
              if (a < 0 || a > this.fieldRow.length) throw Error("index " + a + " out of bounds.");
              if (!(b || b === "" && c)) return a;
              typeof b === "string" && (b = $.fromJson$$module$build$src$core$field_registry({ type: "field_label", text: b }));
              b.setSourceBlock(this.sourceBlock);
              this.sourceBlock.initialized && this.initField(b);
              b.name = c;
              b.setVisible(this.isVisible());
              b.prefixField && (a = this.insertFieldAt(a, b.prefixField));
              this.fieldRow.splice(a, 0, b);
              a++;
              b.suffixField && (a = this.insertFieldAt(a, b.suffixField));
              this.sourceBlock.rendered && this.sourceBlock.queueRender();
              return a;
            }
            removeField(a, b) {
              for (let c = 0, d; d = this.fieldRow[c]; c++) if (d.name === a) return d.dispose(), this.fieldRow.splice(c, 1), this.sourceBlock.rendered && this.sourceBlock.queueRender(), true;
              if (b) return false;
              throw Error('Field "' + a + '" not found.');
            }
            isVisible() {
              return this.visible;
            }
            setVisible(a) {
              let b = [];
              if (this.visible === a) return b;
              this.visible = a;
              for (let c = 0, d; d = this.fieldRow[c]; c++) d.setVisible(a);
              if (this.connection && this.connection instanceof RenderedConnection$$module$build$src$core$rendered_connection) {
                a ? b = this.connection.startTrackingAll() : this.connection.stopTrackingAll();
                const c = this.connection.targetBlock();
                c && (c.getSvgRoot().style.display = a ? "block" : "none");
              }
              return b;
            }
            markDirty() {
              for (let a = 0, b; b = this.fieldRow[a]; a++) b.markDirty();
            }
            setCheck(a) {
              if (!this.connection) throw Error("This input does not have a connection.");
              this.connection.setCheck(a);
              return this;
            }
            setAlign(a) {
              this.align = a;
              this.sourceBlock.rendered && this.sourceBlock.queueRender();
              return this;
            }
            setShadowDom(a) {
              if (!this.connection) throw Error("This input does not have a connection.");
              this.connection.setShadowDom(a);
              return this;
            }
            getShadowDom() {
              if (!this.connection) throw Error("This input does not have a connection.");
              return this.connection.getShadowDom();
            }
            init() {
              for (const a of this.fieldRow) a.init();
            }
            initModel() {
              for (const a of this.fieldRow) a.initModel();
            }
            initField(a) {
              this.sourceBlock.rendered ? a.init() : a.initModel();
            }
            dispose() {
              for (let a = 0, b; b = this.fieldRow[a]; a++) b.dispose();
              this.connection && this.connection.dispose();
            }
            makeConnection(a) {
              return this.sourceBlock.makeConnection_(a);
            }
          }, module$build$src$core$inputs$input = {};
          module$build$src$core$inputs$input.Input = Input$$module$build$src$core$inputs$input;
          var DummyInput$$module$build$src$core$inputs$dummy_input = class extends Input$$module$build$src$core$inputs$input {
            constructor(a, b) {
              super(a, b);
              this.name = a;
              this.type = $.inputTypes$$module$build$src$core$inputs$input_types.DUMMY;
            }
          }, module$build$src$core$inputs$dummy_input = {};
          module$build$src$core$inputs$dummy_input.DummyInput = DummyInput$$module$build$src$core$inputs$dummy_input;
          var EndRowInput$$module$build$src$core$inputs$end_row_input = class extends Input$$module$build$src$core$inputs$input {
            constructor(a, b) {
              super(a, b);
              this.name = a;
              this.type = $.inputTypes$$module$build$src$core$inputs$input_types.END_ROW;
            }
          }, module$build$src$core$inputs$end_row_input = {};
          module$build$src$core$inputs$end_row_input.EndRowInput = EndRowInput$$module$build$src$core$inputs$end_row_input;
          var StatementInput$$module$build$src$core$inputs$statement_input = class extends Input$$module$build$src$core$inputs$input {
            constructor(a, b) {
              if (!a) throw Error("Statement inputs must have a non-empty name");
              super(a, b);
              this.name = a;
              this.type = $.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT;
              this.connection = this.makeConnection(ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT);
            }
          }, module$build$src$core$inputs$statement_input = {};
          module$build$src$core$inputs$statement_input.StatementInput = StatementInput$$module$build$src$core$inputs$statement_input;
          var module$build$src$core$inputs$value_input;
          $.ValueInput$$module$build$src$core$inputs$value_input = class extends Input$$module$build$src$core$inputs$input {
            constructor(a, b) {
              if (!a) throw Error("Value inputs must have a non-empty name");
              super(a, b);
              this.name = a;
              this.type = $.inputTypes$$module$build$src$core$inputs$input_types.VALUE;
              this.connection = this.makeConnection(ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE);
            }
          };
          module$build$src$core$inputs$value_input = {};
          module$build$src$core$inputs$value_input.ValueInput = $.ValueInput$$module$build$src$core$inputs$value_input;
          var module$build$src$core$interfaces$i_icon = {};
          module$build$src$core$interfaces$i_icon.isIcon = isIcon$$module$build$src$core$interfaces$i_icon;
          var module$build$src$core$interfaces$i_comment_icon = {};
          module$build$src$core$interfaces$i_comment_icon.isCommentIcon = isCommentIcon$$module$build$src$core$interfaces$i_comment_icon;
          var Block$$module$build$src$core$block = class {
            constructor(a, b, c) {
              this.data = null;
              this.disposed = false;
              this.hue = null;
              this.colour_ = "#000000";
              this.styleName_ = "";
              this.suppressPrefixSuffix = false;
              this.previousConnection = this.nextConnection = this.outputConnection = null;
              this.inputList = [];
              this.icons = [];
              this.disabledReasons = /* @__PURE__ */ new Set();
              this.tooltip = "";
              this.contextMenu = true;
              this.parentBlock_ = null;
              this.childBlocks_ = [];
              this.editable = this.movable = this.deletable = true;
              this.collapsed_ = this.shadow = false;
              this.outputShape_ = null;
              this.rendered = this.isInsertionMarker_ = this.initialized = this.disposing = false;
              this.onchangeWrapper = this.helpUrl = null;
              this.statementInputCount = 0;
              this.workspace = a;
              this.id = c && !a.getBlockById(c) ? c : genUid$$module$build$src$core$utils$idgenerator();
              a.setBlockById(this.id, this);
              this.xy = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.isInFlyout = a.isFlyout;
              this.isInMutator = a.isMutator;
              this.RTL = a.RTL;
              if (b) {
                this.type = b;
                c = Blocks$$module$build$src$core$blocks[b];
                if (!c || typeof c !== "object") throw TypeError("Invalid block definition for type: " + b);
                Object.assign(this, c);
              }
              a.addTopBlock(this);
              a.addTypedBlock(this);
              new.target === Block$$module$build$src$core$block && this.doInit_();
            }
            doInit_() {
              const a = $.getGroup$$module$build$src$core$events$utils();
              a || $.setGroup$$module$build$src$core$events$utils(true);
              const b = getRecordUndo$$module$build$src$core$events$utils();
              try {
                typeof this.init === "function" && ($.setRecordUndo$$module$build$src$core$events$utils(false), this.init(), $.setRecordUndo$$module$build$src$core$events$utils(b)), isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(this));
              } finally {
                $.setGroup$$module$build$src$core$events$utils(a), $.setRecordUndo$$module$build$src$core$events$utils(b);
              }
              this.inputsInlineDefault = this.inputsInline;
              typeof this.onchange === "function" && this.setOnChange(this.onchange);
            }
            dispose(a = false) {
              this.disposing = true;
              this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper);
              this.unplug(a);
              isEnabled$$module$build$src$core$events$utils() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_DELETE))(this));
              this.workspace.removeTopBlock(this);
              this.disposeInternal();
            }
            disposeInternal() {
              this.disposing = true;
              this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper);
              this.workspace.removeTypedBlock(this);
              this.workspace.removeBlockById(this.id);
              typeof this.destroy === "function" && this.destroy();
              this.childBlocks_.forEach((a) => a.disposeInternal());
              this.inputList.forEach((a) => a.dispose());
              this.inputList.length = 0;
              this.getConnections_(true).forEach((a) => a.dispose());
              this.disposed = true;
            }
            isDeadOrDying() {
              return this.disposing || this.disposed;
            }
            initModel() {
              if (!this.initialized) {
                for (const a of this.inputList) a.initModel();
                this.initialized = true;
              }
            }
            unplug(a) {
              this.outputConnection && this.unplugFromRow(a);
              this.previousConnection && this.unplugFromStack(a);
            }
            unplugFromRow(a) {
              let b = null, c;
              if ((c = this.outputConnection) == null ? 0 : c.isConnected()) b = this.outputConnection.targetConnection, this.outputConnection.disconnect();
              b && a && (a = this.getOnlyValueConnection()) && a.isConnected() && !a.targetBlock().isShadow() && (a = a.targetConnection, a == null || a.disconnect(), this.workspace.connectionChecker.canConnect(a, b, false) ? b.connect(a) : a == null || a.onFailedConnect(b));
            }
            getOnlyValueConnection() {
              let a = null;
              for (let b = 0; b < this.inputList.length; b++) {
                const c = this.inputList[b].connection;
                if (c && c.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE && c.targetConnection) {
                  if (a) return null;
                  a = c;
                }
              }
              return a;
            }
            unplugFromStack(a) {
              let b = null, c;
              if ((c = this.previousConnection) == null ? 0 : c.isConnected()) b = this.previousConnection.targetConnection, this.previousConnection.disconnect();
              if (a) {
                for (a = this.getNextBlock(); a && (a.isShadow() || !a.isMovable()); ) a = a.getNextBlock();
                if (a) {
                  var d, e, f, g;
                  a = (g = (d = a.previousConnection) == null ? void 0 : (e = d.targetBlock()) == null ? void 0 : (f = e.nextConnection) == null ? void 0 : f.targetConnection) != null ? g : null;
                  a == null || a.disconnect();
                  b && this.workspace.connectionChecker.canConnect(
                    b,
                    a,
                    false
                  ) && b.connect(a);
                }
              }
            }
            getConnections_(a) {
              a = [];
              this.outputConnection && a.push(this.outputConnection);
              this.previousConnection && a.push(this.previousConnection);
              this.nextConnection && a.push(this.nextConnection);
              for (let b = 0, c; c = this.inputList[b]; b++) c.connection && a.push(c.connection);
              return a;
            }
            lastConnectionInStack(a) {
              let b = this.nextConnection;
              for (; b; ) {
                const c = b.targetBlock();
                if (!c || a && c.isShadow()) return b;
                b = c.nextConnection;
              }
              return null;
            }
            bumpNeighbours() {
            }
            getParent() {
              return this.parentBlock_;
            }
            getInputWithBlock(a) {
              for (let b = 0, c; c = this.inputList[b]; b++) if (c.connection && c.connection.targetBlock() === a) return c;
              return null;
            }
            getSurroundParent() {
              let a = this, b;
              do
                if (b = a, a = a.getParent(), !a) return null;
              while (a.getNextBlock() === b);
              return a;
            }
            getNextBlock() {
              return this.nextConnection && this.nextConnection.targetBlock();
            }
            getPreviousBlock() {
              return this.previousConnection && this.previousConnection.targetBlock();
            }
            getRootBlock() {
              let a, b = this;
              do
                a = b, b = a.parentBlock_;
              while (b);
              return a;
            }
            getTopStackBlock() {
              let a = this, b;
              do
                b = a.getPreviousBlock();
              while (b && b.getNextBlock() === a && (a = b));
              return a;
            }
            getChildren(a) {
              if (!a) return this.childBlocks_;
              a = [];
              for (let c = 0, d; d = this.inputList[c]; c++) if (d.connection) {
                var b = d.connection.targetBlock();
                b && a.push(b);
              }
              (b = this.getNextBlock()) && a.push(b);
              return a;
            }
            setParent(a) {
              if (a !== this.parentBlock_) {
                var b = this.previousConnection && this.previousConnection.targetBlock() || this.outputConnection && this.outputConnection.targetBlock(), c = !!b;
                if (c && a && b !== a) throw Error("Block connected to superior one that is not new parent.");
                if (!c && a) throw Error("Block not connected to new parent.");
                if (c && !a) throw Error("Cannot set parent to null while block is still connected to superior block.");
                this.parentBlock_ ? removeElem$$module$build$src$core$utils$array(this.parentBlock_.childBlocks_, this) : this.workspace.removeTopBlock(this);
                (this.parentBlock_ = a) ? a.childBlocks_.push(this) : this.workspace.addTopBlock(this);
              }
            }
            getDescendants(a) {
              const b = [this], c = this.getChildren(a);
              for (let d, e = 0; d = c[e]; e++) b.push(...d.getDescendants(a));
              return b;
            }
            isDeletable() {
              return this.deletable && !this.isInFlyout && !this.shadow && !this.isDeadOrDying() && !this.workspace.isReadOnly();
            }
            isOwnDeletable() {
              return this.deletable;
            }
            setDeletable(a) {
              this.deletable = a;
            }
            isMovable() {
              return this.movable && !this.isInFlyout && !this.shadow && !this.isDeadOrDying() && !this.workspace.isReadOnly();
            }
            isOwnMovable() {
              return this.movable;
            }
            setMovable(a) {
              this.movable = a;
            }
            isDuplicatable() {
              return this.workspace.hasBlockLimits() ? this.workspace.isCapacityAvailable(getBlockTypeCounts$$module$build$src$core$common(this, true)) : true;
            }
            isShadow() {
              return this.shadow;
            }
            setShadow(a) {
              this.shadow = a;
            }
            isInsertionMarker() {
              return this.isInsertionMarker_;
            }
            setInsertionMarker(a) {
              this.isInsertionMarker_ = a;
            }
            isEditable() {
              return this.editable && !this.isDeadOrDying() && !this.workspace.isReadOnly();
            }
            isOwnEditable() {
              return this.editable;
            }
            setEditable(a) {
              this.editable = a;
              for (const b of this.getFields()) b.updateEditable();
            }
            isDisposed() {
              return this.disposed;
            }
            isSimpleReporter() {
              if (!this.outputConnection) return false;
              for (const a of this.inputList) if (a.connection || a.fieldRow.length > 1) return false;
              return true;
            }
            getMatchingConnection(a, b) {
              const c = this.getConnections_(true);
              a = a.getConnections_(true);
              if (c.length !== a.length) throw Error("Connection lists did not match in length.");
              for (let d = 0; d < a.length; d++) if (a[d] === b) return c[d];
              return null;
            }
            setHelpUrl(a) {
              this.helpUrl = a;
            }
            setTooltip(a) {
              this.tooltip = a;
            }
            getTooltip() {
              return getTooltipOfObject$$module$build$src$core$tooltip(this);
            }
            getColour() {
              return this.colour_;
            }
            getStyleName() {
              return this.styleName_;
            }
            getHue() {
              return this.hue;
            }
            setColour(a) {
              a = parseBlockColour$$module$build$src$core$utils$parsing(a);
              this.hue = a.hue;
              this.colour_ = a.hex;
            }
            setStyle(a) {
              this.styleName_ = a;
            }
            setOnChange(a) {
              if (a && typeof a !== "function") throw Error("onchange must be a function.");
              this.onchangeWrapper && this.workspace.removeChangeListener(this.onchangeWrapper);
              this.onchange = a;
              this.onchangeWrapper = a.bind(this);
              this.workspace.addChangeListener(this.onchangeWrapper);
            }
            getField(a) {
              if (typeof a !== "string") throw TypeError("Block.prototype.getField expects a string with the field name but received " + (a === void 0 ? "nothing" : a + " of type " + typeof a) + " instead");
              for (const b of this.getFields()) if (b.name === a) return b;
              return null;
            }
            *getFields() {
              for (const a of this.inputList) for (const b of a.fieldRow) yield b;
            }
            getVars() {
              const a = [];
              for (const b of this.getFields()) b.referencesVariables() && a.push(b.getValue());
              return a;
            }
            getVarModels() {
              const a = [];
              for (const b of this.getFields()) if (b.referencesVariables()) {
                const c = this.workspace.getVariableById(b.getValue());
                c && a.push(c);
              }
              return a;
            }
            updateVarName(a) {
              for (const b of this.getFields()) b.referencesVariables() && a.getId() === b.getValue() && b.refreshVariableName();
            }
            renameVarById(a, b) {
              for (const c of this.getFields()) c.referencesVariables() && a === c.getValue() && c.setValue(b);
            }
            getFieldValue(a) {
              return (a = this.getField(a)) ? a.getValue() : null;
            }
            setFieldValue(a, b) {
              const c = this.getField(b);
              if (!c) throw Error('Field "' + b + '" not found.');
              c.setValue(a);
            }
            setPreviousStatement(a, b) {
              if (a) b === void 0 && (b = null), this.previousConnection || (this.previousConnection = this.makeConnection_(ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT)), this.previousConnection.setCheck(b);
              else if (this.previousConnection) {
                if (this.previousConnection.isConnected()) throw Error("Must disconnect previous statement before removing connection.");
                this.previousConnection.dispose();
                this.previousConnection = null;
              }
            }
            setNextStatement(a, b) {
              if (a) b === void 0 && (b = null), this.nextConnection || (this.nextConnection = this.makeConnection_(ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT)), this.nextConnection.setCheck(b);
              else if (this.nextConnection) {
                if (this.nextConnection.isConnected()) throw Error("Must disconnect next statement before removing connection.");
                this.nextConnection.dispose();
                this.nextConnection = null;
              }
            }
            setOutput(a, b) {
              if (a) b === void 0 && (b = null), this.outputConnection || (this.outputConnection = this.makeConnection_(ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE)), this.outputConnection.setCheck(b);
              else if (this.outputConnection) {
                if (this.outputConnection.isConnected()) throw Error("Must disconnect output value before removing connection.");
                this.outputConnection.dispose();
                this.outputConnection = null;
              }
            }
            setInputsInline(a) {
              this.inputsInline !== a && (fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this, "inline", null, this.inputsInline, a)), this.inputsInline = a);
            }
            getInputsInline() {
              if (this.inputsInline !== void 0) return this.inputsInline;
              for (var a = 1; a < this.inputList.length; a++) if (this.inputList[a - 1] instanceof DummyInput$$module$build$src$core$inputs$dummy_input && this.inputList[a] instanceof DummyInput$$module$build$src$core$inputs$dummy_input) return false;
              for (a = 1; a < this.inputList.length; a++) if (this.inputList[a - 1] instanceof $.ValueInput$$module$build$src$core$inputs$value_input && this.inputList[a] instanceof DummyInput$$module$build$src$core$inputs$dummy_input) return true;
              for (a = 0; a < this.inputList.length; a++) if (this.inputList[a] instanceof EndRowInput$$module$build$src$core$inputs$end_row_input) return true;
              return false;
            }
            setOutputShape(a) {
              this.outputShape_ = a;
            }
            getOutputShape() {
              return this.outputShape_;
            }
            isEnabled() {
              return this.disabledReasons.size === 0;
            }
            setDisabledReason(a, b) {
              a || this.workspace.options.disable || !this.hasDisabledReason(MANUALLY_DISABLED$$module$build$src$core$constants) || b == MANUALLY_DISABLED$$module$build$src$core$constants || this.setDisabledReason(false, MANUALLY_DISABLED$$module$build$src$core$constants);
              this.disabledReasons.has(b) !== a && (a ? this.disabledReasons.add(b) : this.disabledReasons.delete(b), a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this, "disabled", null, !a, a), a.setDisabledReason(b), fire$$module$build$src$core$events$utils(a));
            }
            getInheritedDisabled() {
              let a = this.getSurroundParent();
              for (; a; ) {
                if (!a.isEnabled()) return true;
                a = a.getSurroundParent();
              }
              return false;
            }
            hasDisabledReason(a) {
              return this.disabledReasons.has(a);
            }
            getDisabledReasons() {
              return this.disabledReasons;
            }
            isCollapsed() {
              return this.collapsed_;
            }
            setCollapsed(a) {
              this.collapsed_ !== a && (fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this, "collapsed", null, this.collapsed_, a)), this.collapsed_ = a);
            }
            toString(a, b) {
              b = this.toTokens(b);
              for (let d = 2; d < b.length; d++) b[d - 2] === "(" && b[d] === ")" && (b[d - 2] = b[d - 1], b.splice(d - 1, 2));
              let c = "";
              b = b.reduce((d, e) => {
                d = d + (c === "(" || e === ")" ? "" : " ") + e;
                c = e[e.length - 1];
                return d;
              }, "");
              b = b.trim() || "???";
              a && b.length > a && (b = b.substring(0, a - 3) + "...");
              return b;
            }
            toTokens(a = "?") {
              const b = [];
              for (const d of this.inputList) if (d.name != COLLAPSED_INPUT_NAME$$module$build$src$core$constants) {
                for (const e of d.fieldRow) b.push(e.getText());
                if (d.connection) {
                  const e = d.connection.targetBlock();
                  if (e) {
                    var c = d.connection;
                    let f = c.getCheck();
                    !f && c.targetConnection && (f = c.targetConnection.getCheck());
                    (c = !!f && (f.includes("Boolean") || f.includes("Number"))) && b.push("(");
                    b.push(...e.toTokens(a));
                    c && b.push(")");
                  } else b.push(a);
                }
              }
              return b;
            }
            appendValueInput(a) {
              return this.appendInput(new $.ValueInput$$module$build$src$core$inputs$value_input(a, this));
            }
            appendStatementInput(a) {
              this.statementInputCount++;
              return this.appendInput(new StatementInput$$module$build$src$core$inputs$statement_input(a, this));
            }
            appendDummyInput(a = "") {
              return this.appendInput(new DummyInput$$module$build$src$core$inputs$dummy_input(
                a,
                this
              ));
            }
            appendEndRowInput(a = "") {
              return this.appendInput(new EndRowInput$$module$build$src$core$inputs$end_row_input(a, this));
            }
            appendInput(a) {
              this.inputList.push(a);
              return a;
            }
            appendInputFromRegistry(a, b) {
              return (a = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.INPUT, a, false)) ? this.appendInput(new a(b, this)) : null;
            }
            jsonInit(a) {
              var b = a.type ? 'Block "' + a.type + '": ' : "";
              if (a.output && a.previousStatement) throw Error(b + "Must not have both an output and a previousStatement.");
              for (var c = 0; a["args" + c]; ) {
                if (a["message" + c] === void 0) throw Error(b + `args${c} must have a corresponding message (message${c}).`);
                c++;
              }
              a.style && a.style.hat && (this.hat = a.style.hat, a.style = null);
              if (a.style && a.colour) throw Error(b + "Must not have both a colour and a style.");
              a.style ? this.jsonInitStyle(a, b) : this.jsonInitColour(a, b);
              for (c = 0; a["message" + c] !== void 0; ) this.interpolate(a["message" + c], a["args" + c] || [], a["implicitAlign" + c] || a["lastDummyAlign" + c], b), c++;
              a.inputsInline !== void 0 && ($.disable$$module$build$src$core$events$utils(), this.setInputsInline(a.inputsInline), $.enable$$module$build$src$core$events$utils());
              a.output !== void 0 && this.setOutput(true, a.output);
              a.outputShape !== void 0 && this.setOutputShape(a.outputShape);
              a.previousStatement !== void 0 && this.setPreviousStatement(true, a.previousStatement);
              a.nextStatement !== void 0 && this.setNextStatement(true, a.nextStatement);
              a.tooltip !== void 0 && (c = replaceMessageReferences$$module$build$src$core$utils$parsing(a.tooltip), this.setTooltip(c));
              a.enableContextMenu !== void 0 && (this.contextMenu = !!a.enableContextMenu);
              a.suppressPrefixSuffix !== void 0 && (this.suppressPrefixSuffix = !!a.suppressPrefixSuffix);
              a.helpUrl !== void 0 && (c = replaceMessageReferences$$module$build$src$core$utils$parsing(a.helpUrl), this.setHelpUrl(c));
              typeof a.extensions === "string" && (console.warn(b + "JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '" + a.type + "' block."), a.extensions = [a.extensions]);
              a.mutator !== void 0 && apply$$module$build$src$core$extensions(a.mutator, this, true);
              a = a.extensions;
              if (Array.isArray(a)) for (b = 0; b < a.length; b++) apply$$module$build$src$core$extensions(a[b], this, false);
            }
            jsonInitColour(a, b) {
              if ("colour" in a) if (a.colour === void 0) console.warn(b + "Undefined colour value.");
              else {
                a = a.colour;
                try {
                  this.setColour(a);
                } catch (c) {
                  console.warn(b + "Illegal colour value: ", a);
                }
              }
            }
            jsonInitStyle(a, b) {
              a = a.style;
              try {
                this.setStyle(a);
              } catch (c) {
                console.warn(b + "Style does not exist: ", a);
              }
            }
            mixin(a, b) {
              if (b !== void 0 && typeof b !== "boolean") throw Error("opt_disableCheck must be a boolean if provided");
              if (!b) {
                b = [];
                for (const c in a) this[c] !== void 0 && b.push(c);
                if (b.length) throw Error("Mixin will overwrite block members: " + JSON.stringify(b));
              }
              Object.assign(this, a);
            }
            interpolate(a, b, c, d) {
              a = tokenizeInterpolation$$module$build$src$core$utils$parsing(a);
              this.validateTokens(a, b.length);
              b = this.interpolateArguments(a, b, c);
              c = [];
              for (let e = 0, f; f = b[e]; e++) if (this.isInputKeyword(f.type)) {
                if (a = this.inputFromJson(f, d)) {
                  for (let g = 0, h; h = c[g]; g++) a.appendField(h[0], h[1]);
                  c.length = 0;
                }
              } else (a = this.fieldFromJson(f)) && c.push([a, f.name]);
            }
            validateTokens(a, b) {
              const c = [];
              let d = 0;
              for (let e = 0; e < a.length; e++) {
                const f = a[e];
                if (typeof f === "number") {
                  if (f < 1 || f > b) throw Error('Block "' + this.type + '": Message index %' + f + " out of range.");
                  if (c[f]) throw Error('Block "' + this.type + '": Message index %' + f + " duplicated.");
                  c[f] = true;
                  d++;
                }
              }
              if (d !== b) throw Error('Block "' + this.type + '": Message does not reference all ' + b + " arg(s).");
            }
            interpolateArguments(a, b, c) {
              const d = [];
              for (let f = 0; f < a.length; f++) {
                var e = a[f];
                typeof e === "number" && (e = b[e - 1]);
                if (typeof e === "string") {
                  if (e === "\n") e = { type: "input_end_row" }, c && (e.align = c);
                  else if (e = this.stringToFieldJson(e), !e) continue;
                }
                d.push(e);
              }
              (a = d.length) && !this.isInputKeyword(d[a - 1].type) && (a = { type: "input_dummy" }, c && (a.align = c), d.push(a));
              return d;
            }
            fieldFromJson(a) {
              const b = $.fromJson$$module$build$src$core$field_registry(a);
              return !b && a.alt ? typeof a.alt === "string" ? (a = this.stringToFieldJson(a.alt)) ? this.fieldFromJson(a) : null : this.fieldFromJson(a.alt) : b;
            }
            inputFromJson(a, b) {
              var c = {
                LEFT: $.Align$$module$build$src$core$inputs$align.LEFT,
                RIGHT: $.Align$$module$build$src$core$inputs$align.RIGHT,
                CENTRE: $.Align$$module$build$src$core$inputs$align.CENTRE,
                CENTER: $.Align$$module$build$src$core$inputs$align.CENTRE
              };
              let d;
              switch (a.type) {
                case "input_value":
                  d = this.appendValueInput(a.name);
                  break;
                case "input_statement":
                  d = this.appendStatementInput(a.name);
                  break;
                case "input_dummy":
                  d = this.appendDummyInput(a.name);
                  break;
                case "input_end_row":
                  d = this.appendEndRowInput(a.name);
                  break;
                default:
                  d = this.appendInputFromRegistry(a.type, a.name);
              }
              if (!d) return null;
              a.check && d.setCheck(a.check);
              a.align && (c = c[a.align.toUpperCase()], c === void 0 ? console.warn(b + "Illegal align value: ", a.align) : d.setAlign(c));
              return d;
            }
            isInputKeyword(a) {
              return a === "input_value" || a === "input_statement" || a === "input_dummy" || a === "input_end_row" || hasItem$$module$build$src$core$registry(Type$$module$build$src$core$registry.INPUT, a);
            }
            stringToFieldJson(a) {
              return (a = a.trim()) ? { type: "field_label", text: a } : null;
            }
            moveInputBefore(a, b) {
              if (a !== b) {
                var c = -1, d = b ? -1 : this.inputList.length;
                for (let e = 0, f; f = this.inputList[e]; e++) if (f.name === a) {
                  if (c = e, d !== -1) break;
                } else if (b && f.name === b && (d = e, c !== -1)) break;
                if (c === -1) throw Error('Named input "' + a + '" not found.');
                if (d === -1) throw Error('Reference input "' + b + '" not found.');
                this.moveNumberedInputBefore(c, d);
              }
            }
            moveNumberedInputBefore(a, b) {
              if (a === b) throw Error("Can't move input to itself.");
              if (a >= this.inputList.length) throw RangeError("Input index " + a + " out of bounds.");
              if (b > this.inputList.length) throw RangeError("Reference input " + b + " out of bounds.");
              const c = this.inputList[a];
              this.inputList.splice(a, 1);
              a < b && b--;
              this.inputList.splice(
                b,
                0,
                c
              );
            }
            removeInput(a, b) {
              for (let c = 0, d; d = this.inputList[c]; c++) if (d.name === a) return d instanceof StatementInput$$module$build$src$core$inputs$statement_input && this.statementInputCount--, d.dispose(), this.inputList.splice(c, 1), true;
              if (b) return false;
              throw Error("Input not found: " + a);
            }
            getInput(a) {
              for (let b = 0, c; c = this.inputList[b]; b++) if (c.name === a) return c;
              return null;
            }
            getInputTargetBlock(a) {
              return (a = this.getInput(a)) && a.connection && a.connection.targetBlock();
            }
            getCommentText() {
              let a, b;
              return (b = (a = this.getIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT)) == null ? void 0 : a.getText()) != null ? b : null;
            }
            setCommentText(a) {
              var b;
              let c;
              const d = (c = (b = this.getIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT)) == null ? void 0 : b.getText()) != null ? c : null;
              if (d !== a) {
                if (a !== null) {
                  b = this.getIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT);
                  if (!b) {
                    b = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.ICON, IconType$$module$build$src$core$icons$icon_types.COMMENT.toString(), false);
                    if (!b) throw Error("No comment icon class is registered, so a comment cannot be set");
                    b = new b(this);
                    if (!isCommentIcon$$module$build$src$core$interfaces$i_comment_icon(b)) throw Error("The class registered as a comment icon does not conform to the ICommentIcon interface");
                    b = this.addIcon(b);
                  }
                  $.disable$$module$build$src$core$events$utils();
                  b.setText(a);
                  $.enable$$module$build$src$core$events$utils();
                } else this.removeIcon(IconType$$module$build$src$core$icons$icon_types.COMMENT);
                fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(
                  this,
                  "comment",
                  null,
                  d,
                  a
                ));
              }
            }
            setWarningText(a, b) {
            }
            setMutator(a) {
            }
            addIcon(a) {
              if (this.hasIcon(a.getType())) throw new DuplicateIconType$$module$build$src$core$icons$exceptions(a);
              this.icons.push(a);
              this.icons.sort((b, c) => b.getWeight() - c.getWeight());
              return a;
            }
            removeIcon(a) {
              if (!this.hasIcon(a)) return false;
              let b;
              (b = this.getIcon(a)) == null || b.dispose();
              this.icons = this.icons.filter((c) => !c.getType().equals(a));
              return true;
            }
            hasIcon(a) {
              return this.icons.some((b) => b.getType().equals(a));
            }
            getIcon(a) {
              return a instanceof IconType$$module$build$src$core$icons$icon_types ? this.icons.find((b) => b.getType().equals(a)) : this.icons.find((b) => b.getType().toString() === a);
            }
            getIcons() {
              return [...this.icons];
            }
            getRelativeToSurfaceXY() {
              return this.xy;
            }
            moveBy(a, b, c) {
              if (this.parentBlock_) throw Error("Block has parent");
              const d = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_MOVE))(this);
              c && d.setReason(c);
              this.xy.translate(a, b);
              d.recordNew();
              fire$$module$build$src$core$events$utils(d);
            }
            makeConnection_(a) {
              return new Connection$$module$build$src$core$connection(
                this,
                a
              );
            }
            allInputsFilled(a) {
              a === void 0 && (a = true);
              if (!a && this.isShadow()) return false;
              for (let c = 0, d; d = this.inputList[c]; c++) if (d.connection) {
                var b = d.connection.targetBlock();
                if (!b || !b.allInputsFilled(a)) return false;
              }
              return (b = this.getNextBlock()) ? b.allInputsFilled(a) : true;
            }
            toDevString() {
              let a = this.type ? '"' + this.type + '" block' : "Block";
              this.id && (a += ' (id="' + this.id + '")');
              return a;
            }
          };
          Block$$module$build$src$core$block.COLLAPSED_INPUT_NAME = COLLAPSED_INPUT_NAME$$module$build$src$core$constants;
          Block$$module$build$src$core$block.COLLAPSED_FIELD_NAME = COLLAPSED_FIELD_NAME$$module$build$src$core$constants;
          var module$build$src$core$block = {};
          module$build$src$core$block.Block = Block$$module$build$src$core$block;
          var disconnectPid$$module$build$src$core$block_animations = null, wobblingBlock$$module$build$src$core$block_animations = null, module$build$src$core$block_animations = {};
          module$build$src$core$block_animations.connectionUiEffect = connectionUiEffect$$module$build$src$core$block_animations;
          module$build$src$core$block_animations.disconnectUiEffect = disconnectUiEffect$$module$build$src$core$block_animations;
          module$build$src$core$block_animations.disconnectUiStop = disconnectUiStop$$module$build$src$core$block_animations;
          module$build$src$core$block_animations.disposeUiEffect = disposeUiEffect$$module$build$src$core$block_animations;
          var BlockPaster$$module$build$src$core$clipboard$block_paster = class {
            paste(a, b, c) {
              if (!b.isCapacityAvailable(a.typeCounts)) return null;
              c && (a.blockState.x = c.x, a.blockState.y = c.y);
              c = c || new Coordinate$$module$build$src$core$utils$coordinate(a.blockState.x || 0, a.blockState.y || 0);
              $.disable$$module$build$src$core$events$utils();
              let d;
              try {
                d = append$$module$build$src$core$serialization$blocks(a.blockState, b), moveBlockToNotConflict$$module$build$src$core$clipboard$block_paster(d, c);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
              if (!d) return d;
              isEnabled$$module$build$src$core$events$utils() && !d.isShadow() && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(d));
              const e = d;
              finishQueuedRenders$$module$build$src$core$render_management().then(() => $.getFocusManager$$module$build$src$core$focus_manager().focusNode(e));
              return d;
            }
          };
          BlockPaster$$module$build$src$core$clipboard$block_paster.TYPE = "block";
          register$$module$build$src$core$clipboard$registry(BlockPaster$$module$build$src$core$clipboard$block_paster.TYPE, new BlockPaster$$module$build$src$core$clipboard$block_paster());
          var module$build$src$core$clipboard$block_paster = {};
          module$build$src$core$clipboard$block_paster.BlockPaster = BlockPaster$$module$build$src$core$clipboard$block_paster;
          module$build$src$core$clipboard$block_paster.moveBlockToNotConflict = moveBlockToNotConflict$$module$build$src$core$clipboard$block_paster;
          var bumpIntoBounds$$module$build$src$core$bump_objects = bumpObjectIntoBounds$$module$build$src$core$bump_objects, module$build$src$core$bump_objects = {};
          module$build$src$core$bump_objects.bumpIntoBounds = bumpObjectIntoBounds$$module$build$src$core$bump_objects;
          module$build$src$core$bump_objects.bumpIntoBoundsHandler = bumpIntoBoundsHandler$$module$build$src$core$bump_objects;
          module$build$src$core$bump_objects.bumpTopObjectsIntoBounds = bumpTopObjectsIntoBounds$$module$build$src$core$bump_objects;
          var BlockDragStrategy$$module$build$src$core$dragging$block_drag_strategy = class {
            constructor(a) {
              this.block = a;
              this.connectionPreviewer = this.connectionCandidate = this.startLoc = this.startChildConn = this.startParentConn = null;
              this.dragging = false;
              this.dragOffset = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.originalEventGroup = "";
              this.workspace = a.workspace;
            }
            isMovable() {
              if (this.block.isShadow()) {
                let a, b;
                return (b = (a = this.block.getParent()) == null ? void 0 : a.isMovable()) != null ? b : false;
              }
              return this.block.isOwnMovable() && !this.block.isDeadOrDying() && !this.workspace.isReadOnly() && !this.block.isInFlyout;
            }
            startDrag(a) {
              if (this.block.isShadow()) this.startDraggingShadow(a);
              else {
                this.dragging = true;
                this.fireDragStartEvent();
                this.startLoc = this.block.getRelativeToSurfaceXY();
                this.connectionCandidate = null;
                this.connectionPreviewer = new (getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.CONNECTION_PREVIEWER, this.workspace.options))(this.block);
                startTextWidthCache$$module$build$src$core$utils$dom();
                this.workspace.setResizesEnabled(false);
                disconnectUiStop$$module$build$src$core$block_animations();
                a = this.shouldHealStack(a);
                this.shouldDisconnect(a) && this.disconnectBlock(a);
                this.block.setDragging(true);
                var b;
                (b = this.workspace.getLayerManager()) == null || b.moveToDragLayer(this.block);
              }
            }
            shouldHealStack(a) {
              return !!a && (a.altKey || a.ctrlKey || a.metaKey);
            }
            startDraggingShadow(a) {
              const b = this.block.getParent();
              if (!b) throw Error("Tried to drag a shadow block with no parent. Shadow blocks should always have parents.");
              this.dragOffset = Coordinate$$module$build$src$core$utils$coordinate.difference(b.getRelativeToSurfaceXY(), this.block.getRelativeToSurfaceXY());
              b.startDrag(a);
            }
            shouldDisconnect(a) {
              return !!(this.block.getParent() || a && this.block.nextConnection && this.block.nextConnection.targetBlock());
            }
            disconnectBlock(a) {
              let b, c, d;
              this.startParentConn = (d = (b = this.block.outputConnection) == null ? void 0 : b.targetConnection) != null ? d : (c = this.block.previousConnection) == null ? void 0 : c.targetConnection;
              if (a) {
                let e;
                this.startChildConn = (e = this.block.nextConnection) == null ? void 0 : e.targetConnection;
              }
              this.block.unplug(a);
              disconnectUiEffect$$module$build$src$core$block_animations(this.block);
            }
            fireDragStartEvent() {
              const a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_DRAG))(this.block, true, this.block.getDescendants(false));
              fire$$module$build$src$core$events$utils(a);
            }
            fireDragEndEvent() {
              const a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_DRAG))(
                this.block,
                false,
                this.block.getDescendants(false)
              );
              fire$$module$build$src$core$events$utils(a);
            }
            fireMoveEvent() {
              if (!this.block.isDeadOrDying()) {
                var a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_MOVE))(this.block);
                a.setReason(["drag"]);
                a.oldCoordinate = this.startLoc;
                a.recordNew();
                fire$$module$build$src$core$events$utils(a);
              }
            }
            drag(a) {
              if (this.block.isShadow()) {
                let b;
                (b = this.block.getParent()) == null || b.drag(Coordinate$$module$build$src$core$utils$coordinate.sum(a, this.dragOffset));
              } else this.block.moveDuringDrag(a), this.updateConnectionPreview(this.block, Coordinate$$module$build$src$core$utils$coordinate.difference(a, this.startLoc));
            }
            updateConnectionPreview(a, b) {
              var c = this.connectionCandidate;
              const d = this.getConnectionCandidate(a, b);
              if (d) {
                this.connectionCandidate = b = c && this.currCandidateIsBetter(c, b, d) ? c : d;
                var { local: e, neighbour: f } = b;
                b = e.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE || e.type === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT;
                var g;
                c = f.isConnected() && !((g = f.targetBlock()) == null ? 0 : g.isInsertionMarker());
                if (b && c && !this.orphanCanConnectAtEnd(a, f.targetBlock(), e.type)) {
                  let k;
                  (k = this.connectionPreviewer) == null || k.previewReplacement(e, f, f.targetBlock());
                } else {
                  var h;
                  (h = this.connectionPreviewer) == null || h.previewConnection(e, f);
                }
              } else {
                let k;
                (k = this.connectionPreviewer) == null || k.hidePreview();
                this.connectionCandidate = null;
              }
            }
            orphanCanConnectAtEnd(a, b, c) {
              return !!Connection$$module$build$src$core$connection.getConnectionForOrphanedConnection(a, c === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE ? b.outputConnection : b.previousConnection);
            }
            currCandidateIsBetter(a, b, c) {
              const { local: d, neighbour: e } = a;
              a = new Coordinate$$module$build$src$core$utils$coordinate(d.x, d.y);
              const f = new Coordinate$$module$build$src$core$utils$coordinate(e.x, e.y);
              b = Coordinate$$module$build$src$core$utils$coordinate.distance(Coordinate$$module$build$src$core$utils$coordinate.sum(a, b), f);
              return c.distance > b - $.config$$module$build$src$core$config.currentConnectionPreference;
            }
            getConnectionCandidate(a, b) {
              a = this.getLocalConnections(a);
              let c = this.getSearchRadius(), d = null;
              for (const e of a) {
                const { connection: f, radius: g } = e.closest(c, b);
                f && (d = { local: e, neighbour: f, distance: g }, c = g);
              }
              return d;
            }
            getSearchRadius() {
              return this.connectionCandidate ? $.config$$module$build$src$core$config.connectingSnapRadius : $.config$$module$build$src$core$config.snapRadius;
            }
            getLocalConnections(a) {
              const b = a.getConnections_(false), c = a.lastConnectionInStack(true);
              c && c !== a.nextConnection && b.push(c);
              return b;
            }
            endDrag(a) {
              if (this.block.isShadow()) {
                let c;
                (c = this.block.getParent()) == null || c.endDrag(a);
              } else {
                this.originalEventGroup = $.getGroup$$module$build$src$core$events$utils();
                this.fireDragEndEvent();
                this.fireMoveEvent();
                stopTextWidthCache$$module$build$src$core$utils$dom();
                disconnectUiStop$$module$build$src$core$block_animations();
                var b;
                (b = this.connectionPreviewer) == null || b.hidePreview();
                if (!this.block.isDeadOrDying() && this.dragging) {
                  let c;
                  (c = this.workspace.getLayerManager()) == null || c.moveOffDragLayer(this.block, BLOCK$$module$build$src$core$layers);
                  this.block.setDragging(false);
                }
                this.connectionCandidate ? (this.applyConnections(this.connectionCandidate), this.disposeStep()) : this.block.queueRender().then(() => this.disposeStep());
              }
            }
            disposeStep() {
              const a = $.getGroup$$module$build$src$core$events$utils();
              $.setGroup$$module$build$src$core$events$utils(this.originalEventGroup);
              this.block.snapToGrid();
              let b;
              (b = this.connectionPreviewer) == null || b.dispose();
              this.workspace.setResizesEnabled(true);
              $.setGroup$$module$build$src$core$events$utils(a);
            }
            applyConnections(a) {
              const { local: b, neighbour: c } = a;
              b.connect(c);
              const d = b.isSuperior() ? c : b, e = this.block.getRootBlock();
              finishQueuedRenders$$module$build$src$core$render_management().then(() => {
                connectionUiEffect$$module$build$src$core$block_animations(d.getSourceBlock());
                setTimeout(() => {
                  e.bringToFront();
                }, 0);
              });
            }
            revertDrag() {
              if (this.block.isShadow()) {
                let c;
                (c = this.block.getParent()) == null || c.revertDrag();
              } else {
                var a;
                (a = this.connectionPreviewer) == null || a.hidePreview();
                this.connectionCandidate = null;
                var b;
                (b = this.startChildConn) == null || b.connect(this.block.nextConnection);
                if (this.startParentConn) switch (this.startParentConn.type) {
                  case ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE:
                    this.startParentConn.connect(this.block.outputConnection);
                    break;
                  case ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT:
                    this.startParentConn.connect(this.block.previousConnection);
                }
                else {
                  this.block.moveTo(this.startLoc, ["drag"]);
                  let c;
                  (c = this.workspace.getLayerManager()) == null || c.moveOffDragLayer(this.block, BLOCK$$module$build$src$core$layers);
                  bumpObjectIntoBounds$$module$build$src$core$bump_objects(this.workspace, this.workspace.getMetricsManager().getScrollMetrics(true), this.block);
                }
                this.startParentConn = this.startChildConn = null;
                this.block.setDragging(false);
                this.dragging = false;
              }
            }
          }, module$build$src$core$dragging$block_drag_strategy = {};
          module$build$src$core$dragging$block_drag_strategy.BlockDragStrategy = BlockDragStrategy$$module$build$src$core$dragging$block_drag_strategy;
          var TextBubble$$module$build$src$core$bubbles$text_bubble = class extends Bubble$$module$build$src$core$bubbles$bubble {
            constructor(a, b, c, d) {
              super(b, c, d);
              this.text = a;
              this.workspace = b;
              this.anchor = c;
              this.ownerRect = d;
              this.paragraph = this.stringToSvg(a, this.contentContainer);
              this.updateBubbleSize();
              addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyTextBubble");
            }
            getText() {
              return this.text;
            }
            setText(a) {
              this.text = a;
              removeNode$$module$build$src$core$utils$dom(this.paragraph);
              this.paragraph = this.stringToSvg(
                a,
                this.contentContainer
              );
              this.updateBubbleSize();
            }
            stringToSvg(a, b) {
              b = this.createParagraph(b);
              a = this.createTextFragments(b, a);
              this.workspace.RTL && this.rightAlignTextFragments(b.getBBox().width, a);
              return b;
            }
            createParagraph(a) {
              return createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyText blocklyBubbleText blocklyNoPointerEvents", transform: `translate(0,${Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH})`, style: `direction: ${this.workspace.RTL ? "rtl" : "ltr"}` }, a);
            }
            createTextFragments(a, b) {
              let c = 1;
              return b.split("\n").map((d) => {
                const e = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.TEXT, { y: `${c}em`, x: Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH }, a);
                d = document.createTextNode(d);
                e.appendChild(d);
                c += 1;
                return e;
              });
            }
            rightAlignTextFragments(a, b) {
              for (const c of b) c.setAttribute("text-anchor", "start"), c.setAttribute("x", `${a + Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH}`);
            }
            updateBubbleSize() {
              const a = this.paragraph.getBBox();
              this.setSize(new Size$$module$build$src$core$utils$size(a.width + Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH * 2, a.height + Bubble$$module$build$src$core$bubbles$bubble.BORDER_WIDTH * 2), true);
            }
          }, module$build$src$core$bubbles$text_bubble = {};
          module$build$src$core$bubbles$text_bubble.TextBubble = TextBubble$$module$build$src$core$bubbles$text_bubble;
          var SIZE$$module$build$src$core$icons$warning_icon = 17, WarningIcon$$module$build$src$core$icons$warning_icon = class extends Icon$$module$build$src$core$icons$icon {
            constructor(a) {
              super(a);
              this.sourceBlock = a;
              this.textMap = /* @__PURE__ */ new Map();
              this.textBubble = null;
            }
            getType() {
              return WarningIcon$$module$build$src$core$icons$warning_icon.TYPE;
            }
            initView(a) {
              this.svgRoot || (super.initView(a), createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.PATH,
                { "class": "blocklyIconShape", d: "M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z" },
                this.svgRoot
              ), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyIconSymbol", d: "m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z" }, this.svgRoot), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyIconSymbol", x: "7", y: "11", height: "2", width: "2" }, this.svgRoot), addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyWarningIcon"));
            }
            dispose() {
              super.dispose();
              let a;
              (a = this.textBubble) == null || a.dispose();
            }
            getWeight() {
              return WarningIcon$$module$build$src$core$icons$warning_icon.WEIGHT;
            }
            getSize() {
              return new Size$$module$build$src$core$utils$size(SIZE$$module$build$src$core$icons$warning_icon, SIZE$$module$build$src$core$icons$warning_icon);
            }
            applyColour() {
              super.applyColour();
              let a;
              (a = this.textBubble) == null || a.setColour(this.sourceBlock.getColour());
            }
            updateCollapsed() {
            }
            isShownWhenCollapsed() {
              return true;
            }
            onLocationChange(a) {
              super.onLocationChange(a);
              let b;
              (b = this.textBubble) == null || b.setAnchorLocation(this.getAnchorLocation());
            }
            addMessage(a, b) {
              if (this.textMap.get(b) === a) return this;
              a ? this.textMap.set(b, a) : this.textMap.delete(b);
              let c;
              (c = this.textBubble) == null || c.setText(this.getText());
              return this;
            }
            getText() {
              return [...this.textMap.values()].join("\n");
            }
            onClick() {
              super.onClick();
              this.setBubbleVisible(!this.bubbleIsVisible());
            }
            isClickableInFlyout() {
              return false;
            }
            bubbleIsVisible() {
              return !!this.textBubble;
            }
            setBubbleVisible(a) {
              const b = this;
              return (0, $jscomp.asyncExecutePromiseGeneratorFunction)(function* () {
                if (b.bubbleIsVisible() !== a) {
                  yield finishQueuedRenders$$module$build$src$core$render_management();
                  if (a) b.textBubble = new TextBubble$$module$build$src$core$bubbles$text_bubble(b.getText(), b.sourceBlock.workspace, b.getAnchorLocation(), b.getBubbleOwnerRect()), b.applyColour();
                  else {
                    let c;
                    (c = b.textBubble) == null || c.dispose();
                    b.textBubble = null;
                  }
                  fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BUBBLE_OPEN))(b.sourceBlock, a, "warning"));
                }
              });
            }
            getBubble() {
              return this.textBubble;
            }
            getAnchorLocation() {
              const a = SIZE$$module$build$src$core$icons$warning_icon / 2;
              return Coordinate$$module$build$src$core$utils$coordinate.sum(this.workspaceLocation, new Coordinate$$module$build$src$core$utils$coordinate(a, a));
            }
            getBubbleOwnerRect() {
              const a = this.sourceBlock.getSvgRoot().getBBox();
              return new Rect$$module$build$src$core$utils$rect(a.y, a.y + a.height, a.x, a.x + a.width);
            }
          };
          WarningIcon$$module$build$src$core$icons$warning_icon.TYPE = IconType$$module$build$src$core$icons$icon_types.WARNING;
          WarningIcon$$module$build$src$core$icons$warning_icon.WEIGHT = 2;
          var module$build$src$core$icons$warning_icon = {};
          module$build$src$core$icons$warning_icon.WarningIcon = WarningIcon$$module$build$src$core$icons$warning_icon;
          var BlockSvg$$module$build$src$core$block_svg = class extends Block$$module$build$src$core$block {
            constructor(a, b, c) {
              super(a, b, c);
              this.childlessWidth = this.width = this.height = 0;
              this.warningTextDb = /* @__PURE__ */ new Map();
              this.mutator = null;
              this.rendered = true;
              this.visuallyDisabled = false;
              this.translation = "";
              this.dragging = false;
              this.relativeCoords = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.dragStrategy = new BlockDragStrategy$$module$build$src$core$dragging$block_drag_strategy(this);
              if (!a.rendered) throw TypeError("Cannot create a rendered block in a headless workspace");
              this.workspace = a;
              this.svgGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {});
              b && addClass$$module$build$src$core$utils$dom(this.svgGroup, b);
              this.style = a.getRenderer().getConstants().getBlockStyle(null);
              this.pathObject = a.getRenderer().makePathObject(this.svgGroup, this.style);
              a = this.pathObject.svgPath;
              a.tooltip = this;
              bindMouseEvents$$module$build$src$core$tooltip(a);
              this.svgGroup.setAttribute("data-id", this.id);
              a.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.doInit_();
            }
            initSvg() {
              if (!this.initialized) {
                for (var a of this.inputList) a.init();
                for (const b of this.getIcons()) b.initView(this.createIconPointerDownListener(b)), b.updateEditable();
                this.applyColour();
                this.pathObject.updateMovable(this.isMovable() || this.isInFlyout);
                (a = this.getSvgRoot()) && conditionalBind$$module$build$src$core$browser_events(a, "pointerdown", this, this.onMouseDown);
                a.parentNode || this.workspace.getCanvas().appendChild(a);
                this.initialized = true;
              }
            }
            getColourSecondary() {
              return this.style.colourSecondary;
            }
            getColourTertiary() {
              return this.style.colourTertiary;
            }
            select() {
              this.addSelect();
              fireSelectedEvent$$module$build$src$core$common(this);
            }
            unselect() {
              this.removeSelect();
              fireSelectedEvent$$module$build$src$core$common(null);
            }
            setParent(a) {
              var b = this.parentBlock_;
              if (a !== b) {
                startTextWidthCache$$module$build$src$core$utils$dom();
                super.setParent(a);
                stopTextWidthCache$$module$build$src$core$utils$dom();
                var c = this.getSvgRoot();
                if (!this.workspace.isClearing && c) {
                  var d = this.getRelativeToSurfaceXY(), e = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode(), f, g = this.getSvgRoot().contains((f = e == null ? void 0 : e.getFocusableElement()) != null ? f : null);
                  a ? (a.getSvgRoot().appendChild(c), g && e && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(e)) : b && (a = this.workspace.getCanvas().querySelector(".blocklyDragging"), b = a == null ? void 0 : a.parentElement, f = this.workspace.getCanvas(), b === f ? f.insertBefore(c, a) : (f.appendChild(c), g && e && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(e)), this.translate(d.x, d.y));
                  this.applyColour();
                }
              }
            }
            getRelativeToSurfaceXY() {
              const a = this.workspace.getLayerManager();
              if (!a) throw Error("Cannot calculate position because the workspace has not been appended");
              let b = 0, c = 0, d = this.getSvgRoot();
              if (d) {
                do {
                  const e = getRelativeXY$$module$build$src$core$utils$svg_math(d);
                  b += e.x;
                  c += e.y;
                  d = d.parentNode;
                } while (d && !a.hasLayer(d));
              }
              return new Coordinate$$module$build$src$core$utils$coordinate(b, c);
            }
            moveBy(a, b, c) {
              if (this.parentBlock_) throw Error("Block has parent");
              const d = isEnabled$$module$build$src$core$events$utils();
              let e = null;
              d && (e = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_MOVE))(this), c && e.setReason(c));
              a = new Coordinate$$module$build$src$core$utils$coordinate(a, b);
              b = this.getRelativeToSurfaceXY();
              a = Coordinate$$module$build$src$core$utils$coordinate.sum(b, a);
              this.translate(a.x, a.y);
              this.updateComponentLocations(a);
              d && e && (e.recordNew(), fire$$module$build$src$core$events$utils(e));
              this.workspace.resizeContents();
            }
            translate(a, b) {
              this.translation = `translate(${a}, ${b})`;
              this.relativeCoords = new Coordinate$$module$build$src$core$utils$coordinate(a, b);
              this.getSvgRoot().setAttribute(
                "transform",
                this.getTranslation()
              );
            }
            getTranslation() {
              return this.translation;
            }
            moveTo(a, b) {
              const c = this.getRelativeToSurfaceXY();
              this.moveBy(a.x - c.x, a.y - c.y, b);
            }
            moveDuringDrag(a) {
              this.translate(a.x, a.y);
              this.getSvgRoot().setAttribute("transform", this.getTranslation());
              this.updateComponentLocations(a);
            }
            snapToGrid() {
              if (!this.isDeadOrDying() && !this.getParent() && !this.isInFlyout) {
                var a = this.workspace.getGrid();
                if (a != null && a.shouldSnap()) {
                  var b = this.getRelativeToSurfaceXY();
                  a = a.alignXY(b);
                  a !== b && this.moveTo(a, ["snap"]);
                }
              }
            }
            getBoundingRectangle() {
              return this.getBoundingRectangleWithDimensions(this.getHeightWidth());
            }
            getBoundingRectangleWithoutChildren() {
              return this.getBoundingRectangleWithDimensions({
                height: this.height,
                width: this.childlessWidth
              });
            }
            getBoundingRectangleWithDimensions(a) {
              const b = this.getRelativeToSurfaceXY();
              let c, d;
              this.RTL ? (c = b.x - a.width, d = b.x) : (c = b.x, d = b.x + a.width);
              return new Rect$$module$build$src$core$utils$rect(b.y, b.y + a.height, c, d);
            }
            markDirty() {
              this.pathObject.constants = this.workspace.getRenderer().getConstants();
              for (let a = 0, b; b = this.inputList[a]; a++) b.markDirty();
            }
            setCollapsed(a) {
              this.collapsed_ !== a && (super.setCollapsed(a), this.updateCollapsed());
            }
            childHasWarning() {
              const a = this.getChildren(false);
              for (const b of a) if (b.getIcon(WarningIcon$$module$build$src$core$icons$warning_icon.TYPE) || b.childHasWarning()) return true;
              return false;
            }
            updateCollapsed() {
              var a = this.isCollapsed();
              const b = COLLAPSED_INPUT_NAME$$module$build$src$core$constants, c = COLLAPSED_FIELD_NAME$$module$build$src$core$constants;
              for (let e = 0, f; f = this.inputList[e]; e++) f.name !== b && f.setVisible(!a);
              for (var d of this.getIcons()) d.updateCollapsed();
              a ? (addClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyCollapsed"), this.childHasWarning() && this.setWarningText($.Msg$$module$build$src$core$msg.COLLAPSED_WARNINGS_WARNING, BlockSvg$$module$build$src$core$block_svg.COLLAPSED_WARNING_ID), a = this.toString(COLLAPSE_CHARS$$module$build$src$core$internal_constants), (d = this.getField(c)) ? d.setValue(a) : (this.getInput(b) || this.appendDummyInput(b)).appendField(new FieldLabel$$module$build$src$core$field_label(a), c)) : (this.updateDisabled(), this.removeInput(b), removeClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyCollapsed"), this.setWarningText(
                null,
                BlockSvg$$module$build$src$core$block_svg.COLLAPSED_WARNING_ID
              ));
            }
            onMouseDown(a) {
              if (!this.workspace.isReadOnly()) {
                var b = this.workspace.getGesture(a);
                b && b.handleBlockStart(a, this);
              }
            }
            showHelp() {
              const a = typeof this.helpUrl === "function" ? this.helpUrl() : this.helpUrl;
              a && window.open(a);
            }
            generateContextMenu(a) {
              if (this.workspace.isReadOnly() || !this.contextMenu) return null;
              a = ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.getContextMenuOptions({ block: this, focusedNode: this }, a);
              this.customContextMenu && this.customContextMenu(a);
              return a;
            }
            calculateContextMenuLocation(a) {
              if (a instanceof PointerEvent) return new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY);
              a = wsToScreenCoordinates$$module$build$src$core$utils$svg_math(this.workspace, this.getRelativeToSurfaceXY());
              let b, c;
              const d = (b = this.inputList.filter((e) => e.isVisible()).flatMap((e) => e.fieldRow).find((e) => e.isVisible())) == null ? void 0 : (c = b.getSvgRoot()) == null ? void 0 : c.getBoundingClientRect();
              return new Coordinate$$module$build$src$core$utils$coordinate(this.RTL ? a.x - 5 : a.x + 5, (d && d.height ? d.y + d.height : a.y + this.height) + 5);
            }
            showContextMenu(a) {
              const b = this.generateContextMenu(a), c = this.calculateContextMenuLocation(a);
              b && b.length && (show$$module$build$src$core$contextmenu(a, b, this.RTL, this.workspace, c), setCurrentBlock$$module$build$src$core$contextmenu(this));
            }
            updateComponentLocations(a) {
              this.dragging || this.updateConnectionLocations(a);
              this.updateIconLocations(a);
              this.updateFieldLocations(a);
              for (const b of this.getChildren(false)) b.updateComponentLocations(Coordinate$$module$build$src$core$utils$coordinate.sum(
                a,
                b.relativeCoords
              ));
            }
            updateConnectionLocations(a) {
              for (const b of this.getConnections_(false)) b.moveToOffset(a);
            }
            updateIconLocations(a) {
              for (const b of this.getIcons()) b.onLocationChange(a);
            }
            updateFieldLocations(a) {
              for (const b of this.inputList) for (const c of b.fieldRow) c.onLocationChange(a);
            }
            addClass(a) {
              addClass$$module$build$src$core$utils$dom(this.svgGroup, a);
            }
            removeClass(a) {
              removeClass$$module$build$src$core$utils$dom(this.svgGroup, a);
            }
            setDragging(a) {
              (this.dragging = a) ? (this.translation = "", draggingConnections$$module$build$src$core$common.push(...this.getConnections_(true)), this.addClass("blocklyDragging")) : (draggingConnections$$module$build$src$core$common.length = 0, this.removeClass("blocklyDragging"));
              for (let b = 0; b < this.childBlocks_.length; b++) this.childBlocks_[b].setDragging(a);
            }
            setMovable(a) {
              super.setMovable(a);
              this.pathObject.updateMovable(a);
            }
            setEditable(a) {
              super.setEditable(a);
              a ? removeClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyNotEditable") : addClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyNotEditable");
              a = this.getIcons();
              for (let b = 0; b < a.length; b++) a[b].updateEditable();
            }
            setShadow(a) {
              super.setShadow(a);
              this.applyColour();
            }
            setInsertionMarker(a) {
              this.isInsertionMarker_ !== a && (this.isInsertionMarker_ = a) && (this.setColour(this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR), this.pathObject.updateInsertionMarker(true));
            }
            getSvgRoot() {
              return this.svgGroup;
            }
            dispose(a, b) {
              this.disposing = true;
              dispose$$module$build$src$core$tooltip();
              hide$$module$build$src$core$contextmenu();
              const c = $.getFocusManager$$module$build$src$core$focus_manager();
              var d, e;
              if (this.getSvgRoot().contains((e = (d = c.getFocusedNode()) == null ? void 0 : d.getFocusableElement()) != null ? e : null)) {
                d = this.getParent();
                if (!d) {
                  let f;
                  if (e = (f = this.outputConnection) != null ? f : this.previousConnection) {
                    let g;
                    d = (g = e.closest(0, new Coordinate$$module$build$src$core$utils$coordinate(0, 0)).connection) == null ? void 0 : g.getSourceBlock();
                  }
                }
                d ? c.focusNode(d) : setTimeout(() => c.focusTree(this.workspace), 0);
              }
              b && (this.unplug(a), disposeUiEffect$$module$build$src$core$block_animations(this));
              super.dispose(!!a);
              removeNode$$module$build$src$core$utils$dom(this.svgGroup);
            }
            disposeInternal() {
              this.disposing = true;
              super.disposeInternal();
              $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === this && this.workspace.cancelCurrentGesture();
              [...this.warningTextDb.values()].forEach((a) => clearTimeout(a));
              this.warningTextDb.clear();
              this.getIcons().forEach((a) => a.dispose());
            }
            checkAndDelete() {
              this.workspace.isFlyout || ($.setGroup$$module$build$src$core$events$utils(true), this.workspace.hideChaff(), this.outputConnection ? this.dispose(false, true) : this.dispose(true, true), $.setGroup$$module$build$src$core$events$utils(false));
            }
            toCopyData(a = false) {
              return this.isInsertionMarker_ ? null : { paster: BlockPaster$$module$build$src$core$clipboard$block_paster.TYPE, blockState: save$$module$build$src$core$serialization$blocks(this, { addCoordinates: true, addNextBlocks: a, saveIds: false }), typeCounts: getBlockTypeCounts$$module$build$src$core$common(this, true) };
            }
            applyColour() {
              var a, b;
              (b = (a = this.pathObject).applyColour) == null || b.call(a, this);
              a = this.getIcons();
              for (b = 0; b < a.length; b++) a[b].applyColour();
              for (const c of this.getFields()) c.applyColour();
            }
            updateDisabled() {
              const a = !this.isEnabled() || this.getInheritedDisabled();
              if (this.visuallyDisabled === a) {
                let b;
                (b = this.getNextBlock()) == null || b.updateDisabled();
              } else {
                this.applyColour();
                this.visuallyDisabled = a;
                for (const b of this.getChildren(false)) b.updateDisabled();
              }
            }
            setWarningText(a, b = "") {
              if (b) this.warningTextDb.has(b) && (clearTimeout(this.warningTextDb.get(b)), this.warningTextDb.delete(b));
              else {
                for (var c of this.warningTextDb.values()) clearTimeout(c);
                this.warningTextDb.clear();
              }
              if (this.workspace.isDragging()) this.warningTextDb.set(b, setTimeout(() => {
                this.isDeadOrDying() || (this.warningTextDb.delete(b), this.setWarningText(a, b));
              }, 100));
              else if (this.isInFlyout && (a = null), c = this.getIcon(WarningIcon$$module$build$src$core$icons$warning_icon.TYPE), a) {
                let d = this.getSurroundParent(), e = null;
                for (; d; ) d.isCollapsed() && (e = d), d = d.getSurroundParent();
                e && e.setWarningText($.Msg$$module$build$src$core$msg.COLLAPSED_WARNINGS_WARNING, BlockSvg$$module$build$src$core$block_svg.COLLAPSED_WARNING_ID);
                c ? c.addMessage(a, b) : this.addIcon(new WarningIcon$$module$build$src$core$icons$warning_icon(this).addMessage(a, b));
              } else c && (b ? (c.addMessage("", b), c.getText() || this.removeIcon(WarningIcon$$module$build$src$core$icons$warning_icon.TYPE)) : this.removeIcon(WarningIcon$$module$build$src$core$icons$warning_icon.TYPE));
            }
            setMutator(a) {
              this.removeIcon($.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE);
              a && this.addIcon(a);
            }
            addIcon(a) {
              super.addIcon(a);
              a instanceof $.MutatorIcon$$module$build$src$core$icons$mutator_icon && (this.mutator = a);
              a.initView(this.createIconPointerDownListener(a));
              a.applyColour();
              a.updateEditable();
              this.queueRender();
              return a;
            }
            createIconPointerDownListener(a) {
              return (b) => {
                this.isDeadOrDying() || (b = this.workspace.getGesture(b)) && b.setStartIcon(a);
              };
            }
            removeIcon(a) {
              const b = super.removeIcon(a);
              a.equals($.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE) && (this.mutator = null);
              this.queueRender();
              return b;
            }
            setDisabledReason(a, b) {
              const c = this.isEnabled();
              super.setDisabledReason(a, b);
              this.isEnabled() === c || this.getInheritedDisabled() || this.updateDisabled();
            }
            setDeletable(a) {
              super.setDeletable(a);
              a ? removeClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyNotDeletable") : addClass$$module$build$src$core$utils$dom(this.svgGroup, "blocklyNotDeletable");
            }
            setHighlighted(a) {
              this.pathObject.updateHighlighted(a);
            }
            addSelect() {
              this.pathObject.updateSelected(true);
            }
            removeSelect() {
              this.pathObject.updateSelected(false);
            }
            setDeleteStyle(a) {
              this.pathObject.updateDraggingDelete(a);
            }
            getColour() {
              return this.style.colourPrimary;
            }
            setColour(a) {
              super.setColour(a);
              a = this.workspace.getRenderer().getConstants().getBlockStyleForColour(this.colour_);
              let b, c;
              (c = (b = this.pathObject).setStyle) == null || c.call(b, a.style);
              this.style = a.style;
              this.styleName_ = a.name;
              this.applyColour();
            }
            setStyle(a) {
              const b = this.workspace.getRenderer().getConstants().getBlockStyle(a);
              this.styleName_ && removeClass$$module$build$src$core$utils$dom(this.svgGroup, this.styleName_);
              if (b) {
                this.hat = b.hat;
                let c, d;
                (d = (c = this.pathObject).setStyle) == null || d.call(c, b);
                this.colour_ = b.colourPrimary;
                this.style = b;
                this.applyColour();
                addClass$$module$build$src$core$utils$dom(this.svgGroup, a);
                this.styleName_ = a;
              } else throw Error("Invalid style name: " + a);
            }
            getStyle() {
              return this.style;
            }
            bringToFront(a = false) {
              const b = $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode();
              let c = this;
              if (!c.isDeadOrDying()) {
                do {
                  const d = c.getSvgRoot(), e = d.parentNode, f = e.childNodes;
                  f[f.length - 1] !== d && e.appendChild(d);
                  if (a) break;
                  c = c.getParent();
                } while (c);
                b && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(b);
              }
            }
            setPreviousStatement(a, b) {
              super.setPreviousStatement(a, b);
              this.queueRender();
            }
            setNextStatement(a, b) {
              super.setNextStatement(a, b);
              this.queueRender();
            }
            setOutput(a, b) {
              super.setOutput(a, b);
              this.queueRender();
            }
            setInputsInline(a) {
              super.setInputsInline(a);
              this.queueRender();
            }
            removeInput(a, b) {
              a = super.removeInput(a, b);
              this.queueRender();
              return a;
            }
            moveNumberedInputBefore(a, b) {
              super.moveNumberedInputBefore(a, b);
              this.queueRender();
            }
            appendInput(a) {
              super.appendInput(a);
              this.queueRender();
              return a;
            }
            setConnectionTracking(a) {
              this.previousConnection && this.previousConnection.setTracking(a);
              this.outputConnection && this.outputConnection.setTracking(a);
              if (this.nextConnection) {
                this.nextConnection.setTracking(a);
                var b = this.nextConnection.targetBlock();
                b && b.setConnectionTracking(a);
              }
              if (!this.collapsed_) for (b = 0; b < this.inputList.length; b++) {
                var c = this.inputList[b].connection;
                c && (c.setTracking(a), (c = c.targetBlock()) && c.setConnectionTracking(a));
              }
            }
            getConnections_(a) {
              const b = [];
              this.outputConnection && b.push(this.outputConnection);
              this.previousConnection && b.push(this.previousConnection);
              this.nextConnection && b.push(this.nextConnection);
              if (a || !this.collapsed_) for (let c = 0, d; d = this.inputList[c]; c++) d.connection && b.push(d.connection);
              return b;
            }
            lastConnectionInStack(a) {
              return super.lastConnectionInStack(a);
            }
            getMatchingConnection(a, b) {
              return super.getMatchingConnection(a, b);
            }
            makeConnection_(a) {
              return new RenderedConnection$$module$build$src$core$rendered_connection(this, a);
            }
            getNextBlock() {
              return super.getNextBlock();
            }
            getPreviousBlock() {
              return super.getPreviousBlock();
            }
            bumpNeighbours() {
              const a = this.getRootBlock();
              if (!(this.isDeadOrDying() || this.workspace.isDragging() || a.isInFlyout)) for (const b of this.getConnections_(false)) {
                if (b.isSuperior()) {
                  let c;
                  (c = b.targetBlock()) == null || c.bumpNeighbours();
                }
                for (const c of b.neighbours($.config$$module$build$src$core$config.snapRadius)) c.getSourceBlock().getRootBlock() !== a && (b.isConnected() && c.isConnected() || (b.isSuperior() ? c.bumpAwayFrom(b, false) : b.bumpAwayFrom(c, true)));
              }
            }
            scheduleSnapAndBump() {
              this.snapToGrid();
              this.bumpNeighbours();
            }
            positionNearConnection(a, b, c) {
              if (a.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT || a.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE) {
                let d = b.x;
                b = b.y;
                d += c.x - a.getOffsetInBlock().x;
                b += c.y - a.getOffsetInBlock().y;
                this.moveBy(d, b);
              }
            }
            getChildren(a) {
              return super.getChildren(a);
            }
            queueRender() {
              return queueRender$$module$build$src$core$render_management(this);
            }
            render() {
              this.queueRender();
              triggerQueuedRenders$$module$build$src$core$render_management();
            }
            renderEfficiently() {
              startTextWidthCache$$module$build$src$core$utils$dom();
              this.isCollapsed() && this.updateCollapsed();
              this.isEnabled() || this.updateDisabled();
              this.workspace.getRenderer().render(this);
              this.tightenChildrenEfficiently();
              stopTextWidthCache$$module$build$src$core$utils$dom();
            }
            tightenChildrenEfficiently() {
              for (const a of this.inputList) {
                const b = a.connection;
                b && b.tightenEfficiently();
              }
              this.nextConnection && this.nextConnection.tightenEfficiently();
            }
            getHeightWidth() {
              let a = this.height, b = this.width;
              var c = this.getNextBlock();
              if (c) {
                c = c.getHeightWidth();
                const d = this.workspace.getRenderer().getConstants().NOTCH_HEIGHT;
                a += c.height - d;
                b = Math.max(b, c.width);
              }
              return { height: a, width: b };
            }
            fadeForReplacement(a) {
              this.pathObject.updateReplacementFade(a);
            }
            highlightShapeForInput(a, b) {
              this.pathObject.updateShapeForInputHighlight(a, b);
            }
            getDragStrategy() {
              return this.dragStrategy;
            }
            setDragStrategy(a) {
              this.dragStrategy = a;
            }
            isCopyable() {
              return this.isOwnDeletable() && this.isOwnMovable();
            }
            isMovable() {
              return this.dragStrategy.isMovable();
            }
            startDrag(a) {
              this.dragStrategy.startDrag(a);
            }
            drag(a, b) {
              this.dragStrategy.drag(a, b);
            }
            endDrag(a) {
              this.dragStrategy.endDrag(a);
            }
            revertDrag() {
              this.dragStrategy.revertDrag();
            }
            toFlyoutInfo() {
              const a = Object.assign({}, { kind: "BLOCK" }, save$$module$build$src$core$serialization$blocks(this)), b = /* @__PURE__ */ new Set(["id", "height", "width", "pinned", "enabled"]), c = function(d) {
                for (const e in d) b.has(e) ? delete d[e] : typeof d[e] === "object" && c(d[e]);
              };
              c(a);
              return [a];
            }
            jsonInit(a) {
              super.jsonInit(a);
              a.classes && this.addClass(Array.isArray(a.classes) ? a.classes.join(" ") : a.classes);
            }
            getFocusableElement() {
              return this.pathObject.svgPath;
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              this.select();
              this.workspace.scrollBoundsIntoView(this.getBoundingRectangleWithoutChildren());
            }
            onNodeBlur() {
              this.unselect();
            }
            canBeFocused() {
              return true;
            }
          };
          BlockSvg$$module$build$src$core$block_svg.INLINE = -1;
          BlockSvg$$module$build$src$core$block_svg.COLLAPSED_WARNING_ID = "TEMP_COLLAPSED_WARNING_";
          var module$build$src$core$block_svg = {};
          module$build$src$core$block_svg.BlockSvg = BlockSvg$$module$build$src$core$block_svg;
          var DragTarget$$module$build$src$core$drag_target = class {
            constructor() {
            }
            onDragEnter(a) {
            }
            onDragOver(a) {
            }
            onDragExit(a) {
            }
            onDrop(a) {
            }
            getClientRect() {
              return null;
            }
            shouldPreventMove(a) {
              return false;
            }
          }, module$build$src$core$drag_target = {};
          module$build$src$core$drag_target.DragTarget = DragTarget$$module$build$src$core$drag_target;
          var module$build$src$core$interfaces$i_deletable = {};
          module$build$src$core$interfaces$i_deletable.isDeletable = isDeletable$$module$build$src$core$interfaces$i_deletable;
          var DeleteArea$$module$build$src$core$delete_area = class extends DragTarget$$module$build$src$core$drag_target {
            constructor() {
              super();
              this.wouldDelete_ = false;
            }
            wouldDelete(a) {
              a instanceof BlockSvg$$module$build$src$core$block_svg ? (a = !a.getParent() && a.isDeletable(), this.updateWouldDelete_(a)) : this.updateWouldDelete_(isDeletable$$module$build$src$core$interfaces$i_deletable(a) && a.isDeletable());
              return this.wouldDelete_;
            }
            updateWouldDelete_(a) {
              this.wouldDelete_ = a;
            }
          }, module$build$src$core$delete_area = {};
          module$build$src$core$delete_area.DeleteArea = DeleteArea$$module$build$src$core$delete_area;
          var FlyoutItem$$module$build$src$core$flyout_item = class {
            constructor(a, b) {
              this.element = a;
              this.type = b;
            }
            getElement() {
              return this.element;
            }
            getType() {
              return this.type;
            }
          }, module$build$src$core$flyout_item = {};
          module$build$src$core$flyout_item.FlyoutItem = FlyoutItem$$module$build$src$core$flyout_item;
          var MetricsManager$$module$build$src$core$metrics_manager = class {
            constructor(a) {
              this.workspace_ = a;
            }
            getDimensionsPx_(a) {
              let b = 0, c = 0;
              a && (b = a.getWidth(), c = a.getHeight());
              return new Size$$module$build$src$core$utils$size(b, c);
            }
            getFlyoutMetrics(a) {
              a = this.getDimensionsPx_(this.workspace_.getFlyout(a));
              return { width: a.width, height: a.height, position: this.workspace_.toolboxPosition };
            }
            getToolboxMetrics() {
              const a = this.getDimensionsPx_(this.workspace_.getToolbox());
              return { width: a.width, height: a.height, position: this.workspace_.toolboxPosition };
            }
            getSvgMetrics() {
              return this.workspace_.getCachedParentSvgSize();
            }
            getAbsoluteMetrics() {
              let a = 0, b = 0;
              const c = this.getToolboxMetrics(), d = this.getFlyoutMetrics(), e = !!this.workspace_.getToolbox();
              var f;
              const g = !((f = this.workspace_.getFlyout()) == null ? 0 : f.autoClose);
              f = e ? c.position : d.position;
              const h = f === Position$$module$build$src$core$utils$toolbox.TOP;
              f === Position$$module$build$src$core$utils$toolbox.LEFT && (e && (a += c.width), g && (a += d.width));
              h && (e && (b += c.height), g && (b += d.height));
              return { top: b, left: a };
            }
            getViewMetrics(a) {
              a = a ? this.workspace_.scale : 1;
              const b = this.getSvgMetrics(), c = this.getToolboxMetrics(), d = this.getFlyoutMetrics(), e = !!this.workspace_.getToolbox();
              var f;
              const g = !((f = this.workspace_.getFlyout()) == null ? 0 : f.autoClose);
              f = e ? c.position : d.position;
              const h = f === Position$$module$build$src$core$utils$toolbox.LEFT || f === Position$$module$build$src$core$utils$toolbox.RIGHT;
              if (f === Position$$module$build$src$core$utils$toolbox.TOP || f === Position$$module$build$src$core$utils$toolbox.BOTTOM) e && (b.height -= c.height), g && (b.height -= d.height);
              h && (e && (b.width -= c.width), g && (b.width -= d.width));
              return { height: b.height / a, width: b.width / a, top: -this.workspace_.scrollY / a, left: -this.workspace_.scrollX / a };
            }
            getContentMetrics(a) {
              a = a ? 1 : this.workspace_.scale;
              const b = this.workspace_.getBlocksBoundingBox();
              return { height: (b.bottom - b.top) * a, width: (b.right - b.left) * a, top: b.top * a, left: b.left * a };
            }
            hasFixedEdges() {
              return !this.workspace_.isMovableHorizontally() || !this.workspace_.isMovableVertically();
            }
            getComputedFixedEdges_(a) {
              if (!this.hasFixedEdges()) return {};
              const b = this.workspace_.isMovableHorizontally(), c = this.workspace_.isMovableVertically();
              a = a || this.getViewMetrics(false);
              const d = {};
              c || (d.top = a.top, d.bottom = a.top + a.height);
              b || (d.left = a.left, d.right = a.left + a.width);
              return d;
            }
            getPaddedContent_(a, b) {
              const c = b.top + b.height, d = b.left + b.width, e = a.width;
              a = a.height;
              const f = e / 2, g = a / 2;
              return { top: Math.min(b.top - g, c - a), bottom: Math.max(c + g, b.top + a), left: Math.min(b.left - f, d - e), right: Math.max(d + f, b.left + e) };
            }
            getScrollMetrics(a, b, c) {
              a = a ? this.workspace_.scale : 1;
              b = b || this.getViewMetrics(false);
              var d = c || this.getContentMetrics();
              c = this.getComputedFixedEdges_(b);
              b = this.getPaddedContent_(b, d);
              d = c.top !== void 0 ? c.top : b.top;
              const e = c.left !== void 0 ? c.left : b.left;
              return { top: d / a, left: e / a, width: ((c.right !== void 0 ? c.right : b.right) - e) / a, height: ((c.bottom !== void 0 ? c.bottom : b.bottom) - d) / a };
            }
            getUiMetrics() {
              return { viewMetrics: this.getViewMetrics(), absoluteMetrics: this.getAbsoluteMetrics(), toolboxMetrics: this.getToolboxMetrics() };
            }
            getMetrics() {
              const a = this.getToolboxMetrics(), b = this.getFlyoutMetrics(true), c = this.getSvgMetrics(), d = this.getAbsoluteMetrics(), e = this.getViewMetrics(), f = this.getContentMetrics(), g = this.getScrollMetrics(false, e, f);
              return { contentHeight: f.height, contentWidth: f.width, contentTop: f.top, contentLeft: f.left, scrollHeight: g.height, scrollWidth: g.width, scrollTop: g.top, scrollLeft: g.left, viewHeight: e.height, viewWidth: e.width, viewTop: e.top, viewLeft: e.left, absoluteTop: d.top, absoluteLeft: d.left, svgHeight: c.height, svgWidth: c.width, toolboxWidth: a.width, toolboxHeight: a.height, toolboxPosition: a.position, flyoutWidth: b.width, flyoutHeight: b.height };
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.METRICS_MANAGER, DEFAULT$$module$build$src$core$registry, MetricsManager$$module$build$src$core$metrics_manager);
          var module$build$src$core$metrics_manager = {};
          module$build$src$core$metrics_manager.MetricsManager = MetricsManager$$module$build$src$core$metrics_manager;
          var FlyoutMetricsManager$$module$build$src$core$flyout_metrics_manager = class extends MetricsManager$$module$build$src$core$metrics_manager {
            constructor(a, b) {
              super(a);
              this.flyout_ = b;
            }
            getBoundingBox() {
              let a;
              try {
                a = this.workspace_.getCanvas().getBBox();
              } catch (b) {
                a = { height: 0, y: 0, width: 0, x: 0 };
              }
              return a;
            }
            getContentMetrics(a) {
              const b = this.getBoundingBox();
              a = a ? 1 : this.workspace_.scale;
              return { height: b.height * a, width: b.width * a, top: b.y * a, left: b.x * a };
            }
            getScrollMetrics(a, b, c) {
              b = c || this.getContentMetrics();
              c = this.flyout_.MARGIN * this.workspace_.scale;
              a = a ? this.workspace_.scale : 1;
              return { height: (b.height + 2 * c) / a, width: (b.width + b.left + c) / a, top: 0, left: 0 };
            }
          }, module$build$src$core$flyout_metrics_manager = {};
          module$build$src$core$flyout_metrics_manager.FlyoutMetricsManager = FlyoutMetricsManager$$module$build$src$core$flyout_metrics_manager;
          var FlyoutButton$$module$build$src$core$flyout_button = class {
            constructor(a, b, c, d) {
              this.workspace = a;
              this.targetWorkspace = b;
              this.isFlyoutLabel = d;
              this.height = this.width = 0;
              this.cursorSvg = this.svgText = null;
              this.text = c.text;
              this.position = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.callbackKey = c.callbackKey || c.callbackkey;
              this.cssClass = c["web-class"] || null;
              this.info = c;
              a = this.isFlyoutLabel ? "blocklyFlyoutLabel" : "blocklyFlyoutButton";
              this.cssClass && (a += " " + this.cssClass);
              this.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.svgGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { id: this.id, "class": a }, this.workspace.getCanvas());
              let e;
              this.isFlyoutLabel || (e = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyFlyoutButtonShadow", rx: FlyoutButton$$module$build$src$core$flyout_button.BORDER_RADIUS, ry: FlyoutButton$$module$build$src$core$flyout_button.BORDER_RADIUS, x: 1, y: 1 }, this.svgGroup));
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.RECT,
                { "class": this.isFlyoutLabel ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground", rx: FlyoutButton$$module$build$src$core$flyout_button.BORDER_RADIUS, ry: FlyoutButton$$module$build$src$core$flyout_button.BORDER_RADIUS },
                this.svgGroup
              );
              b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.TEXT, { "class": this.isFlyoutLabel ? "blocklyFlyoutLabelText" : "blocklyText", x: 0, y: 0, "text-anchor": "middle" }, this.svgGroup);
              c = replaceMessageReferences$$module$build$src$core$utils$parsing(this.text);
              this.workspace.RTL && (c += "\u200F");
              b.textContent = c;
              this.isFlyoutLabel && (this.svgText = b, this.workspace.getThemeManager().subscribe(this.svgText, "flyoutForegroundColour", "fill"));
              d = getComputedStyle$$module$build$src$core$utils$style(b, "fontSize");
              const f = getComputedStyle$$module$build$src$core$utils$style(b, "fontWeight"), g = getComputedStyle$$module$build$src$core$utils$style(b, "fontFamily");
              this.width = getFastTextWidthWithSizeString$$module$build$src$core$utils$dom(b, d, f, g);
              c = measureFontMetrics$$module$build$src$core$utils$dom(
                c,
                d,
                f,
                g
              );
              this.height = this.height || c.height;
              if (!this.isFlyoutLabel) {
                this.width += 2 * FlyoutButton$$module$build$src$core$flyout_button.TEXT_MARGIN_X;
                this.height += 2 * FlyoutButton$$module$build$src$core$flyout_button.TEXT_MARGIN_Y;
                let h;
                (h = e) == null || h.setAttribute("width", String(this.width));
                let k;
                (k = e) == null || k.setAttribute("height", String(this.height));
              }
              a.setAttribute("width", String(this.width));
              a.setAttribute("height", String(this.height));
              b.setAttribute("x", String(this.width / 2));
              b.setAttribute("y", String(this.height / 2 - c.height / 2 + c.baseline));
              this.updateTransform();
              this.onMouseDownWrapper = conditionalBind$$module$build$src$core$browser_events(this.svgGroup, "pointerdown", this, this.onMouseDown);
              this.onMouseUpWrapper = conditionalBind$$module$build$src$core$browser_events(this.svgGroup, "pointerup", this, this.onMouseUp);
            }
            createDom() {
              return this.svgGroup;
            }
            show() {
              this.updateTransform();
              this.svgGroup.setAttribute("display", "block");
            }
            updateTransform() {
              this.svgGroup.setAttribute("transform", "translate(" + this.position.x + "," + this.position.y + ")");
            }
            moveTo(a, b) {
              this.position.x = a;
              this.position.y = b;
              this.updateTransform();
            }
            moveBy(a, b, c) {
              this.moveTo(this.position.x + a, this.position.y + b);
            }
            isLabel() {
              return this.isFlyoutLabel;
            }
            getPosition() {
              return this.position;
            }
            getBoundingRectangle() {
              return new Rect$$module$build$src$core$utils$rect(this.position.y, this.position.y + this.height, this.position.x, this.position.x + this.width);
            }
            getButtonText() {
              return this.text;
            }
            getTargetWorkspace() {
              return this.targetWorkspace;
            }
            getWorkspace() {
              return this.workspace;
            }
            dispose() {
              unbind$$module$build$src$core$browser_events(this.onMouseDownWrapper);
              unbind$$module$build$src$core$browser_events(this.onMouseUpWrapper);
              this.svgGroup && removeNode$$module$build$src$core$utils$dom(this.svgGroup);
              this.svgText && this.workspace.getThemeManager().unsubscribe(this.svgText);
            }
            setCursorSvg(a) {
              a ? this.svgGroup && (this.svgGroup.appendChild(a), this.cursorSvg = a) : this.cursorSvg = null;
            }
            onMouseUp(a) {
              (a = this.targetWorkspace.getGesture(a)) && a.cancel();
              this.isFlyoutLabel && this.callbackKey ? console.warn("Labels should not have callbacks. Label text: " + this.text) : this.isFlyoutLabel || this.callbackKey && this.targetWorkspace.getButtonCallback(this.callbackKey) ? this.isFlyoutLabel || (a = this.targetWorkspace.getButtonCallback(this.callbackKey)) && a(this) : console.warn("Buttons should have callbacks. Button text: " + this.text);
            }
            onMouseDown(a) {
              const b = this.targetWorkspace.getGesture(a), c = this.targetWorkspace.getFlyout();
              b && c && b.handleFlyoutStart(a, c);
            }
            getSvgRoot() {
              return this.svgGroup;
            }
            getFocusableElement() {
              return this.svgGroup;
            }
            getFocusableTree() {
              return this.workspace;
            }
            onNodeFocus() {
              var a = this.getPosition();
              a = new Rect$$module$build$src$core$utils$rect(a.y, a.y + this.height, a.x, a.x + this.width);
              this.workspace.scrollBoundsIntoView(a);
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
          };
          FlyoutButton$$module$build$src$core$flyout_button.TEXT_MARGIN_X = 5;
          FlyoutButton$$module$build$src$core$flyout_button.TEXT_MARGIN_Y = 2;
          FlyoutButton$$module$build$src$core$flyout_button.BORDER_RADIUS = 4;
          register$$module$build$src$core$css("\n.blocklyFlyoutButton {\n  fill: #888;\n  cursor: default;\n}\n\n.blocklyFlyoutButtonShadow {\n  fill: #666;\n}\n\n.blocklyFlyoutButton:hover {\n  fill: #aaa;\n}\n\n.blocklyFlyoutLabel {\n  cursor: default;\n}\n\n.blocklyFlyoutLabelBackground {\n  opacity: 0;\n}\n");
          var module$build$src$core$flyout_button = {};
          module$build$src$core$flyout_button.FlyoutButton = FlyoutButton$$module$build$src$core$flyout_button;
          var FlyoutButtonNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_button_navigation_policy = class {
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return a.getWorkspace();
            }
            getNextSibling(a) {
              return null;
            }
            getPreviousSibling(a) {
              return null;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof FlyoutButton$$module$build$src$core$flyout_button;
            }
          }, module$build$src$core$keyboard_nav$flyout_button_navigation_policy = {};
          module$build$src$core$keyboard_nav$flyout_button_navigation_policy.FlyoutButtonNavigationPolicy = FlyoutButtonNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_button_navigation_policy;
          var FlyoutNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_navigation_policy = class {
            constructor(a, b) {
              this.policy = a;
              this.flyout = b;
            }
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return this.policy.getParent(a);
            }
            getNextSibling(a) {
              const b = this.flyout.getContents();
              if (!b) return null;
              let c = b.findIndex((d) => d.getElement() === a);
              if (c === -1) return null;
              c++;
              c >= b.length && (c = 0);
              return b[c].getElement();
            }
            getPreviousSibling(a) {
              const b = this.flyout.getContents();
              if (!b) return null;
              let c = b.findIndex((d) => d.getElement() === a);
              if (c === -1) return null;
              c--;
              c < 0 && (c = b.length - 1);
              return b[c].getElement();
            }
            isNavigable(a) {
              return this.policy.isNavigable(a);
            }
            isApplicable(a) {
              return this.policy.isApplicable(a);
            }
          }, module$build$src$core$keyboard_nav$flyout_navigation_policy = {};
          module$build$src$core$keyboard_nav$flyout_navigation_policy.FlyoutNavigationPolicy = FlyoutNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_navigation_policy;
          var FlyoutSeparator$$module$build$src$core$flyout_separator = class {
            constructor(a, b) {
              this.gap = a;
              this.axis = b;
              this.y = this.x = 0;
            }
            getBoundingRectangle() {
              switch (this.axis) {
                case "x":
                  return new Rect$$module$build$src$core$utils$rect(this.y, this.y, this.x, this.x + this.gap);
                case "y":
                  return new Rect$$module$build$src$core$utils$rect(this.y, this.y + this.gap, this.x, this.x);
              }
            }
            moveBy(a, b, c) {
              this.x += a;
              this.y += b;
            }
            isNavigable() {
              return false;
            }
            getFocusableElement() {
              throw Error("Cannot be focused");
            }
            getFocusableTree() {
              throw Error("Cannot be focused");
            }
            onNodeFocus() {
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return false;
            }
          }, module$build$src$core$flyout_separator = {};
          module$build$src$core$flyout_separator.FlyoutSeparator = FlyoutSeparator$$module$build$src$core$flyout_separator;
          var FlyoutSeparatorNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_separator_navigation_policy = class {
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return null;
            }
            getNextSibling(a) {
              return null;
            }
            getPreviousSibling(a) {
              return null;
            }
            isNavigable(a) {
              return false;
            }
            isApplicable(a) {
              return a instanceof FlyoutSeparator$$module$build$src$core$flyout_separator;
            }
          }, module$build$src$core$keyboard_nav$flyout_separator_navigation_policy = {};
          module$build$src$core$keyboard_nav$flyout_separator_navigation_policy.FlyoutSeparatorNavigationPolicy = FlyoutSeparatorNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_separator_navigation_policy;
          var BlockCommentNavigationPolicy$$module$build$src$core$keyboard_nav$block_comment_navigation_policy = class {
            getFirstChild(a) {
              return a.getEditor();
            }
            getParent(a) {
              let b;
              return (b = a.getOwner()) != null ? b : null;
            }
            getNextSibling(a) {
              return null;
            }
            getPreviousSibling(a) {
              return null;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof TextInputBubble$$module$build$src$core$bubbles$textinput_bubble;
            }
          }, module$build$src$core$keyboard_nav$block_comment_navigation_policy = {};
          module$build$src$core$keyboard_nav$block_comment_navigation_policy.BlockCommentNavigationPolicy = BlockCommentNavigationPolicy$$module$build$src$core$keyboard_nav$block_comment_navigation_policy;
          var BlockNavigationPolicy$$module$build$src$core$keyboard_nav$block_navigation_policy = class {
            getFirstChild(a) {
              return getBlockNavigationCandidates$$module$build$src$core$keyboard_nav$block_navigation_policy(a, true)[0];
            }
            getParent(a) {
              var b;
              if ((b = a.previousConnection) == null ? 0 : b.targetBlock()) {
                if (b = a.getSurroundParent()) return b;
              } else {
                let c;
                if ((c = a.outputConnection) == null ? 0 : c.targetBlock()) return a.outputConnection.targetBlock();
              }
              return a.workspace;
            }
            getNextSibling(a) {
              let b;
              if ((b = a.nextConnection) == null ? 0 : b.targetBlock()) {
                let d;
                return (d = a.nextConnection) == null ? void 0 : d.targetBlock();
              }
              let c;
              return ((c = a.outputConnection) == null ? 0 : c.targetBlock()) ? navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1) : a.getSurroundParent() ? navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a.getTopStackBlock(), 1) : this.getParent(a) instanceof WorkspaceSvg$$module$build$src$core$workspace_svg ? navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1) : null;
            }
            getPreviousSibling(a) {
              let b;
              if ((b = a.previousConnection) == null ? 0 : b.targetBlock()) {
                let d;
                return (d = a.previousConnection) == null ? void 0 : d.targetBlock();
              }
              let c;
              return ((c = a.outputConnection) == null ? 0 : c.targetBlock()) ? navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1) : this.getParent(a) instanceof WorkspaceSvg$$module$build$src$core$workspace_svg ? navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1) : null;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof BlockSvg$$module$build$src$core$block_svg;
            }
          }, module$build$src$core$keyboard_nav$block_navigation_policy = {};
          module$build$src$core$keyboard_nav$block_navigation_policy.BlockNavigationPolicy = BlockNavigationPolicy$$module$build$src$core$keyboard_nav$block_navigation_policy;
          module$build$src$core$keyboard_nav$block_navigation_policy.navigateBlock = navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy;
          module$build$src$core$keyboard_nav$block_navigation_policy.navigateStacks = navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy;
          var CommentBarButtonNavigationPolicy$$module$build$src$core$keyboard_nav$comment_bar_button_navigation_policy = class {
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return a.getCommentView().workspace.getCommentById(a.getCommentView().commentId);
            }
            getNextSibling(a) {
              const b = a.getCommentView().getCommentBarButtons();
              a = b.indexOf(a);
              return a >= 0 && a + 1 < b.length ? b[a + 1] : null;
            }
            getPreviousSibling(a) {
              const b = a.getCommentView().getCommentBarButtons();
              a = b.indexOf(a);
              return a > 0 ? b[a - 1] : null;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof CommentBarButton$$module$build$src$core$comments$comment_bar_button;
            }
          }, module$build$src$core$keyboard_nav$comment_bar_button_navigation_policy = {};
          module$build$src$core$keyboard_nav$comment_bar_button_navigation_policy.CommentBarButtonNavigationPolicy = CommentBarButtonNavigationPolicy$$module$build$src$core$keyboard_nav$comment_bar_button_navigation_policy;
          var CommentEditorNavigationPolicy$$module$build$src$core$keyboard_nav$comment_editor_navigation_policy = class {
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return null;
            }
            getNextSibling(a) {
              return null;
            }
            getPreviousSibling(a) {
              return null;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof CommentEditor$$module$build$src$core$comments$comment_editor;
            }
          }, module$build$src$core$keyboard_nav$comment_editor_navigation_policy = {};
          module$build$src$core$keyboard_nav$comment_editor_navigation_policy.CommentEditorNavigationPolicy = CommentEditorNavigationPolicy$$module$build$src$core$keyboard_nav$comment_editor_navigation_policy;
          var ConnectionNavigationPolicy$$module$build$src$core$keyboard_nav$connection_navigation_policy = class {
            getFirstChild(a) {
              return a.getParentInput() ? a.targetConnection : null;
            }
            getParent(a) {
              return a.getSourceBlock();
            }
            getNextSibling(a) {
              if (a.getParentInput()) return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1);
              if (a.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT) {
                const c = a.targetConnection;
                var b = a.getSourceBlock();
                if (!c && b.getRootBlock().lastConnectionInStack(false) === a) {
                  a = b.workspace.getTopBlocks(true);
                  b = a.indexOf(b.getRootBlock()) + 1;
                  b >= a.length && (b = 0);
                  b = a[b];
                  let d;
                  return (d = this.getParentConnection(b)) != null ? d : b;
                }
                return c;
              }
              return a.getSourceBlock();
            }
            getPreviousSibling(a) {
              if (a.getParentInput()) return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1);
              if (a.type === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT || a.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE) {
                const c = a.targetConnection && !a.targetConnection.getParentInput() ? a.targetConnection : null;
                var b = a.getSourceBlock();
                if (!c && this.getParentConnection(b.getRootBlock()) === a) {
                  a = b.workspace.getTopBlocks(true);
                  b = a.indexOf(b.getRootBlock()) - 1;
                  b < 0 && (b = a.length - 1);
                  b = a[b];
                  let d;
                  return (d = b.lastConnectionInStack(false)) != null ? d : b;
                }
                return c;
              }
              return a.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT ? a.getSourceBlock() : null;
            }
            getParentConnection(a) {
              let b;
              return !a.outputConnection || ((b = a.previousConnection) == null ? 0 : b.isConnected()) ? a.previousConnection : a.outputConnection;
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof RenderedConnection$$module$build$src$core$rendered_connection;
            }
          }, module$build$src$core$keyboard_nav$connection_navigation_policy = {};
          module$build$src$core$keyboard_nav$connection_navigation_policy.ConnectionNavigationPolicy = ConnectionNavigationPolicy$$module$build$src$core$keyboard_nav$connection_navigation_policy;
          var FieldNavigationPolicy$$module$build$src$core$keyboard_nav$field_navigation_policy = class {
            getFirstChild(a) {
              return null;
            }
            getParent(a) {
              return a.getSourceBlock();
            }
            getNextSibling(a) {
              return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1);
            }
            getPreviousSibling(a) {
              return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1);
            }
            isNavigable(a) {
              let b;
              return a.canBeFocused() && a.isVisible() && (a.isClickable() || a.isCurrentlyEditable()) && !(((b = a.getSourceBlock()) == null ? 0 : b.isSimpleReporter()) && a.isFullBlockField()) && a.getParentInput().isVisible();
            }
            isApplicable(a) {
              return a instanceof Field$$module$build$src$core$field;
            }
          }, module$build$src$core$keyboard_nav$field_navigation_policy = {};
          module$build$src$core$keyboard_nav$field_navigation_policy.FieldNavigationPolicy = FieldNavigationPolicy$$module$build$src$core$keyboard_nav$field_navigation_policy;
          var module$build$src$core$icons$registry = {};
          module$build$src$core$icons$registry.register = register$$module$build$src$core$icons$registry;
          module$build$src$core$icons$registry.unregister = unregister$$module$build$src$core$icons$registry;
          var SIZE$$module$build$src$core$icons$comment_icon = 17, DEFAULT_BUBBLE_WIDTH$$module$build$src$core$icons$comment_icon = 160, DEFAULT_BUBBLE_HEIGHT$$module$build$src$core$icons$comment_icon = 80, CommentIcon$$module$build$src$core$icons$comment_icon = class extends Icon$$module$build$src$core$icons$icon {
            constructor(a) {
              super(a);
              this.sourceBlock = a;
              this.textInputBubble = null;
              this.text = "";
              this.bubbleSize = new Size$$module$build$src$core$utils$size(DEFAULT_BUBBLE_WIDTH$$module$build$src$core$icons$comment_icon, DEFAULT_BUBBLE_HEIGHT$$module$build$src$core$icons$comment_icon);
              this.bubbleVisiblity = false;
            }
            getType() {
              return CommentIcon$$module$build$src$core$icons$comment_icon.TYPE;
            }
            initView(a) {
              this.svgRoot || (super.initView(a), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CIRCLE, { "class": "blocklyIconShape", r: "8", cx: "8", cy: "8" }, this.svgRoot), createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.PATH,
                { "class": "blocklyIconSymbol", d: "m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.4050.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25-1.201,0.998 -1.201,1.528 -1.204,2.19z" },
                this.svgRoot
              ), createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { "class": "blocklyIconSymbol", x: "6.8", y: "10.78", height: "2", width: "2" }, this.svgRoot), addClass$$module$build$src$core$utils$dom(this.svgRoot, "blocklyCommentIcon"));
            }
            dispose() {
              super.dispose();
              let a;
              (a = this.textInputBubble) == null || a.dispose();
            }
            getWeight() {
              return CommentIcon$$module$build$src$core$icons$comment_icon.WEIGHT;
            }
            getSize() {
              return new Size$$module$build$src$core$utils$size(
                SIZE$$module$build$src$core$icons$comment_icon,
                SIZE$$module$build$src$core$icons$comment_icon
              );
            }
            applyColour() {
              super.applyColour();
              const a = this.sourceBlock.getColour();
              let b;
              (b = this.textInputBubble) == null || b.setColour(a);
            }
            updateEditable() {
              const a = this, b = () => super.updateEditable;
              return (0, $jscomp.asyncExecutePromiseGeneratorFunction)(function* () {
                b().call(a);
                a.bubbleIsVisible() && (yield a.setBubbleVisible(false), yield a.setBubbleVisible(true));
              });
            }
            onLocationChange(a) {
              const b = this.workspaceLocation;
              super.onLocationChange(a);
              this.bubbleLocation && (a = Coordinate$$module$build$src$core$utils$coordinate.difference(
                this.workspaceLocation,
                b
              ), this.bubbleLocation = Coordinate$$module$build$src$core$utils$coordinate.sum(this.bubbleLocation, a));
              a = this.getAnchorLocation();
              let c;
              (c = this.textInputBubble) == null || c.setAnchorLocation(a);
            }
            setText(a) {
              const b = this.text;
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this.sourceBlock, "comment", null, b, a));
              this.text = a;
              let c;
              (c = this.textInputBubble) == null || c.setText(this.text);
            }
            getText() {
              return this.text;
            }
            setBubbleSize(a) {
              this.bubbleSize = a;
              let b;
              (b = this.textInputBubble) == null || b.setSize(this.bubbleSize, true);
            }
            getBubbleSize() {
              return this.bubbleSize;
            }
            setBubbleLocation(a) {
              this.bubbleLocation = a;
              let b;
              (b = this.textInputBubble) == null || b.moveDuringDrag(a);
            }
            getBubbleLocation() {
              return this.bubbleLocation;
            }
            saveState() {
              if (this.text) {
                const a = { text: this.text, pinned: this.bubbleIsVisible(), height: this.bubbleSize.height, width: this.bubbleSize.width }, b = this.getBubbleLocation();
                b && (a.x = this.sourceBlock.workspace.RTL ? this.sourceBlock.workspace.getWidth() - (b.x + this.bubbleSize.width) : b.x, a.y = b.y);
                return a;
              }
              return null;
            }
            loadState(a) {
              let b;
              this.text = (b = a.text) != null ? b : "";
              let c, d;
              this.bubbleSize = new Size$$module$build$src$core$utils$size((c = a.width) != null ? c : DEFAULT_BUBBLE_WIDTH$$module$build$src$core$icons$comment_icon, (d = a.height) != null ? d : DEFAULT_BUBBLE_HEIGHT$$module$build$src$core$icons$comment_icon);
              let e;
              this.bubbleVisiblity = (e = a.pinned) != null ? e : false;
              this.setBubbleVisible(this.bubbleVisiblity);
              let f = a.x;
              const g = a.y;
              finishQueuedRenders$$module$build$src$core$render_management().then(() => {
                f && g && (f = this.sourceBlock.workspace.RTL ? this.sourceBlock.workspace.getWidth() - (f + this.bubbleSize.width) : f, this.setBubbleLocation(new Coordinate$$module$build$src$core$utils$coordinate(f, g)));
              });
            }
            onClick() {
              super.onClick();
              this.setBubbleVisible(!this.bubbleIsVisible());
            }
            isClickableInFlyout() {
              return false;
            }
            onTextChange() {
              if (this.textInputBubble) {
                var a = this.textInputBubble.getText();
                this.text !== a && (fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(
                  this.sourceBlock,
                  "comment",
                  null,
                  this.text,
                  a
                )), this.text = a);
              }
            }
            onSizeChange() {
              this.textInputBubble && (this.bubbleSize = this.textInputBubble.getSize());
            }
            onBubbleLocationChange() {
              this.textInputBubble && (this.bubbleLocation = this.textInputBubble.getRelativeToSurfaceXY());
            }
            bubbleIsVisible() {
              return this.bubbleVisiblity;
            }
            setBubbleVisible(a) {
              const b = this;
              return (0, $jscomp.asyncExecutePromiseGeneratorFunction)(function* () {
                b.bubbleVisiblity !== a && (b.bubbleVisiblity = a, yield finishQueuedRenders$$module$build$src$core$render_management(), !b.sourceBlock.rendered || b.sourceBlock.isInFlyout || b.sourceBlock.isInsertionMarker() || (a ? (b.sourceBlock.isEditable() ? b.showEditableBubble() : b.showNonEditableBubble(), b.applyColour()) : b.hideBubble(), fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BUBBLE_OPEN))(b.sourceBlock, a, "comment"))));
              });
            }
            getBubble() {
              return this.textInputBubble;
            }
            showEditableBubble() {
              this.createBubble();
              let a;
              (a = this.textInputBubble) == null || a.addTextChangeListener(() => this.onTextChange());
              let b;
              (b = this.textInputBubble) == null || b.addSizeChangeListener(() => this.onSizeChange());
            }
            showNonEditableBubble() {
              this.createBubble();
              let a;
              (a = this.textInputBubble) == null || a.setEditable(false);
            }
            createBubble() {
              this.textInputBubble = new TextInputBubble$$module$build$src$core$bubbles$textinput_bubble(this.sourceBlock.workspace, this.getAnchorLocation(), this.getBubbleOwnerRect(), this);
              this.textInputBubble.setText(this.getText());
              this.textInputBubble.setSize(this.bubbleSize, true);
              this.bubbleLocation && this.textInputBubble.moveDuringDrag(this.bubbleLocation);
              this.textInputBubble.addTextChangeListener(() => this.onTextChange());
              this.textInputBubble.addSizeChangeListener(() => this.onSizeChange());
              this.textInputBubble.addLocationChangeListener(() => this.onBubbleLocationChange());
            }
            hideBubble() {
              let a;
              (a = this.textInputBubble) == null || a.dispose();
              this.textInputBubble = null;
            }
            getAnchorLocation() {
              const a = SIZE$$module$build$src$core$icons$comment_icon / 2;
              return Coordinate$$module$build$src$core$utils$coordinate.sum(
                this.workspaceLocation,
                new Coordinate$$module$build$src$core$utils$coordinate(a, a)
              );
            }
            getBubbleOwnerRect() {
              return this.sourceBlock.getBoundingRectangleWithoutChildren();
            }
          };
          CommentIcon$$module$build$src$core$icons$comment_icon.TYPE = IconType$$module$build$src$core$icons$icon_types.COMMENT;
          CommentIcon$$module$build$src$core$icons$comment_icon.WEIGHT = 3;
          register$$module$build$src$core$icons$registry(CommentIcon$$module$build$src$core$icons$comment_icon.TYPE, CommentIcon$$module$build$src$core$icons$comment_icon);
          var module$build$src$core$icons$comment_icon = {};
          module$build$src$core$icons$comment_icon.CommentIcon = CommentIcon$$module$build$src$core$icons$comment_icon;
          var IconNavigationPolicy$$module$build$src$core$keyboard_nav$icon_navigation_policy = class {
            getFirstChild(a) {
              if (a instanceof $.MutatorIcon$$module$build$src$core$icons$mutator_icon && a.bubbleIsVisible() && $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === a) {
                let b, c;
                return (c = (b = a.getBubble()) == null ? void 0 : b.getWorkspace()) != null ? c : null;
              }
              if (a instanceof CommentIcon$$module$build$src$core$icons$comment_icon && a.bubbleIsVisible() && $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode() === a) {
                let b, c;
                return (c = (b = a.getBubble()) == null ? void 0 : b.getEditor()) != null ? c : null;
              }
              return null;
            }
            getParent(a) {
              return a.getSourceBlock();
            }
            getNextSibling(a) {
              return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1);
            }
            getPreviousSibling(a) {
              return navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1);
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof Icon$$module$build$src$core$icons$icon;
            }
          }, module$build$src$core$keyboard_nav$icon_navigation_policy = {};
          module$build$src$core$keyboard_nav$icon_navigation_policy.IconNavigationPolicy = IconNavigationPolicy$$module$build$src$core$keyboard_nav$icon_navigation_policy;
          var WorkspaceCommentNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_comment_navigation_policy = class {
            getFirstChild(a) {
              return a.view.getCommentBarButtons()[0];
            }
            getParent(a) {
              return a.workspace;
            }
            getNextSibling(a) {
              return navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy(a, 1);
            }
            getPreviousSibling(a) {
              return navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy(a, -1);
            }
            isNavigable(a) {
              return a.canBeFocused();
            }
            isApplicable(a) {
              return a instanceof RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment;
            }
          }, module$build$src$core$keyboard_nav$workspace_comment_navigation_policy = {};
          module$build$src$core$keyboard_nav$workspace_comment_navigation_policy.WorkspaceCommentNavigationPolicy = WorkspaceCommentNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_comment_navigation_policy;
          var WorkspaceNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_navigation_policy = class {
            getFirstChild(a) {
              a = a.getTopBlocks(true);
              return a.length ? a[0] : null;
            }
            getParent(a) {
              return null;
            }
            getNextSibling(a) {
              return null;
            }
            getPreviousSibling(a) {
              return null;
            }
            isNavigable(a) {
              return a.canBeFocused() && !a.isMutator;
            }
            isApplicable(a) {
              return a instanceof WorkspaceSvg$$module$build$src$core$workspace_svg;
            }
          }, module$build$src$core$keyboard_nav$workspace_navigation_policy = {};
          module$build$src$core$keyboard_nav$workspace_navigation_policy.WorkspaceNavigationPolicy = WorkspaceNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_navigation_policy;
          var Navigator$$module$build$src$core$navigator = class {
            constructor() {
              this.rules = [
                new BlockNavigationPolicy$$module$build$src$core$keyboard_nav$block_navigation_policy(),
                new FieldNavigationPolicy$$module$build$src$core$keyboard_nav$field_navigation_policy(),
                new ConnectionNavigationPolicy$$module$build$src$core$keyboard_nav$connection_navigation_policy(),
                new WorkspaceNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_navigation_policy(),
                new IconNavigationPolicy$$module$build$src$core$keyboard_nav$icon_navigation_policy(),
                new WorkspaceCommentNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_comment_navigation_policy(),
                new CommentBarButtonNavigationPolicy$$module$build$src$core$keyboard_nav$comment_bar_button_navigation_policy(),
                new BlockCommentNavigationPolicy$$module$build$src$core$keyboard_nav$block_comment_navigation_policy(),
                new CommentEditorNavigationPolicy$$module$build$src$core$keyboard_nav$comment_editor_navigation_policy()
              ];
            }
            addNavigationPolicy(a) {
              this.rules.push(a);
            }
            get(a) {
              return this.rules.find((b) => b.isApplicable(a));
            }
            getFirstChild(a) {
              let b;
              const c = (b = this.get(a)) == null ? void 0 : b.getFirstChild(a);
              if (!c) return null;
              let d;
              return (d = this.get(c)) != null && d.isNavigable(c) ? c : this.getFirstChild(c) || this.getNextSibling(c);
            }
            getParent(a) {
              let b;
              const c = (b = this.get(a)) == null ? void 0 : b.getParent(a);
              if (!c) return null;
              let d;
              return (d = this.get(c)) != null && d.isNavigable(c) ? c : this.getParent(c);
            }
            getNextSibling(a) {
              let b;
              const c = (b = this.get(a)) == null ? void 0 : b.getNextSibling(a);
              if (!c) return null;
              let d;
              return (d = this.get(c)) != null && d.isNavigable(c) ? c : this.getNextSibling(c);
            }
            getPreviousSibling(a) {
              let b;
              const c = (b = this.get(a)) == null ? void 0 : b.getPreviousSibling(a);
              if (!c) return null;
              let d;
              return (d = this.get(c)) != null && d.isNavigable(c) ? c : this.getPreviousSibling(c);
            }
          }, module$build$src$core$navigator = {};
          module$build$src$core$navigator.Navigator = Navigator$$module$build$src$core$navigator;
          var FlyoutNavigator$$module$build$src$core$flyout_navigator = class extends Navigator$$module$build$src$core$navigator {
            constructor(a) {
              super();
              this.rules.push(new FlyoutButtonNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_button_navigation_policy(), new FlyoutSeparatorNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_separator_navigation_policy());
              this.rules = this.rules.map((b) => new FlyoutNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_navigation_policy(b, a));
            }
          }, module$build$src$core$flyout_navigator = {};
          module$build$src$core$flyout_navigator.FlyoutNavigator = FlyoutNavigator$$module$build$src$core$flyout_navigator;
          var ScrollbarPair$$module$build$src$core$scrollbar_pair = class {
            constructor(a, b, c, d, e) {
              this.workspace = a;
              this.oldHostMetrics = this.corner_ = this.vScroll = this.hScroll = null;
              b = b === void 0 ? true : b;
              c = c === void 0 ? true : c;
              const f = b && c;
              b && (this.hScroll = new Scrollbar$$module$build$src$core$scrollbar(a, true, f, d, e));
              c && (this.vScroll = new Scrollbar$$module$build$src$core$scrollbar(a, false, f, d, e));
              f && (this.corner_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, {
                height: Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness,
                width: Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness,
                "class": "blocklyScrollbarBackground"
              }), insertAfter$$module$build$src$core$utils$dom(this.corner_, a.getBubbleCanvas()));
            }
            dispose() {
              removeNode$$module$build$src$core$utils$dom(this.corner_);
              this.oldHostMetrics = this.corner_ = null;
              this.hScroll && (this.hScroll.dispose(), this.hScroll = null);
              this.vScroll && (this.vScroll.dispose(), this.vScroll = null);
            }
            resize() {
              const a = this.workspace.getMetrics();
              if (a) {
                var b = false, c = false;
                this.oldHostMetrics && this.oldHostMetrics.viewWidth === a.viewWidth && this.oldHostMetrics.viewHeight === a.viewHeight && this.oldHostMetrics.absoluteTop === a.absoluteTop && this.oldHostMetrics.absoluteLeft === a.absoluteLeft ? (this.oldHostMetrics && this.oldHostMetrics.scrollWidth === a.scrollWidth && this.oldHostMetrics.viewLeft === a.viewLeft && this.oldHostMetrics.scrollLeft === a.scrollLeft || (b = true), this.oldHostMetrics && this.oldHostMetrics.scrollHeight === a.scrollHeight && this.oldHostMetrics.viewTop === a.viewTop && this.oldHostMetrics.scrollTop === a.scrollTop || (c = true)) : c = b = true;
                if (b || c) {
                  try {
                    $.disable$$module$build$src$core$events$utils(), this.hScroll && b && this.hScroll.resize(a), this.vScroll && c && this.vScroll.resize(a);
                  } finally {
                    $.enable$$module$build$src$core$events$utils();
                  }
                  this.workspace.maybeFireViewportChangeEvent();
                }
                if (this.hScroll && this.vScroll) {
                  if (!this.oldHostMetrics || this.oldHostMetrics.viewWidth !== a.viewWidth || this.oldHostMetrics.absoluteLeft !== a.absoluteLeft) {
                    let d;
                    (d = this.corner_) == null || d.setAttribute("x", String(this.vScroll.position.x));
                  }
                  if (!this.oldHostMetrics || this.oldHostMetrics.viewHeight !== a.viewHeight || this.oldHostMetrics.absoluteTop !== a.absoluteTop) {
                    let d;
                    (d = this.corner_) == null || d.setAttribute("y", String(this.hScroll.position.y));
                  }
                }
                this.oldHostMetrics = a;
              }
            }
            canScrollHorizontally() {
              return !!this.hScroll;
            }
            canScrollVertically() {
              return !!this.vScroll;
            }
            setOrigin(a, b) {
              this.hScroll && this.hScroll.setOrigin(a, b);
              this.vScroll && this.vScroll.setOrigin(a, b);
            }
            set(a, b, c) {
              this.hScroll && this.hScroll.set(a, false);
              this.vScroll && this.vScroll.set(b, false);
              if (c || c === void 0) a = {}, this.hScroll && (a.x = this.hScroll.getRatio_()), this.vScroll && (a.y = this.vScroll.getRatio_()), this.workspace.setMetrics(a);
            }
            setX(a) {
              this.hScroll && this.hScroll.set(a, true);
            }
            setY(a) {
              this.vScroll && this.vScroll.set(a, true);
            }
            setContainerVisible(a) {
              this.hScroll && this.hScroll.setContainerVisible(a);
              this.vScroll && this.vScroll.setContainerVisible(a);
            }
            isVisible() {
              let a = false;
              this.hScroll && (a = this.hScroll.isVisible());
              this.vScroll && (a = a || this.vScroll.isVisible());
              return a;
            }
            setVisible(a) {
              this.hScroll && this.hScroll.setVisibleInternal(a);
              this.vScroll && this.vScroll.setVisibleInternal(a);
            }
            resizeContent(a) {
              this.hScroll && this.hScroll.resizeContentHorizontal(a);
              this.vScroll && this.vScroll.resizeContentVertical(a);
            }
            resizeView(a) {
              this.hScroll && this.hScroll.resizeViewHorizontal(a);
              this.vScroll && this.vScroll.resizeViewVertical(a);
            }
          }, module$build$src$core$scrollbar_pair = {};
          module$build$src$core$scrollbar_pair.ScrollbarPair = ScrollbarPair$$module$build$src$core$scrollbar_pair;
          var SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater = "sep", SeparatorFlyoutInflater$$module$build$src$core$separator_flyout_inflater = class {
            load(a, b) {
              a = new FlyoutSeparator$$module$build$src$core$flyout_separator(0, b.horizontalLayout ? "x" : "y");
              return new FlyoutItem$$module$build$src$core$flyout_item(a, SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater);
            }
            gapForItem(a, b) {
              let c;
              return (c = parseInt(String(a.gap))) != null ? c : b;
            }
            disposeItem(a) {
            }
            getType() {
              return SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUT_INFLATER, SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater, SeparatorFlyoutInflater$$module$build$src$core$separator_flyout_inflater);
          var module$build$src$core$separator_flyout_inflater = { SEPARATOR_TYPE: SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater };
          module$build$src$core$separator_flyout_inflater.SeparatorFlyoutInflater = SeparatorFlyoutInflater$$module$build$src$core$separator_flyout_inflater;
          var Flyout$$module$build$src$core$flyout_base = class extends DeleteArea$$module$build$src$core$delete_area {
            constructor(a) {
              super();
              this.horizontalLayout = false;
              this.boundEvents = [];
              this.reflowWrapper = null;
              this.contents = [];
              this.autoClose = true;
              this.visible = false;
              this.containerVisible = true;
              this.CORNER_RADIUS = 8;
              this.SCROLLBAR_MARGIN = 2.5;
              this.height_ = this.width_ = 0;
              this.dragAngleRange_ = 70;
              this.svgGroup_ = this.svgBackground_ = null;
              this.inflaters = /* @__PURE__ */ new Map();
              a.setMetrics = this.setMetrics_.bind(this);
              this.workspace_ = new WorkspaceSvg$$module$build$src$core$workspace_svg(a);
              this.workspace_.setMetricsManager(new FlyoutMetricsManager$$module$build$src$core$flyout_metrics_manager(this.workspace_, this));
              this.workspace_.internalIsFlyout = true;
              this.workspace_.setVisible(this.visible);
              this.workspace_.setNavigator(new FlyoutNavigator$$module$build$src$core$flyout_navigator(this));
              this.id = genUid$$module$build$src$core$utils$idgenerator();
              this.RTL = !!a.RTL;
              this.toolboxPosition_ = a.toolboxPosition;
              this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH;
              this.MARGIN = this.CORNER_RADIUS;
              this.GAP_X = this.MARGIN * 3;
              this.GAP_Y = this.MARGIN * 3;
            }
            createDom(a) {
              this.svgGroup_ = createSvgElement$$module$build$src$core$utils$dom(a, { "class": "blocklyFlyout" });
              this.svgGroup_.style.display = "none";
              this.svgBackground_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyFlyoutBackground" }, this.svgGroup_);
              this.svgGroup_.appendChild(this.workspace_.createDom());
              this.workspace_.getThemeManager().subscribe(
                this.svgBackground_,
                "flyoutBackgroundColour",
                "fill"
              );
              this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutOpacity", "fill-opacity");
              return this.svgGroup_;
            }
            init(a) {
              this.targetWorkspace = a;
              this.workspace_.targetWorkspace = a;
              this.workspace_.scrollbar = new ScrollbarPair$$module$build$src$core$scrollbar_pair(this.workspace_, this.horizontalLayout, !this.horizontalLayout, "blocklyFlyoutScrollbar", this.SCROLLBAR_MARGIN);
              this.hide();
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(this.svgGroup_, "wheel", this, this.wheel_));
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(this.svgBackground_, "pointerdown", this, this.onMouseDown));
              this.workspace_.getGesture = this.targetWorkspace.getGesture.bind(this.targetWorkspace);
              this.workspace_.setVariableMap(this.targetWorkspace.getVariableMap());
              this.workspace_.createPotentialVariableMap();
              a.getComponentManager().addComponent({ component: this, weight: ComponentManager$$module$build$src$core$component_manager.ComponentWeight.FLYOUT_WEIGHT, capabilities: [
                ComponentManager$$module$build$src$core$component_manager.Capability.AUTOHIDEABLE,
                ComponentManager$$module$build$src$core$component_manager.Capability.DELETE_AREA,
                ComponentManager$$module$build$src$core$component_manager.Capability.DRAG_TARGET
              ] });
            }
            dispose() {
              this.hide();
              this.targetWorkspace.getComponentManager().removeComponent(this.id);
              for (const a of this.boundEvents) unbind$$module$build$src$core$browser_events(a);
              this.boundEvents.length = 0;
              this.workspace_ && (this.workspace_.getThemeManager().unsubscribe(this.svgBackground_), this.workspace_.dispose());
              this.svgGroup_ && removeNode$$module$build$src$core$utils$dom(this.svgGroup_);
            }
            getWidth() {
              return this.width_;
            }
            getHeight() {
              return this.height_;
            }
            getFlyoutScale() {
              return this.targetWorkspace.scale;
            }
            getWorkspace() {
              return this.workspace_;
            }
            setAutoClose(a) {
              this.autoClose = a;
              this.targetWorkspace.recordDragTargets();
              this.targetWorkspace.resizeContents();
            }
            autoHide(a) {
              !a && this.targetWorkspace.getFlyout(true) === this && this.autoClose && this.hide();
            }
            getTargetWorkspace() {
              return this.targetWorkspace;
            }
            isVisible() {
              return this.visible;
            }
            setVisible(a) {
              const b = a !== this.isVisible();
              this.visible = a;
              b && (this.autoClose || this.targetWorkspace.recordDragTargets(), this.updateDisplay());
            }
            setContainerVisible(a) {
              const b = a !== this.containerVisible;
              this.containerVisible = a;
              b && this.updateDisplay();
            }
            getContents() {
              return this.contents;
            }
            setContents(a) {
              this.contents = a;
            }
            updateDisplay() {
              let a;
              a = this.containerVisible ? this.isVisible() : false;
              this.svgGroup_ && (this.svgGroup_.style.display = a ? "block" : "none");
              let b;
              (b = this.workspace_.scrollbar) == null || b.setContainerVisible(a);
            }
            positionAt_(a, b, c, d) {
              let e;
              (e = this.svgGroup_) == null || e.setAttribute("width", `${a}`);
              let f;
              (f = this.svgGroup_) == null || f.setAttribute("height", `${b}`);
              this.workspace_.setCachedParentSvgSize(a, b);
              this.svgGroup_ && setCssTransform$$module$build$src$core$utils$dom(this.svgGroup_, "translate(" + c + "px," + d + "px)");
              if (a = this.workspace_.scrollbar) a.setOrigin(c, d), a.resize(), a.hScroll && a.hScroll.setPosition(a.hScroll.position.x, a.hScroll.position.y), a.vScroll && a.vScroll.setPosition(a.vScroll.position.x, a.vScroll.position.y);
            }
            hide() {
              this.isVisible() && (this.setVisible(false), this.reflowWrapper && (this.workspace_.removeChangeListener(this.reflowWrapper), this.reflowWrapper = null));
            }
            show(a) {
              this.workspace_.setResizesEnabled(false);
              this.hide();
              this.clearOldBlocks();
              typeof a === "string" && (a = this.getDynamicCategoryContents(a));
              this.setVisible(true);
              a = convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox(a);
              a = this.createFlyoutInfo(a);
              triggerQueuedRenders$$module$build$src$core$render_management(this.workspace_);
              this.setContents(a);
              this.layout_(a);
              this.horizontalLayout ? this.height_ = 0 : this.width_ = 0;
              this.reflow();
              this.workspace_.setResizesEnabled(true);
              this.reflowWrapper = (b) => {
                b.type !== EventType$$module$build$src$core$events$type.BLOCK_CHANGE && b.type !== EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE || this.reflow();
              };
              this.workspace_.addChangeListener(this.reflowWrapper);
            }
            createFlyoutInfo(a) {
              const b = [], c = this.horizontalLayout ? this.GAP_X : this.GAP_Y;
              for (const d of a) if ("custom" in d && (a = this.getDynamicCategoryContents(d.custom), a = convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox(a), b.push(...this.createFlyoutInfo(a))), a = d.kind.toLowerCase(), a = this.getInflaterForType(a)) b.push(a.load(d, this)), (a = a.gapForItem(d, c)) && b.push(new FlyoutItem$$module$build$src$core$flyout_item(new FlyoutSeparator$$module$build$src$core$flyout_separator(
                a,
                this.horizontalLayout ? "x" : "y"
              ), SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater));
              return this.normalizeSeparators(b);
            }
            normalizeSeparators(a) {
              for (let b = a.length - 1; b > 0; b--) {
                const c = a[b].getType().toLowerCase(), d = a[b - 1].getType().toLowerCase();
                c === SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater && d === SEPARATOR_TYPE$$module$build$src$core$separator_flyout_inflater && a.splice(b - 1, 1);
              }
              return a;
            }
            getDynamicCategoryContents(a) {
              a = this.workspace_.targetWorkspace.getToolboxCategoryCallback(a);
              if (typeof a !== "function") throw TypeError("Couldn't find a callback function when opening a toolbox category.");
              return a(this.workspace_.targetWorkspace);
            }
            clearOldBlocks() {
              this.getContents().forEach((b) => {
                let c;
                (c = this.getInflaterForType(b.getType())) == null || c.disposeItem(b);
              });
              let a;
              (a = this.workspace_.getPotentialVariableMap()) == null || a.clear();
            }
            onMouseDown(a) {
              const b = this.targetWorkspace.getGesture(a);
              b && b.handleFlyoutStart(a, this);
            }
            isBlockCreatable(a) {
              return a.isEnabled() && !this.getTargetWorkspace().isReadOnly();
            }
            createBlock(a) {
              let b = null;
              $.disable$$module$build$src$core$events$utils();
              var c = this.targetWorkspace.getAllVariables();
              this.targetWorkspace.setResizesEnabled(false);
              try {
                b = this.placeNewBlock(a);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
              this.targetWorkspace.hideChaff();
              a = getAddedVariables$$module$build$src$core$variables(this.targetWorkspace, c);
              if (isEnabled$$module$build$src$core$events$utils()) {
                $.setGroup$$module$build$src$core$events$utils(true);
                for (c = 0; c < a.length; c++) {
                  const d = a[c];
                  fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_CREATE))(d));
                }
                fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CREATE))(b));
              }
              this.autoClose && this.hide();
              return b;
            }
            reflow() {
              this.reflowWrapper && this.workspace_.removeChangeListener(this.reflowWrapper);
              this.reflowInternal_();
              this.reflowWrapper && this.workspace_.addChangeListener(this.reflowWrapper);
            }
            isScrollable() {
              return this.workspace_.scrollbar ? this.workspace_.scrollbar.isVisible() : false;
            }
            placeNewBlock(a) {
              var b = this.targetWorkspace;
              if (!a.getSvgRoot()) throw Error("oldBlock is not rendered");
              const c = this.serializeBlock(a);
              b.setResizesEnabled(false);
              b = append$$module$build$src$core$serialization$blocks(
                c,
                b
              );
              this.positionNewBlock(a, b);
              return b;
            }
            serializeBlock(a) {
              return save$$module$build$src$core$serialization$blocks(a);
            }
            positionNewBlock(a, b) {
              const c = this.targetWorkspace;
              var d = c.getOriginOffsetInPixels(), e = this.workspace_.getOriginOffsetInPixels();
              a = a.getRelativeToSurfaceXY();
              a.scale(this.workspace_.scale);
              e = Coordinate$$module$build$src$core$utils$coordinate.sum(e, a);
              d = Coordinate$$module$build$src$core$utils$coordinate.difference(e, d);
              d.scale(1 / c.scale);
              b.moveTo(new Coordinate$$module$build$src$core$utils$coordinate(
                d.x,
                d.y
              ));
            }
            getInflaterForType(a) {
              if (this.inflaters.has(a)) {
                var b;
                return (b = this.inflaters.get(a)) != null ? b : null;
              }
              return (b = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUT_INFLATER, a)) ? (b = new b(), this.inflaters.set(a, b), b) : null;
            }
            getFocusableElement() {
              throw Error("Flyouts are not directly focusable.");
            }
            getFocusableTree() {
              throw Error("Flyouts are not directly focusable.");
            }
            onNodeFocus() {
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return false;
            }
            getRootFocusableNode() {
              throw Error("Flyouts are not directly focusable.");
            }
            getRestoredFocusableNode(a) {
              throw Error("Flyouts are not directly focusable.");
            }
            getNestedTrees() {
              throw Error("Flyouts are not directly focusable.");
            }
            lookUpFocusableNode(a) {
              throw Error("Flyouts are not directly focusable.");
            }
            onTreeFocus(a, b) {
            }
            onTreeBlur(a) {
              throw Error("Flyouts are not directly focusable.");
            }
          }, module$build$src$core$flyout_base = {};
          module$build$src$core$flyout_base.Flyout = Flyout$$module$build$src$core$flyout_base;
          var module$build$src$core$interfaces$i_draggable = {};
          module$build$src$core$interfaces$i_draggable.isDraggable = isDraggable$$module$build$src$core$interfaces$i_draggable;
          var KeyboardNavigationController$$module$build$src$core$keyboard_navigation_controller = class {
            constructor() {
              this.isActive = false;
              this.activeClassName = "blocklyKeyboardNavigation";
            }
            setIsActive(a = true) {
              this.isActive = a;
              this.updateActiveVisualization();
            }
            getIsActive() {
              return this.isActive;
            }
            updateActiveVisualization() {
              this.isActive ? document.body.classList.add(this.activeClassName) : document.body.classList.remove(this.activeClassName);
            }
          }, keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller = new KeyboardNavigationController$$module$build$src$core$keyboard_navigation_controller(), module$build$src$core$keyboard_navigation_controller = {};
          module$build$src$core$keyboard_navigation_controller.KeyboardNavigationController = KeyboardNavigationController$$module$build$src$core$keyboard_navigation_controller;
          module$build$src$core$keyboard_navigation_controller.keyboardNavigationController = keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller;
          var WorkspaceDragger$$module$build$src$core$workspace_dragger = class {
            constructor(a) {
              this.workspace = a;
              this.horizontalScrollEnabled = this.workspace.isMovableHorizontally();
              this.verticalScrollEnabled = this.workspace.isMovableVertically();
              this.startScrollXY_ = new Coordinate$$module$build$src$core$utils$coordinate(a.scrollX, a.scrollY);
            }
            dispose() {
              this.workspace = null;
            }
            startDrag() {
            }
            endDrag(a) {
              this.drag(a);
            }
            drag(a) {
              a = Coordinate$$module$build$src$core$utils$coordinate.sum(this.startScrollXY_, a);
              if (this.horizontalScrollEnabled && this.verticalScrollEnabled) this.workspace.scroll(a.x, a.y);
              else if (this.horizontalScrollEnabled) this.workspace.scroll(a.x, this.workspace.scrollY);
              else if (this.verticalScrollEnabled) this.workspace.scroll(this.workspace.scrollX, a.y);
              else throw new TypeError("Invalid state.");
            }
          }, module$build$src$core$workspace_dragger = {};
          module$build$src$core$workspace_dragger.WorkspaceDragger = WorkspaceDragger$$module$build$src$core$workspace_dragger;
          var ZOOM_IN_MULTIPLIER$$module$build$src$core$gesture = 5, ZOOM_OUT_MULTIPLIER$$module$build$src$core$gesture = 6, Gesture$$module$build$src$core$gesture = class {
            constructor(a, b) {
              this.creatorWorkspace = b;
              this.mouseDownXY = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
              this.startWorkspace_ = this.targetBlock = this.startComment = this.startBlock = this.startIcon = this.startField = this.startBubble = null;
              this.hasExceededDragRadius = false;
              this.boundEvents = [];
              this.workspaceDragger = this.dragger = null;
              this.dragging = false;
              this.flyout = null;
              this.multiTouch = this.isEnding_ = this.gestureHasStarted = this.calledUpdateIsDragging = false;
              this.cachedPoints = /* @__PURE__ */ new Map();
              this.startDistance = this.previousScale = 0;
              this.currentDropdownOwner = this.isPinchZoomEnabled = null;
              this.mostRecentEvent = a;
              this.currentDragDeltaXY = new Coordinate$$module$build$src$core$utils$coordinate(0, 0);
            }
            dispose() {
              clearTouchIdentifier$$module$build$src$core$touch();
              unblock$$module$build$src$core$tooltip();
              this.creatorWorkspace.clearGesture();
              for (const a of this.boundEvents) unbind$$module$build$src$core$browser_events(a);
              this.boundEvents.length = 0;
              this.workspaceDragger && this.workspaceDragger.dispose();
            }
            updateFromEvent(a) {
              const b = new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY);
              this.updateDragDelta(b) && (this.updateIsDragging(a), longStop$$module$build$src$core$touch());
              this.mostRecentEvent = a;
            }
            updateDragDelta(a) {
              this.currentDragDeltaXY = Coordinate$$module$build$src$core$utils$coordinate.difference(a, this.mouseDownXY);
              return this.hasExceededDragRadius ? false : this.hasExceededDragRadius = Coordinate$$module$build$src$core$utils$coordinate.magnitude(this.currentDragDeltaXY) > (this.flyout ? $.config$$module$build$src$core$config.flyoutDragRadius : $.config$$module$build$src$core$config.dragRadius);
            }
            updateIsDraggingFromFlyout() {
              let a;
              if (!this.targetBlock || (a = this.flyout) == null || !a.isBlockCreatable(this.targetBlock)) return false;
              if (!this.flyout.targetWorkspace) throw Error("Cannot update dragging from the flyout because the ' +\n          'flyout's target workspace is undefined");
              return !this.flyout.isScrollable() || this.flyout.isDragTowardWorkspace(this.currentDragDeltaXY) ? (this.startWorkspace_ = this.flyout.targetWorkspace, this.startWorkspace_.updateScreenCalculationsIfScrolled(), $.getGroup$$module$build$src$core$events$utils() || $.setGroup$$module$build$src$core$events$utils(true), this.startBlock = null, this.targetBlock = this.flyout.createBlock(this.targetBlock), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.targetBlock), true) : false;
            }
            updateIsDraggingWorkspace() {
              if (!this.startWorkspace_) throw Error("Cannot update dragging the workspace because the start workspace is undefined");
              if (this.flyout ? this.flyout.isScrollable() : this.startWorkspace_ && this.startWorkspace_.isDraggable()) this.dragging = true, this.workspaceDragger = new WorkspaceDragger$$module$build$src$core$workspace_dragger(this.startWorkspace_), this.workspaceDragger.startDrag();
            }
            updateIsDragging(a) {
              if (!this.startWorkspace_) throw Error("Cannot update dragging because the start workspace is undefined");
              if (this.calledUpdateIsDragging) throw Error("updateIsDragging_ should only be called once per gesture.");
              this.calledUpdateIsDragging = true;
              this.flyout && this.updateIsDraggingFromFlyout();
              const b = getSelected$$module$build$src$core$common();
              b && isDraggable$$module$build$src$core$interfaces$i_draggable(b) && b.isMovable() ? (this.dragging = true, this.dragger = this.createDragger(b, this.startWorkspace_), this.dragger.onDragStart(a), this.dragger.onDrag(a, this.currentDragDeltaXY)) : this.updateIsDraggingWorkspace();
            }
            createDragger(a, b) {
              return new (getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.BLOCK_DRAGGER,
                this.creatorWorkspace.options,
                true
              ))(a, b);
            }
            doStart(a) {
              if (!this.startWorkspace_) throw Error("Cannot start the touch gesture becauase the start workspace is undefined");
              this.isPinchZoomEnabled = this.startWorkspace_.options.zoomOptions && this.startWorkspace_.options.zoomOptions.pinch;
              isTargetInput$$module$build$src$core$browser_events(a) ? this.cancel() : (this.gestureHasStarted = true, disconnectUiStop$$module$build$src$core$block_animations(), this.startWorkspace_.updateScreenCalculationsIfScrolled(), this.startWorkspace_.isMutator && this.startWorkspace_.resize(), this.currentDropdownOwner = getOwner$$module$build$src$core$dropdowndiv(), this.startWorkspace_.hideChaff(!!this.flyout), this.startWorkspace_.markFocused(), this.mostRecentEvent = a, block$$module$build$src$core$tooltip(), isRightButton$$module$build$src$core$browser_events(a) ? this.handleRightClick(a) : (a.type.toLowerCase() === "pointerdown" && a.pointerType !== "mouse" && longStart$$module$build$src$core$touch(a, this), this.mouseDownXY = new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY), this.bindMouseEvents(a), this.isEnding_ || this.handleTouchStart(a)));
            }
            bindMouseEvents(a) {
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(document, "pointerdown", null, this.handleStart.bind(this), true));
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(document, "pointermove", null, this.handleMove.bind(this), true));
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(document, "pointerup", null, this.handleUp.bind(this), true));
              this.boundEvents.push(conditionalBind$$module$build$src$core$browser_events(
                document,
                "pointercancel",
                null,
                this.handleUp.bind(this),
                true
              ));
              a.preventDefault();
              a.stopPropagation();
            }
            handleStart(a) {
              this.isDragging() || (this.handleTouchStart(a), this.isMultiTouch() && longStop$$module$build$src$core$touch());
            }
            handleMove(a) {
              if (this.isDragging() && shouldHandleEvent$$module$build$src$core$touch(a) || !this.isMultiTouch()) {
                this.updateFromEvent(a);
                if (this.workspaceDragger) this.workspaceDragger.drag(this.currentDragDeltaXY);
                else if (this.dragger) this.dragger.onDrag(this.mostRecentEvent, this.currentDragDeltaXY);
                a.preventDefault();
                a.stopPropagation();
              } else this.isMultiTouch() && (this.handleTouchMove(a), longStop$$module$build$src$core$touch());
            }
            handleUp(a) {
              this.isDragging() || this.handleTouchEnd(a);
              if (!this.isMultiTouch() || this.isDragging()) {
                if (!shouldHandleEvent$$module$build$src$core$touch(a)) return;
                this.updateFromEvent(a);
                longStop$$module$build$src$core$touch();
                if (this.isEnding_) {
                  console.log("Trying to end a gesture recursively.");
                  return;
                }
                this.isEnding_ = true;
                this.dragger ? (keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller.setIsActive(false), this.dragger.onDragEnd(a, this.currentDragDeltaXY)) : this.workspaceDragger ? (keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller.setIsActive(false), this.workspaceDragger.endDrag(this.currentDragDeltaXY)) : this.isBubbleClick() || this.isCommentClick() || (this.isFieldClick() ? this.doFieldClick() : this.isIconClick() ? this.doIconClick() : this.isBlockClick() ? this.doBlockClick() : this.isWorkspaceClick() && this.doWorkspaceClick(a));
              }
              a.preventDefault();
              a.stopPropagation();
              this.dispose();
            }
            handleTouchStart(a) {
              var b = getTouchIdentifierFromEvent$$module$build$src$core$touch(a);
              this.cachedPoints.set(b, this.getTouchPoint(a));
              var c = Array.from(this.cachedPoints.keys());
              c.length === 2 && (b = this.cachedPoints.get(c[0]), c = this.cachedPoints.get(c[1]), this.startDistance = Coordinate$$module$build$src$core$utils$coordinate.distance(b, c), this.multiTouch = true, a.preventDefault());
            }
            handleTouchMove(a) {
              const b = getTouchIdentifierFromEvent$$module$build$src$core$touch(a);
              this.cachedPoints.set(b, this.getTouchPoint(a));
              if (this.isPinchZoomEnabled && this.cachedPoints.size === 2) this.handlePinch(a);
              else {
                this.updateFromEvent(a);
                if (this.workspaceDragger) this.workspaceDragger.drag(this.currentDragDeltaXY);
                else if (this.dragger) this.dragger.onDrag(this.mostRecentEvent, this.currentDragDeltaXY);
                a.preventDefault();
                a.stopPropagation();
              }
            }
            handlePinch(a) {
              var b = Array.from(this.cachedPoints.keys()), c = this.cachedPoints.get(b[0]);
              b = this.cachedPoints.get(b[1]);
              c = Coordinate$$module$build$src$core$utils$coordinate.distance(c, b) / this.startDistance;
              if (this.previousScale > 0 && this.previousScale < Infinity) {
                b = c - this.previousScale;
                b = b > 0 ? b * ZOOM_IN_MULTIPLIER$$module$build$src$core$gesture : b * ZOOM_OUT_MULTIPLIER$$module$build$src$core$gesture;
                if (!this.startWorkspace_) throw Error("Cannot handle a pinch because the start workspace is undefined");
                const d = this.startWorkspace_, e = mouseToSvg$$module$build$src$core$browser_events(a, d.getParentSvg(), d.getInverseScreenCTM());
                d.zoom(e.x, e.y, b);
              }
              this.previousScale = c;
              a.preventDefault();
            }
            handleTouchEnd(a) {
              a = getTouchIdentifierFromEvent$$module$build$src$core$touch(a);
              this.cachedPoints.has(a) && this.cachedPoints.delete(a);
              this.cachedPoints.size < 2 && (this.cachedPoints.clear(), this.previousScale = 0);
            }
            getTouchPoint(a) {
              return this.startWorkspace_ ? new Coordinate$$module$build$src$core$utils$coordinate(a.pageX, a.pageY) : null;
            }
            isMultiTouch() {
              return this.multiTouch;
            }
            cancel() {
              if (!this.isEnding_) {
                longStop$$module$build$src$core$touch();
                if (this.dragger) this.dragger.onDragEnd(this.mostRecentEvent, this.currentDragDeltaXY);
                else this.workspaceDragger && this.workspaceDragger.endDrag(this.currentDragDeltaXY);
                this.dispose();
              }
            }
            handleRightClick(a) {
              this.targetBlock ? (this.bringBlockToFront(), this.targetBlock.workspace.hideChaff(!!this.flyout), this.targetBlock.showContextMenu(a)) : this.startBubble ? this.startBubble.showContextMenu(a) : this.startComment ? (this.startComment.workspace.hideChaff(), this.startComment.showContextMenu(a)) : this.startWorkspace_ && !this.flyout && (this.startWorkspace_.hideChaff(), $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.startWorkspace_), this.startWorkspace_.showContextMenu(a));
              a.preventDefault();
              a.stopPropagation();
              keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller.setIsActive(false);
              this.dispose();
            }
            handleWsStart(a, b) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.handleWsStart, but the gesture had already been started.");
              this.setStartWorkspace(b);
              this.mostRecentEvent = a;
              this.startBlock || this.startBubble || this.startComment ? this.startBlock && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.startBlock) : $.getFocusManager$$module$build$src$core$focus_manager().focusNode(b);
              this.doStart(a);
            }
            fireWorkspaceClick(a) {
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.CLICK))(null, a.id, "workspace"));
            }
            handleFlyoutStart(a, b) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.handleFlyoutStart, but the gesture had already been started.");
              this.setStartFlyout(b);
              this.handleWsStart(a, b.getWorkspace());
            }
            handleBlockStart(a, b) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.handleBlockStart, but the gesture had already been started.");
              this.setStartBlock(b);
              this.mostRecentEvent = a;
            }
            handleBubbleStart(a, b) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.handleBubbleStart, but the gesture had already been started.");
              this.setStartBubble(b);
              this.mostRecentEvent = a;
            }
            handleCommentStart(a, b) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.handleCommentStart, but the gesture had already been started.");
              this.setStartComment(b);
              this.mostRecentEvent = a;
            }
            doFieldClick() {
              if (!this.startField) throw Error("Cannot do a field click because the start field is undefined");
              this.bringBlockToFront();
              this.currentDropdownOwner !== this.startField && this.startField.showEditor(this.mostRecentEvent);
            }
            doIconClick() {
              if (!this.startIcon) throw Error("Cannot do an icon click because the start icon is undefined");
              this.bringBlockToFront();
              this.startIcon.onClick();
            }
            doBlockClick() {
              if (this.flyout && this.flyout.autoClose) {
                if (!this.targetBlock) throw Error("Cannot do a block click because the target block is undefined");
                if (this.flyout.isBlockCreatable(this.targetBlock)) {
                  $.getGroup$$module$build$src$core$events$utils() || $.setGroup$$module$build$src$core$events$utils(true);
                  var a = this.flyout.createBlock(this.targetBlock);
                  a.snapToGrid();
                  a.bumpNeighbours();
                  $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a);
                }
              } else {
                if (!this.startWorkspace_) throw Error("Cannot do a block click because the start workspace is undefined");
                a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.CLICK))(this.startBlock, this.startWorkspace_.id, "block");
                fire$$module$build$src$core$events$utils(a);
              }
              this.bringBlockToFront();
              $.setGroup$$module$build$src$core$events$utils(false);
            }
            doWorkspaceClick(a) {
              this.fireWorkspaceClick(this.startWorkspace_ || this.creatorWorkspace);
            }
            bringBlockToFront() {
              this.targetBlock && !this.flyout && ($.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.targetBlock), this.targetBlock.bringToFront());
            }
            setStartField(a) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.setStartField, but the gesture had already been started.");
              this.startField || (this.startField = a);
            }
            setStartIcon(a) {
              if (this.gestureHasStarted) throw Error("Tried to call gesture.setStartIcon, but the gesture had already been started.");
              this.startIcon || (this.startIcon = a);
            }
            setStartBubble(a) {
              this.startBubble || (this.startBubble = a);
            }
            setStartComment(a) {
              this.startComment || (this.startComment = a);
            }
            setStartBlock(a) {
              this.startBlock || this.startBubble || (this.startBlock = a, a.isInFlyout && a !== a.getRootBlock() ? this.setTargetBlock(a.getRootBlock()) : this.setTargetBlock(a));
            }
            setTargetBlock(a) {
              a.isShadow() ? this.setTargetBlock(a.getParent()) : (this.targetBlock = a, $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a));
            }
            setStartWorkspace(a) {
              this.startWorkspace_ || (this.startWorkspace_ = a);
            }
            setStartFlyout(a) {
              this.flyout || (this.flyout = a);
            }
            isBubbleClick() {
              return !!this.startBubble && !this.hasExceededDragRadius;
            }
            isCommentClick() {
              return !!this.startComment && !this.hasExceededDragRadius;
            }
            isBlockClick() {
              return !!this.startBlock && !this.hasExceededDragRadius && !this.isFieldClick() && !this.isIconClick();
            }
            isFieldClick() {
              return this.startField ? this.startField.isClickable() && !this.hasExceededDragRadius && (!this.flyout || this.startField.isClickableInFlyout(this.flyout.autoClose)) : false;
            }
            isIconClick() {
              if (!this.startIcon) return false;
              const a = !this.flyout || !this.startIcon.isClickableInFlyout || this.startIcon.isClickableInFlyout(this.flyout.autoClose);
              return !this.hasExceededDragRadius && a;
            }
            isWorkspaceClick() {
              return !this.startBlock && !this.startBubble && !this.startField && !this.hasExceededDragRadius;
            }
            getCurrentDragger() {
              let a, b;
              return (b = (a = this.workspaceDragger) != null ? a : this.dragger) != null ? b : null;
            }
            isDragging() {
              return this.dragging;
            }
            hasStarted() {
              return this.gestureHasStarted;
            }
            static inProgress() {
              const a = getAllWorkspaces$$module$build$src$core$common();
              for (let b = 0, c; c = a[b]; b++) if (c.currentGesture_) return true;
              return false;
            }
          }, module$build$src$core$gesture = {};
          module$build$src$core$gesture.Gesture = Gesture$$module$build$src$core$gesture;
          var Grid$$module$build$src$core$grid = class {
            constructor(a, b) {
              this.pattern = a;
              this.scale = 1;
              let c;
              this.spacing = (c = b.spacing) != null ? c : 0;
              let d;
              this.length = (d = b.length) != null ? d : 1;
              this.line2 = (this.line1 = a.firstChild) && this.line1.nextSibling;
              let e;
              this.snapToGrid = (e = b.snap) != null ? e : false;
            }
            setSpacing(a) {
              this.spacing = a;
              this.update(this.scale);
            }
            getSpacing() {
              return this.spacing;
            }
            setLength(a) {
              this.length = a;
              this.update(this.scale);
            }
            getLength() {
              return this.length;
            }
            setSnapToGrid(a) {
              this.snapToGrid = a;
            }
            shouldSnap() {
              return this.snapToGrid;
            }
            getPatternId() {
              return this.pattern.id;
            }
            update(a) {
              this.scale = a;
              var b = this.spacing * a;
              this.pattern.setAttribute("width", `${b}`);
              this.pattern.setAttribute("height", `${b}`);
              b = Math.floor(this.spacing / 2) + 0.5;
              let c = b - this.length / 2, d = b + this.length / 2;
              b *= a;
              c *= a;
              d *= a;
              this.setLineAttributes(this.line1, a, c, d, b, b);
              this.setLineAttributes(this.line2, a, b, b, c, d);
            }
            setLineAttributes(a, b, c, d, e, f) {
              a && (a.setAttribute("stroke-width", `${b}`), a.setAttribute("x1", `${c}`), a.setAttribute("y1", `${e}`), a.setAttribute("x2", `${d}`), a.setAttribute("y2", `${f}`));
            }
            moveTo(a, b) {
              this.pattern.setAttribute(
                "x",
                `${a}`
              );
              this.pattern.setAttribute("y", `${b}`);
            }
            alignXY(a) {
              var b = this.getSpacing();
              const c = b / 2, d = Math.round(Math.round((a.x - c) / b) * b + c);
              b = Math.round(Math.round((a.y - c) / b) * b + c);
              return d === a.x && b === a.y ? a : new Coordinate$$module$build$src$core$utils$coordinate(d, b);
            }
            static createDom(a, b, c, d) {
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATTERN, { id: "blocklyGridPattern" + a, patternUnits: "userSpaceOnUse" }, c);
              let e, f;
              if (((e = b.length) != null ? e : 1) > 0 && ((f = b.spacing) != null ? f : 0) > 0) {
                createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.LINE, { stroke: b.colour }, a);
                let g;
                (g = b.length) != null && g && createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.LINE, { stroke: b.colour }, a);
              } else createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.LINE, {}, a);
              d && d.style.setProperty("--blocklyGridPattern", `url(#${a.id})`);
              return a;
            }
          }, module$build$src$core$grid = {};
          module$build$src$core$grid.Grid = Grid$$module$build$src$core$grid;
          var module$build$src$core$interfaces$i_autohideable = {};
          module$build$src$core$interfaces$i_autohideable.isAutoHideable = isAutoHideable$$module$build$src$core$interfaces$i_autohideable;
          var LayerManager$$module$build$src$core$layer_manager = class {
            constructor(a) {
              this.workspace = a;
              this.layers = /* @__PURE__ */ new Map();
              if (a = a.getInjectionDiv()) this.dragLayer = this.createDragLayer(a), this.animationLayer = this.createAnimationLayer(a);
              a = this.createLayer(BLOCK$$module$build$src$core$layers);
              addClass$$module$build$src$core$utils$dom(a, "blocklyBlockCanvas");
              a = this.createLayer(BUBBLE$$module$build$src$core$layers);
              addClass$$module$build$src$core$utils$dom(a, "blocklyBubbleCanvas");
            }
            createDragLayer(a) {
              const b = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.SVG,
                { "class": "blocklyBlockDragSurface", xmlns: SVG_NS$$module$build$src$core$utils$dom, "xmlns:html": HTML_NS$$module$build$src$core$utils$dom, "xmlns:xlink": XLINK_NS$$module$build$src$core$utils$dom, version: "1.1" }
              );
              a.append(b);
              return createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {}, b);
            }
            createAnimationLayer(a) {
              const b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.SVG, {
                "class": "blocklyAnimationLayer",
                xmlns: SVG_NS$$module$build$src$core$utils$dom,
                "xmlns:html": HTML_NS$$module$build$src$core$utils$dom,
                "xmlns:xlink": XLINK_NS$$module$build$src$core$utils$dom,
                version: "1.1"
              });
              a.append(b);
              return createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {}, b);
            }
            appendToAnimationLayer(a) {
              let b;
              const c = (b = this.dragLayer) == null ? void 0 : b.getAttribute("transform");
              if (c) {
                let e;
                (e = this.animationLayer) == null || e.setAttribute("transform", c);
              }
              let d;
              (d = this.animationLayer) == null || d.appendChild(a.getSvgRoot());
            }
            translateLayers(a, b) {
              a = `translate(${a.x}, ${a.y}) scale(${b})`;
              let c;
              (c = this.dragLayer) == null || c.setAttribute("transform", a);
              for (const [, d] of this.layers) d.setAttribute("transform", a);
            }
            moveToDragLayer(a) {
              let b;
              (b = this.dragLayer) == null || b.appendChild(a.getSvgRoot());
              a.canBeFocused() && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a);
            }
            moveOffDragLayer(a, b) {
              this.append(a, b);
              a.canBeFocused() && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a);
            }
            append(a, b) {
              this.layers.has(b) || this.createLayer(b);
              a = a.getSvgRoot();
              let c;
              if (((c = this.layers.get(b)) == null ? void 0 : c.lastChild) !== a) {
                let d;
                (d = this.layers.get(b)) == null || d.appendChild(a);
              }
            }
            createLayer(a) {
              const b = this.workspace.getSvgGroup(), c = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, {});
              let d = false;
              const e = [...this.layers].sort((f, g) => f[0] - g[0]);
              for (const [f, g] of e) if (a < f) {
                b.insertBefore(c, g);
                d = true;
                break;
              }
              d || b.appendChild(c);
              this.layers.set(a, c);
              return c;
            }
            hasLayer(a) {
              return a === this.dragLayer || new Set(this.layers.values()).has(a);
            }
            getBlockLayer() {
              return this.layers.get(BLOCK$$module$build$src$core$layers);
            }
            getBubbleLayer() {
              return this.layers.get(BUBBLE$$module$build$src$core$layers);
            }
          }, module$build$src$core$layer_manager = {};
          module$build$src$core$layer_manager.LayerManager = LayerManager$$module$build$src$core$layer_manager;
          var Marker$$module$build$src$core$keyboard_nav$marker = class {
            constructor() {
              this.curNode = this.colour = null;
              this.type = "marker";
            }
            getCurNode() {
              return this.curNode;
            }
            setCurNode(a) {
              this.curNode = a;
            }
            dispose() {
              this.curNode = null;
            }
            getSourceBlockFromNode(a) {
              return a instanceof BlockSvg$$module$build$src$core$block_svg ? a : a instanceof Field$$module$build$src$core$field || a instanceof RenderedConnection$$module$build$src$core$rendered_connection ? a.getSourceBlock() : null;
            }
            getSourceBlock() {
              return this.getSourceBlockFromNode(this.getCurNode());
            }
          }, module$build$src$core$keyboard_nav$marker = {};
          module$build$src$core$keyboard_nav$marker.Marker = Marker$$module$build$src$core$keyboard_nav$marker;
          var LineCursor$$module$build$src$core$keyboard_nav$line_cursor = class extends Marker$$module$build$src$core$keyboard_nav$marker {
            constructor(a) {
              super();
              this.workspace = a;
              this.type = "cursor";
              this.potentialNodes = null;
            }
            next() {
              var a = this.getCurNode();
              if (!a) return null;
              (a = this.getNextNode(
                a,
                (b) => {
                  let c;
                  return b instanceof BlockSvg$$module$build$src$core$block_svg && !((c = b.outputConnection) == null ? 0 : c.targetBlock()) || b instanceof RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment;
                },
                true
              )) && this.setCurNode(a);
              return a;
            }
            in() {
              var a = this.getCurNode();
              if (!a) return null;
              (a = this.getNextNode(a, () => true, true)) && this.setCurNode(a);
              return a;
            }
            prev() {
              var a = this.getCurNode();
              if (!a) return null;
              (a = this.getPreviousNode(a, (b) => {
                let c;
                return b instanceof BlockSvg$$module$build$src$core$block_svg && !((c = b.outputConnection) == null ? 0 : c.targetBlock()) || b instanceof RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment;
              }, true)) && this.setCurNode(a);
              return a;
            }
            out() {
              var a = this.getCurNode();
              if (!a) return null;
              (a = this.getPreviousNode(a, () => true, true)) && this.setCurNode(a);
              return a;
            }
            atEndOfLine() {
              var a = this.getCurNode();
              if (!a) return false;
              const b = this.getNextNode(a, () => true, true);
              a = this.getNextNode(a, (c) => {
                let d;
                return c instanceof BlockSvg$$module$build$src$core$block_svg && !((d = c.outputConnection) == null ? 0 : d.targetBlock());
              }, true);
              return b === a;
            }
            getNextNodeImpl(a, b, c = /* @__PURE__ */ new Set()) {
              if (!a || c.has(a)) return null;
              let d = this.workspace.getNavigator().getFirstChild(a) || this.workspace.getNavigator().getNextSibling(a);
              for (var e = a; e && !d; ) {
                e = this.workspace.getNavigator().getParent(e);
                if (!e) break;
                d = this.workspace.getNavigator().getNextSibling(e);
              }
              return b(d) ? d : d ? (c.add(a), this.getNextNodeImpl(d, b, c)) : null;
            }
            getNextNode(a, b, c) {
              return !a || !c && this.getLastNode() === a ? null : this.getNextNodeImpl(a, b);
            }
            getPreviousNodeImpl(a, b, c = /* @__PURE__ */ new Set()) {
              if (!a || c.has(a)) return null;
              const d = this.getRightMostChild(this.workspace.getNavigator().getPreviousSibling(a), a) || this.workspace.getNavigator().getParent(a);
              return b(d) ? d : d ? (c.add(a), this.getPreviousNodeImpl(
                d,
                b,
                c
              )) : null;
            }
            getPreviousNode(a, b, c) {
              return !a || !c && this.getFirstNode() === a ? null : this.getPreviousNodeImpl(a, b);
            }
            getRightMostChild(a, b) {
              if (!a) return a;
              let c = this.workspace.getNavigator().getFirstChild(a);
              if (!c || c === b) return a;
              for (a = c; a && a !== b; a = this.workspace.getNavigator().getNextSibling(c)) c = a;
              return this.getRightMostChild(c, b);
            }
            preDelete(a) {
              var b = this.getCurNode();
              b = b ? [b] : [];
              var c;
              let d, e;
              const f = (e = (c = a.previousConnection) == null ? void 0 : c.targetConnection) != null ? e : (d = a.outputConnection) == null ? void 0 : d.targetConnection;
              f && b.push(f);
              (c = a.getNextBlock()) && b.push(c);
              (a = a.getParent()) && b.push(a);
              b.push(this.workspace);
              this.potentialNodes = b;
            }
            postDelete() {
              const a = this.potentialNodes;
              this.potentialNodes = null;
              if (!a) throw Error("must call preDelete first");
              for (const b of a) {
                let c;
                if ((c = this.getSourceBlockFromNode(b)) == null || !c.disposed) {
                  this.setCurNode(b);
                  return;
                }
              }
              throw Error("no valid nodes in this.potentialNodes");
            }
            getCurNode() {
              return $.getFocusManager$$module$build$src$core$focus_manager().getFocusedNode();
            }
            setCurNode(a) {
              $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a);
            }
            getFirstNode() {
              return this.workspace.getNavigator().getFirstChild(this.workspace);
            }
            getLastNode() {
              const a = this.getFirstNode();
              return this.getPreviousNode(a, () => true, true);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.CURSOR, DEFAULT$$module$build$src$core$registry, LineCursor$$module$build$src$core$keyboard_nav$line_cursor);
          var module$build$src$core$keyboard_nav$line_cursor = {};
          module$build$src$core$keyboard_nav$line_cursor.LineCursor = LineCursor$$module$build$src$core$keyboard_nav$line_cursor;
          var MarkerManager$$module$build$src$core$marker_manager = class {
            constructor(a) {
              this.workspace = a;
              this.markers = /* @__PURE__ */ new Map();
              this.cursor = new LineCursor$$module$build$src$core$keyboard_nav$line_cursor(this.workspace);
            }
            registerMarker(a, b) {
              this.markers.has(a) && this.unregisterMarker(a);
              this.markers.set(a, b);
            }
            unregisterMarker(a) {
              const b = this.markers.get(a);
              if (b) b.dispose(), this.markers.delete(a);
              else throw Error("Marker with ID " + a + " does not exist. Can only unregister markers that exist.");
            }
            getCursor() {
              return this.cursor;
            }
            getMarker(a) {
              return this.markers.get(a) || null;
            }
            setCursor(a) {
              this.cursor = a;
            }
            dispose() {
              const a = Object.keys(this.markers);
              for (let b = 0, c; c = a[b]; b++) this.unregisterMarker(c);
              this.markers.clear();
              this.cursor.dispose();
            }
          };
          MarkerManager$$module$build$src$core$marker_manager.LOCAL_MARKER = "local_marker_1";
          var module$build$src$core$marker_manager = {};
          module$build$src$core$marker_manager.MarkerManager = MarkerManager$$module$build$src$core$marker_manager;
          var module$build$src$core$icons = {};
          module$build$src$core$icons.CommentIcon = CommentIcon$$module$build$src$core$icons$comment_icon;
          module$build$src$core$icons.Icon = Icon$$module$build$src$core$icons$icon;
          module$build$src$core$icons.IconType = IconType$$module$build$src$core$icons$icon_types;
          module$build$src$core$icons.MutatorIcon = $.MutatorIcon$$module$build$src$core$icons$mutator_icon;
          module$build$src$core$icons.WarningIcon = WarningIcon$$module$build$src$core$icons$warning_icon;
          module$build$src$core$icons.exceptions = module$build$src$core$icons$exceptions;
          module$build$src$core$icons.registry = module$build$src$core$icons$registry;
          var module$build$src$core$interfaces$i_procedure_block = {};
          module$build$src$core$interfaces$i_procedure_block.isProcedureBlock = isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block;
          $.Names$$module$build$src$core$names = class {
            constructor(a, b) {
              this.db = /* @__PURE__ */ new Map();
              this.dbReverse = /* @__PURE__ */ new Set();
              this.variableMap = null;
              this.variablePrefix = b || "";
              this.reservedWords = new Set(a ? a.split(",") : []);
            }
            reset() {
              this.db.clear();
              this.dbReverse.clear();
              this.variableMap = null;
            }
            setVariableMap(a) {
              this.variableMap = a;
            }
            getNameForUserVariable(a) {
              return this.variableMap ? (a = this.variableMap.getVariableById(a)) ? a.getName() : null : (console.warn("Deprecated call to Names.prototype.getName without defining a variable map. To fix, add the following code in your generator's init() function:\nBlockly.YourGeneratorName.nameDB_.setVariableMap(workspace.getVariableMap());"), null);
            }
            populateVariables(a) {
              a = $.allUsedVarModels$$module$build$src$core$variables(a);
              for (let b = 0; b < a.length; b++) this.getName(a[b].getId(), $.NameType$$module$build$src$core$names.VARIABLE);
            }
            populateProcedures(a) {
              throw Error("The implementation of populateProcedures should be monkey-patched in by blockly.ts");
            }
            getName(a, b) {
              let c = a;
              b === $.NameType$$module$build$src$core$names.VARIABLE && (a = this.getNameForUserVariable(a)) && (c = a);
              a = c.toLowerCase();
              const d = b === $.NameType$$module$build$src$core$names.VARIABLE || b === $.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "";
              this.db.has(b) || this.db.set(b, /* @__PURE__ */ new Map());
              const e = this.db.get(b);
              if (e.has(a)) return d + e.get(a);
              b = this.getDistinctName(c, b);
              e.set(a, b.substr(d.length));
              return b;
            }
            getUserNames(a) {
              let b;
              return (a = (b = this.db.get(a)) == null ? void 0 : b.keys()) ? Array.from(a) : [];
            }
            getDistinctName(a, b) {
              a = this.safeName(a);
              let c = null, d, e;
              for (; this.dbReverse.has(a + ((d = c) != null ? d : "")) || this.reservedWords.has(a + ((e = c) != null ? e : "")); ) c = c ? c + 1 : 2;
              let f;
              a += (f = c) != null ? f : "";
              this.dbReverse.add(a);
              return (b === $.NameType$$module$build$src$core$names.VARIABLE || b === $.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "") + a;
            }
            safeName(a) {
              a ? (a = encodeURI(a.replace(/ /g, "_")).replace(/[^\w]/g, "_"), "0123456789".includes(a[0]) && (a = "my_" + a)) : a = $.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed";
              return a;
            }
            static equals(a, b) {
              return a.toLowerCase() === b.toLowerCase();
            }
          };
          (function(a) {
            a = a.NameType || (a.NameType = {});
            a.DEVELOPER_VARIABLE = "DEVELOPER_VARIABLE";
            a.VARIABLE = "VARIABLE";
            a.PROCEDURE = "PROCEDURE";
          })($.Names$$module$build$src$core$names || ($.Names$$module$build$src$core$names = {}));
          $.NameType$$module$build$src$core$names = $.Names$$module$build$src$core$names.NameType;
          $.Names$$module$build$src$core$names.DEVELOPER_VARIABLE_TYPE = $.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE;
          var module$build$src$core$names = { NameType: $.NameType$$module$build$src$core$names };
          module$build$src$core$names.Names = $.Names$$module$build$src$core$names;
          var module$build$src$core$interfaces$i_observable = {};
          module$build$src$core$interfaces$i_observable.isObservable = isObservable$$module$build$src$core$interfaces$i_observable;
          var ObservableProcedureMap$$module$build$src$core$observable_procedure_map = class extends Map {
            constructor() {
              super();
            }
            set(a, b) {
              if (this.get(a) === b) return this;
              super.set(a, b);
              isObservable$$module$build$src$core$interfaces$i_observable(b) && b.startPublishing();
              return this;
            }
            delete(a) {
              const b = this.get(a);
              a = super.delete(a);
              if (!a) return a;
              isObservable$$module$build$src$core$interfaces$i_observable(b) && b.stopPublishing();
              return a;
            }
            clear() {
              if (this.size) for (const a of this.keys()) this.delete(a);
            }
            add(a) {
              return this.set(
                a.getId(),
                a
              );
            }
            getProcedures() {
              return [...this.values()];
            }
          }, module$build$src$core$observable_procedure_map = {};
          module$build$src$core$observable_procedure_map.ObservableProcedureMap = ObservableProcedureMap$$module$build$src$core$observable_procedure_map;
          var CATEGORY_NAME$$module$build$src$core$procedures, module$build$src$core$procedures;
          CATEGORY_NAME$$module$build$src$core$procedures = "PROCEDURE";
          $.DEFAULT_ARG$$module$build$src$core$procedures = "x";
          module$build$src$core$procedures = { CATEGORY_NAME: CATEGORY_NAME$$module$build$src$core$procedures, DEFAULT_ARG: $.DEFAULT_ARG$$module$build$src$core$procedures };
          module$build$src$core$procedures.ObservableProcedureMap = ObservableProcedureMap$$module$build$src$core$observable_procedure_map;
          module$build$src$core$procedures.allProcedures = allProcedures$$module$build$src$core$procedures;
          module$build$src$core$procedures.findLegalName = $.findLegalName$$module$build$src$core$procedures;
          module$build$src$core$procedures.flyoutCategory = flyoutCategory$$module$build$src$core$procedures;
          module$build$src$core$procedures.getCallers = getCallers$$module$build$src$core$procedures;
          module$build$src$core$procedures.getDefinition = $.getDefinition$$module$build$src$core$procedures;
          module$build$src$core$procedures.internalFlyoutCategory = internalFlyoutCategory$$module$build$src$core$procedures;
          module$build$src$core$procedures.isNameUsed = isNameUsed$$module$build$src$core$procedures;
          module$build$src$core$procedures.isProcedureBlock = isProcedureBlock$$module$build$src$core$interfaces$i_procedure_block;
          module$build$src$core$procedures.mutateCallers = $.mutateCallers$$module$build$src$core$procedures;
          module$build$src$core$procedures.mutatorOpenListener = mutatorOpenListener$$module$build$src$core$procedures;
          module$build$src$core$procedures.rename = $.rename$$module$build$src$core$procedures;
          var TypesContainer$$module$build$src$core$renderers$measurables$types = class {
            constructor() {
              this.NONE = 0;
              this.FIELD = 1;
              this.HAT = 2;
              this.ICON = 4;
              this.SPACER = 8;
              this.BETWEEN_ROW_SPACER = 16;
              this.IN_ROW_SPACER = 32;
              this.EXTERNAL_VALUE_INPUT = 64;
              this.INPUT = 128;
              this.INLINE_INPUT = 256;
              this.STATEMENT_INPUT = 512;
              this.CONNECTION = 1024;
              this.PREVIOUS_CONNECTION = 2048;
              this.NEXT_CONNECTION = 4096;
              this.OUTPUT_CONNECTION = 8192;
              this.CORNER = 16384;
              this.LEFT_SQUARE_CORNER = 32768;
              this.LEFT_ROUND_CORNER = 65536;
              this.RIGHT_SQUARE_CORNER = 131072;
              this.RIGHT_ROUND_CORNER = 262144;
              this.JAGGED_EDGE = 524288;
              this.ROW = 1048576;
              this.TOP_ROW = 2097152;
              this.BOTTOM_ROW = 4194304;
              this.INPUT_ROW = 8388608;
              this.LEFT_CORNER = this.LEFT_SQUARE_CORNER | this.LEFT_ROUND_CORNER;
              this.RIGHT_CORNER = this.RIGHT_SQUARE_CORNER | this.RIGHT_ROUND_CORNER;
              this.nextTypeValue_ = 16777216;
            }
            getType(a) {
              Object.prototype.hasOwnProperty.call(this, a) || (this[a] = this.nextTypeValue_, this.nextTypeValue_ <<= 1);
              return this[a];
            }
            isField(a) {
              return (a.type & this.FIELD) >= 1;
            }
            isHat(a) {
              return (a.type & this.HAT) >= 1;
            }
            isIcon(a) {
              return (a.type & this.ICON) >= 1;
            }
            isSpacer(a) {
              return (a.type & this.SPACER) >= 1;
            }
            isInRowSpacer(a) {
              return (a.type & this.IN_ROW_SPACER) >= 1;
            }
            isSpacerRow(a) {
              return (a.type & this.BETWEEN_ROW_SPACER) >= 1;
            }
            isInput(a) {
              return (a.type & this.INPUT) >= 1;
            }
            isExternalInput(a) {
              return (a.type & this.EXTERNAL_VALUE_INPUT) >= 1;
            }
            isInlineInput(a) {
              return (a.type & this.INLINE_INPUT) >= 1;
            }
            isStatementInput(a) {
              return (a.type & this.STATEMENT_INPUT) >= 1;
            }
            isPreviousConnection(a) {
              return (a.type & this.PREVIOUS_CONNECTION) >= 1;
            }
            isNextConnection(a) {
              return (a.type & this.NEXT_CONNECTION) >= 1;
            }
            isPreviousOrNextConnection(a) {
              return this.isPreviousConnection(a) || this.isNextConnection(a);
            }
            isRoundCorner(a) {
              return (a.type & this.LEFT_ROUND_CORNER) >= 1 || (a.type & this.RIGHT_ROUND_CORNER) >= 1;
            }
            isLeftRoundedCorner(a) {
              return this.isRoundCorner(a) && (a.type & this.LEFT_ROUND_CORNER) >= 1;
            }
            isRightRoundedCorner(a) {
              return this.isRoundCorner(a) && (a.type & this.RIGHT_ROUND_CORNER) >= 1;
            }
            isLeftSquareCorner(a) {
              return (a.type & this.LEFT_SQUARE_CORNER) >= 1;
            }
            isRightSquareCorner(a) {
              return (a.type & this.RIGHT_SQUARE_CORNER) >= 1;
            }
            isCorner(a) {
              return (a.type & this.CORNER) >= 1;
            }
            isJaggedEdge(a) {
              return (a.type & this.JAGGED_EDGE) >= 1;
            }
            isRow(a) {
              return (a.type & this.ROW) >= 1;
            }
            isBetweenRowSpacer(a) {
              return (a.type & this.BETWEEN_ROW_SPACER) >= 1;
            }
            isTopRow(a) {
              return (a.type & this.TOP_ROW) >= 1;
            }
            isBottomRow(a) {
              return (a.type & this.BOTTOM_ROW) >= 1;
            }
            isTopOrBottomRow(a) {
              return this.isTopRow(a) || this.isBottomRow(a);
            }
            isInputRow(a) {
              return (a.type & this.INPUT_ROW) >= 1;
            }
          }, Types$$module$build$src$core$renderers$measurables$types = new TypesContainer$$module$build$src$core$renderers$measurables$types(), module$build$src$core$renderers$measurables$types = { Types: Types$$module$build$src$core$renderers$measurables$types };
          var Measurable$$module$build$src$core$renderers$measurables$base = class {
            constructor(a) {
              this.centerline = this.xPos = this.height = this.width = 0;
              this.constants_ = a;
              this.type = Types$$module$build$src$core$renderers$measurables$types.NONE;
              this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;
            }
          }, module$build$src$core$renderers$measurables$base = {};
          module$build$src$core$renderers$measurables$base.Measurable = Measurable$$module$build$src$core$renderers$measurables$base;
          var Row$$module$build$src$core$renderers$measurables$row = class {
            constructor(a) {
              this.elements = [];
              this.xPos = this.yPos = this.widthWithConnectedBlocks = this.minWidth = this.minHeight = this.width = this.height = 0;
              this.hasStatement = this.hasExternalInput = false;
              this.statementEdge = 0;
              this.hasJaggedEdge = this.hasDummyInput = this.hasInlineInput = false;
              this.align = null;
              this.constants_ = a;
              this.type = Types$$module$build$src$core$renderers$measurables$types.ROW;
              this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;
            }
            getLastInput() {
              for (let a = this.elements.length - 1; a >= 0; a--) {
                const b = this.elements[a];
                if (Types$$module$build$src$core$renderers$measurables$types.isInput(b)) return b;
              }
              return null;
            }
            measure() {
              throw Error("Unexpected attempt to measure a base Row.");
            }
            startsWithElemSpacer() {
              return true;
            }
            endsWithElemSpacer() {
              return true;
            }
            getFirstSpacer() {
              for (let a = 0; a < this.elements.length; a++) {
                const b = this.elements[a];
                if (Types$$module$build$src$core$renderers$measurables$types.isInRowSpacer(b)) return b;
              }
              return null;
            }
            getLastSpacer() {
              for (let a = this.elements.length - 1; a >= 0; a--) {
                const b = this.elements[a];
                if (Types$$module$build$src$core$renderers$measurables$types.isInRowSpacer(b)) return b;
              }
              return null;
            }
          }, module$build$src$core$renderers$measurables$row = {};
          module$build$src$core$renderers$measurables$row.Row = Row$$module$build$src$core$renderers$measurables$row;
          var BottomRow$$module$build$src$core$renderers$measurables$bottom_row = class extends Row$$module$build$src$core$renderers$measurables$row {
            constructor(a) {
              super(a);
              this.hasNextConnection = false;
              this.connection = null;
              this.baseline = this.descenderHeight = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.BOTTOM_ROW;
            }
            hasLeftSquareCorner(a) {
              return !!a.outputConnection || !!a.getNextBlock();
            }
            hasRightSquareCorner(a) {
              return true;
            }
            measure() {
              let a = 0, b = 0, c = 0;
              for (let d = 0; d < this.elements.length; d++) {
                const e = this.elements[d];
                b += e.width;
                Types$$module$build$src$core$renderers$measurables$types.isSpacer(e) || (Types$$module$build$src$core$renderers$measurables$types.isNextConnection(e) ? c = Math.max(c, e.height) : a = Math.max(a, e.height));
              }
              this.width = Math.max(this.minWidth, b);
              this.height = Math.max(this.minHeight, a) + c;
              this.descenderHeight = c;
              this.widthWithConnectedBlocks = this.width;
            }
            startsWithElemSpacer() {
              return false;
            }
            endsWithElemSpacer() {
              return false;
            }
          }, module$build$src$core$renderers$measurables$bottom_row = {};
          module$build$src$core$renderers$measurables$bottom_row.BottomRow = BottomRow$$module$build$src$core$renderers$measurables$bottom_row;
          var Connection$$module$build$src$core$renderers$measurables$connection = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b) {
              super(a);
              this.connectionModel = b;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.CONNECTION;
              this.shape = this.constants_.shapeFor(b);
              this.isDynamicShape = "isDynamic" in this.shape && this.shape.isDynamic;
              this.highlighted = b.isHighlighted();
            }
          }, module$build$src$core$renderers$measurables$connection = {};
          module$build$src$core$renderers$measurables$connection.Connection = Connection$$module$build$src$core$renderers$measurables$connection;
          var InputConnection$$module$build$src$core$renderers$measurables$input_connection = class extends Connection$$module$build$src$core$renderers$measurables$connection {
            constructor(a, b) {
              super(a, b.connection);
              this.input = b;
              this.connectionOffsetY = this.connectionOffsetX = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.INPUT;
              this.align = b.align;
              (this.connectedBlock = b.connection && b.connection.targetBlock() ? b.connection.targetBlock() : null) ? (a = this.connectedBlock.getHeightWidth(), this.connectedBlockWidth = a.width, this.connectedBlockHeight = a.height) : this.connectedBlockHeight = this.connectedBlockWidth = 0;
            }
          }, module$build$src$core$renderers$measurables$input_connection = {};
          module$build$src$core$renderers$measurables$input_connection.InputConnection = InputConnection$$module$build$src$core$renderers$measurables$input_connection;
          var ExternalValueInput$$module$build$src$core$renderers$measurables$external_value_input = class extends InputConnection$$module$build$src$core$renderers$measurables$input_connection {
            constructor(a, b) {
              super(a, b);
              this.height = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.EXTERNAL_VALUE_INPUT;
              this.height = this.connectedBlock ? this.connectedBlockHeight - this.constants_.TAB_OFFSET_FROM_TOP - this.constants_.MEDIUM_PADDING : this.shape.height;
              this.width = this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING;
              this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
              this.connectionHeight = this.shape.height;
              this.connectionWidth = this.shape.width;
            }
          }, module$build$src$core$renderers$measurables$external_value_input = {};
          module$build$src$core$renderers$measurables$external_value_input.ExternalValueInput = ExternalValueInput$$module$build$src$core$renderers$measurables$external_value_input;
          var Field$$module$build$src$core$renderers$measurables$field = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b, c) {
              super(a);
              this.field = b;
              this.parentInput = c;
              this.isEditable = b.EDITABLE;
              this.flipRtl = b.getFlipRtl();
              this.type |= Types$$module$build$src$core$renderers$measurables$types.FIELD;
              a = this.field.getSize();
              this.height = a.height;
              this.width = a.width;
            }
          }, module$build$src$core$renderers$measurables$field = {};
          module$build$src$core$renderers$measurables$field.Field = Field$$module$build$src$core$renderers$measurables$field;
          var Hat$$module$build$src$core$renderers$measurables$hat = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a) {
              super(a);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.HAT;
              this.height = this.constants_.START_HAT.height;
              this.width = this.constants_.START_HAT.width;
              this.ascenderHeight = this.height;
            }
          }, module$build$src$core$renderers$measurables$hat = {};
          module$build$src$core$renderers$measurables$hat.Hat = Hat$$module$build$src$core$renderers$measurables$hat;
          var Icon$$module$build$src$core$renderers$measurables$icon = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b) {
              super(a);
              this.icon = b;
              this.flipRtl = false;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.ICON;
              a = b.getSize();
              this.height = a.height;
              this.width = a.width;
            }
          }, module$build$src$core$renderers$measurables$icon = {};
          module$build$src$core$renderers$measurables$icon.Icon = Icon$$module$build$src$core$renderers$measurables$icon;
          var InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b) {
              super(a);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.SPACER | Types$$module$build$src$core$renderers$measurables$types.IN_ROW_SPACER;
              this.width = b;
              this.height = this.constants_.SPACER_DEFAULT_HEIGHT;
            }
          }, module$build$src$core$renderers$measurables$in_row_spacer = {};
          module$build$src$core$renderers$measurables$in_row_spacer.InRowSpacer = InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer;
          var InlineInput$$module$build$src$core$renderers$measurables$inline_input = class extends InputConnection$$module$build$src$core$renderers$measurables$input_connection {
            constructor(a, b) {
              super(a, b);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.INLINE_INPUT;
              this.connectedBlock ? (this.width = this.connectedBlockWidth, this.height = this.connectedBlockHeight) : (this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT, this.width = this.constants_.EMPTY_INLINE_INPUT_PADDING);
              this.connectionHeight = this.isDynamicShape ? this.shape.height(this.height) : this.shape.height;
              this.connectionWidth = this.isDynamicShape ? this.shape.width(this.height) : this.shape.width;
              this.connectedBlock || (this.width += this.connectionWidth * (this.isDynamicShape ? 2 : 1));
              this.connectionOffsetY = "connectionOffsetY" in this.shape ? this.shape.connectionOffsetY(this.connectionHeight) : this.constants_.TAB_OFFSET_FROM_TOP;
              this.connectionOffsetX = "connectionOffsetX" in this.shape ? this.shape.connectionOffsetX(this.connectionWidth) : 0;
            }
          }, module$build$src$core$renderers$measurables$inline_input = {};
          module$build$src$core$renderers$measurables$inline_input.InlineInput = InlineInput$$module$build$src$core$renderers$measurables$inline_input;
          var InputRow$$module$build$src$core$renderers$measurables$input_row = class extends Row$$module$build$src$core$renderers$measurables$row {
            constructor(a) {
              super(a);
              this.connectedBlockWidths = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.INPUT_ROW;
            }
            measure() {
              this.width = this.minWidth;
              this.height = this.minHeight;
              let a = 0;
              for (let b = 0; b < this.elements.length; b++) {
                const c = this.elements[b];
                this.width += c.width;
                Types$$module$build$src$core$renderers$measurables$types.isInput(c) && (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(c) ? a += c.connectedBlockWidth : Types$$module$build$src$core$renderers$measurables$types.isExternalInput(c) && c.connectedBlockWidth !== 0 && (a += c.connectedBlockWidth - c.connectionWidth));
                Types$$module$build$src$core$renderers$measurables$types.isSpacer(c) || (this.height = Math.max(this.height, c.height));
              }
              this.connectedBlockWidths = a;
              this.widthWithConnectedBlocks = this.width + a;
            }
            endsWithElemSpacer() {
              return !this.hasExternalInput && !this.hasStatement;
            }
          }, module$build$src$core$renderers$measurables$input_row = {};
          module$build$src$core$renderers$measurables$input_row.InputRow = InputRow$$module$build$src$core$renderers$measurables$input_row;
          var JaggedEdge$$module$build$src$core$renderers$measurables$jagged_edge = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a) {
              super(a);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.JAGGED_EDGE;
              this.height = this.constants_.JAGGED_TEETH.height;
              this.width = this.constants_.JAGGED_TEETH.width;
            }
          }, module$build$src$core$renderers$measurables$jagged_edge = {};
          module$build$src$core$renderers$measurables$jagged_edge.JaggedEdge = JaggedEdge$$module$build$src$core$renderers$measurables$jagged_edge;
          var NextConnection$$module$build$src$core$renderers$measurables$next_connection = class extends Connection$$module$build$src$core$renderers$measurables$connection {
            constructor(a, b) {
              super(a, b);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.NEXT_CONNECTION;
              this.height = this.shape.height;
              this.width = this.shape.width;
            }
          }, module$build$src$core$renderers$measurables$next_connection = {};
          module$build$src$core$renderers$measurables$next_connection.NextConnection = NextConnection$$module$build$src$core$renderers$measurables$next_connection;
          var OutputConnection$$module$build$src$core$renderers$measurables$output_connection = class extends Connection$$module$build$src$core$renderers$measurables$connection {
            constructor(a, b) {
              super(a, b);
              this.connectionOffsetX = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.OUTPUT_CONNECTION;
              this.height = this.isDynamicShape ? 0 : this.shape.height;
              this.startX = this.width = this.isDynamicShape ? 0 : this.shape.width;
              this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
            }
          }, module$build$src$core$renderers$measurables$output_connection = {};
          module$build$src$core$renderers$measurables$output_connection.OutputConnection = OutputConnection$$module$build$src$core$renderers$measurables$output_connection;
          var PreviousConnection$$module$build$src$core$renderers$measurables$previous_connection = class extends Connection$$module$build$src$core$renderers$measurables$connection {
            constructor(a, b) {
              super(a, b);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.PREVIOUS_CONNECTION;
              this.height = this.shape.height;
              this.width = this.shape.width;
            }
          }, module$build$src$core$renderers$measurables$previous_connection = {};
          module$build$src$core$renderers$measurables$previous_connection.PreviousConnection = PreviousConnection$$module$build$src$core$renderers$measurables$previous_connection;
          var RoundCorner$$module$build$src$core$renderers$measurables$round_corner = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b) {
              super(a);
              this.type = (b && b !== "left" ? Types$$module$build$src$core$renderers$measurables$types.RIGHT_ROUND_CORNER : Types$$module$build$src$core$renderers$measurables$types.LEFT_ROUND_CORNER) | Types$$module$build$src$core$renderers$measurables$types.CORNER;
              this.width = this.constants_.CORNER_RADIUS;
              this.height = this.constants_.CORNER_RADIUS / 2;
            }
          }, module$build$src$core$renderers$measurables$round_corner = {};
          module$build$src$core$renderers$measurables$round_corner.RoundCorner = RoundCorner$$module$build$src$core$renderers$measurables$round_corner;
          var SpacerRow$$module$build$src$core$renderers$measurables$spacer_row = class extends Row$$module$build$src$core$renderers$measurables$row {
            constructor(a, b, c) {
              super(a);
              this.height = b;
              this.width = c;
              this.precedesStatement = this.followsStatement = false;
              this.widthWithConnectedBlocks = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.SPACER | Types$$module$build$src$core$renderers$measurables$types.BETWEEN_ROW_SPACER;
              this.elements = [new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(
                this.constants_,
                c
              )];
            }
            measure() {
            }
          }, module$build$src$core$renderers$measurables$spacer_row = {};
          module$build$src$core$renderers$measurables$spacer_row.SpacerRow = SpacerRow$$module$build$src$core$renderers$measurables$spacer_row;
          var SquareCorner$$module$build$src$core$renderers$measurables$square_corner = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a, b) {
              super(a);
              this.type = (b && b !== "left" ? Types$$module$build$src$core$renderers$measurables$types.RIGHT_SQUARE_CORNER : Types$$module$build$src$core$renderers$measurables$types.LEFT_SQUARE_CORNER) | Types$$module$build$src$core$renderers$measurables$types.CORNER;
              this.width = this.height = this.constants_.NO_PADDING;
            }
          }, module$build$src$core$renderers$measurables$square_corner = {};
          module$build$src$core$renderers$measurables$square_corner.SquareCorner = SquareCorner$$module$build$src$core$renderers$measurables$square_corner;
          var StatementInput$$module$build$src$core$renderers$measurables$statement_input = class extends InputConnection$$module$build$src$core$renderers$measurables$input_connection {
            constructor(a, b) {
              super(a, b);
              this.type |= Types$$module$build$src$core$renderers$measurables$types.STATEMENT_INPUT;
              this.height = this.connectedBlock ? this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER : this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT;
              this.width = this.constants_.STATEMENT_INPUT_NOTCH_OFFSET + this.shape.width;
            }
          }, module$build$src$core$renderers$measurables$statement_input = {};
          module$build$src$core$renderers$measurables$statement_input.StatementInput = StatementInput$$module$build$src$core$renderers$measurables$statement_input;
          var TopRow$$module$build$src$core$renderers$measurables$top_row = class extends Row$$module$build$src$core$renderers$measurables$row {
            constructor(a) {
              super(a);
              this.ascenderHeight = this.capline = 0;
              this.hasPreviousConnection = false;
              this.connection = null;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.TOP_ROW;
            }
            hasLeftSquareCorner(a) {
              const b = (a.hat ? a.hat === "cap" : this.constants_.ADD_START_HATS) && !a.outputConnection && !a.previousConnection, c = a.getPreviousBlock();
              return !!a.outputConnection || b || (c ? c.getNextBlock() === a : false);
            }
            hasRightSquareCorner(a) {
              return true;
            }
            measure() {
              let a = 0, b = 0, c = 0;
              for (let d = 0; d < this.elements.length; d++) {
                const e = this.elements[d];
                b += e.width;
                Types$$module$build$src$core$renderers$measurables$types.isSpacer(e) || (Types$$module$build$src$core$renderers$measurables$types.isHat(e) ? c = Math.max(c, e.ascenderHeight) : a = Math.max(a, e.height));
              }
              this.width = Math.max(this.minWidth, b);
              this.height = Math.max(this.minHeight, a) + c;
              this.capline = this.ascenderHeight = c;
              this.widthWithConnectedBlocks = this.width;
            }
            startsWithElemSpacer() {
              return false;
            }
            endsWithElemSpacer() {
              return false;
            }
          }, module$build$src$core$renderers$measurables$top_row = {};
          module$build$src$core$renderers$measurables$top_row.TopRow = TopRow$$module$build$src$core$renderers$measurables$top_row;
          var ConstantProvider$$module$build$src$core$renderers$common$constants = class {
            constructor() {
              this.NO_PADDING = 0;
              this.SMALL_PADDING = 3;
              this.MEDIUM_PADDING = 5;
              this.MEDIUM_LARGE_PADDING = 8;
              this.LARGE_PADDING = 10;
              this.TAB_HEIGHT = 15;
              this.TAB_OFFSET_FROM_TOP = 5;
              this.TAB_VERTICAL_OVERLAP = 2.5;
              this.TAB_WIDTH = 8;
              this.NOTCH_WIDTH = 15;
              this.NOTCH_HEIGHT = 4;
              this.MIN_BLOCK_WIDTH = 12;
              this.EMPTY_BLOCK_SPACER_HEIGHT = 16;
              this.CORNER_RADIUS = 8;
              this.NOTCH_OFFSET_LEFT = 15;
              this.STATEMENT_BOTTOM_SPACER = 0;
              this.STATEMENT_INPUT_PADDING_LEFT = 20;
              this.BETWEEN_STATEMENT_PADDING_Y = 4;
              this.ADD_START_HATS = false;
              this.START_HAT_HEIGHT = 15;
              this.START_HAT_WIDTH = 100;
              this.SPACER_DEFAULT_HEIGHT = 15;
              this.MIN_BLOCK_HEIGHT = 24;
              this.EMPTY_INLINE_INPUT_PADDING = 14.5;
              this.EXTERNAL_VALUE_INPUT_PADDING = 2;
              this.JAGGED_TEETH_HEIGHT = 12;
              this.JAGGED_TEETH_WIDTH = 6;
              this.FIELD_TEXT_FONTSIZE = 11;
              this.FIELD_TEXT_FONTWEIGHT = "normal";
              this.FIELD_TEXT_FONTFAMILY = "sans-serif";
              this.FIELD_TEXT_BASELINE = this.FIELD_TEXT_HEIGHT = -1;
              this.FIELD_BORDER_RECT_RADIUS = 4;
              this.FIELD_BORDER_RECT_HEIGHT = 16;
              this.FIELD_BORDER_RECT_X_PADDING = 5;
              this.FIELD_BORDER_RECT_Y_PADDING = 3;
              this.FIELD_BORDER_RECT_COLOUR = "#fff";
              this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = false;
              this.FIELD_DROPDOWN_SVG_ARROW_SIZE = 12;
              this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = false;
              this.FIELD_COLOUR_DEFAULT_WIDTH = 26;
              this.defs = null;
              this.embossFilterId = "";
              this.embossFilter = null;
              this.disabledPatternId = "";
              this.disabledPattern = null;
              this.debugFilterId = "";
              this.cssNode = this.debugFilter = null;
              this.CURSOR_COLOUR = "#cc0a0a";
              this.MARKER_COLOUR = "#4286f4";
              this.CURSOR_WS_WIDTH = 100;
              this.WS_CURSOR_HEIGHT = 5;
              this.CURSOR_STACK_PADDING = 10;
              this.CURSOR_BLOCK_PADDING = 2;
              this.CURSOR_STROKE_WIDTH = 4;
              this.FULL_BLOCK_FIELDS = false;
              this.INSERTION_MARKER_COLOUR = "#000000";
              this.INSERTION_MARKER_OPACITY = 0.2;
              this.SHAPES = { PUZZLE: 1, NOTCH: 2 };
              this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING;
              this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT;
              this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT;
              this.TOP_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;
              this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
              this.BOTTOM_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;
              this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
              this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11;
              this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT;
              this.START_POINT = moveBy$$module$build$src$core$utils$svg_paths(0, 0);
              this.FIELD_TEXT_BASELINE_CENTER = true;
              this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;
              this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;
              this.FIELD_DROPDOWN_SVG_ARROW_DATAURI = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=";
              this.FIELD_COLOUR_DEFAULT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;
              this.FIELD_CHECKBOX_X_OFFSET = this.FIELD_BORDER_RECT_X_PADDING - 3;
              this.randomIdentifier = String(Math.random()).substring(2);
            }
            init() {
              this.JAGGED_TEETH = this.makeJaggedTeeth();
              this.NOTCH = this.makeNotch();
              this.START_HAT = this.makeStartHat();
              this.PUZZLE_TAB = this.makePuzzleTab();
              this.INSIDE_CORNERS = this.makeInsideCorners();
              this.OUTSIDE_CORNERS = this.makeOutsideCorners();
            }
            setTheme(a) {
              this.blockStyles = /* @__PURE__ */ Object.create(null);
              const b = a.blockStyles;
              for (const c in b) this.blockStyles[c] = this.validatedBlockStyle_(b[c]);
              this.setDynamicProperties_(a);
            }
            setDynamicProperties_(a) {
              this.setFontConstants_(a);
              this.setComponentConstants_(a);
              this.ADD_START_HATS = a.startHats !== void 0 ? a.startHats : this.ADD_START_HATS;
            }
            setFontConstants_(a) {
              a.fontStyle && a.fontStyle.family && (this.FIELD_TEXT_FONTFAMILY = a.fontStyle.family);
              a.fontStyle && a.fontStyle.weight && (this.FIELD_TEXT_FONTWEIGHT = a.fontStyle.weight);
              a.fontStyle && a.fontStyle.size && (this.FIELD_TEXT_FONTSIZE = a.fontStyle.size);
              a = measureFontMetrics$$module$build$src$core$utils$dom(
                "Hg",
                this.FIELD_TEXT_FONTSIZE + "pt",
                this.FIELD_TEXT_FONTWEIGHT,
                this.FIELD_TEXT_FONTFAMILY
              );
              this.FIELD_TEXT_HEIGHT = a.height;
              this.FIELD_TEXT_BASELINE = a.baseline;
            }
            setComponentConstants_(a) {
              this.CURSOR_COLOUR = a.getComponentStyle("cursorColour") || this.CURSOR_COLOUR;
              this.MARKER_COLOUR = a.getComponentStyle("markerColour") || this.MARKER_COLOUR;
              this.INSERTION_MARKER_COLOUR = a.getComponentStyle("insertionMarkerColour") || this.INSERTION_MARKER_COLOUR;
              this.INSERTION_MARKER_OPACITY = Number(a.getComponentStyle("insertionMarkerOpacity")) || this.INSERTION_MARKER_OPACITY;
            }
            getBlockStyleForColour(a) {
              const b = "auto_" + a;
              this.blockStyles[b] || (this.blockStyles[b] = this.createBlockStyle_(a));
              return { style: this.blockStyles[b], name: b };
            }
            getBlockStyle(a) {
              return this.blockStyles[a || ""] || (a && a.startsWith("auto_") ? this.getBlockStyleForColour(a.substring(5)).style : this.createBlockStyle_("#000000"));
            }
            createBlockStyle_(a) {
              return this.validatedBlockStyle_({ colourPrimary: a });
            }
            validatedBlockStyle_(a) {
              const b = {};
              a && Object.assign(b, a);
              a = parseBlockColour$$module$build$src$core$utils$parsing(b.colourPrimary || "#000");
              b.colourPrimary = a.hex;
              b.colourSecondary = b.colourSecondary ? parseBlockColour$$module$build$src$core$utils$parsing(b.colourSecondary).hex : this.generateSecondaryColour_(b.colourPrimary);
              b.colourTertiary = b.colourTertiary ? parseBlockColour$$module$build$src$core$utils$parsing(b.colourTertiary).hex : this.generateTertiaryColour_(b.colourPrimary);
              b.hat = b.hat || "";
              return b;
            }
            generateSecondaryColour_(a) {
              return blend$$module$build$src$core$utils$colour("#fff", a, 0.6) || a;
            }
            generateTertiaryColour_(a) {
              return blend$$module$build$src$core$utils$colour(
                "#fff",
                a,
                0.3
              ) || a;
            }
            dispose() {
              this.embossFilter && removeNode$$module$build$src$core$utils$dom(this.embossFilter);
              this.disabledPattern && removeNode$$module$build$src$core$utils$dom(this.disabledPattern);
              this.debugFilter && removeNode$$module$build$src$core$utils$dom(this.debugFilter);
              this.cssNode = null;
            }
            makeJaggedTeeth() {
              const a = this.JAGGED_TEETH_HEIGHT, b = this.JAGGED_TEETH_WIDTH, c = line$$module$build$src$core$utils$svg_paths([point$$module$build$src$core$utils$svg_paths(b, a / 4), point$$module$build$src$core$utils$svg_paths(-b * 2, a / 2), point$$module$build$src$core$utils$svg_paths(b, a / 4)]);
              return { height: a, width: b, path: c };
            }
            makeStartHat() {
              const a = this.START_HAT_HEIGHT, b = this.START_HAT_WIDTH, c = curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(30, -a), point$$module$build$src$core$utils$svg_paths(70, -a), point$$module$build$src$core$utils$svg_paths(b, 0)]);
              return { height: a * 0.75, width: b, path: c };
            }
            makePuzzleTab() {
              function a(f) {
                f = f ? -1 : 1;
                const g = -f;
                var h = c / 2;
                const k = h + 2.5, l = h + 0.5, m = point$$module$build$src$core$utils$svg_paths(
                  -b,
                  f * h
                );
                h = point$$module$build$src$core$utils$svg_paths(b, f * h);
                return curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(0, f * k), point$$module$build$src$core$utils$svg_paths(-b, g * l), m]) + curve$$module$build$src$core$utils$svg_paths("s", [point$$module$build$src$core$utils$svg_paths(b, g * 2.5), h]);
              }
              const b = this.TAB_WIDTH, c = this.TAB_HEIGHT, d = a(true), e = a(false);
              return { type: this.SHAPES.PUZZLE, width: b, height: c, pathDown: e, pathUp: d };
            }
            makeNotch() {
              function a(g) {
                return line$$module$build$src$core$utils$svg_paths([point$$module$build$src$core$utils$svg_paths(g * d, c), point$$module$build$src$core$utils$svg_paths(g * 3, 0), point$$module$build$src$core$utils$svg_paths(g * d, -c)]);
              }
              const b = this.NOTCH_WIDTH, c = this.NOTCH_HEIGHT, d = (b - 3) / 2, e = a(1), f = a(-1);
              return { type: this.SHAPES.NOTCH, width: b, height: c, pathLeft: e, pathRight: f };
            }
            makeInsideCorners() {
              const a = this.CORNER_RADIUS, b = arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a, point$$module$build$src$core$utils$svg_paths(-a, a)), c = arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a, point$$module$build$src$core$utils$svg_paths(
                a,
                a
              ));
              return { width: a, height: a, pathTop: b, pathBottom: c };
            }
            makeOutsideCorners() {
              const a = this.CORNER_RADIUS, b = moveBy$$module$build$src$core$utils$svg_paths(0, a) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a, point$$module$build$src$core$utils$svg_paths(a, -a)), c = arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a, point$$module$build$src$core$utils$svg_paths(a, a)), d = arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a, point$$module$build$src$core$utils$svg_paths(-a, -a)), e = arc$$module$build$src$core$utils$svg_paths(
                "a",
                "0 0,1",
                a,
                point$$module$build$src$core$utils$svg_paths(-a, a)
              );
              return { topLeft: b, topRight: c, bottomRight: e, bottomLeft: d, rightHeight: a };
            }
            shapeFor(a) {
              switch (a.type) {
                case ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE:
                case ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE:
                  return this.PUZZLE_TAB;
                case ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT:
                case ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT:
                  return this.NOTCH;
                default:
                  throw Error("Unknown connection type");
              }
            }
            createDom(a, b, c, d) {
              this.injectCSS_(b, c);
              this.defs = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.DEFS, {}, a);
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FILTER, { id: "blocklyEmbossFilter" + this.randomIdentifier }, this.defs);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEGAUSSIANBLUR, { "in": "SourceAlpha", stdDeviation: 1, result: "blur" }, a);
              b = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.FESPECULARLIGHTING,
                { "in": "blur", surfaceScale: 1, specularConstant: 0.5, specularExponent: 10, "lighting-color": "white", result: "specOut" },
                a
              );
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEPOINTLIGHT, { x: -5e3, y: -1e4, z: 2e4 }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPOSITE, { "in": "specOut", in2: "SourceAlpha", operator: "in", result: "specOut" }, a);
              createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.FECOMPOSITE,
                { "in": "SourceGraphic", in2: "specOut", operator: "arithmetic", k1: 0, k2: 1, k3: 1, k4: 0 },
                a
              );
              this.embossFilterId = a.id;
              this.embossFilter = a;
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATTERN, { id: "blocklyDisabledPattern" + this.randomIdentifier, patternUnits: "userSpaceOnUse", width: 10, height: 10 }, this.defs);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { width: 10, height: 10, fill: "#aaa" }, a);
              createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.PATH,
                { d: "M 0 0 L 10 10 M 10 0 L 0 10", stroke: "#cc0" },
                a
              );
              this.disabledPatternId = a.id;
              this.disabledPattern = a;
              this.createDebugFilter();
              d && (d.style.setProperty("--blocklyEmbossFilter", `url(#${this.embossFilterId})`), d.style.setProperty("--blocklyDisabledPattern", `url(#${this.disabledPatternId})`), d.style.setProperty("--blocklyDebugFilter", `url(#${this.debugFilterId})`));
            }
            createDebugFilter() {
              if (!this.debugFilter) {
                const a = createSvgElement$$module$build$src$core$utils$dom(
                  Svg$$module$build$src$core$utils$svg.FILTER,
                  { id: "blocklyDebugFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" },
                  this.defs
                ), b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPONENTTRANSFER, { result: "outBlur" }, a);
                createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, b);
                createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFLOOD, {
                  "flood-color": "#ff0000",
                  "flood-opacity": 0.5,
                  result: "outColor"
                }, a);
                createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPOSITE, { "in": "outColor", in2: "outBlur", operator: "in", result: "outGlow" }, a);
                this.debugFilterId = a.id;
                this.debugFilter = a;
              }
            }
            injectCSS_(a, b) {
              b = this.getCSS_(b);
              a = "blockly-renderer-style-" + a;
              this.cssNode = document.getElementById(a);
              const c = b.join("\n");
              this.cssNode ? this.cssNode.firstChild.textContent = c : (b = document.createElement("style"), b.id = a, a = document.createTextNode(c), b.appendChild(a), document.head.insertBefore(b, document.head.firstChild), this.cssNode = b);
            }
            getCSS_(a) {
              return [
                `${a} .blocklyText, `,
                `${a} .blocklyFlyoutLabelText {`,
                `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`,
                "}",
                `${a} .blocklyText {`,
                "fill: #fff;",
                "}",
                `${a} .blocklyNonEditableField>rect,`,
                `${a} .blocklyEditableField>rect {`,
                `fill: ${this.FIELD_BORDER_RECT_COLOUR};`,
                "fill-opacity: .6;",
                "stroke: none;",
                "}",
                `${a} .blocklyNonEditableField>text,`,
                `${a} .blocklyEditableField>text {`,
                "fill: #000;",
                "}",
                `${a} .blocklyFlyoutLabelText {`,
                "fill: #000;",
                "}",
                `${a} .blocklyText.blocklyBubbleText {`,
                "fill: #000;",
                "}",
                `${a} .blocklyEditableField:not(.blocklyEditing):hover>rect {`,
                "stroke: #fff;",
                "stroke-width: 2;",
                "}",
                `${a} .blocklyHtmlInput {`,
                `font-family: ${this.FIELD_TEXT_FONTFAMILY};`,
                `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`,
                "}",
                `${a} .blocklySelected>.blocklyPath {`,
                "stroke: #fc3;",
                "stroke-width: 3px;",
                "}",
                `${a} .blocklyHighlightedConnectionPath {`,
                "stroke: #fc3;",
                "}",
                `${a} .blocklyReplaceable .blocklyPath {`,
                "fill-opacity: .5;",
                "}",
                `${a} .blocklyReplaceable .blocklyPathLight,`,
                `${a} .blocklyReplaceable .blocklyPathDark {`,
                "display: none;",
                "}",
                `${a} .blocklyInsertionMarker>.blocklyPath {`,
                `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`,
                "stroke: none;",
                "}"
              ];
            }
          }, module$build$src$core$renderers$common$constants = {};
          module$build$src$core$renderers$common$constants.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$common$constants;
          module$build$src$core$renderers$common$constants.isDynamicShape = isDynamicShape$$module$build$src$core$renderers$common$constants;
          module$build$src$core$renderers$common$constants.isNotch = isNotch$$module$build$src$core$renderers$common$constants;
          module$build$src$core$renderers$common$constants.isPuzzleTab = isPuzzleTab$$module$build$src$core$renderers$common$constants;
          var Drawer$$module$build$src$core$renderers$common$drawer = class {
            constructor(a, b) {
              this.inlinePath_ = this.outlinePath_ = "";
              this.block_ = a;
              this.info_ = b;
              this.topLeft_ = a.getRelativeToSurfaceXY();
              this.constants_ = b.getRenderer().getConstants();
            }
            draw() {
              this.drawOutline_();
              this.drawInternals_();
              this.updateConnectionHighlights();
              this.block_.pathObject.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
              this.info_.RTL && this.block_.pathObject.flipRTL();
              this.recordSizeOnBlock_();
            }
            recordSizeOnBlock_() {
              this.block_.height = this.info_.height;
              this.block_.width = this.info_.widthWithChildren;
              this.block_.childlessWidth = this.info_.width;
            }
            drawOutline_() {
              this.drawTop_();
              for (let a = 1; a < this.info_.rows.length - 1; a++) {
                const b = this.info_.rows[a];
                b.hasJaggedEdge ? this.drawJaggedEdge_(b) : b.hasStatement ? this.drawStatementInput_(b) : b.hasExternalInput ? this.drawValueInput_(b) : this.drawRightSideRow_(b);
              }
              this.drawBottom_();
              this.drawLeft_();
            }
            drawTop_() {
              const a = this.info_.topRow, b = a.elements;
              this.positionPreviousConnection_();
              this.outlinePath_ += moveBy$$module$build$src$core$utils$svg_paths(a.xPos, this.info_.startY);
              for (let c = 0, d; d = b[c]; c++) Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(d) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft : Types$$module$build$src$core$renderers$measurables$types.isRightRoundedCorner(d) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topRight : Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(d) ? this.outlinePath_ += d.shape.pathLeft : Types$$module$build$src$core$renderers$measurables$types.isHat(d) ? this.outlinePath_ += this.constants_.START_HAT.path : Types$$module$build$src$core$renderers$measurables$types.isSpacer(d) && (this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("h", d.width));
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("v", a.height - a.ascenderHeight);
            }
            drawJaggedEdge_(a) {
              this.outlinePath_ += this.constants_.JAGGED_TEETH.path + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a.height - this.constants_.JAGGED_TEETH.height);
            }
            drawValueInput_(a) {
              const b = a.getLastInput();
              this.positionExternalValueConnection_(a);
              const c = isDynamicShape$$module$build$src$core$renderers$common$constants(b.shape) ? b.shape.pathDown(b.height) : b.shape.pathDown;
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", b.xPos + b.width) + c + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a.height - b.connectionHeight);
            }
            drawStatementInput_(a) {
              var b = a.getLastInput();
              if (b) {
                var c = b.xPos + b.notchOffset + b.shape.width;
                b = b.shape.pathRight + lineOnAxis$$module$build$src$core$utils$svg_paths(
                  "h",
                  -(b.notchOffset - this.constants_.INSIDE_CORNERS.width)
                ) + this.constants_.INSIDE_CORNERS.pathTop;
                var d = a.height - 2 * this.constants_.INSIDE_CORNERS.height;
                this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", c) + b + lineOnAxis$$module$build$src$core$utils$svg_paths("v", d) + this.constants_.INSIDE_CORNERS.pathBottom + lineOnAxis$$module$build$src$core$utils$svg_paths("H", a.xPos + a.width);
                this.positionStatementInputConnection_(a);
              }
            }
            drawRightSideRow_(a) {
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths(
                "V",
                a.yPos + a.height
              );
            }
            drawBottom_() {
              const a = this.info_.bottomRow, b = a.elements;
              this.positionNextConnection_();
              let c = 0, d = "";
              for (let e = b.length - 1, f; f = b[e]; e--) Types$$module$build$src$core$renderers$measurables$types.isNextConnection(f) ? d += f.shape.pathRight : Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(f) ? d += lineOnAxis$$module$build$src$core$utils$svg_paths("H", a.xPos) : Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(f) ? d += this.constants_.OUTSIDE_CORNERS.bottomLeft : Types$$module$build$src$core$renderers$measurables$types.isRightRoundedCorner(f) ? (d += this.constants_.OUTSIDE_CORNERS.bottomRight, c = this.constants_.OUTSIDE_CORNERS.rightHeight) : Types$$module$build$src$core$renderers$measurables$types.isSpacer(f) && (d += lineOnAxis$$module$build$src$core$utils$svg_paths("h", f.width * -1));
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.baseline - c);
              this.outlinePath_ += d;
            }
            drawLeft_() {
              var a = this.info_.outputConnection;
              this.positionOutputConnection_();
              if (a) {
                const b = a.connectionOffsetY + a.height;
                a = isDynamicShape$$module$build$src$core$renderers$common$constants(a.shape) ? a.shape.pathUp(a.height) : a.shape.pathUp;
                this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", b) + a;
              }
              this.outlinePath_ += "z";
            }
            drawInternals_() {
              for (let a = 0, b; b = this.info_.rows[a]; a++) for (let c = 0, d; d = b.elements[c]; c++) Types$$module$build$src$core$renderers$measurables$types.isInlineInput(d) ? this.drawInlineInput_(d) : (Types$$module$build$src$core$renderers$measurables$types.isIcon(d) || Types$$module$build$src$core$renderers$measurables$types.isField(d)) && this.layoutField_(d);
            }
            layoutField_(a) {
              const b = a.centerline - a.height / 2;
              let c = a.xPos;
              var d = "";
              this.info_.RTL && (c = -(c + a.width), a.flipRtl && (c += a.width, d = "scale(-1 1)"));
              Types$$module$build$src$core$renderers$measurables$types.isIcon(a) ? (d = a.icon, d.setOffsetInBlock(new Coordinate$$module$build$src$core$utils$coordinate(c, b)), this.info_.isInsertionMarker && d.hideForInsertionMarker()) : (a = a.field.getSvgRoot(), a.setAttribute("transform", "translate(" + c + "," + b + ")" + d), this.info_.isInsertionMarker && a.setAttribute("display", "none"));
            }
            drawInlineInput_(a) {
              const b = a.width, c = a.height, d = a.connectionOffsetY, e = a.connectionHeight + d;
              this.inlinePath_ += moveTo$$module$build$src$core$utils$svg_paths(a.xPos + a.connectionWidth, a.centerline - c / 2) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", d) + a.shape.pathDown + lineOnAxis$$module$build$src$core$utils$svg_paths("v", c - e) + lineOnAxis$$module$build$src$core$utils$svg_paths("h", b - a.connectionWidth) + lineOnAxis$$module$build$src$core$utils$svg_paths(
                "v",
                -c
              ) + "z";
              this.positionInlineInputConnection_(a);
            }
            positionInlineInputConnection_(a) {
              const b = a.centerline - a.height / 2;
              if (a.connectionModel) {
                let c = a.xPos + a.connectionWidth + a.connectionOffsetX;
                this.info_.RTL && (c *= -1);
                a.connectionModel.setOffsetInBlock(c, b + a.connectionOffsetY);
              }
            }
            positionStatementInputConnection_(a) {
              const b = a.getLastInput();
              if (b == null ? 0 : b.connectionModel) {
                let c = a.xPos + a.statementEdge + b.notchOffset;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos);
              }
            }
            positionExternalValueConnection_(a) {
              const b = a.getLastInput();
              if (b && b.connectionModel) {
                let c = a.xPos + a.width;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos);
              }
            }
            positionPreviousConnection_() {
              const a = this.info_.topRow;
              if (a.connection) {
                const b = a.xPos + a.notchOffset;
                a.connection.connectionModel.setOffsetInBlock(this.info_.RTL ? -b : b, 0);
              }
            }
            positionNextConnection_() {
              const a = this.info_.bottomRow;
              if (a.connection) {
                const b = a.connection, c = b.xPos;
                b.connectionModel.setOffsetInBlock(this.info_.RTL ? -c : c, a.baseline);
              }
            }
            positionOutputConnection_() {
              if (this.info_.outputConnection) {
                const a = this.info_.startX + this.info_.outputConnection.connectionOffsetX;
                this.block_.outputConnection.setOffsetInBlock(this.info_.RTL ? -a : a, this.info_.outputConnection.connectionOffsetY);
              }
            }
            updateConnectionHighlights() {
              for (const a of this.info_.rows) for (const b of a.elements) {
                if (!(b instanceof Connection$$module$build$src$core$renderers$measurables$connection)) continue;
                const c = this.drawConnectionHighlightPath(b);
                c && (c.style.display = b.highlighted ? "" : "none");
              }
            }
            drawConnectionHighlightPath(a) {
              const b = a.connectionModel;
              a = b.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE || b.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE ? this.getExpressionConnectionHighlightPath(a) : this.getStatementConnectionHighlightPath(a);
              const c = b.getSourceBlock();
              let d, e;
              return (e = (d = c.pathObject).addConnectionHighlight) == null ? void 0 : e.call(d, b, a, b.getOffsetInBlock(), c.RTL);
            }
            getExpressionConnectionHighlightPath(a) {
              let b = "";
              isDynamicShape$$module$build$src$core$renderers$common$constants(a.shape) ? b = a.shape.pathDown(a.height) : isPuzzleTab$$module$build$src$core$renderers$common$constants(a.shape) && (b = a.shape.pathDown);
              a = this.constants_.TAB_OFFSET_FROM_TOP;
              return moveBy$$module$build$src$core$utils$svg_paths(0, -a) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a) + b + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a);
            }
            getStatementConnectionHighlightPath(a) {
              if (!isNotch$$module$build$src$core$renderers$common$constants(a.shape)) throw Error("Statement connections should have notch shapes");
              const b = this.constants_.NOTCH_OFFSET_LEFT - this.constants_.CORNER_RADIUS;
              return moveBy$$module$build$src$core$utils$svg_paths(-b, 0) + lineOnAxis$$module$build$src$core$utils$svg_paths("h", b) + a.shape.pathLeft + lineOnAxis$$module$build$src$core$utils$svg_paths("h", b);
            }
          }, module$build$src$core$renderers$common$drawer = {};
          module$build$src$core$renderers$common$drawer.Drawer = Drawer$$module$build$src$core$renderers$common$drawer;
          var RenderInfo$$module$build$src$core$renderers$common$info = class {
            constructor(a, b) {
              this.statementEdge = this.width = this.widthWithChildren = this.height = 0;
              this.rows = [];
              this.inputRows = [];
              this.startY = this.startX = 0;
              this.renderer_ = a;
              this.block_ = b;
              this.constants_ = this.renderer_.getConstants();
              this.outputConnection = b.outputConnection ? new OutputConnection$$module$build$src$core$renderers$measurables$output_connection(this.constants_, b.outputConnection) : null;
              this.isInline = b.getInputsInline() && !b.isCollapsed();
              this.isCollapsed = b.isCollapsed();
              this.isInsertionMarker = b.isInsertionMarker();
              this.RTL = b.RTL;
              this.topRow = new TopRow$$module$build$src$core$renderers$measurables$top_row(this.constants_);
              this.bottomRow = new BottomRow$$module$build$src$core$renderers$measurables$bottom_row(this.constants_);
            }
            getRenderer() {
              return this.renderer_;
            }
            measure() {
              this.createRows_();
              this.addElemSpacing_();
              this.addRowSpacing_();
              this.computeBounds_();
              this.alignRowElements_();
              this.finalize_();
            }
            createRows_() {
              this.populateTopRow_();
              this.rows.push(this.topRow);
              let a = new InputRow$$module$build$src$core$renderers$measurables$input_row(this.constants_);
              this.inputRows.push(a);
              var b = this.block_.getIcons();
              for (let c = 0, d; d = b[c]; c++) {
                const e = new Icon$$module$build$src$core$renderers$measurables$icon(this.constants_, d);
                this.isCollapsed && !d.isShownWhenCollapsed() || a.elements.push(e);
              }
              b = void 0;
              for (let c = 0, d; d = this.block_.inputList[c]; c++) if (d.isVisible()) {
                this.shouldStartNewRow_(d, b) && (this.rows.push(a), a = new InputRow$$module$build$src$core$renderers$measurables$input_row(this.constants_), this.inputRows.push(a));
                for (let e = 0, f; f = d.fieldRow[e]; e++) a.elements.push(new Field$$module$build$src$core$renderers$measurables$field(this.constants_, f, d));
                this.addInput_(d, a);
                b = d;
              }
              this.isCollapsed && (a.hasJaggedEdge = true, a.elements.push(new JaggedEdge$$module$build$src$core$renderers$measurables$jagged_edge(this.constants_)));
              (a.elements.length || a.hasDummyInput) && this.rows.push(a);
              this.populateBottomRow_();
              this.rows.push(this.bottomRow);
            }
            populateTopRow_() {
              var a = !!this.block_.previousConnection;
              const b = (this.block_.hat ? this.block_.hat === "cap" : this.constants_.ADD_START_HATS) && !this.outputConnection && !a;
              let c = this.topRow.hasLeftSquareCorner(this.block_) ? SquareCorner$$module$build$src$core$renderers$measurables$square_corner : RoundCorner$$module$build$src$core$renderers$measurables$round_corner;
              this.topRow.elements.push(new c(this.constants_));
              b ? (a = new Hat$$module$build$src$core$renderers$measurables$hat(this.constants_), this.topRow.elements.push(a)) : a && (this.topRow.hasPreviousConnection = true, this.topRow.connection = new PreviousConnection$$module$build$src$core$renderers$measurables$previous_connection(this.constants_, this.block_.previousConnection), this.topRow.elements.push(this.topRow.connection));
              this.block_.inputList.length && this.block_.inputList[0] instanceof StatementInput$$module$build$src$core$inputs$statement_input && !this.block_.isCollapsed() ? this.topRow.minHeight = this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT : this.topRow.minHeight = this.constants_.TOP_ROW_MIN_HEIGHT;
              c = this.topRow.hasRightSquareCorner(this.block_) ? SquareCorner$$module$build$src$core$renderers$measurables$square_corner : RoundCorner$$module$build$src$core$renderers$measurables$round_corner;
              this.topRow.elements.push(new c(this.constants_, "right"));
            }
            populateBottomRow_() {
              this.bottomRow.hasNextConnection = !!this.block_.nextConnection;
              this.bottomRow.minHeight = this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1] instanceof StatementInput$$module$build$src$core$inputs$statement_input ? this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT : this.constants_.BOTTOM_ROW_MIN_HEIGHT;
              this.bottomRow.hasLeftSquareCorner(this.block_) ? this.bottomRow.elements.push(new SquareCorner$$module$build$src$core$renderers$measurables$square_corner(this.constants_)) : this.bottomRow.elements.push(new RoundCorner$$module$build$src$core$renderers$measurables$round_corner(this.constants_));
              this.bottomRow.hasNextConnection && (this.bottomRow.connection = new NextConnection$$module$build$src$core$renderers$measurables$next_connection(this.constants_, this.block_.nextConnection), this.bottomRow.elements.push(this.bottomRow.connection));
              this.bottomRow.hasRightSquareCorner(this.block_) ? this.bottomRow.elements.push(new SquareCorner$$module$build$src$core$renderers$measurables$square_corner(this.constants_, "right")) : this.bottomRow.elements.push(new RoundCorner$$module$build$src$core$renderers$measurables$round_corner(this.constants_, "right"));
            }
            addInput_(a, b) {
              if (this.isInline && a instanceof $.ValueInput$$module$build$src$core$inputs$value_input) b.elements.push(new InlineInput$$module$build$src$core$renderers$measurables$inline_input(
                this.constants_,
                a
              )), b.hasInlineInput = true;
              else if (a instanceof StatementInput$$module$build$src$core$inputs$statement_input) b.elements.push(new StatementInput$$module$build$src$core$renderers$measurables$statement_input(this.constants_, a)), b.hasStatement = true;
              else if (a instanceof $.ValueInput$$module$build$src$core$inputs$value_input) b.elements.push(new ExternalValueInput$$module$build$src$core$renderers$measurables$external_value_input(this.constants_, a)), b.hasExternalInput = true;
              else if (a instanceof DummyInput$$module$build$src$core$inputs$dummy_input || a instanceof EndRowInput$$module$build$src$core$inputs$end_row_input) b.minHeight = Math.max(b.minHeight, a.getSourceBlock() && a.getSourceBlock().isShadow() ? this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT : this.constants_.DUMMY_INPUT_MIN_HEIGHT), b.hasDummyInput = true;
              b.align === null && (b.align = a.align);
            }
            shouldStartNewRow_(a, b) {
              return b ? b instanceof EndRowInput$$module$build$src$core$inputs$end_row_input || a instanceof StatementInput$$module$build$src$core$inputs$statement_input || b instanceof StatementInput$$module$build$src$core$inputs$statement_input ? true : a instanceof $.ValueInput$$module$build$src$core$inputs$value_input || a instanceof DummyInput$$module$build$src$core$inputs$dummy_input || b instanceof $.ValueInput$$module$build$src$core$inputs$value_input ? !this.isInline : false : false;
            }
            addElemSpacing_() {
              for (let a = 0, b; b = this.rows[a]; a++) {
                const c = b.elements;
                b.elements = [];
                b.startsWithElemSpacer() && b.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, this.getInRowSpacing_(null, c[0])));
                if (c.length) {
                  for (let d = 0; d < c.length - 1; d++) {
                    b.elements.push(c[d]);
                    const e = this.getInRowSpacing_(c[d], c[d + 1]);
                    b.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, e));
                  }
                  b.elements.push(c[c.length - 1]);
                  b.endsWithElemSpacer() && b.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, this.getInRowSpacing_(c[c.length - 1], null)));
                }
              }
            }
            getInRowSpacing_(a, b) {
              if (!a && b && Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b)) return this.constants_.STATEMENT_INPUT_PADDING_LEFT;
              if (a && Types$$module$build$src$core$renderers$measurables$types.isInput(a) && !b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isExternalInput(a)) return this.constants_.NO_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a)) return this.constants_.LARGE_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(a)) return this.constants_.NO_PADDING;
              }
              return a && Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(a) && b && (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b) || Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) ? b.notchOffset : a && Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) && b && (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b) || Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) ? b.notchOffset - this.constants_.CORNER_RADIUS : a && Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING;
            }
            computeBounds_() {
              let a = 0, b = 0, c = 0;
              for (let e = 0, f; f = this.rows[e]; e++) {
                f.measure();
                b = Math.max(b, f.width);
                if (f.hasStatement) {
                  var d = f.getLastInput();
                  let g, h;
                  d = f.width - ((h = (g = d) == null ? void 0 : g.width) != null ? h : 0);
                  a = Math.max(a, d);
                }
                c = Math.max(c, f.widthWithConnectedBlocks);
              }
              this.statementEdge = a;
              this.width = b;
              for (let e = 0, f; f = this.rows[e]; e++) f.hasStatement && (f.statementEdge = this.statementEdge);
              this.widthWithChildren = Math.max(b, c);
              this.outputConnection && (this.startX = this.outputConnection.width, this.width += this.outputConnection.width, this.widthWithChildren += this.outputConnection.width);
            }
            alignRowElements_() {
              for (let b = 0, c; c = this.rows[b]; b++) if (c.hasStatement) this.alignStatementRow_(c);
              else {
                var a = c.width;
                a = this.getDesiredRowWidth_(c) - a;
                a > 0 && this.addAlignmentPadding_(c, a);
                Types$$module$build$src$core$renderers$measurables$types.isTopOrBottomRow(c) && (c.widthWithConnectedBlocks = c.width);
              }
            }
            getDesiredRowWidth_(a) {
              return this.width - this.startX;
            }
            addAlignmentPadding_(a, b) {
              const c = a.getFirstSpacer(), d = a.getLastSpacer();
              if (a.hasExternalInput || a.hasStatement) a.widthWithConnectedBlocks += b;
              if (a.align === $.Align$$module$build$src$core$inputs$align.LEFT && d) d.width += b;
              else if (a.align === $.Align$$module$build$src$core$inputs$align.CENTRE && c && d) c.width += b / 2, d.width += b / 2;
              else if (a.align === $.Align$$module$build$src$core$inputs$align.RIGHT && c) c.width += b;
              else if (d) d.width += b;
              else return;
              a.width += b;
            }
            alignStatementRow_(a) {
              const b = a.getLastInput();
              if (b) {
                var c = a.width - b.width, d = this.statementEdge;
                c = d - c;
                c > 0 && this.addAlignmentPadding_(a, c);
                c = a.width;
                d = this.getDesiredRowWidth_(a);
                b.width += d - c;
                b.height = Math.max(b.height, a.height);
                a.width += d - c;
                a.widthWithConnectedBlocks = Math.max(a.width, this.statementEdge + a.connectedBlockWidths);
              }
            }
            addRowSpacing_() {
              const a = this.rows;
              this.rows = [];
              for (let b = 0; b < a.length; b++) this.rows.push(a[b]), b !== a.length - 1 && this.rows.push(this.makeSpacerRow_(a[b], a[b + 1]));
            }
            makeSpacerRow_(a, b) {
              var c = this.getSpacerRowHeight_(a, b);
              const d = this.getSpacerRowWidth_(a, b);
              c = new SpacerRow$$module$build$src$core$renderers$measurables$spacer_row(
                this.constants_,
                c,
                d
              );
              a.hasStatement && (c.followsStatement = true);
              b.hasStatement && (c.precedesStatement = true);
              return c;
            }
            getSpacerRowWidth_(a, b) {
              return this.width - this.startX;
            }
            getSpacerRowHeight_(a, b) {
              return this.constants_.MEDIUM_PADDING;
            }
            getElemCenterline_(a, b) {
              return Types$$module$build$src$core$renderers$measurables$types.isSpacer(b) ? a.yPos + b.height / 2 : Types$$module$build$src$core$renderers$measurables$types.isBottomRow(a) ? (a = a.yPos + a.height - a.descenderHeight, Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2) : Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) ? Types$$module$build$src$core$renderers$measurables$types.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2 : a.yPos + a.height / 2;
            }
            recordElemPositions_(a) {
              let b = a.xPos;
              for (let c = 0, d; d = a.elements[c]; c++) Types$$module$build$src$core$renderers$measurables$types.isSpacer(d) && (d.height = a.height), d.xPos = b, d.centerline = this.getElemCenterline_(a, d), b += d.width;
            }
            finalize_() {
              let a = 0, b = 0;
              for (let c = 0, d; d = this.rows[c]; c++) d.yPos = b, d.xPos = this.startX, b += d.height, a = Math.max(a, d.widthWithConnectedBlocks), this.recordElemPositions_(d);
              if (this.outputConnection && this.block_.nextConnection) {
                const c = this.block_.nextConnection.targetBlock();
                c && (a = Math.max(a, c.getHeightWidth().width));
              }
              this.widthWithChildren = a + this.startX;
              this.height = b;
              this.startY = this.topRow.capline;
              this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
            }
            getMeasureableForConnection(a) {
              let b;
              if (((b = this.outputConnection) == null ? void 0 : b.connectionModel) === a) return this.outputConnection;
              for (const c of this.rows) for (const d of c.elements) if (d instanceof Connection$$module$build$src$core$renderers$measurables$connection && d.connectionModel === a) return d;
              return null;
            }
          }, module$build$src$core$renderers$common$info = {};
          module$build$src$core$renderers$common$info.RenderInfo = RenderInfo$$module$build$src$core$renderers$common$info;
          var PathObject$$module$build$src$core$renderers$common$path_object = class {
            constructor(a, b, c) {
              this.connectionHighlights = /* @__PURE__ */ new WeakMap();
              this.highlightOffsets = /* @__PURE__ */ new WeakMap();
              this.constants = c;
              this.style = b;
              this.svgRoot = a;
              this.svgPath = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyPath" }, this.svgRoot);
              this.setClass_("blocklyBlock", true);
            }
            setPath(a) {
              this.svgPath.setAttribute("d", a);
            }
            flipRTL() {
              this.svgPath.setAttribute("transform", "scale(-1 1)");
            }
            applyColour(a) {
              this.svgPath.setAttribute(
                "stroke",
                this.style.colourTertiary
              );
              this.svgPath.setAttribute("fill", this.style.colourPrimary);
              this.updateShadow_(a.isShadow());
              this.updateDisabled_(!a.isEnabled() || a.getInheritedDisabled());
            }
            setStyle(a) {
              this.style = a;
            }
            setClass_(a, b) {
              a && (b ? addClass$$module$build$src$core$utils$dom(this.svgRoot, a) : removeClass$$module$build$src$core$utils$dom(this.svgRoot, a));
            }
            updateHighlighted(a) {
              a ? this.setClass_("blocklyHighlighted", true) : this.setClass_("blocklyHighlighted", false);
            }
            updateShadow_(a) {
              a ? (this.setClass_(
                "blocklyShadow",
                true
              ), this.svgPath.setAttribute("stroke", "none"), this.svgPath.setAttribute("fill", this.style.colourSecondary)) : this.setClass_("blocklyShadow", false);
            }
            updateDisabled_(a) {
              this.setClass_("blocklyDisabled", a);
              this.setClass_("blocklyDisabledPattern", a);
            }
            updateSelected(a) {
              this.setClass_("blocklySelected", a);
            }
            updateDraggingDelete(a) {
              this.setClass_("blocklyDraggingDelete", a);
            }
            updateInsertionMarker(a) {
              this.setClass_("blocklyInsertionMarker", a);
            }
            updateMovable(a) {
              this.setClass_("blocklyDraggable", a);
            }
            updateReplacementFade(a) {
              this.setClass_(
                "blocklyReplaceable",
                a
              );
            }
            updateShapeForInputHighlight(a, b) {
            }
            addConnectionHighlight(a, b, c, d) {
              c = `translate(${c.x}, ${c.y})` + (d ? " scale(-1 1)" : "");
              if (d = this.connectionHighlights.get(a)) return d.setAttribute("d", b), d.setAttribute("transform", c), d;
              b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { id: a.id, "class": "blocklyHighlightedConnectionPath", style: "display: none;", d: b, transform: c }, this.svgRoot);
              this.connectionHighlights.set(a, b);
              return b;
            }
            removeConnectionHighlight(a) {
              const b = this.connectionHighlights.get(a);
              b && (removeNode$$module$build$src$core$utils$dom(b), this.connectionHighlights.delete(a));
            }
          }, module$build$src$core$renderers$common$path_object = {};
          module$build$src$core$renderers$common$path_object.PathObject = PathObject$$module$build$src$core$renderers$common$path_object;
          var Renderer$$module$build$src$core$renderers$common$renderer = class {
            constructor(a) {
              this.overrides = null;
              this.name = a;
            }
            getClassName() {
              return this.name + "-renderer";
            }
            init(a, b) {
              this.constants_ = this.makeConstants_();
              b && (this.overrides = b, Object.assign(this.constants_, b));
              this.constants_.setTheme(a);
              this.constants_.init();
            }
            createDom(a, b, c) {
              this.constants_.createDom(a, this.name + "-" + b.name, "." + this.getClassName() + "." + b.getClassName(), c);
            }
            refreshDom(a, b, c) {
              const d = this.getConstants();
              d.dispose();
              this.constants_ = this.makeConstants_();
              this.overrides && Object.assign(this.constants_, this.overrides);
              this.constants_.randomIdentifier = d.randomIdentifier;
              this.constants_.setTheme(b);
              this.constants_.init();
              this.createDom(a, b, c);
            }
            dispose() {
              this.constants_ && this.constants_.dispose();
            }
            makeConstants_() {
              return new ConstantProvider$$module$build$src$core$renderers$common$constants();
            }
            makeRenderInfo_(a) {
              return new RenderInfo$$module$build$src$core$renderers$common$info(this, a);
            }
            makeDrawer_(a, b) {
              return new Drawer$$module$build$src$core$renderers$common$drawer(
                a,
                b
              );
            }
            makePathObject(a, b) {
              return new PathObject$$module$build$src$core$renderers$common$path_object(a, b, this.constants_);
            }
            getConstants() {
              return this.constants_;
            }
            shouldHighlightConnection(a) {
              return true;
            }
            orphanCanConnectAtEnd(a, b, c) {
              return !!Connection$$module$build$src$core$connection.getConnectionForOrphanedConnection(a, c === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE ? b.outputConnection : b.previousConnection);
            }
            render(a) {
              const b = this.makeRenderInfo_(a);
              b.measure();
              this.makeDrawer_(a, b).draw();
            }
          }, module$build$src$core$renderers$common$renderer = {};
          module$build$src$core$renderers$common$renderer.Renderer = Renderer$$module$build$src$core$renderers$common$renderer;
          var module$build$src$core$renderers$common$block_rendering = {};
          module$build$src$core$renderers$common$block_rendering.BottomRow = BottomRow$$module$build$src$core$renderers$measurables$bottom_row;
          module$build$src$core$renderers$common$block_rendering.Connection = Connection$$module$build$src$core$renderers$measurables$connection;
          module$build$src$core$renderers$common$block_rendering.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$common$constants;
          module$build$src$core$renderers$common$block_rendering.Drawer = Drawer$$module$build$src$core$renderers$common$drawer;
          module$build$src$core$renderers$common$block_rendering.ExternalValueInput = ExternalValueInput$$module$build$src$core$renderers$measurables$external_value_input;
          module$build$src$core$renderers$common$block_rendering.Field = Field$$module$build$src$core$renderers$measurables$field;
          module$build$src$core$renderers$common$block_rendering.Hat = Hat$$module$build$src$core$renderers$measurables$hat;
          module$build$src$core$renderers$common$block_rendering.Icon = Icon$$module$build$src$core$renderers$measurables$icon;
          module$build$src$core$renderers$common$block_rendering.InRowSpacer = InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer;
          module$build$src$core$renderers$common$block_rendering.InlineInput = InlineInput$$module$build$src$core$renderers$measurables$inline_input;
          module$build$src$core$renderers$common$block_rendering.InputConnection = InputConnection$$module$build$src$core$renderers$measurables$input_connection;
          module$build$src$core$renderers$common$block_rendering.InputRow = InputRow$$module$build$src$core$renderers$measurables$input_row;
          module$build$src$core$renderers$common$block_rendering.JaggedEdge = JaggedEdge$$module$build$src$core$renderers$measurables$jagged_edge;
          module$build$src$core$renderers$common$block_rendering.Measurable = Measurable$$module$build$src$core$renderers$measurables$base;
          module$build$src$core$renderers$common$block_rendering.NextConnection = NextConnection$$module$build$src$core$renderers$measurables$next_connection;
          module$build$src$core$renderers$common$block_rendering.OutputConnection = OutputConnection$$module$build$src$core$renderers$measurables$output_connection;
          module$build$src$core$renderers$common$block_rendering.PathObject = PathObject$$module$build$src$core$renderers$common$path_object;
          module$build$src$core$renderers$common$block_rendering.PreviousConnection = PreviousConnection$$module$build$src$core$renderers$measurables$previous_connection;
          module$build$src$core$renderers$common$block_rendering.RenderInfo = RenderInfo$$module$build$src$core$renderers$common$info;
          module$build$src$core$renderers$common$block_rendering.Renderer = Renderer$$module$build$src$core$renderers$common$renderer;
          module$build$src$core$renderers$common$block_rendering.RoundCorner = RoundCorner$$module$build$src$core$renderers$measurables$round_corner;
          module$build$src$core$renderers$common$block_rendering.Row = Row$$module$build$src$core$renderers$measurables$row;
          module$build$src$core$renderers$common$block_rendering.SpacerRow = SpacerRow$$module$build$src$core$renderers$measurables$spacer_row;
          module$build$src$core$renderers$common$block_rendering.SquareCorner = SquareCorner$$module$build$src$core$renderers$measurables$square_corner;
          module$build$src$core$renderers$common$block_rendering.StatementInput = StatementInput$$module$build$src$core$renderers$measurables$statement_input;
          module$build$src$core$renderers$common$block_rendering.TopRow = TopRow$$module$build$src$core$renderers$measurables$top_row;
          module$build$src$core$renderers$common$block_rendering.Types = Types$$module$build$src$core$renderers$measurables$types;
          module$build$src$core$renderers$common$block_rendering.init = init$$module$build$src$core$renderers$common$block_rendering;
          module$build$src$core$renderers$common$block_rendering.register = register$$module$build$src$core$renderers$common$block_rendering;
          module$build$src$core$renderers$common$block_rendering.unregister = unregister$$module$build$src$core$renderers$common$block_rendering;
          var ThemeManager$$module$build$src$core$theme_manager = class {
            constructor(a, b) {
              this.workspace = a;
              this.theme = b;
              this.subscribedWorkspaces = [];
              this.componentDB = /* @__PURE__ */ new Map();
            }
            getTheme() {
              return this.theme;
            }
            setTheme(a) {
              var b = this.theme;
              this.theme = a;
              if (a = this.workspace.getInjectionDiv()) b && (b = b.getClassName()) && removeClass$$module$build$src$core$utils$dom(a, b), (b = this.theme.getClassName()) && addClass$$module$build$src$core$utils$dom(a, b);
              for (let c = 0, d; d = this.subscribedWorkspaces[c]; c++) d.refreshTheme();
              for (const [
                c,
                d
              ] of this.componentDB) for (const e of d) {
                a = e.element;
                b = e.propertyName;
                const f = this.theme && this.theme.getComponentStyle(c);
                a.style.setProperty(b, f || "");
              }
              for (const c of this.subscribedWorkspaces) c.hideChaff();
            }
            subscribeWorkspace(a) {
              this.subscribedWorkspaces.push(a);
            }
            unsubscribeWorkspace(a) {
              if (!removeElem$$module$build$src$core$utils$array(this.subscribedWorkspaces, a)) throw Error("Cannot unsubscribe a workspace that hasn't been subscribed.");
            }
            subscribe(a, b, c) {
              this.componentDB.has(b) || this.componentDB.set(
                b,
                []
              );
              this.componentDB.get(b).push({ element: a, propertyName: c });
              b = this.theme && this.theme.getComponentStyle(b);
              a.style.setProperty(c, b || "");
            }
            unsubscribe(a) {
              if (a) for (const [b, c] of this.componentDB) {
                for (let d = c.length - 1; d >= 0; d--) c[d].element === a && c.splice(d, 1);
                c.length || this.componentDB.delete(b);
              }
            }
            dispose() {
              this.subscribedWorkspaces.length = 0;
              this.componentDB.clear();
            }
          }, module$build$src$core$theme_manager = {};
          module$build$src$core$theme_manager.ThemeManager = ThemeManager$$module$build$src$core$theme_manager;
          var CATEGORY_NAME$$module$build$src$core$variables_dynamic = "VARIABLE_DYNAMIC", onCreateVariableButtonClick_String$$module$build$src$core$variables_dynamic = stringButtonClickHandler$$module$build$src$core$variables_dynamic, onCreateVariableButtonClick_Number$$module$build$src$core$variables_dynamic = numberButtonClickHandler$$module$build$src$core$variables_dynamic, onCreateVariableButtonClick_Colour$$module$build$src$core$variables_dynamic = colourButtonClickHandler$$module$build$src$core$variables_dynamic, module$build$src$core$variables_dynamic = { CATEGORY_NAME: CATEGORY_NAME$$module$build$src$core$variables_dynamic };
          module$build$src$core$variables_dynamic.flyoutCategory = flyoutCategory$$module$build$src$core$variables_dynamic;
          module$build$src$core$variables_dynamic.flyoutCategoryBlocks = flyoutCategoryBlocks$$module$build$src$core$variables_dynamic;
          module$build$src$core$variables_dynamic.internalFlyoutCategory = internalFlyoutCategory$$module$build$src$core$variables_dynamic;
          module$build$src$core$variables_dynamic.onCreateVariableButtonClick_Colour = colourButtonClickHandler$$module$build$src$core$variables_dynamic;
          module$build$src$core$variables_dynamic.onCreateVariableButtonClick_Number = numberButtonClickHandler$$module$build$src$core$variables_dynamic;
          module$build$src$core$variables_dynamic.onCreateVariableButtonClick_String = stringButtonClickHandler$$module$build$src$core$variables_dynamic;
          var ConnectionChecker$$module$build$src$core$connection_checker = class {
            canConnect(a, b, c, d) {
              return this.canConnectWithReason(a, b, c, d) === Connection$$module$build$src$core$connection.CAN_CONNECT;
            }
            canConnectWithReason(a, b, c, d) {
              const e = this.doSafetyChecks(a, b);
              return e !== Connection$$module$build$src$core$connection.CAN_CONNECT ? e : this.doTypeChecks(a, b) ? c && !this.doDragChecks(a, b, d || 0) ? Connection$$module$build$src$core$connection.REASON_DRAG_CHECKS_FAILED : Connection$$module$build$src$core$connection.CAN_CONNECT : Connection$$module$build$src$core$connection.REASON_CHECKS_FAILED;
            }
            getErrorMessage(a, b, c) {
              switch (a) {
                case Connection$$module$build$src$core$connection.REASON_SELF_CONNECTION:
                  return "Attempted to connect a block to itself.";
                case Connection$$module$build$src$core$connection.REASON_DIFFERENT_WORKSPACES:
                  return "Blocks not on same workspace.";
                case Connection$$module$build$src$core$connection.REASON_WRONG_TYPE:
                  return "Attempt to connect incompatible types.";
                case Connection$$module$build$src$core$connection.REASON_TARGET_NULL:
                  return "Target connection is null.";
                case Connection$$module$build$src$core$connection.REASON_CHECKS_FAILED:
                  return "Connection checks failed. " + (b + " expected " + b.getCheck() + ", found " + c.getCheck());
                case Connection$$module$build$src$core$connection.REASON_SHADOW_PARENT:
                  return "Connecting non-shadow to shadow block.";
                case Connection$$module$build$src$core$connection.REASON_DRAG_CHECKS_FAILED:
                  return "Drag checks failed.";
                case Connection$$module$build$src$core$connection.REASON_PREVIOUS_AND_OUTPUT:
                  return "Block would have an output and a previous connection.";
                default:
                  return "Unknown connection failure: this should never happen!";
              }
            }
            doSafetyChecks(a, b) {
              if (!a || !b) return Connection$$module$build$src$core$connection.REASON_TARGET_NULL;
              let c, d, e;
              a.isSuperior() ? (c = a.getSourceBlock(), d = b.getSourceBlock(), e = b) : (d = a.getSourceBlock(), c = b.getSourceBlock(), e = a, a = b);
              return c === d ? Connection$$module$build$src$core$connection.REASON_SELF_CONNECTION : e.type !== OPPOSITE_TYPE$$module$build$src$core$internal_constants[a.type] ? Connection$$module$build$src$core$connection.REASON_WRONG_TYPE : c.workspace !== d.workspace ? Connection$$module$build$src$core$connection.REASON_DIFFERENT_WORKSPACES : c.isShadow() && !d.isShadow() ? Connection$$module$build$src$core$connection.REASON_SHADOW_PARENT : e.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE && d.previousConnection && d.previousConnection.isConnected() || e.type === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT && d.outputConnection && d.outputConnection.isConnected() ? Connection$$module$build$src$core$connection.REASON_PREVIOUS_AND_OUTPUT : Connection$$module$build$src$core$connection.CAN_CONNECT;
            }
            doTypeChecks(a, b) {
              a = a.getCheck();
              b = b.getCheck();
              if (!a || !b) return true;
              for (let c = 0; c < a.length; c++) if (b.includes(a[c])) return true;
              return false;
            }
            doDragChecks(a, b, c) {
              if (a.distanceFrom(b) > c || b.getSourceBlock().isInsertionMarker()) return false;
              switch (b.type) {
                case ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT:
                  return this.canConnectToPrevious_(a, b);
                case ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE:
                  if (b.isConnected() && !b.targetBlock().isInsertionMarker() || a.isConnected()) return false;
                  break;
                case ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE:
                  if (b.isConnected() && !b.targetBlock().isMovable() && !b.targetBlock().isShadow()) return false;
                  break;
                case ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT:
                  if (b.isConnected() && !a.getSourceBlock().nextConnection && !b.targetBlock().isShadow() && b.targetBlock().nextConnection || b.targetBlock() && !b.targetBlock().isMovable() && !b.targetBlock().isShadow()) return false;
                  break;
                default:
                  return false;
              }
              return draggingConnections$$module$build$src$core$common.includes(b) ? false : true;
            }
            canConnectToPrevious_(a, b) {
              if (a.targetConnection || draggingConnections$$module$build$src$core$common.includes(b)) return false;
              if (!b.targetConnection) return true;
              a = b.targetBlock();
              return a.isInsertionMarker() ? !a.getPreviousBlock() : false;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.CONNECTION_CHECKER, DEFAULT$$module$build$src$core$registry, ConnectionChecker$$module$build$src$core$connection_checker);
          var module$build$src$core$connection_checker = {};
          module$build$src$core$connection_checker.ConnectionChecker = ConnectionChecker$$module$build$src$core$connection_checker;
          var Workspace$$module$build$src$core$workspace = class {
            get isFlyout() {
              return this.internalIsFlyout;
            }
            get isMutator() {
              return this.internalIsMutator;
            }
            constructor(a) {
              this.isClearing = this.internalIsMutator = this.internalIsFlyout = this.rendered = false;
              this.MAX_UNDO = 1024;
              this.connectionDBList = [];
              this.topBlocks = [];
              this.topComments = [];
              this.commentDB = /* @__PURE__ */ new Map();
              this.listeners = [];
              this.undoStack_ = [];
              this.redoStack_ = [];
              this.blockDB = /* @__PURE__ */ new Map();
              this.typedBlocksDB = /* @__PURE__ */ new Map();
              this.procedureMap = new ObservableProcedureMap$$module$build$src$core$observable_procedure_map();
              this.readOnly = false;
              this.potentialVariableMap = null;
              this.id = genUid$$module$build$src$core$utils$idgenerator();
              registerWorkspace$$module$build$src$core$common(this);
              this.options = a || new Options$$module$build$src$core$options({});
              this.RTL = !!this.options.RTL;
              this.horizontalLayout = !!this.options.horizontalLayout;
              this.toolboxPosition = this.options.toolboxPosition;
              this.connectionChecker = new (getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.CONNECTION_CHECKER,
                this.options,
                true
              ))(this);
              this.variableMap = new (this.getVariableMapClass())(this);
              this.setIsReadOnly(this.options.readOnly);
            }
            dispose() {
              this.listeners.length = 0;
              this.clear();
              unregisterWorkpace$$module$build$src$core$common(this);
            }
            sortObjects(a, b) {
              const c = (d) => ({ getBoundingRectangle: () => {
                const e = d.getRelativeToSurfaceXY();
                return new Rect$$module$build$src$core$utils$rect(e.y, e.y, e.x, e.x);
              }, moveBy: () => {
              } });
              return this.sortByOrigin(c(a), c(b));
            }
            sortByOrigin(a, b) {
              const c = Math.sin(toRadians$$module$build$src$core$utils$math(Workspace$$module$build$src$core$workspace.SCAN_ANGLE)) * (this.RTL ? -1 : 1);
              a = a.getBoundingRectangle().getOrigin();
              b = b.getBoundingRectangle().getOrigin();
              return a.y + c * a.x - (b.y + c * b.x);
            }
            addTopBlock(a) {
              this.topBlocks.push(a);
            }
            removeTopBlock(a) {
              if (!removeElem$$module$build$src$core$utils$array(this.topBlocks, a)) throw Error("Block not present in workspace's list of top-most blocks.");
            }
            getTopBlocks(a = false) {
              const b = [].concat(this.topBlocks);
              a && b.length > 1 && b.sort(this.sortObjects.bind(this));
              return b;
            }
            addTypedBlock(a) {
              this.typedBlocksDB.has(a.type) || this.typedBlocksDB.set(
                a.type,
                []
              );
              this.typedBlocksDB.get(a.type).push(a);
            }
            removeTypedBlock(a) {
              removeElem$$module$build$src$core$utils$array(this.typedBlocksDB.get(a.type), a);
              this.typedBlocksDB.get(a.type).length || this.typedBlocksDB.delete(a.type);
            }
            getBlocksByType(a, b = false) {
              if (!this.typedBlocksDB.has(a)) return [];
              a = this.typedBlocksDB.get(a).slice(0);
              b && a && a.length > 1 && a.sort(this.sortObjects.bind(this));
              return a.filter((c) => !c.isInsertionMarker());
            }
            addTopComment(a) {
              this.topComments.push(a);
              this.commentDB.has(a.id) && console.warn('Overriding an existing comment on this workspace, with id "' + a.id + '"');
              this.commentDB.set(a.id, a);
            }
            removeTopComment(a) {
              if (!removeElem$$module$build$src$core$utils$array(this.topComments, a)) throw Error("Comment not present in workspace's list of top-most comments.");
              this.commentDB.delete(a.id);
            }
            getTopComments(a = false) {
              const b = [].concat(this.topComments);
              a && b.length > 1 && b.sort(this.sortObjects.bind(this));
              return b;
            }
            getAllBlocks(a = false) {
              if (a) {
                var b = this.getTopBlocks(true);
                a = [];
                for (let c = 0; c < b.length; c++) a.push(...b[c].getDescendants(true));
              } else for (a = this.getTopBlocks(false), b = 0; b < a.length; b++) a.push(...a[b].getChildren(false));
              return a.filter((c) => !c.isInsertionMarker());
            }
            clear() {
              this.isClearing = true;
              try {
                const a = $.getGroup$$module$build$src$core$events$utils();
                for (a || $.setGroup$$module$build$src$core$events$utils(true); this.topBlocks.length; ) this.topBlocks[0].dispose(false);
                for (; this.topComments.length; ) this.topComments[this.topComments.length - 1].dispose();
                $.setGroup$$module$build$src$core$events$utils(a);
                this.isFlyout || this.variableMap.clear();
                this.potentialVariableMap && this.potentialVariableMap.clear();
              } finally {
                this.isClearing = false;
              }
            }
            renameVariableById(a, b) {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.renameVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().renameVariable");
              (a = this.variableMap.getVariableById(a)) && this.variableMap.renameVariable(a, b);
            }
            createVariable(a, b, c) {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.createVariable", "v12", "v13", "Blockly.Workspace.getVariableMap().createVariable");
              return this.variableMap.createVariable(a, b != null ? b : void 0, c != null ? c : void 0);
            }
            getVariableUsesById(a) {
              warn$$module$build$src$core$utils$deprecation(
                "Blockly.Workspace.getVariableUsesById",
                "v12",
                "v13",
                "Blockly.Variables.getVariableUsesById"
              );
              return getVariableUsesById$$module$build$src$core$variables(this, a);
            }
            deleteVariableById(a) {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.deleteVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().deleteVariable");
              const b = this.variableMap.getVariableById(a);
              b ? $.deleteVariable$$module$build$src$core$variables(this, b) : console.warn(`Can't delete non-existent variable: ${a}`);
            }
            getVariable(a, b) {
              warn$$module$build$src$core$utils$deprecation(
                "Blockly.Workspace.getVariable",
                "v12",
                "v13",
                "Blockly.Workspace.getVariableMap().getVariable"
              );
              return this.variableMap.getVariable(a, b);
            }
            getVariableById(a) {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.getVariableById", "v12", "v13", "Blockly.Workspace.getVariableMap().getVariableById");
              return this.variableMap.getVariableById(a);
            }
            getVariablesOfType(a) {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.getVariablesOfType", "v12", "v13", "Blockly.Workspace.getVariableMap().getVariablesOfType");
              return this.variableMap.getVariablesOfType(a != null ? a : "");
            }
            getAllVariables() {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.getAllVariables", "v12", "v13", "Blockly.Workspace.getVariableMap().getAllVariables");
              return this.variableMap.getAllVariables();
            }
            getAllVariableNames() {
              warn$$module$build$src$core$utils$deprecation("Blockly.Workspace.getAllVariableNames", "v12", "v13", "Blockly.Workspace.getVariableMap().getAllVariables");
              return this.variableMap.getAllVariables().map((a) => a.getName());
            }
            getWidth() {
              return 0;
            }
            newBlock(a, b) {
              throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts");
            }
            newComment(a) {
              throw Error("The implementation of newComment should be monkey-patched in by blockly.ts");
            }
            remainingCapacity() {
              return isNaN(this.options.maxBlocks) ? Infinity : this.options.maxBlocks - this.getAllBlocks(false).length;
            }
            remainingCapacityOfType(a) {
              return this.options.maxInstances ? (this.options.maxInstances[a] !== void 0 ? this.options.maxInstances[a] : Infinity) - this.getBlocksByType(a, false).length : Infinity;
            }
            isCapacityAvailable(a) {
              if (!this.hasBlockLimits()) return true;
              let b = 0;
              for (const c in a) {
                if (a[c] > this.remainingCapacityOfType(c)) return false;
                b += a[c];
              }
              return b > this.remainingCapacity() ? false : true;
            }
            hasBlockLimits() {
              return this.options.maxBlocks !== Infinity || !!this.options.maxInstances;
            }
            getUndoStack() {
              return this.undoStack_;
            }
            getRedoStack() {
              return this.redoStack_;
            }
            undo(a) {
              var b = a ? this.redoStack_ : this.undoStack_, c = a ? this.undoStack_ : this.redoStack_;
              const d = b.pop();
              if (d) {
                for (var e = [d]; b.length && d.group && d.group === b[b.length - 1].group; ) {
                  const f = b.pop();
                  f && e.push(f);
                }
                for (b = 0; b < e.length; b++) c.push(e[b]);
                $.setRecordUndo$$module$build$src$core$events$utils(false);
                try {
                  for (c = 0; c < e.length; c++) e[c].run(a);
                } finally {
                  $.setRecordUndo$$module$build$src$core$events$utils(true);
                }
              }
            }
            clearUndo() {
              this.undoStack_.length = 0;
              this.redoStack_.length = 0;
              clearPendingUndo$$module$build$src$core$events$utils();
            }
            addChangeListener(a) {
              this.listeners.push(a);
              return a;
            }
            removeChangeListener(a) {
              removeElem$$module$build$src$core$utils$array(this.listeners, a);
            }
            fireChangeListener(a) {
              if (a.recordUndo) for (this.undoStack_.push(a), this.redoStack_.length = 0; this.undoStack_.length > this.MAX_UNDO && this.MAX_UNDO >= 0; ) this.undoStack_.shift();
              for (let b = 0; b < this.listeners.length; b++) (0, this.listeners[b])(a);
            }
            getBlockById(a) {
              return this.blockDB.get(a) || null;
            }
            setBlockById(a, b) {
              this.blockDB.set(a, b);
            }
            removeBlockById(a) {
              this.blockDB.delete(a);
            }
            getCommentById(a) {
              let b;
              return (b = this.commentDB.get(a)) != null ? b : null;
            }
            allInputsFilled(a) {
              const b = this.getTopBlocks(false);
              for (let c = 0; c < b.length; c++) if (!b[c].allInputsFilled(a)) return false;
              return true;
            }
            getPotentialVariableMap() {
              return this.potentialVariableMap;
            }
            createPotentialVariableMap() {
              this.potentialVariableMap = new (this.getVariableMapClass())(this, true);
            }
            getVariableMap() {
              return this.variableMap;
            }
            setVariableMap(a) {
              this.variableMap = a;
            }
            getProcedureMap() {
              return this.procedureMap;
            }
            getRootWorkspace() {
              let a = null;
              const b = this.options.parentWorkspace;
              this.isFlyout ? b && b.options && (a = b.options.parentWorkspace) : b && (a = b);
              return a;
            }
            static getById(a) {
              return getWorkspaceById$$module$build$src$core$common(a);
            }
            static getAll() {
              return getAllWorkspaces$$module$build$src$core$common();
            }
            getVariableMapClass() {
              const a = getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.VARIABLE_MAP,
                this.options,
                true
              );
              if (!a) throw Error("No variable map is registered.");
              return a;
            }
            isReadOnly() {
              return this.readOnly;
            }
            setIsReadOnly(a) {
              this.readOnly = a;
              this.options.readOnly = a;
            }
          };
          Workspace$$module$build$src$core$workspace.SCAN_ANGLE = 3;
          var module$build$src$core$workspace = {};
          module$build$src$core$workspace.Workspace = Workspace$$module$build$src$core$workspace;
          var SOUND_LIMIT$$module$build$src$core$workspace_audio = 100, WorkspaceAudio$$module$build$src$core$workspace_audio = class {
            constructor(a) {
              this.parentWorkspace = a;
              this.sounds = /* @__PURE__ */ new Map();
              this.lastSound = null;
              this.muted = false;
            }
            dispose() {
              this.sounds.clear();
            }
            load(a, b) {
              if (a.length) {
                try {
                  var c = new globalThis.Audio();
                } catch (e) {
                  return;
                }
                for (let e = 0; e < a.length; e++) {
                  const f = a[e], g = f.match(/\.(\w+)$/);
                  if (g && c.canPlayType("audio/" + g[1])) {
                    var d = new globalThis.Audio(f);
                    break;
                  }
                }
                d && this.sounds.set(b, d);
              }
            }
            preload() {
              for (const a of this.sounds.values()) {
                a.volume = 0.01;
                const b = a.play();
                b !== void 0 ? b.then(a.pause).catch(function() {
                }) : a.pause();
                if (IPAD$$module$build$src$core$utils$useragent || IPHONE$$module$build$src$core$utils$useragent) break;
              }
            }
            play(a, b) {
              if (!this.muted) {
                var c = this.sounds.get(a);
                c ? (a = /* @__PURE__ */ new Date(), this.lastSound !== null && a.getTime() - this.lastSound.getTime() < SOUND_LIMIT$$module$build$src$core$workspace_audio || (this.lastSound = a, c = IPAD$$module$build$src$core$utils$useragent || ANDROID$$module$build$src$core$utils$useragent ? c : c.cloneNode(), c.volume = b === void 0 ? 1 : b, c.play())) : this.parentWorkspace && this.parentWorkspace.getAudioManager().play(a, b);
              }
            }
            setMuted(a) {
              this.muted = a;
            }
            getMuted() {
              return this.muted;
            }
          }, module$build$src$core$workspace_audio = {};
          module$build$src$core$workspace_audio.WorkspaceAudio = WorkspaceAudio$$module$build$src$core$workspace_audio;
          var ZOOM_TO_FIT_MARGIN$$module$build$src$core$workspace_svg = 20, WorkspaceSvg$$module$build$src$core$workspace_svg = class extends Workspace$$module$build$src$core$workspace {
            constructor(a) {
              super(a);
              this.resizeHandlerWrapper = null;
              this.resizesEnabled = this.visible = this.rendered = true;
              this.startScrollY = this.startScrollX = this.scrollY = this.scrollX = 0;
              this.oldScale = this.scale = 1;
              this.oldLeft = this.oldTop = 0;
              this.inverseScreenCTM = this.targetWorkspace = this.dummyWheelListener = this.configureContextMenu = this.lastRecordedPageScroll = this.injectionDiv = this.currentGesture_ = this.toolbox = this.flyout = this.scrollbar = this.trashcan = null;
              this.inverseScreenCTMDirty = true;
              this.highlightedBlocks = [];
              this.toolboxCategoryCallbacks = /* @__PURE__ */ new Map();
              this.flyoutButtonCallbacks = /* @__PURE__ */ new Map();
              this.cachedParentSvg = null;
              this.keyboardMoveInProgress = this.keyboardAccessibilityMode = false;
              this.topBoundedElements = [];
              this.dragTargetAreas = [];
              this.zoomControls_ = this.layerManager = null;
              this.navigator = new Navigator$$module$build$src$core$navigator();
              this.metricsManager = new (getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.METRICS_MANAGER,
                a,
                true
              ))(this);
              this.getMetrics = a.getMetrics || this.metricsManager.getMetrics.bind(this.metricsManager);
              this.setMetrics = a.setMetrics || WorkspaceSvg$$module$build$src$core$workspace_svg.setTopLevelWorkspaceMetrics;
              this.componentManager = new ComponentManager$$module$build$src$core$component_manager();
              this.connectionDBList = ConnectionDB$$module$build$src$core$connection_db.init(this.connectionChecker);
              this.audioManager = new WorkspaceAudio$$module$build$src$core$workspace_audio(a.parentWorkspace);
              this.grid = this.options.gridPattern ? new Grid$$module$build$src$core$grid(this.options.gridPattern, a.gridOptions) : null;
              this.markerManager = new MarkerManager$$module$build$src$core$marker_manager(this);
              module$build$src$core$variables && internalFlyoutCategory$$module$build$src$core$variables && this.registerToolboxCategoryCallback(CATEGORY_NAME$$module$build$src$core$variables, internalFlyoutCategory$$module$build$src$core$variables);
              module$build$src$core$variables_dynamic && internalFlyoutCategory$$module$build$src$core$variables_dynamic && this.registerToolboxCategoryCallback(
                CATEGORY_NAME$$module$build$src$core$variables_dynamic,
                internalFlyoutCategory$$module$build$src$core$variables_dynamic
              );
              module$build$src$core$procedures && internalFlyoutCategory$$module$build$src$core$procedures && (this.registerToolboxCategoryCallback(CATEGORY_NAME$$module$build$src$core$procedures, internalFlyoutCategory$$module$build$src$core$procedures), this.addChangeListener(mutatorOpenListener$$module$build$src$core$procedures));
              this.addChangeListener(this.variableChangeCallback.bind(this));
              this.themeManager_ = this.options.parentWorkspace ? this.options.parentWorkspace.getThemeManager() : new ThemeManager$$module$build$src$core$theme_manager(this, this.options.theme || Classic$$module$build$src$core$theme$classic);
              this.themeManager_.subscribeWorkspace(this);
              let b;
              this.renderer = init$$module$build$src$core$renderers$common$block_rendering(this.options.renderer || "geras", this.getTheme(), (b = this.options.rendererOverrides) != null ? b : void 0);
              this.cachedParentSvgSize = new Size$$module$build$src$core$utils$size(0, 0);
            }
            getMarkerManager() {
              return this.markerManager;
            }
            getMetricsManager() {
              return this.metricsManager;
            }
            setMetricsManager(a) {
              this.metricsManager = a;
              this.getMetrics = this.metricsManager.getMetrics.bind(this.metricsManager);
            }
            getComponentManager() {
              return this.componentManager;
            }
            getMarker(a) {
              return this.markerManager.getMarker(a);
            }
            getCursor() {
              return this.markerManager.getCursor();
            }
            getRenderer() {
              return this.renderer;
            }
            getThemeManager() {
              return this.themeManager_;
            }
            getTheme() {
              return this.themeManager_.getTheme();
            }
            setTheme(a) {
              a || (a = Classic$$module$build$src$core$theme$classic);
              this.themeManager_.setTheme(a);
            }
            refreshTheme() {
              if (this.svgGroup_) {
                var a = this.options.parentWorkspace === null;
                this.renderer.refreshDom(this.svgGroup_, this.getTheme(), a ? this.getInjectionDiv() : void 0);
              }
              this.updateBlockStyles(this.getAllBlocks(false).filter((b) => !!b.getStyleName()));
              this.refreshToolboxSelection();
              this.toolbox && this.toolbox.refreshTheme();
              this.isVisible() && this.setVisible(true);
              a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.THEME_CHANGE))(this.getTheme().name, this.id);
              fire$$module$build$src$core$events$utils(a);
            }
            updateBlockStyles(a) {
              for (let b = 0, c; c = a[b]; b++) {
                const d = c.getStyleName();
                d && c.setStyle(d);
              }
            }
            getInverseScreenCTM() {
              if (this.inverseScreenCTMDirty) {
                const a = this.getParentSvg().getScreenCTM();
                a && (this.inverseScreenCTM = a.inverse(), this.inverseScreenCTMDirty = false);
              }
              return this.inverseScreenCTM;
            }
            updateInverseScreenCTM() {
              this.inverseScreenCTMDirty = true;
            }
            isVisible() {
              return this.visible;
            }
            getSvgXY(a) {
              let b = 0, c = 0, d = 1;
              if (this.getCanvas().contains(a) || this.getBubbleCanvas().contains(a)) d = this.scale;
              do {
                const e = getRelativeXY$$module$build$src$core$utils$svg_math(a);
                if (a === this.getCanvas() || a === this.getBubbleCanvas()) d = 1;
                b += e.x * d;
                c += e.y * d;
                a = a.parentNode;
              } while (a && a !== this.getParentSvg() && a !== this.getInjectionDiv());
              return new Coordinate$$module$build$src$core$utils$coordinate(b, c);
            }
            getCachedParentSvgSize() {
              const a = this.cachedParentSvgSize;
              return new Size$$module$build$src$core$utils$size(a.width, a.height);
            }
            getOriginOffsetInPixels() {
              return getInjectionDivXY$$module$build$src$core$utils$svg_math(this.getCanvas());
            }
            getInjectionDiv() {
              if (!this.injectionDiv) {
                let a = this.svgGroup_;
                for (; a; ) {
                  if ((" " + (a.getAttribute("class") || "") + " ").includes(" injectionDiv ")) {
                    this.injectionDiv = a;
                    break;
                  }
                  a = a.parentNode;
                }
              }
              return this.injectionDiv;
            }
            getSvgGroup() {
              return this.svgGroup_;
            }
            getBlockCanvas() {
              return this.getCanvas();
            }
            setResizeHandlerWrapper(a) {
              this.resizeHandlerWrapper = a;
            }
            createDom(a, b) {
              this.injectionDiv || (this.injectionDiv = b != null ? b : null);
              this.svgGroup_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyWorkspace", id: this.id });
              b && setState$$module$build$src$core$utils$aria(
                this.svgGroup_,
                State$$module$build$src$core$utils$aria.LABEL,
                $.Msg$$module$build$src$core$msg.WORKSPACE_ARIA_LABEL
              );
              a && (this.svgBackground_ = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { height: "100%", width: "100%", "class": a }, this.svgGroup_), a === "blocklyMainBackground" && this.grid ? this.svgBackground_.style.fill = "var(--blocklyGridPattern)" : this.themeManager_.subscribe(this.svgBackground_, "workspaceBackgroundColour", "fill"));
              this.layerManager = new LayerManager$$module$build$src$core$layer_manager(this);
              this.svgBlockCanvas_ = this.layerManager.getBlockLayer();
              this.svgBubbleCanvas_ = this.layerManager.getBubbleLayer();
              this.isFlyout || (conditionalBind$$module$build$src$core$browser_events(this.svgGroup_, "pointerdown", this, this.onMouseDown, false), this.dummyWheelListener = () => {
              }, document.body.addEventListener("wheel", this.dummyWheelListener), conditionalBind$$module$build$src$core$browser_events(this.svgGroup_, "wheel", this, this.onMouseWheel));
              this.options.hasCategories && (this.toolbox = new (getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.TOOLBOX,
                this.options,
                true
              ))(this));
              this.grid && this.grid.update(this.scale);
              this.recordDragTargets();
              (a = getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.CURSOR, this.options)) && this.markerManager.setCursor(new a(this));
              a = this.options.parentWorkspace === null;
              this.renderer.createDom(this.svgGroup_, this.getTheme(), a ? this.getInjectionDiv() : void 0);
              $.getFocusManager$$module$build$src$core$focus_manager().registerTree(this, !!this.injectionDiv || this.isFlyout);
              return this.svgGroup_;
            }
            dispose() {
              this.rendered = false;
              this.currentGesture_ && this.currentGesture_.cancel();
              this.svgGroup_ && removeNode$$module$build$src$core$utils$dom(this.svgGroup_);
              this.toolbox && (this.toolbox.dispose(), this.toolbox = null);
              this.flyout && (this.flyout.dispose(), this.flyout = null);
              this.trashcan && (this.trashcan.dispose(), this.trashcan = null);
              this.scrollbar && (this.scrollbar.dispose(), this.scrollbar = null);
              this.zoomControls_ && this.zoomControls_.dispose();
              this.audioManager && this.audioManager.dispose();
              this.grid && (this.grid = null);
              this.renderer.dispose();
              this.markerManager.dispose();
              super.dispose();
              this.themeManager_ && (this.themeManager_.unsubscribeWorkspace(this), this.themeManager_.unsubscribe(this.svgBackground_), this.options.parentWorkspace || this.themeManager_.dispose());
              this.connectionDBList.length = 0;
              this.toolboxCategoryCallbacks.clear();
              this.flyoutButtonCallbacks.clear();
              if (!this.options.parentWorkspace) {
                const a = this.getParentSvg();
                a && a.parentNode && removeNode$$module$build$src$core$utils$dom(a.parentNode);
              }
              this.resizeHandlerWrapper && (unbind$$module$build$src$core$browser_events(this.resizeHandlerWrapper), this.resizeHandlerWrapper = null);
              this.dummyWheelListener && (document.body.removeEventListener("wheel", this.dummyWheelListener), this.dummyWheelListener = null);
              $.getFocusManager$$module$build$src$core$focus_manager().isRegistered(this) && $.getFocusManager$$module$build$src$core$focus_manager().unregisterTree(this);
            }
            addTrashcan() {
              this.trashcan = WorkspaceSvg$$module$build$src$core$workspace_svg.newTrashcan(this);
              const a = this.trashcan.createDom();
              this.svgGroup_.insertBefore(a, this.getCanvas());
            }
            static newTrashcan(a) {
              throw Error("The implementation of newTrashcan should be monkey-patched in by blockly.ts");
            }
            addZoomControls() {
              this.zoomControls_ = new ZoomControls$$module$build$src$core$zoom_controls(this);
              const a = this.zoomControls_.createDom();
              this.svgGroup_.appendChild(a);
            }
            copyOptionsForFlyout() {
              return new Options$$module$build$src$core$options({
                parentWorkspace: this,
                rtl: this.RTL,
                oneBasedIndex: this.options.oneBasedIndex,
                horizontalLayout: this.horizontalLayout,
                renderer: this.options.renderer,
                rendererOverrides: this.options.rendererOverrides,
                plugins: this.options.plugins,
                modalInputs: this.options.modalInputs,
                move: { scrollbars: true }
              });
            }
            addFlyout(a) {
              const b = this.copyOptionsForFlyout();
              b.toolboxPosition = this.options.toolboxPosition;
              this.flyout = this.horizontalLayout ? new (getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_HORIZONTAL_TOOLBOX, this.options, true))(b) : new (getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_VERTICAL_TOOLBOX, this.options, true))(b);
              this.flyout.autoClose = false;
              this.flyout.getWorkspace().setVisible(true);
              return this.flyout.createDom(a);
            }
            getFlyout(a) {
              return this.flyout || a ? this.flyout : this.toolbox ? this.toolbox.getFlyout() : null;
            }
            getToolbox() {
              return this.toolbox;
            }
            updateScreenCalculations() {
              this.updateInverseScreenCTM();
              this.recordDragTargets();
            }
            resizeContents() {
              this.resizesEnabled && this.rendered && (this.scrollbar && this.scrollbar.resize(), this.updateInverseScreenCTM());
            }
            resize() {
              this.toolbox ? this.toolbox.position() : this.flyout && this.flyout.position();
              const a = this.componentManager.getComponents(
                ComponentManager$$module$build$src$core$component_manager.Capability.POSITIONABLE,
                true
              ), b = this.getMetricsManager().getUiMetrics(), c = [];
              for (let d = 0, e; e = a[d]; d++) {
                e.position(b, c);
                const f = e.getBoundingRectangle();
                f && c.push(f);
              }
              this.scrollbar && this.scrollbar.resize();
              this.updateScreenCalculations();
            }
            updateScreenCalculationsIfScrolled() {
              const a = getDocumentScroll$$module$build$src$core$utils$svg_math();
              Coordinate$$module$build$src$core$utils$coordinate.equals(this.lastRecordedPageScroll, a) || (this.lastRecordedPageScroll = a, this.updateScreenCalculations());
            }
            getLayerManager() {
              return this.layerManager;
            }
            getCanvas() {
              return this.layerManager.getBlockLayer();
            }
            setCachedParentSvgSize(a, b) {
              const c = this.getParentSvg();
              a != null && (this.cachedParentSvgSize.width = a, c.setAttribute("data-cached-width", `${a}`));
              b != null && (this.cachedParentSvgSize.height = b, c.setAttribute("data-cached-height", `${b}`));
            }
            getBubbleCanvas() {
              return this.layerManager.getBubbleLayer();
            }
            getParentSvg() {
              if (!this.cachedParentSvg) {
                let a = this.svgGroup_;
                for (; a; ) {
                  if (a.tagName === "svg") {
                    this.cachedParentSvg = a;
                    break;
                  }
                  a = a.parentNode;
                }
              }
              return this.cachedParentSvg;
            }
            maybeFireViewportChangeEvent() {
              if (isEnabled$$module$build$src$core$events$utils()) {
                var a = this.scale, b = -this.scrollY, c = -this.scrollX;
                if (!(a === this.oldScale && Math.abs(b - this.oldTop) < 1 && Math.abs(c - this.oldLeft) < 1)) {
                  var d = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VIEWPORT_CHANGE))(b, c, a, this.id, this.oldScale);
                  this.oldScale = a;
                  this.oldTop = b;
                  this.oldLeft = c;
                  fire$$module$build$src$core$events$utils(d);
                }
              }
            }
            translate(a, b) {
              let c;
              (c = this.layerManager) == null || c.translateLayers(new Coordinate$$module$build$src$core$utils$coordinate(a, b), this.scale);
              let d;
              (d = this.grid) == null || d.moveTo(a, b);
              this.maybeFireViewportChangeEvent();
            }
            getWidth() {
              const a = this.getMetrics();
              return a ? a.viewWidth / this.scale : 0;
            }
            setVisible(a) {
              this.visible = a;
              this.svgGroup_ && (this.scrollbar && this.scrollbar.setContainerVisible(a), this.getFlyout() && this.getFlyout().setContainerVisible(a), this.getParentSvg().style.display = a ? "block" : "none", this.toolbox && this.toolbox.setVisible(a), a || this.hideChaff(true));
            }
            render() {
              const a = this.getAllBlocks(false);
              for (let b = a.length - 1; b >= 0; b--) a[b].queueRender();
              this.getTopBlocks().flatMap((b) => b.getDescendants(false)).filter((b) => b.isInsertionMarker()).forEach((b) => b.queueRender());
            }
            highlightBlock(a, b) {
              if (b === void 0) {
                for (let c = 0, d; d = this.highlightedBlocks[c]; c++) d.setHighlighted(false);
                this.highlightedBlocks.length = 0;
              }
              if (a = a ? this.getBlockById(a) : null) (b = b === void 0 || b) ? this.highlightedBlocks.includes(a) || this.highlightedBlocks.push(a) : removeElem$$module$build$src$core$utils$array(this.highlightedBlocks, a), a.setHighlighted(b);
            }
            variableChangeCallback(a) {
              switch (a.type) {
                case EventType$$module$build$src$core$events$type.VAR_CREATE:
                case EventType$$module$build$src$core$events$type.VAR_DELETE:
                case EventType$$module$build$src$core$events$type.VAR_RENAME:
                case EventType$$module$build$src$core$events$type.VAR_TYPE_CHANGE:
                  this.refreshToolboxSelection();
              }
            }
            refreshToolboxSelection() {
              const a = this.isFlyout ? this.targetWorkspace : this;
              a && !a.currentGesture_ && a.toolbox && a.toolbox.getFlyout() && a.toolbox.refreshSelection();
            }
            recordDragTargets() {
              const a = this.componentManager.getComponents(ComponentManager$$module$build$src$core$component_manager.Capability.DRAG_TARGET, true);
              this.dragTargetAreas = [];
              for (let b = 0, c; c = a[b]; b++) {
                const d = c.getClientRect();
                d && this.dragTargetAreas.push({ component: c, clientRect: d });
              }
            }
            newBlock(a, b) {
              throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts");
            }
            newComment(a) {
              throw Error("The implementation of newComment should be monkey-patched in by blockly.ts");
            }
            getDragTarget(a) {
              for (let b = 0, c; c = this.dragTargetAreas[b]; b++) if (c.clientRect.contains(a.clientX, a.clientY)) return c.component;
              return null;
            }
            onMouseDown(a) {
              const b = this.getGesture(a);
              b && b.handleWsStart(a, this);
            }
            startDrag(a, b) {
              start$$module$build$src$core$utils$drag(this, a, b);
            }
            moveDrag(a) {
              return move$$module$build$src$core$utils$drag(this, a);
            }
            setKeyboardMoveInProgress(a) {
              this.keyboardMoveInProgress = a;
            }
            isDragging() {
              return this.keyboardMoveInProgress || this.currentGesture_ !== null && this.currentGesture_.isDragging();
            }
            isDraggable() {
              return this.options.moveOptions && this.options.moveOptions.drag;
            }
            isMovable() {
              return this.options.moveOptions && !!this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.wheel || this.options.zoomOptions && this.options.zoomOptions.pinch;
            }
            isMovableHorizontally() {
              const a = !!this.scrollbar;
              return this.isMovable() && (!a || a && this.scrollbar.canScrollHorizontally());
            }
            isMovableVertically() {
              const a = !!this.scrollbar;
              return this.isMovable() && (!a || a && this.scrollbar.canScrollVertically());
            }
            onMouseWheel(a) {
              if (Gesture$$module$build$src$core$gesture.inProgress()) a.preventDefault(), a.stopPropagation();
              else {
                var b = this.options.zoomOptions && this.options.zoomOptions.wheel, c = this.options.moveOptions && this.options.moveOptions.wheel;
                if (b || c) {
                  var d = getScrollDeltaPixels$$module$build$src$core$browser_events(a);
                  if (MAC$$module$build$src$core$utils$useragent) var e = a.metaKey;
                  b && (a.ctrlKey || e || !c) ? (d = -d.y / 50, b = mouseToSvg$$module$build$src$core$browser_events(a, this.getParentSvg(), this.getInverseScreenCTM()), this.zoom(b.x, b.y, d)) : (b = this.scrollX - d.x, c = this.scrollY - d.y, a.shiftKey && !d.x && (b = this.scrollX - d.y, c = this.scrollY), this.scroll(b, c));
                  a.preventDefault();
                }
              }
            }
            getBlocksBoundingBox() {
              const a = this.getTopBoundedElements();
              if (!a.length) return new Rect$$module$build$src$core$utils$rect(0, 0, 0, 0);
              const b = a[0].getBoundingRectangle();
              for (let d = 1; d < a.length; d++) {
                var c = a[d];
                c.isInsertionMarker && c.isInsertionMarker() || (c = c.getBoundingRectangle(), c.top < b.top && (b.top = c.top), c.bottom > b.bottom && (b.bottom = c.bottom), c.left < b.left && (b.left = c.left), c.right > b.right && (b.right = c.right));
              }
              return b;
            }
            cleanUp() {
              this.setResizesEnabled(false);
              const a = $.getGroup$$module$build$src$core$events$utils();
              a || $.setGroup$$module$build$src$core$events$utils(true);
              var b = this.getTopBlocks(true), c = b.filter((g) => g.isMovable());
              const d = b.filter((g) => !g.isMovable()).map((g) => g.getBoundingRectangle());
              b = function(g) {
                for (const h of d) if (g.intersects(h)) return h;
                return null;
              };
              var e = 0;
              const f = this.renderer.getConstants().MIN_BLOCK_HEIGHT;
              for (const g of c) {
                c = g.getBoundingRectangle();
                g.moveBy(-c.left, e - c.top, ["cleanup"]);
                g.snapToGrid();
                c = g.getBoundingRectangle();
                for (e = b(c); e != null; ) e = e.top + e.getHeight() + f, g.moveBy(0, e - c.top, ["cleanup"]), g.snapToGrid(), c = g.getBoundingRectangle(), e = b(c);
                e = g.getRelativeToSurfaceXY().y + g.getHeightWidth().height + f;
              }
              $.setGroup$$module$build$src$core$events$utils(a);
              this.setResizesEnabled(true);
            }
            showContextMenu(a) {
              if (!this.isReadOnly() && !this.isFlyout) {
                var b = ContextMenuRegistry$$module$build$src$core$contextmenu_registry.registry.getContextMenuOptions({ workspace: this, focusedNode: this }, a);
                this.configureContextMenu && this.configureContextMenu(b, a);
                var c = a instanceof PointerEvent ? new Coordinate$$module$build$src$core$utils$coordinate(a.clientX, a.clientY) : wsToScreenCoordinates$$module$build$src$core$utils$svg_math(this, new Coordinate$$module$build$src$core$utils$coordinate(
                  5,
                  5
                ));
                show$$module$build$src$core$contextmenu(a, b, this.RTL, this, c);
              }
            }
            updateToolbox(a) {
              if (a = convertToolboxDefToJson$$module$build$src$core$utils$toolbox(a)) {
                if (!this.options.languageTree) throw Error("Existing toolbox is null.  Can't create new toolbox.");
                if (hasCategories$$module$build$src$core$utils$toolbox(a)) {
                  if (!this.toolbox) throw Error("Existing toolbox has no categories.  Can't change mode.");
                  this.options.languageTree = a;
                  this.toolbox.render(a);
                } else {
                  if (!this.flyout) throw Error("Existing toolbox has categories.  Can't change mode.");
                  this.options.languageTree = a;
                  this.flyout.show(a);
                }
              } else if (this.options.languageTree) throw Error("Can't nullify an existing toolbox.");
            }
            markFocused() {
              this.options.parentWorkspace ? this.options.parentWorkspace.markFocused() : (setMainWorkspace$$module$build$src$core$common(this), this.getParentSvg().focus({ preventScroll: true }));
            }
            zoom(a, b, c) {
              c = Math.pow(this.options.zoomOptions.scaleSpeed, c);
              const d = this.scale * c;
              if (this.scale !== d) {
                d > this.options.zoomOptions.maxScale ? c = this.options.zoomOptions.maxScale / this.scale : d < this.options.zoomOptions.minScale && (c = this.options.zoomOptions.minScale / this.scale);
                var e = this.getCanvas().getCTM(), f = this.getParentSvg().createSVGPoint();
                f.x = a;
                f.y = b;
                f = f.matrixTransform(e.inverse());
                a = f.x;
                b = f.y;
                e = e.translate(a * (1 - c), b * (1 - c)).scale(c);
                this.scrollX = e.e;
                this.scrollY = e.f;
                this.setScale(d);
              }
            }
            zoomCenter(a) {
              var b = this.getMetrics();
              let c;
              this.flyout ? (c = b.svgWidth ? b.svgWidth / 2 : 0, b = b.svgHeight ? b.svgHeight / 2 : 0) : (c = b.viewWidth / 2 + b.absoluteLeft, b = b.viewHeight / 2 + b.absoluteTop);
              this.zoom(c, b, a);
            }
            zoomToFit() {
              if (this.isMovable()) {
                var a = this.getMetrics(), b = a.viewWidth;
                a = a.viewHeight;
                var c = this.getBlocksBoundingBox(), d = ZOOM_TO_FIT_MARGIN$$module$build$src$core$workspace_svg * 2, e = c.right - c.left + d;
                c = c.bottom - c.top + d;
                if (e) {
                  this.flyout && (this.horizontalLayout ? (a += this.flyout.getHeight(), c += this.flyout.getHeight() / this.scale) : (b += this.flyout.getWidth(), e += this.flyout.getWidth() / this.scale));
                  b /= e;
                  a /= c;
                  $.disable$$module$build$src$core$events$utils();
                  try {
                    this.setScale(Math.min(b, a)), this.scrollCenter();
                  } finally {
                    $.enable$$module$build$src$core$events$utils();
                  }
                  this.maybeFireViewportChangeEvent();
                }
              } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
            }
            beginCanvasTransition() {
              addClass$$module$build$src$core$utils$dom(
                this.getCanvas(),
                "blocklyCanvasTransitioning"
              );
              addClass$$module$build$src$core$utils$dom(this.getBubbleCanvas(), "blocklyCanvasTransitioning");
            }
            endCanvasTransition() {
              removeClass$$module$build$src$core$utils$dom(this.getCanvas(), "blocklyCanvasTransitioning");
              removeClass$$module$build$src$core$utils$dom(this.getBubbleCanvas(), "blocklyCanvasTransitioning");
            }
            scrollCenter() {
              if (this.isMovable()) {
                var a = this.getMetrics(), b = (a.scrollWidth - a.viewWidth) / 2, c = (a.scrollHeight - a.viewHeight) / 2;
                b = -b - a.scrollLeft;
                c = -c - a.scrollTop;
                this.scroll(
                  b,
                  c
                );
              } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
            }
            centerOnBlock(a, b) {
              if (this.isMovable()) {
                var c = a ? this.getBlockById(a) : null;
                if (c) {
                  a = c.getRelativeToSurfaceXY();
                  c = b ? { height: c.height, width: c.width } : c.getHeightWidth();
                  var d = this.scale;
                  b = (a.x + (this.RTL ? -1 : 1) * c.width / 2) * d;
                  a = (a.y + c.height / 2) * d;
                  c = this.getMetrics();
                  this.scroll(-(b - c.viewWidth / 2), -(a - c.viewHeight / 2));
                }
              } else console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.");
            }
            setScale(a) {
              this.options.zoomOptions.maxScale && a > this.options.zoomOptions.maxScale ? a = this.options.zoomOptions.maxScale : this.options.zoomOptions.minScale && a < this.options.zoomOptions.minScale && (a = this.options.zoomOptions.minScale);
              this.scale = a;
              this.hideChaff(false);
              (a = this.getFlyout(false)) && a.isVisible() && (a.reflow(), this.recordDragTargets());
              this.grid && this.grid.update(this.scale);
              a = this.getMetrics();
              this.scrollX -= a.absoluteLeft;
              this.scrollY -= a.absoluteTop;
              a.viewLeft += a.absoluteLeft;
              a.viewTop += a.absoluteTop;
              this.scroll(this.scrollX, this.scrollY);
              this.scrollbar && (this.flyout ? this.scrollbar.resizeView(a) : this.scrollbar.resizeContent(a));
            }
            getScale() {
              return this.scale;
            }
            getAbsoluteScale() {
              const a = (c) => {
                if (c.isFlyout) {
                  let d;
                  const e = (d = c.targetWorkspace) == null ? void 0 : d.getFlyout();
                  if (e instanceof Flyout$$module$build$src$core$flyout_base) return e.getFlyoutScale();
                }
                return c.getScale();
              }, b = (c, d) => c.options.parentWorkspace && c.options.parentWorkspace.getSvgGroup().contains(c.getSvgGroup()) ? b(c.options.parentWorkspace, d * a(c)) : d * a(c);
              return b(this, 1);
            }
            scroll(a, b) {
              this.hideChaff(true);
              const c = this.getMetrics();
              a = Math.min(a, -c.scrollLeft);
              b = Math.min(b, -c.scrollTop);
              const d = c.scrollTop + Math.max(0, c.scrollHeight - c.viewHeight);
              a = Math.max(a, -(c.scrollLeft + Math.max(0, c.scrollWidth - c.viewWidth)));
              b = Math.max(b, -d);
              this.scrollX = a;
              this.scrollY = b;
              this.scrollbar && this.scrollbar.set(-(a + c.scrollLeft), -(b + c.scrollTop), false);
              a += c.absoluteLeft;
              b += c.absoluteTop;
              this.translate(a, b);
            }
            getBlockById(a) {
              return super.getBlockById(a);
            }
            getAllBlocks(a = false) {
              return super.getAllBlocks(a);
            }
            getTopBlocks(a = false) {
              return super.getTopBlocks(a);
            }
            addTopBlock(a) {
              this.addTopBoundedElement(a);
              super.addTopBlock(a);
            }
            removeTopBlock(a) {
              this.removeTopBoundedElement(a);
              super.removeTopBlock(a);
            }
            addTopComment(a) {
              this.addTopBoundedElement(a);
              super.addTopComment(a);
            }
            removeTopComment(a) {
              this.removeTopBoundedElement(a);
              super.removeTopComment(a);
            }
            getTopComments(a = false) {
              return super.getTopComments(a);
            }
            getCommentById(a) {
              return super.getCommentById(a);
            }
            getRootWorkspace() {
              return super.getRootWorkspace();
            }
            addTopBoundedElement(a) {
              this.topBoundedElements.push(a);
            }
            removeTopBoundedElement(a) {
              removeElem$$module$build$src$core$utils$array(
                this.topBoundedElements,
                a
              );
            }
            getTopBoundedElements(a = false) {
              const b = [].concat(this.topBoundedElements);
              a && b.sort(this.sortByOrigin.bind(this));
              return b;
            }
            setResizesEnabled(a) {
              const b = !this.resizesEnabled && a;
              this.resizesEnabled = a;
              b && this.resizeContents();
            }
            clear() {
              this.setResizesEnabled(false);
              super.clear();
              this.topBoundedElements = [];
              this.setResizesEnabled(true);
            }
            registerButtonCallback(a, b) {
              if (typeof b !== "function") throw TypeError("Button callbacks must be functions.");
              this.flyoutButtonCallbacks.set(a, b);
            }
            getButtonCallback(a) {
              let b;
              return (b = this.flyoutButtonCallbacks.get(a)) != null ? b : null;
            }
            removeButtonCallback(a) {
              this.flyoutButtonCallbacks.delete(a);
            }
            registerToolboxCategoryCallback(a, b) {
              if (typeof b !== "function") throw TypeError("Toolbox category callbacks must be functions.");
              this.toolboxCategoryCallbacks.set(a, b);
            }
            getToolboxCategoryCallback(a) {
              return this.toolboxCategoryCallbacks.get(a) || null;
            }
            removeToolboxCategoryCallback(a) {
              this.toolboxCategoryCallbacks.delete(a);
            }
            getGesture(a) {
              if (this.keyboardMoveInProgress) return a.preventDefault(), a.stopPropagation(), null;
              const b = a.type === "pointerdown";
              let c;
              b && ((c = this.currentGesture_) == null ? 0 : c.hasStarted()) && (console.warn("Tried to start the same gesture twice."), this.currentGesture_.cancel());
              !this.currentGesture_ && b && (this.currentGesture_ = new Gesture$$module$build$src$core$gesture(a, this));
              return this.currentGesture_;
            }
            clearGesture() {
              this.currentGesture_ = null;
            }
            cancelCurrentGesture() {
              this.currentGesture_ && this.currentGesture_.cancel();
            }
            getAudioManager() {
              return this.audioManager;
            }
            getGrid() {
              return this.grid;
            }
            hideChaff(a = false) {
              hide$$module$build$src$core$tooltip();
              hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv(this);
              hideWithoutAnimation$$module$build$src$core$dropdowndiv();
              this.hideComponents(a);
            }
            hideComponents(a = false) {
              this.getComponentManager().getComponents(ComponentManager$$module$build$src$core$component_manager.Capability.AUTOHIDEABLE, true).forEach((b) => b.autoHide(a));
            }
            static setTopLevelWorkspaceMetrics(a) {
              const b = this.getMetrics();
              typeof a.x === "number" && (this.scrollX = -(b.scrollLeft + (b.scrollWidth - b.viewWidth) * a.x));
              typeof a.y === "number" && (this.scrollY = -(b.scrollTop + (b.scrollHeight - b.viewHeight) * a.y));
              this.translate(this.scrollX + b.absoluteLeft, this.scrollY + b.absoluteTop);
            }
            addClass(a) {
              this.injectionDiv && addClass$$module$build$src$core$utils$dom(this.injectionDiv, a);
            }
            removeClass(a) {
              this.injectionDiv && removeClass$$module$build$src$core$utils$dom(this.injectionDiv, a);
            }
            setIsReadOnly(a) {
              super.setIsReadOnly(a);
              a ? this.addClass("blocklyReadOnly") : this.removeClass("blocklyReadOnly");
            }
            scrollBoundsIntoView(a, b = 10) {
              if (!Gesture$$module$build$src$core$gesture.inProgress()) {
                var c = this.getScale(), d = this.getMetricsManager().getViewMetrics(true);
                d = new Rect$$module$build$src$core$utils$rect(d.top, d.top + d.height, d.left, d.left + d.width);
                if (!(a.left >= d.left && a.top >= d.top && a.right <= d.right && a.bottom <= d.bottom)) {
                  a = a.clone();
                  a.top -= b;
                  a.bottom += b;
                  a.left -= b;
                  a.right += b;
                  var e = b = 0;
                  a.left < d.left ? b = this.RTL ? Math.min(d.left - a.left, d.right - a.right) : d.left - a.left : a.right > d.right && (b = this.RTL ? d.right - a.right : Math.max(d.right - a.right, d.left - a.left));
                  a.top < d.top ? e = d.top - a.top : a.bottom > d.bottom && (e = Math.max(d.bottom - a.bottom, d.top - a.top));
                  this.scroll(this.scrollX + b * c, this.scrollY + e * c);
                }
              }
            }
            getFocusableElement() {
              return this.svgGroup_;
            }
            getFocusableTree() {
              return this.isMutator && this.options.parentWorkspace || this;
            }
            onNodeFocus() {
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
            getRootFocusableNode() {
              return this;
            }
            getRestoredFocusableNode(a) {
              if (a) return null;
              let b;
              a = (b = this.targetWorkspace) == null ? void 0 : b.getFlyout();
              if (this.isFlyout && a) {
                let d, e;
                return (e = (d = a.getContents().find((f) => {
                  f = f.getElement();
                  return isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(f) && f.canBeFocused();
                })) == null ? void 0 : d.getElement()) != null ? e : null;
              }
              let c;
              return (c = this.getTopBlocks(true)[0]) != null ? c : null;
            }
            getNestedTrees() {
              const a = this.getAllBlocks().map((c) => c.getIcons()).flat().filter((c) => c instanceof $.MutatorIcon$$module$build$src$core$icons$mutator_icon && c.bubbleIsVisible()).map((c) => {
                let d;
                return (d = c.getBubble()) == null ? void 0 : d.getWorkspace();
              }).filter((c) => !!c), b = this.getFlyout(true);
              b && a.push(b.getWorkspace());
              return a;
            }
            searchForWorkspaceComment(a) {
              for (const b of this.getTopComments()) if (b instanceof RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment && b.canBeFocused() && b.getFocusableElement().id === a) return b;
            }
            lookUpFocusableNode(a) {
              var b;
              const c = (b = this.targetWorkspace) == null ? void 0 : b.getFlyout();
              if (this.isFlyout && c) {
                for (var d of c.getContents()) if (b = d.getElement(), isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(b) && b.canBeFocused() && b.getFocusableElement().id === a) return b;
              }
              d = a.indexOf("_field_");
              b = a.indexOf("_connection_");
              if (d !== -1) {
                var e = a.substring(
                  0,
                  d
                );
                if (e = this.getBlockById(e)) {
                  for (var f of e.getFields()) if (f.canBeFocused() && f.getFocusableElement().id === a) return f;
                }
                return null;
              }
              if (b !== -1) {
                e = a.substring(0, b);
                if (e = this.getBlockById(e)) {
                  for (const h of e.getConnections_(true)) if (h.id === a) return h;
                }
                return null;
              }
              f = Math.max(a.indexOf(COMMENT_EDITOR_FOCUS_IDENTIFIER$$module$build$src$core$comments$comment_editor), a.indexOf(COMMENT_COLLAPSE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$collapse_comment_bar_button), a.indexOf(COMMENT_DELETE_BAR_BUTTON_FOCUS_IDENTIFIER$$module$build$src$core$comments$delete_comment_bar_button));
              if (f !== -1 && (f = a.substring(0, f), f = this.searchForWorkspaceComment(f))) {
                if (a.indexOf(COMMENT_EDITOR_FOCUS_IDENTIFIER$$module$build$src$core$comments$comment_editor) > -1) return f.getEditorFocusableNode();
                var g;
                return (g = f.view.getCommentBarButtons().find((h) => h.getFocusableElement().id.includes(a))) != null ? g : null;
              }
              if ((g = this.getAllBlocks(false).find((h) => h.getFocusableElement().id === a)) || (g = this.searchForWorkspaceComment(a))) return g;
              g = this.getAllBlocks().map((h) => h.getIcons()).flat();
              for (e of g) {
                if (e.canBeFocused() && e.getFocusableElement().id === a) return e;
                if (hasBubble$$module$build$src$core$interfaces$i_has_bubble(e)) {
                  if ((g = e.getBubble()) && g.canBeFocused() && g.getFocusableElement().id === a) return g;
                  if (g instanceof TextInputBubble$$module$build$src$core$bubbles$textinput_bubble && g.getEditor().getFocusableElement().id === a) return g.getEditor();
                }
              }
              return null;
            }
            onTreeFocus(a, b) {
            }
            onTreeBlur(a) {
              if (this.isFlyout && this.targetWorkspace && !$.getFocusManager$$module$build$src$core$focus_manager().ephemeralFocusTaken()) {
                var b = this.targetWorkspace.getToolbox();
                b && a === b || isAutoHideable$$module$build$src$core$interfaces$i_autohideable(b) && b.autoHide(false);
              }
            }
            getNavigator() {
              return this.navigator;
            }
            setNavigator(a) {
              this.navigator = a;
            }
          }, module$build$src$core$workspace_svg = {};
          module$build$src$core$workspace_svg.WorkspaceSvg = WorkspaceSvg$$module$build$src$core$workspace_svg;
          module$build$src$core$workspace_svg.resizeSvgContents = resizeSvgContents$$module$build$src$core$workspace_svg;
          var VarBase$$module$build$src$core$events$events_var_base = class extends Abstract$$module$build$src$core$events$events_abstract {
            constructor(a) {
              super();
              this.isBlank = typeof a === "undefined";
              a && (this.varId = a.getId(), this.workspaceId = a.getWorkspace().id);
            }
            toJson() {
              const a = super.toJson();
              if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
              a.varId = this.varId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new VarBase$$module$build$src$core$events$events_var_base());
              b.varId = a.varId;
              return b;
            }
          }, module$build$src$core$events$events_var_base = {};
          module$build$src$core$events$events_var_base.VarBase = VarBase$$module$build$src$core$events$events_var_base;
          var VarCreate$$module$build$src$core$events$events_var_create = class extends VarBase$$module$build$src$core$events$events_var_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.VAR_CREATE;
              a && (this.varType = a.getType(), this.varName = a.getName());
            }
            toJson() {
              const a = super.toJson();
              if (this.varType === void 0) throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
              a.varType = this.varType;
              a.varName = this.varName;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new VarCreate$$module$build$src$core$events$events_var_create());
              b.varType = a.varType;
              b.varName = a.varName;
              return b;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
              b = b.getVariableMap();
              a ? b.createVariable(this.varName, this.varType, this.varId) : (a = b.getVariableById(this.varId)) && b.deleteVariable(a);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.VAR_CREATE, VarCreate$$module$build$src$core$events$events_var_create);
          var module$build$src$core$events$events_var_create = {};
          module$build$src$core$events$events_var_create.VarCreate = VarCreate$$module$build$src$core$events$events_var_create;
          var VariableModel$$module$build$src$core$variable_model = class {
            constructor(a, b, c, d) {
              this.workspace = a;
              this.name = b;
              this.type = c || "";
              this.id = d || genUid$$module$build$src$core$utils$idgenerator();
            }
            getId() {
              return this.id;
            }
            getName() {
              return this.name;
            }
            setName(a) {
              this.name = a;
              return this;
            }
            getType() {
              return this.type;
            }
            setType(a) {
              this.type = a;
              return this;
            }
            getWorkspace() {
              return this.workspace;
            }
            save() {
              const a = { name: this.getName(), id: this.getId() }, b = this.getType();
              b && (a.type = b);
              return a;
            }
            static load(a, b) {
              a = new this(
                b,
                a.name,
                a.type,
                a.id
              );
              b.getVariableMap().addVariable(a);
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_CREATE))(a));
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.VARIABLE_MODEL, DEFAULT$$module$build$src$core$registry, VariableModel$$module$build$src$core$variable_model);
          var module$build$src$core$variable_model = {};
          module$build$src$core$variable_model.VariableModel = VariableModel$$module$build$src$core$variable_model;
          var VarDelete$$module$build$src$core$events$events_var_delete = class extends VarBase$$module$build$src$core$events$events_var_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.VAR_DELETE;
              a && (this.varType = a.getType(), this.varName = a.getName());
            }
            toJson() {
              const a = super.toJson();
              if (this.varType === void 0) throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
              a.varType = this.varType;
              a.varName = this.varName;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new VarDelete$$module$build$src$core$events$events_var_delete());
              b.varType = a.varType;
              b.varName = a.varName;
              return b;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.varName) throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
              b = b.getVariableMap();
              a ? (a = b.getVariableById(this.varId)) && b.deleteVariable(a) : b.createVariable(this.varName, this.varType, this.varId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.VAR_DELETE, VarDelete$$module$build$src$core$events$events_var_delete);
          var module$build$src$core$events$events_var_delete = {};
          module$build$src$core$events$events_var_delete.VarDelete = VarDelete$$module$build$src$core$events$events_var_delete;
          var VarRename$$module$build$src$core$events$events_var_rename = class extends VarBase$$module$build$src$core$events$events_var_base {
            constructor(a, b) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.VAR_RENAME;
              a && (this.oldName = a.getName(), this.newName = typeof b === "undefined" ? "" : b);
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldName) throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.newName) throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
              a.oldName = this.oldName;
              a.newName = this.newName;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new VarRename$$module$build$src$core$events$events_var_rename());
              b.oldName = a.oldName;
              b.newName = a.newName;
              return b;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.oldName) throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.newName) throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
              b = b.getVariableMap();
              const c = b.getVariableById(this.varId);
              a ? c && b.renameVariable(c, this.newName) : c && b.renameVariable(c, this.oldName);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.VAR_RENAME, VarRename$$module$build$src$core$events$events_var_rename);
          var module$build$src$core$events$events_var_rename = {};
          module$build$src$core$events$events_var_rename.VarRename = VarRename$$module$build$src$core$events$events_var_rename;
          var VariableMap$$module$build$src$core$variable_map = class {
            constructor(a, b = false) {
              this.workspace = a;
              this.potentialMap = b;
              this.variableMap = /* @__PURE__ */ new Map();
            }
            clear() {
              for (const a of this.variableMap.values()) for (const b of a.values()) this.deleteVariable(b);
              if (this.variableMap.size !== 0) throw Error("Non-empty variable map");
            }
            renameVariable(a, b) {
              if (a.getName() === b) return a;
              var c = a.getType();
              c = this.getVariable(b, c);
              const d = this.workspace.getAllBlocks(false);
              let e = "";
              this.potentialMap || (e = $.getGroup$$module$build$src$core$events$utils()) || $.setGroup$$module$build$src$core$events$utils(true);
              try {
                c && c.getId() !== a.getId() ? this.renameVariableWithConflict(a, b, c, d) : this.renameVariableAndUses(a, b, d);
              } finally {
                this.potentialMap || $.setGroup$$module$build$src$core$events$utils(e);
              }
              return a;
            }
            changeVariableType(a, b) {
              const c = a.getType();
              if (c === b) return a;
              var d = this.variableMap.get(c);
              d == null || d.delete(a.getId());
              (d == null ? void 0 : d.size) === 0 && this.variableMap.delete(c);
              a.setType(b);
              let e;
              d = (e = this.variableMap.get(b)) != null ? e : /* @__PURE__ */ new Map();
              d.set(a.getId(), a);
              this.variableMap.has(b) || this.variableMap.set(b, d);
              fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_TYPE_CHANGE))(a, c, b));
              return a;
            }
            renameVariableById(a, b) {
              warn$$module$build$src$core$utils$deprecation("VariableMap.renameVariableById", "v12", "v13", "VariableMap.renameVariable");
              const c = this.getVariableById(a);
              if (!c) throw Error("Tried to rename a variable that didn't exist. ID: " + a);
              this.renameVariable(c, b);
            }
            renameVariableAndUses(a, b, c) {
              this.potentialMap || fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_RENAME))(a, b));
              a.setName(b);
              for (b = 0; b < c.length; b++) c[b].updateVarName(a);
            }
            renameVariableWithConflict(a, b, c, d) {
              const e = a.getType(), f = c.getName();
              b !== f && this.renameVariableAndUses(c, b, d);
              for (b = 0; b < d.length; b++) d[b].renameVarById(a.getId(), c.getId());
              this.potentialMap || fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_DELETE))(a));
              let g;
              (g = this.variableMap.get(e)) == null || g.delete(a.getId());
            }
            createVariable(a, b, c) {
              var d = this.getVariable(a, b);
              if (d) {
                if (c && d.getId() !== c) throw Error('Variable "' + a + '" is already in use and its id is "' + d.getId() + '" which conflicts with the passed in id, "' + c + '".');
                return d;
              }
              if (c && this.getVariableById(c)) throw Error('Variable id, "' + c + '", is already in use.');
              d = c || genUid$$module$build$src$core$utils$idgenerator();
              b = b || "";
              c = getClassFromOptions$$module$build$src$core$registry(
                Type$$module$build$src$core$registry.VARIABLE_MODEL,
                this.workspace.options,
                true
              );
              if (!c) throw Error("No variable model is registered.");
              d = new c(this.workspace, a, b, d);
              let e;
              a = (e = this.variableMap.get(b)) != null ? e : /* @__PURE__ */ new Map();
              a.set(d.getId(), d);
              this.variableMap.has(b) || this.variableMap.set(b, a);
              this.potentialMap || fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_CREATE))(d));
              return d;
            }
            addVariable(a) {
              const b = a.getType();
              this.variableMap.has(b) || this.variableMap.set(b, /* @__PURE__ */ new Map());
              let c;
              (c = this.variableMap.get(b)) == null || c.set(a.getId(), a);
            }
            deleteVariable(a) {
              const b = getVariableUsesById$$module$build$src$core$variables(this.workspace, a.getId());
              let c = "";
              this.potentialMap || (c = $.getGroup$$module$build$src$core$events$utils()) || $.setGroup$$module$build$src$core$events$utils(true);
              try {
                for (let e = 0; e < b.length; e++) b[e].dispose(true);
                const d = this.variableMap.get(a.getType());
                d && d.has(a.getId()) && (d.delete(a.getId()), this.potentialMap || fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.VAR_DELETE))(a)), d.size === 0 && this.variableMap.delete(a.getType()));
              } finally {
                this.potentialMap || $.setGroup$$module$build$src$core$events$utils(c);
              }
            }
            deleteVariableById(a) {
              warn$$module$build$src$core$utils$deprecation("VariableMap.deleteVariableById", "v12", "v13", "Blockly.Variables.deleteVariable");
              (a = this.getVariableById(a)) && $.deleteVariable$$module$build$src$core$variables(this.workspace, a);
            }
            getVariable(a, b) {
              b = this.variableMap.get(b || "");
              if (!b) return null;
              let c;
              return (c = [...b.values()].find((d) => $.Names$$module$build$src$core$names.equals(
                d.getName(),
                a
              ))) != null ? c : null;
            }
            getVariableById(a) {
              for (const b of this.variableMap.values()) if (b.has(a)) {
                let c;
                return (c = b.get(a)) != null ? c : null;
              }
              return null;
            }
            getVariablesOfType(a) {
              return (a = this.variableMap.get(a || "")) ? [...a.values()] : [];
            }
            getTypes() {
              return [...this.variableMap.keys()];
            }
            getAllVariables() {
              let a = [];
              for (const b of this.variableMap.values()) a = a.concat(...b.values());
              return a;
            }
            getAllVariableNames() {
              warn$$module$build$src$core$utils$deprecation("VariableMap.getAllVariableNames", "v12", "v13", "Blockly.Variables.getAllVariables");
              const a = [];
              for (const b of this.variableMap.values()) for (const c of b.values()) a.push(c.getName());
              return a;
            }
            getVariableUsesById(a) {
              warn$$module$build$src$core$utils$deprecation("VariableMap.getVariableUsesById", "v12", "v13", "Blockly.Variables.getVariableUsesById");
              return getVariableUsesById$$module$build$src$core$variables(this.workspace, a);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.VARIABLE_MAP, DEFAULT$$module$build$src$core$registry, VariableMap$$module$build$src$core$variable_map);
          var module$build$src$core$variable_map = {};
          module$build$src$core$variable_map.VariableMap = VariableMap$$module$build$src$core$variable_map;
          var TrashcanOpen$$module$build$src$core$events$events_trashcan_open = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b) {
              super(b);
              this.type = EventType$$module$build$src$core$events$type.TRASHCAN_OPEN;
              this.isOpen = a;
            }
            toJson() {
              const a = super.toJson();
              if (this.isOpen === void 0) throw Error("Whether this is already open or not is undefined. Either pass a value to the constructor, or call fromJson");
              a.isOpen = this.isOpen;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new TrashcanOpen$$module$build$src$core$events$events_trashcan_open());
              b.isOpen = a.isOpen;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.TRASHCAN_OPEN, TrashcanOpen$$module$build$src$core$events$events_trashcan_open);
          var module$build$src$core$events$events_trashcan_open = {};
          module$build$src$core$events$events_trashcan_open.TrashcanOpen = TrashcanOpen$$module$build$src$core$events$events_trashcan_open;
          var Trashcan$$module$build$src$core$trashcan = class extends DeleteArea$$module$build$src$core$delete_area {
            constructor(a) {
              super();
              this.workspace = a;
              this.id = "trashcan";
              this.contents = [];
              this.flyout = null;
              this.isLidOpen = false;
              this.minOpenness = 0;
              this.lidTask = this.svgLid = this.svgGroup = null;
              this.top = this.left = this.lidOpen = 0;
              this.initialized = false;
              this.workspace.options.maxTrashcanContents <= 0 || (a = this.workspace.copyOptionsForFlyout(), this.workspace.horizontalLayout ? (a.toolboxPosition = this.workspace.toolboxPosition === Position$$module$build$src$core$utils$toolbox.TOP ? Position$$module$build$src$core$utils$toolbox.BOTTOM : Position$$module$build$src$core$utils$toolbox.TOP, this.flyout = new (getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_HORIZONTAL_TOOLBOX, this.workspace.options, true))(a)) : (a.toolboxPosition = this.workspace.toolboxPosition === Position$$module$build$src$core$utils$toolbox.RIGHT ? Position$$module$build$src$core$utils$toolbox.LEFT : Position$$module$build$src$core$utils$toolbox.RIGHT, this.flyout = new (getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_VERTICAL_TOOLBOX, this.workspace.options, true))(a)), this.workspace.addChangeListener(this.onDelete.bind(this)));
            }
            createDom() {
              this.svgGroup = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.G, { "class": "blocklyTrash" });
              let a;
              const b = String(Math.random()).substring(2);
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.CLIPPATH,
                { id: "blocklyTrashBodyClipPath" + b },
                this.svgGroup
              );
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, { width: WIDTH$$module$build$src$core$trashcan, height: BODY_HEIGHT$$module$build$src$core$trashcan, y: LID_HEIGHT$$module$build$src$core$trashcan }, a);
              const c = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, {
                width: SPRITE$$module$build$src$core$sprites.width,
                x: -SPRITE_LEFT$$module$build$src$core$trashcan,
                height: SPRITE$$module$build$src$core$sprites.height,
                y: -SPRITE_TOP$$module$build$src$core$trashcan,
                "clip-path": "url(#blocklyTrashBodyClipPath" + b + ")"
              }, this.svgGroup);
              c.setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", this.workspace.options.pathToMedia + SPRITE$$module$build$src$core$sprites.url);
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.CLIPPATH, { id: "blocklyTrashLidClipPath" + b }, this.svgGroup);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.RECT, {
                width: WIDTH$$module$build$src$core$trashcan,
                height: LID_HEIGHT$$module$build$src$core$trashcan
              }, a);
              this.svgLid = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { width: SPRITE$$module$build$src$core$sprites.width, x: -SPRITE_LEFT$$module$build$src$core$trashcan, height: SPRITE$$module$build$src$core$sprites.height, y: -SPRITE_TOP$$module$build$src$core$trashcan, "clip-path": "url(#blocklyTrashLidClipPath" + b + ")" }, this.svgGroup);
              this.svgLid.setAttributeNS(
                XLINK_NS$$module$build$src$core$utils$dom,
                "xlink:href",
                this.workspace.options.pathToMedia + SPRITE$$module$build$src$core$sprites.url
              );
              bind$$module$build$src$core$browser_events(this.svgGroup, "pointerdown", this, this.blockMouseDownWhenOpenable);
              bind$$module$build$src$core$browser_events(this.svgGroup, "pointerup", this, this.click);
              bind$$module$build$src$core$browser_events(c, "pointerover", this, this.mouseOver);
              bind$$module$build$src$core$browser_events(c, "pointerout", this, this.mouseOut);
              this.animateLid();
              return this.svgGroup;
            }
            init() {
              if (this.workspace.options.maxTrashcanContents > 0) {
                const a = this.flyout.createDom(Svg$$module$build$src$core$utils$svg.SVG);
                addClass$$module$build$src$core$utils$dom(a, "blocklyTrashcanFlyout");
                insertAfter$$module$build$src$core$utils$dom(a, this.workspace.getParentSvg());
                this.flyout.init(this.workspace);
              }
              this.workspace.getComponentManager().addComponent({ component: this, weight: ComponentManager$$module$build$src$core$component_manager.ComponentWeight.TRASHCAN_WEIGHT, capabilities: [
                ComponentManager$$module$build$src$core$component_manager.Capability.AUTOHIDEABLE,
                ComponentManager$$module$build$src$core$component_manager.Capability.DELETE_AREA,
                ComponentManager$$module$build$src$core$component_manager.Capability.DRAG_TARGET,
                ComponentManager$$module$build$src$core$component_manager.Capability.POSITIONABLE
              ] });
              this.initialized = true;
              this.setLidOpen(false);
            }
            dispose() {
              this.workspace.getComponentManager().removeComponent("trashcan");
              this.svgGroup && removeNode$$module$build$src$core$utils$dom(this.svgGroup);
              this.lidTask && clearTimeout(this.lidTask);
            }
            hasContents() {
              return !!this.contents.length;
            }
            contentsIsOpen() {
              return !!this.flyout && this.flyout.isVisible();
            }
            openFlyout() {
              if (!this.contentsIsOpen()) {
                var a = this.contents.map(function(c) {
                  return JSON.parse(c);
                }), b = this.workspace.getParentSvg().style;
                b.cursor = "wait";
                setTimeout(() => {
                  let c;
                  (c = this.flyout) == null || c.show(a);
                  b.cursor = "";
                  let d;
                  (d = this.workspace.scrollbar) == null || d.setVisible(false);
                }, 10);
                this.fireUiEvent(true);
              }
            }
            closeFlyout() {
              if (this.contentsIsOpen()) {
                var a;
                (a = this.flyout) == null || a.hide();
                var b;
                (b = this.workspace.scrollbar) == null || b.setVisible(true);
                this.fireUiEvent(false);
                this.workspace.recordDragTargets();
              }
            }
            autoHide(a) {
              !a && this.flyout && this.closeFlyout();
            }
            emptyContents() {
              this.hasContents() && (this.contents.length = 0, this.setMinOpenness(0), this.closeFlyout());
            }
            position(a, b) {
              if (this.initialized) {
                var c = getCornerOppositeToolbox$$module$build$src$core$positionable_helpers(this.workspace, a);
                a = getStartPositionRect$$module$build$src$core$positionable_helpers(
                  c,
                  new Size$$module$build$src$core$utils$size(WIDTH$$module$build$src$core$trashcan, BODY_HEIGHT$$module$build$src$core$trashcan + LID_HEIGHT$$module$build$src$core$trashcan),
                  MARGIN_HORIZONTAL$$module$build$src$core$trashcan,
                  MARGIN_VERTICAL$$module$build$src$core$trashcan,
                  a,
                  this.workspace
                );
                b = bumpPositionRect$$module$build$src$core$positionable_helpers(a, MARGIN_VERTICAL$$module$build$src$core$trashcan, c.vertical === verticalPosition$$module$build$src$core$positionable_helpers.TOP ? bumpDirection$$module$build$src$core$positionable_helpers.DOWN : bumpDirection$$module$build$src$core$positionable_helpers.UP, b);
                this.top = b.top;
                this.left = b.left;
                var d;
                (d = this.svgGroup) == null || d.setAttribute(
                  "transform",
                  "translate(" + this.left + "," + this.top + ")"
                );
                var e;
                (e = this.flyout) == null || e.position();
              }
            }
            getBoundingRectangle() {
              return new Rect$$module$build$src$core$utils$rect(this.top, this.top + BODY_HEIGHT$$module$build$src$core$trashcan + LID_HEIGHT$$module$build$src$core$trashcan, this.left, this.left + WIDTH$$module$build$src$core$trashcan);
            }
            getClientRect() {
              if (!this.svgGroup) return null;
              var a = this.svgGroup.getBoundingClientRect();
              const b = a.top + SPRITE_TOP$$module$build$src$core$trashcan - MARGIN_HOTSPOT$$module$build$src$core$trashcan;
              a = a.left + SPRITE_LEFT$$module$build$src$core$trashcan - MARGIN_HOTSPOT$$module$build$src$core$trashcan;
              return new Rect$$module$build$src$core$utils$rect(b, b + LID_HEIGHT$$module$build$src$core$trashcan + BODY_HEIGHT$$module$build$src$core$trashcan + 2 * MARGIN_HOTSPOT$$module$build$src$core$trashcan, a, a + WIDTH$$module$build$src$core$trashcan + 2 * MARGIN_HOTSPOT$$module$build$src$core$trashcan);
            }
            onDragOver(a) {
              this.setLidOpen(this.wouldDelete_);
            }
            onDragExit(a) {
              this.setLidOpen(false);
            }
            onDrop(a) {
              setTimeout(this.setLidOpen.bind(
                this,
                false
              ), 100);
            }
            setLidOpen(a) {
              this.isLidOpen !== a && (this.lidTask && clearTimeout(this.lidTask), this.isLidOpen = a, this.animateLid());
            }
            animateLid() {
              const a = ANIMATION_FRAMES$$module$build$src$core$trashcan;
              var b = 1 / (a + 1);
              this.lidOpen += this.isLidOpen ? b : -b;
              this.lidOpen = Math.min(Math.max(this.lidOpen, this.minOpenness), 1);
              this.setLidAngle(this.lidOpen * MAX_LID_ANGLE$$module$build$src$core$trashcan);
              b = OPACITY_MIN$$module$build$src$core$trashcan + this.lidOpen * (OPACITY_MAX$$module$build$src$core$trashcan - OPACITY_MIN$$module$build$src$core$trashcan);
              this.svgGroup && (this.svgGroup.style.opacity = `${b}`);
              this.lidOpen > this.minOpenness && this.lidOpen < 1 && (this.lidTask = setTimeout(this.animateLid.bind(this), ANIMATION_LENGTH$$module$build$src$core$trashcan / a));
            }
            setLidAngle(a) {
              const b = this.workspace.toolboxPosition === Position$$module$build$src$core$utils$toolbox.RIGHT || this.workspace.horizontalLayout && this.workspace.RTL;
              let c;
              (c = this.svgLid) == null || c.setAttribute("transform", "rotate(" + (b ? -a : a) + "," + (b ? 4 : WIDTH$$module$build$src$core$trashcan - 4) + "," + (LID_HEIGHT$$module$build$src$core$trashcan - 2) + ")");
            }
            setMinOpenness(a) {
              this.minOpenness = a;
              this.isLidOpen || this.setLidAngle(a * MAX_LID_ANGLE$$module$build$src$core$trashcan);
            }
            closeLid() {
              this.setLidOpen(false);
            }
            click() {
              this.hasContents() && !this.workspace.isDragging() && this.openFlyout();
            }
            fireUiEvent(a) {
              a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.TRASHCAN_OPEN))(a, this.workspace.id);
              fire$$module$build$src$core$events$utils(a);
            }
            blockMouseDownWhenOpenable(a) {
              !this.contentsIsOpen() && this.hasContents() && a.stopPropagation();
            }
            mouseOver() {
              this.hasContents() && this.setLidOpen(true);
            }
            mouseOut() {
              this.setLidOpen(false);
            }
            onDelete(a) {
              if (!(this.workspace.options.maxTrashcanContents <= 0 || !isBlockDelete$$module$build$src$core$events$predicates(a) || a.wasShadow)) {
                if (!a.oldJson) throw Error("Encountered a delete event without proper oldJson");
                a = JSON.stringify(this.cleanBlockJson(a.oldJson));
                if (!this.contents.includes(a)) {
                  for (this.contents.unshift(a); this.contents.length > this.workspace.options.maxTrashcanContents; ) this.contents.pop();
                  this.setMinOpenness(HAS_BLOCKS_LID_ANGLE$$module$build$src$core$trashcan);
                }
              }
            }
            cleanBlockJson(a) {
              function b(c) {
                if (c) {
                  delete c.id;
                  delete c.x;
                  delete c.y;
                  delete c.enabled;
                  delete c.disabledReasons;
                  if (c.icons && c.icons.comment) {
                    var d = c.icons.comment;
                    delete d.height;
                    delete d.width;
                    delete d.pinned;
                  }
                  d = c.inputs;
                  for (var e in d) {
                    var f = d[e];
                    const g = f.block;
                    f = f.shadow;
                    g && b(g);
                    f && b(f);
                  }
                  c.next && (e = c.next, c = e.block, e = e.shadow, c && b(c), e && b(e));
                }
              }
              a = JSON.parse(JSON.stringify(a));
              b(a);
              return Object.assign({}, { kind: "BLOCK" }, a);
            }
          }, WIDTH$$module$build$src$core$trashcan = 47, BODY_HEIGHT$$module$build$src$core$trashcan = 44, LID_HEIGHT$$module$build$src$core$trashcan = 16, MARGIN_VERTICAL$$module$build$src$core$trashcan = 20, MARGIN_HORIZONTAL$$module$build$src$core$trashcan = 20, MARGIN_HOTSPOT$$module$build$src$core$trashcan = 10, SPRITE_LEFT$$module$build$src$core$trashcan = 0, SPRITE_TOP$$module$build$src$core$trashcan = 32, HAS_BLOCKS_LID_ANGLE$$module$build$src$core$trashcan = 0.1, ANIMATION_LENGTH$$module$build$src$core$trashcan = 80, ANIMATION_FRAMES$$module$build$src$core$trashcan = 4, OPACITY_MIN$$module$build$src$core$trashcan = 0.4, OPACITY_MAX$$module$build$src$core$trashcan = 0.8, MAX_LID_ANGLE$$module$build$src$core$trashcan = 45, module$build$src$core$trashcan = {};
          module$build$src$core$trashcan.Trashcan = Trashcan$$module$build$src$core$trashcan;
          var stashedCopyData$$module$build$src$core$clipboard = null, stashedWorkspace$$module$build$src$core$clipboard = null, stashedCoordinates$$module$build$src$core$clipboard = void 0, module$build$src$core$clipboard = {};
          module$build$src$core$clipboard.BlockPaster = BlockPaster$$module$build$src$core$clipboard$block_paster;
          module$build$src$core$clipboard.copy = copy$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.getLastCopiedData = getLastCopiedData$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.getLastCopiedLocation = getLastCopiedLocation$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.getLastCopiedWorkspace = getLastCopiedWorkspace$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.paste = paste$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.registry = module$build$src$core$clipboard$registry;
          module$build$src$core$clipboard.setLastCopiedData = setLastCopiedData$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.setLastCopiedLocation = setLastCopiedLocation$$module$build$src$core$clipboard;
          module$build$src$core$clipboard.setLastCopiedWorkspace = setLastCopiedWorkspace$$module$build$src$core$clipboard;
          var module$build$src$core$comments = {};
          module$build$src$core$comments.CollapseCommentBarButton = CollapseCommentBarButton$$module$build$src$core$comments$collapse_comment_bar_button;
          module$build$src$core$comments.CommentBarButton = CommentBarButton$$module$build$src$core$comments$comment_bar_button;
          module$build$src$core$comments.CommentEditor = CommentEditor$$module$build$src$core$comments$comment_editor;
          module$build$src$core$comments.CommentView = CommentView$$module$build$src$core$comments$comment_view;
          module$build$src$core$comments.DeleteCommentBarButton = DeleteCommentBarButton$$module$build$src$core$comments$delete_comment_bar_button;
          module$build$src$core$comments.RenderedWorkspaceComment = RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment;
          module$build$src$core$comments.WorkspaceComment = WorkspaceComment$$module$build$src$core$comments$workspace_comment;
          var module$build$src$core$interfaces$i_copyable = {};
          module$build$src$core$interfaces$i_copyable.isCopyable = isCopyable$$module$build$src$core$interfaces$i_copyable;
          var names$$module$build$src$core$shortcut_items;
          (function(a) {
            a.ESCAPE = "escape";
            a.DELETE = "delete";
            a.COPY = "copy";
            a.CUT = "cut";
            a.PASTE = "paste";
            a.UNDO = "undo";
            a.REDO = "redo";
          })(names$$module$build$src$core$shortcut_items || (names$$module$build$src$core$shortcut_items = {}));
          registerDefaultShortcuts$$module$build$src$core$shortcut_items();
          var module$build$src$core$shortcut_items = {};
          module$build$src$core$shortcut_items.names = names$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerCopy = registerCopy$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerCut = registerCut$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerDefaultShortcuts = registerDefaultShortcuts$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerDelete = registerDelete$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerEscape = registerEscape$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerPaste = registerPaste$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerRedo = registerRedo$$module$build$src$core$shortcut_items;
          module$build$src$core$shortcut_items.registerUndo = registerUndo$$module$build$src$core$shortcut_items;
          var ProcedureSerializer$$module$build$src$core$serialization$procedures = class {
            constructor(a, b) {
              this.procedureModelClass = a;
              this.parameterModelClass = b;
              this.priority = PROCEDURES$$module$build$src$core$serialization$priorities;
            }
            save(a) {
              a = a.getProcedureMap().getProcedures().map((b) => saveProcedure$$module$build$src$core$serialization$procedures(b));
              return a.length ? a : null;
            }
            load(a, b) {
              const c = b.getProcedureMap();
              for (const d of a) c.add(loadProcedure$$module$build$src$core$serialization$procedures(
                this.procedureModelClass,
                this.parameterModelClass,
                d,
                b
              ));
            }
            clear(a) {
              a.getProcedureMap().clear();
            }
          }, module$build$src$core$serialization$procedures = {};
          module$build$src$core$serialization$procedures.ProcedureSerializer = ProcedureSerializer$$module$build$src$core$serialization$procedures;
          module$build$src$core$serialization$procedures.loadProcedure = loadProcedure$$module$build$src$core$serialization$procedures;
          module$build$src$core$serialization$procedures.saveProcedure = saveProcedure$$module$build$src$core$serialization$procedures;
          var VariableSerializer$$module$build$src$core$serialization$variables = class {
            constructor() {
              this.priority = VARIABLES$$module$build$src$core$serialization$priorities;
            }
            save(a) {
              a = a.getAllVariables().map((b) => b.save());
              return a.length ? a : null;
            }
            load(a, b) {
              const c = getObject$$module$build$src$core$registry(Type$$module$build$src$core$registry.VARIABLE_MODEL, DEFAULT$$module$build$src$core$registry);
              a.forEach((d) => {
                c == null || c.load(d, b);
              });
            }
            clear(a) {
              a.getVariableMap().clear();
            }
          };
          register$$module$build$src$core$serialization$registry("variables", new VariableSerializer$$module$build$src$core$serialization$variables());
          var module$build$src$core$serialization$variables = {};
          module$build$src$core$serialization$variables.VariableSerializer = VariableSerializer$$module$build$src$core$serialization$variables;
          var module$build$src$core$serialization$workspaces = {};
          module$build$src$core$serialization$workspaces.load = load$$module$build$src$core$serialization$workspaces;
          module$build$src$core$serialization$workspaces.save = save$$module$build$src$core$serialization$workspaces;
          var module$build$src$core$serialization = { blocks: module$build$src$core$serialization$blocks, exceptions: module$build$src$core$serialization$exceptions, priorities: module$build$src$core$serialization$priorities, procedures: module$build$src$core$serialization$procedures, registry: module$build$src$core$serialization$registry, variables: module$build$src$core$serialization$variables, workspaceComments: module$build$src$core$serialization$workspace_comments, workspaces: module$build$src$core$serialization$workspaces };
          "Blockly" in globalThis || (globalThis.Blockly = { Msg: module$build$src$core$msg });
          var module$build$src$core$main = {};
          var LABEL_TYPE$$module$build$src$core$label_flyout_inflater = "label", LabelFlyoutInflater$$module$build$src$core$label_flyout_inflater = class {
            load(a, b) {
              a = new FlyoutButton$$module$build$src$core$flyout_button(b.getWorkspace(), b.targetWorkspace, a, true);
              a.show();
              return new FlyoutItem$$module$build$src$core$flyout_item(a, LABEL_TYPE$$module$build$src$core$label_flyout_inflater);
            }
            gapForItem(a, b) {
              return b;
            }
            disposeItem(a) {
              a = a.getElement();
              a instanceof FlyoutButton$$module$build$src$core$flyout_button && a.dispose();
            }
            getType() {
              return LABEL_TYPE$$module$build$src$core$label_flyout_inflater;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUT_INFLATER, LABEL_TYPE$$module$build$src$core$label_flyout_inflater, LabelFlyoutInflater$$module$build$src$core$label_flyout_inflater);
          var module$build$src$core$label_flyout_inflater = {};
          module$build$src$core$label_flyout_inflater.LabelFlyoutInflater = LabelFlyoutInflater$$module$build$src$core$label_flyout_inflater;
          var ConstantProvider$$module$build$src$core$renderers$zelos$constants = class extends ConstantProvider$$module$build$src$core$renderers$common$constants {
            constructor(a) {
              super();
              this.GRID_UNIT = 4;
              this.CURSOR_COLOUR = "#ffa200";
              this.CURSOR_RADIUS = 5;
              this.JAGGED_TEETH_WIDTH = this.JAGGED_TEETH_HEIGHT = 0;
              this.START_HAT_HEIGHT = 22;
              this.START_HAT_WIDTH = 96;
              this.SHAPES = { HEXAGONAL: 1, ROUND: 2, SQUARE: 3, PUZZLE: 4, NOTCH: 5 };
              this.SHAPE_IN_SHAPE_PADDING = {
                1: { 0: 5 * this.GRID_UNIT, 1: 2 * this.GRID_UNIT, 2: 5 * this.GRID_UNIT, 3: 5 * this.GRID_UNIT },
                2: { 0: 3 * this.GRID_UNIT, 1: 3 * this.GRID_UNIT, 2: 1 * this.GRID_UNIT, 3: 2 * this.GRID_UNIT },
                3: { 0: 2 * this.GRID_UNIT, 1: 2 * this.GRID_UNIT, 2: 2 * this.GRID_UNIT, 3: 2 * this.GRID_UNIT }
              };
              this.FULL_BLOCK_FIELDS = true;
              this.FIELD_TEXT_FONTWEIGHT = "bold";
              this.FIELD_TEXT_FONTFAMILY = '"Helvetica Neue", "Segoe UI", Helvetica, sans-serif';
              this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = true;
              this.SELECTED_GLOW_COLOUR = "#fff200";
              this.SELECTED_GLOW_SIZE = 0.5;
              this.REPLACEMENT_GLOW_COLOUR = "#fff200";
              this.REPLACEMENT_GLOW_SIZE = 2;
              this.selectedGlowFilterId = "";
              this.selectedGlowFilter = null;
              this.replacementGlowFilterId = "";
              this.SQUARED = this.ROUNDED = this.HEXAGONAL = this.replacementGlowFilter = null;
              a && (this.GRID_UNIT = a);
              this.SMALL_PADDING = this.GRID_UNIT;
              this.MEDIUM_PADDING = 2 * this.GRID_UNIT;
              this.MEDIUM_LARGE_PADDING = 3 * this.GRID_UNIT;
              this.LARGE_PADDING = 4 * this.GRID_UNIT;
              this.CORNER_RADIUS = 1 * this.GRID_UNIT;
              this.NOTCH_WIDTH = 9 * this.GRID_UNIT;
              this.NOTCH_HEIGHT = 2 * this.GRID_UNIT;
              this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT = 3 * this.GRID_UNIT;
              this.MIN_BLOCK_WIDTH = 2 * this.GRID_UNIT;
              this.MIN_BLOCK_HEIGHT = 12 * this.GRID_UNIT;
              this.EMPTY_STATEMENT_INPUT_HEIGHT = 6 * this.GRID_UNIT;
              this.TOP_ROW_MIN_HEIGHT = this.CORNER_RADIUS;
              this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
              this.BOTTOM_ROW_MIN_HEIGHT = this.CORNER_RADIUS;
              this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = 6 * this.GRID_UNIT;
              this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT;
              this.STATEMENT_INPUT_SPACER_MIN_WIDTH = 40 * this.GRID_UNIT;
              this.STATEMENT_INPUT_PADDING_LEFT = 4 * this.GRID_UNIT;
              this.EMPTY_INLINE_INPUT_PADDING = 4 * this.GRID_UNIT;
              this.EMPTY_INLINE_INPUT_HEIGHT = 8 * this.GRID_UNIT;
              this.DUMMY_INPUT_MIN_HEIGHT = 8 * this.GRID_UNIT;
              this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 6 * this.GRID_UNIT;
              this.CURSOR_WS_WIDTH = 20 * this.GRID_UNIT;
              this.FIELD_TEXT_FONTSIZE = 3 * this.GRID_UNIT;
              this.FIELD_BORDER_RECT_RADIUS = this.CORNER_RADIUS;
              this.FIELD_BORDER_RECT_X_PADDING = 2 * this.GRID_UNIT;
              this.FIELD_BORDER_RECT_Y_PADDING = 1.625 * this.GRID_UNIT;
              this.FIELD_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;
              this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;
              this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;
              this.FIELD_COLOUR_DEFAULT_WIDTH = 6 * this.GRID_UNIT;
              this.FIELD_COLOUR_DEFAULT_HEIGHT = 8 * this.GRID_UNIT;
              this.FIELD_CHECKBOX_X_OFFSET = 1 * this.GRID_UNIT;
              this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH = 12 * this.GRID_UNIT;
            }
            setFontConstants_(a) {
              super.setFontConstants_(a);
              this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT = this.FIELD_TEXT_HEIGHT + this.FIELD_BORDER_RECT_Y_PADDING * 2;
            }
            init() {
              super.init();
              this.HEXAGONAL = this.makeHexagonal();
              this.ROUNDED = this.makeRounded();
              this.SQUARED = this.makeSquared();
              this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT + this.INSIDE_CORNERS.rightWidth;
            }
            setDynamicProperties_(a) {
              super.setDynamicProperties_(a);
              this.SELECTED_GLOW_COLOUR = a.getComponentStyle("selectedGlowColour") || this.SELECTED_GLOW_COLOUR;
              const b = Number(a.getComponentStyle("selectedGlowSize"));
              this.SELECTED_GLOW_SIZE = b && !isNaN(b) ? b : this.SELECTED_GLOW_SIZE;
              this.REPLACEMENT_GLOW_COLOUR = a.getComponentStyle("replacementGlowColour") || this.REPLACEMENT_GLOW_COLOUR;
              this.REPLACEMENT_GLOW_SIZE = (a = Number(a.getComponentStyle("replacementGlowSize"))) && !isNaN(a) ? a : this.REPLACEMENT_GLOW_SIZE;
            }
            dispose() {
              super.dispose();
              this.selectedGlowFilter && removeNode$$module$build$src$core$utils$dom(this.selectedGlowFilter);
              this.replacementGlowFilter && removeNode$$module$build$src$core$utils$dom(this.replacementGlowFilter);
            }
            makeStartHat() {
              const a = this.START_HAT_HEIGHT, b = this.START_HAT_WIDTH, c = curve$$module$build$src$core$utils$svg_paths(
                "c",
                [point$$module$build$src$core$utils$svg_paths(25, -a), point$$module$build$src$core$utils$svg_paths(71, -a), point$$module$build$src$core$utils$svg_paths(b, 0)]
              );
              return { height: a * 0.75, width: b, path: c };
            }
            makeHexagonal() {
              function a(c, d, e) {
                var f = c / 2;
                f = f > b ? b : f;
                e = e ? -1 : 1;
                c = (d ? -1 : 1) * c / 2;
                return lineTo$$module$build$src$core$utils$svg_paths(-e * f, c) + lineTo$$module$build$src$core$utils$svg_paths(e * f, c);
              }
              const b = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;
              return { type: this.SHAPES.HEXAGONAL, isDynamic: true, width(c) {
                c /= 2;
                return c > b ? b : c;
              }, height(c) {
                return c;
              }, connectionOffsetY(c) {
                return c / 2;
              }, connectionOffsetX(c) {
                return -c;
              }, pathDown(c) {
                return a(c, false, false);
              }, pathUp(c) {
                return a(c, true, false);
              }, pathRightDown(c) {
                return a(c, false, true);
              }, pathRightUp(c) {
                return a(c, false, true);
              } };
            }
            makeRounded() {
              function a(d, e, f) {
                const g = d > c ? d - c : 0;
                d = (d > c ? c : d) / 2;
                const h = f === e ? "0" : "1";
                return arc$$module$build$src$core$utils$svg_paths("a", "0 0," + h, d, point$$module$build$src$core$utils$svg_paths((f ? 1 : -1) * d, (e ? -1 : 1) * d)) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", (e ? -1 : 1) * g) + arc$$module$build$src$core$utils$svg_paths("a", "0 0," + h, d, point$$module$build$src$core$utils$svg_paths((f ? -1 : 1) * d, (e ? -1 : 1) * d));
              }
              const b = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH, c = b * 2;
              return { type: this.SHAPES.ROUND, isDynamic: true, width(d) {
                d /= 2;
                return d > b ? b : d;
              }, height(d) {
                return d;
              }, connectionOffsetY(d) {
                return d / 2;
              }, connectionOffsetX(d) {
                return -d;
              }, pathDown(d) {
                return a(d, false, false);
              }, pathUp(d) {
                return a(d, true, false);
              }, pathRightDown(d) {
                return a(d, false, true);
              }, pathRightUp(d) {
                return a(d, false, true);
              } };
            }
            makeSquared() {
              function a(c, d, e) {
                c -= b * 2;
                const f = e === d ? "0" : "1";
                return arc$$module$build$src$core$utils$svg_paths("a", "0 0," + f, b, point$$module$build$src$core$utils$svg_paths((e ? 1 : -1) * b, (d ? -1 : 1) * b)) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", (d ? -1 : 1) * c) + arc$$module$build$src$core$utils$svg_paths("a", "0 0," + f, b, point$$module$build$src$core$utils$svg_paths((e ? -1 : 1) * b, (d ? -1 : 1) * b));
              }
              const b = this.CORNER_RADIUS;
              return { type: this.SHAPES.SQUARE, isDynamic: true, width(c) {
                return b;
              }, height(c) {
                return c;
              }, connectionOffsetY(c) {
                return c / 2;
              }, connectionOffsetX(c) {
                return -c;
              }, pathDown(c) {
                return a(c, false, false);
              }, pathUp(c) {
                return a(c, true, false);
              }, pathRightDown(c) {
                return a(c, false, true);
              }, pathRightUp(c) {
                return a(c, false, true);
              } };
            }
            shapeFor(a) {
              let b = a.getCheck();
              !b && a.targetConnection && (b = a.targetConnection.getCheck());
              switch (a.type) {
                case ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE:
                case ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE:
                  a = a.getSourceBlock().getOutputShape();
                  if (a !== null) switch (a) {
                    case this.SHAPES.HEXAGONAL:
                      return this.HEXAGONAL;
                    case this.SHAPES.ROUND:
                      return this.ROUNDED;
                    case this.SHAPES.SQUARE:
                      return this.SQUARED;
                  }
                  if (b && b.includes("Boolean")) return this.HEXAGONAL;
                  if (b && b.includes("Number")) return this.ROUNDED;
                  b && b.includes("String");
                  return this.ROUNDED;
                case ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT:
                case ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT:
                  return this.NOTCH;
                default:
                  throw Error("Unknown type");
              }
            }
            makeNotch() {
              function a(l) {
                return curve$$module$build$src$core$utils$svg_paths(
                  "c",
                  [point$$module$build$src$core$utils$svg_paths(l * e / 2, 0), point$$module$build$src$core$utils$svg_paths(l * e * 3 / 4, g / 2), point$$module$build$src$core$utils$svg_paths(l * e, g)]
                ) + line$$module$build$src$core$utils$svg_paths([point$$module$build$src$core$utils$svg_paths(l * e, f)]) + curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(l * e / 4, g / 2), point$$module$build$src$core$utils$svg_paths(l * e / 2, g), point$$module$build$src$core$utils$svg_paths(l * e, g)]) + lineOnAxis$$module$build$src$core$utils$svg_paths(
                  "h",
                  l * d
                ) + curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(l * e / 2, 0), point$$module$build$src$core$utils$svg_paths(l * e * 3 / 4, -(g / 2)), point$$module$build$src$core$utils$svg_paths(l * e, -g)]) + line$$module$build$src$core$utils$svg_paths([point$$module$build$src$core$utils$svg_paths(l * e, -f)]) + curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(l * e / 4, -(g / 2)), point$$module$build$src$core$utils$svg_paths(l * e / 2, -g), point$$module$build$src$core$utils$svg_paths(l * e, -g)]);
              }
              const b = this.NOTCH_WIDTH, c = this.NOTCH_HEIGHT, d = b / 3, e = d / 3, f = c / 2, g = f / 2, h = a(1), k = a(-1);
              return { type: this.SHAPES.NOTCH, width: b, height: c, pathLeft: h, pathRight: k };
            }
            makeInsideCorners() {
              const a = this.CORNER_RADIUS, b = arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a, point$$module$build$src$core$utils$svg_paths(-a, a)), c = arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a, point$$module$build$src$core$utils$svg_paths(-a, a)), d = arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a, point$$module$build$src$core$utils$svg_paths(
                a,
                a
              )), e = arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a, point$$module$build$src$core$utils$svg_paths(a, a));
              return { width: a, height: a, pathTop: b, pathBottom: d, rightWidth: a, rightHeight: a, pathTopRight: c, pathBottomRight: e };
            }
            generateSecondaryColour_(a) {
              return blend$$module$build$src$core$utils$colour("#000", a, 0.15) || a;
            }
            generateTertiaryColour_(a) {
              return blend$$module$build$src$core$utils$colour("#000", a, 0.25) || a;
            }
            createDom(a, b, c, d) {
              super.createDom(a, b, c, d);
              a = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.DEFS,
                {},
                a
              );
              b = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FILTER, { id: "blocklySelectedGlowFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" }, a);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEGAUSSIANBLUR, { "in": "SourceGraphic", stdDeviation: this.SELECTED_GLOW_SIZE }, b);
              c = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPONENTTRANSFER, { result: "outBlur" }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, c);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFLOOD, { "flood-color": this.SELECTED_GLOW_COLOUR, "flood-opacity": 1, result: "outColor" }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPOSITE, { "in": "outColor", in2: "outBlur", operator: "in", result: "outGlow" }, b);
              this.selectedGlowFilterId = b.id;
              this.selectedGlowFilter = b;
              a = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FILTER, { id: "blocklyReplacementGlowFilter" + this.randomIdentifier, height: "160%", width: "180%", y: "-30%", x: "-40%" }, a);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEGAUSSIANBLUR, { "in": "SourceGraphic", stdDeviation: this.REPLACEMENT_GLOW_SIZE }, a);
              b = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.FECOMPONENTTRANSFER,
                { result: "outBlur" },
                a
              );
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFUNCA, { type: "table", tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1" }, b);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FEFLOOD, { "flood-color": this.REPLACEMENT_GLOW_COLOUR, "flood-opacity": 1, result: "outColor" }, a);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPOSITE, {
                "in": "outColor",
                in2: "outBlur",
                operator: "in",
                result: "outGlow"
              }, a);
              createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.FECOMPOSITE, { "in": "SourceGraphic", in2: "outGlow", operator: "over" }, a);
              this.replacementGlowFilterId = a.id;
              this.replacementGlowFilter = a;
              d && (d.style.setProperty("--blocklySelectedGlowFilter", `url(#${this.selectedGlowFilterId})`), d.style.setProperty("--blocklyReplacementGlowFilter", `url(#${this.replacementGlowFilterId})`));
            }
            getCSS_(a) {
              return [
                `${a} .blocklyText,`,
                `${a} .blocklyFlyoutLabelText {`,
                `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`,
                "}",
                `${a} .blocklyTextInputBubble textarea {`,
                "font-weight: normal;",
                "}",
                `${a} .blocklyText {`,
                "fill: #fff;",
                "}",
                `${a} .blocklyNonEditableField>rect:not(.blocklyDropdownRect),`,
                `${a} .blocklyEditableField>rect:not(.blocklyDropdownRect) {`,
                `fill: ${this.FIELD_BORDER_RECT_COLOUR};`,
                "}",
                `${a} .blocklyNonEditableField>text,`,
                `${a} .blocklyEditableField>text,`,
                `${a} .blocklyNonEditableField>g>text,`,
                `${a} .blocklyEditableField>g>text {`,
                "fill: #575E75;",
                "}",
                `${a} .blocklyFlyoutLabelText {`,
                "fill: #575E75;",
                "}",
                `${a} .blocklyText.blocklyBubbleText {`,
                "fill: #575E75;",
                "}",
                `${a} .blocklyDraggable:not(.blocklyDisabled)`,
                " .blocklyEditableField:not(.blocklyEditing):hover>rect,",
                `${a} .blocklyDraggable:not(.blocklyDisabled)`,
                " .blocklyEditableField:not(.blocklyEditing):hover>.blocklyPath {",
                "stroke: #fff;",
                "stroke-width: 2;",
                "}",
                `${a} .blocklyHtmlInput {`,
                `font-family: ${this.FIELD_TEXT_FONTFAMILY};`,
                `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`,
                "color: #575E75;",
                "}",
                `${a} .blocklyDropdownText {`,
                "fill: #fff !important;",
                "}",
                `${a}.blocklyWidgetDiv .blocklyMenuItem,`,
                `${a}.blocklyDropDownDiv .blocklyMenuItem {`,
                `font-family: ${this.FIELD_TEXT_FONTFAMILY};`,
                "}",
                `${a}.blocklyDropDownDiv .blocklyMenuItemContent {`,
                "color: #fff;",
                "}",
                `${a} .blocklyHighlightedConnectionPath {`,
                `stroke: ${this.SELECTED_GLOW_COLOUR};`,
                "}",
                `${a} .blocklyDisabledPattern > .blocklyOutlinePath {`,
                "fill: var(--blocklyDisabledPattern)",
                "}",
                `${a} .blocklyInsertionMarker>.blocklyPath {`,
                `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`,
                "stroke: none;",
                "}",
                `${a} .blocklySelected>.blocklyPath.blocklyPathSelected {`,
                "fill: none;",
                "filter: var(--blocklySelectedGlowFilter);",
                "}",
                `${a} .blocklyReplaceable>.blocklyPath {`,
                "filter: var(--blocklyReplacementGlowFilter);",
                "}"
              ];
            }
          }, module$build$src$core$renderers$zelos$constants = {};
          module$build$src$core$renderers$zelos$constants.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$zelos$constants;
          var Drawer$$module$build$src$core$renderers$zelos$drawer = class extends Drawer$$module$build$src$core$renderers$common$drawer {
            constructor(a, b) {
              super(a, b);
            }
            draw() {
              const a = this.block_.pathObject;
              a.beginDrawing();
              this.drawOutline_();
              this.drawInternals_();
              this.updateConnectionHighlights();
              a.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
              this.info_.RTL && a.flipRTL();
              this.recordSizeOnBlock_();
              this.info_.outputConnection && (a.outputShapeType = this.info_.outputConnection.shape.type);
              a.endDrawing();
            }
            drawOutline_() {
              this.info_.outputConnection && this.info_.outputConnection.isDynamicShape && !this.info_.hasStatementInput && !this.info_.bottomRow.hasNextConnection ? (this.drawFlatTop_(), this.drawRightDynamicConnection_(), this.drawFlatBottom_(), this.drawLeftDynamicConnection_()) : super.drawOutline_();
            }
            drawLeft_() {
              this.info_.outputConnection && this.info_.outputConnection.isDynamicShape ? this.drawLeftDynamicConnection_() : super.drawLeft_();
            }
            drawRightSideRow_(a) {
              if (!(a.height <= 0)) {
                if (Types$$module$build$src$core$renderers$measurables$types.isSpacer(a)) {
                  const d = a.precedesStatement;
                  var b = a.followsStatement;
                  if (d || b) {
                    const e = this.constants_.INSIDE_CORNERS;
                    var c = e.rightHeight;
                    c = a.height - (d ? c : 0);
                    b = b ? e.pathBottomRight : "";
                    a = c > 0 ? lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.yPos + c) : "";
                    this.outlinePath_ += b + a + (d ? e.pathTopRight : "");
                    return;
                  }
                }
                this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.yPos + a.height);
              }
            }
            drawRightDynamicConnection_() {
              if (!this.info_.outputConnection) throw Error("Cannot draw the output connection of a block that doesn't have one");
              this.outlinePath_ += this.info_.outputConnection.shape.pathRightDown(this.info_.outputConnection.height);
            }
            drawLeftDynamicConnection_() {
              if (!this.info_.outputConnection) throw Error("Cannot draw the output connection of a block that doesn't have one");
              this.positionOutputConnection_();
              this.outlinePath_ += this.info_.outputConnection.shape.pathUp(this.info_.outputConnection.height);
              this.outlinePath_ += "z";
            }
            drawFlatTop_() {
              const a = this.info_.topRow;
              this.positionPreviousConnection_();
              this.outlinePath_ += moveBy$$module$build$src$core$utils$svg_paths(
                a.xPos,
                this.info_.startY
              );
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("h", a.width);
            }
            drawFlatBottom_() {
              const a = this.info_.bottomRow;
              this.positionNextConnection_();
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.baseline);
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("h", -a.width);
            }
            drawInlineInput_(a) {
              this.positionInlineInputConnection_(a);
              const b = a.input.name;
              a.connectedBlock || this.info_.isInsertionMarker || (a = moveTo$$module$build$src$core$utils$svg_paths(a.xPos + a.connectionWidth, a.centerline - a.height / 2) + this.getInlineInputPath(a), this.block_.pathObject.setOutlinePath(b, a));
            }
            getInlineInputPath(a) {
              const b = a.width - a.connectionWidth * 2, c = a.height;
              return lineOnAxis$$module$build$src$core$utils$svg_paths("h", b) + a.shape.pathRightDown(c) + lineOnAxis$$module$build$src$core$utils$svg_paths("h", -b) + a.shape.pathUp(c) + "z";
            }
            drawStatementInput_(a) {
              var b = a.getLastInput();
              const c = b.xPos + b.notchOffset + b.shape.width, d = this.constants_.INSIDE_CORNERS, e = b.shape.pathRight + lineOnAxis$$module$build$src$core$utils$svg_paths(
                "h",
                -(b.notchOffset - d.width)
              ) + d.pathTop, f = a.height - 2 * d.height;
              b = d.pathBottom + lineOnAxis$$module$build$src$core$utils$svg_paths("h", b.notchOffset - d.width) + (b.connectedBottomNextConnection ? "" : b.shape.pathLeft);
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", c) + e + lineOnAxis$$module$build$src$core$utils$svg_paths("v", f) + b + lineOnAxis$$module$build$src$core$utils$svg_paths("H", a.xPos + a.width);
              this.positionStatementInputConnection_(a);
            }
            drawConnectionHighlightPath(a) {
              const b = a.connectionModel;
              if (b.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT || b.type === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT || b.type === ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE && !a.isDynamicShape) return super.drawConnectionHighlightPath(a);
              a = b.type === ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE ? moveTo$$module$build$src$core$utils$svg_paths(a.connectionWidth, -a.height / 2) + this.getInlineInputPath(a) : moveTo$$module$build$src$core$utils$svg_paths(
                a.width,
                -a.height / 2
              ) + a.shape.pathDown(a.height);
              const c = b.getSourceBlock();
              let d, e;
              return (e = (d = c.pathObject).addConnectionHighlight) == null ? void 0 : e.call(d, b, a, b.getOffsetInBlock(), c.RTL);
            }
          }, module$build$src$core$renderers$zelos$drawer = {};
          module$build$src$core$renderers$zelos$drawer.Drawer = Drawer$$module$build$src$core$renderers$zelos$drawer;
          var FieldImage$$module$build$src$core$field_image = class extends Field$$module$build$src$core$field {
            constructor(a, b, c, d, e, f, g) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.imageElement = this.clickHandler = null;
              this.flipRtl = this.isDirty_ = this.EDITABLE = false;
              this.altText = "";
              c = Number(replaceMessageReferences$$module$build$src$core$utils$parsing(c));
              b = Number(replaceMessageReferences$$module$build$src$core$utils$parsing(b));
              if (isNaN(c) || isNaN(b)) throw Error("Height and width values of an image field must cast to numbers.");
              if (c <= 0 || b <= 0) throw Error("Height and width values of an image field must be greater than 0.");
              this.size_ = new Size$$module$build$src$core$utils$size(b, c + FieldImage$$module$build$src$core$field_image.Y_PADDING);
              this.imageHeight = c;
              typeof e === "function" && (this.clickHandler = e);
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (g ? this.configure_(g) : (this.flipRtl = !!f, this.altText = replaceMessageReferences$$module$build$src$core$utils$parsing(d) || ""), this.setValue(replaceMessageReferences$$module$build$src$core$utils$parsing(a)));
            }
            configure_(a) {
              super.configure_(a);
              a.flipRtl && (this.flipRtl = a.flipRtl);
              a.alt && (this.altText = replaceMessageReferences$$module$build$src$core$utils$parsing(a.alt));
            }
            initView() {
              this.imageElement = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.IMAGE, { height: this.imageHeight + "px", width: this.size_.width + "px", alt: this.altText }, this.fieldGroup_);
              this.imageElement.setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", this.value_);
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(
                this.fieldGroup_,
                "blocklyImageField"
              );
              this.clickHandler && (this.imageElement.style.cursor = "pointer");
            }
            updateSize_() {
            }
            doClassValidation_(a) {
              return typeof a !== "string" ? null : a;
            }
            doValueUpdate_(a) {
              this.value_ = a;
              this.imageElement && this.imageElement.setAttributeNS(XLINK_NS$$module$build$src$core$utils$dom, "xlink:href", this.value_);
            }
            getFlipRtl() {
              return this.flipRtl;
            }
            setAlt(a) {
              a !== this.altText && (this.altText = a || "", this.imageElement && this.imageElement.setAttribute("alt", this.altText));
            }
            isClickable() {
              return super.isClickable() && !!this.clickHandler;
            }
            showEditor_() {
              this.clickHandler && this.clickHandler(this);
            }
            setOnClickHandler(a) {
              this.clickHandler = a;
            }
            getText_() {
              return this.altText;
            }
            static fromJson(a) {
              if (!a.src || !a.width || !a.height) throw Error("src, width, and height values for an image field arerequired. The width and height must be non-zero.");
              return new this(a.src, a.width, a.height, void 0, void 0, void 0, a);
            }
          };
          FieldImage$$module$build$src$core$field_image.Y_PADDING = 1;
          register$$module$build$src$core$field_registry("field_image", FieldImage$$module$build$src$core$field_image);
          FieldImage$$module$build$src$core$field_image.prototype.DEFAULT_VALUE = "";
          var module$build$src$core$field_image = {};
          module$build$src$core$field_image.FieldImage = FieldImage$$module$build$src$core$field_image;
          var MINIMUM_WIDTH$$module$build$src$core$field_input = 14, FieldInput$$module$build$src$core$field_input = class extends Field$$module$build$src$core$field {
            set size_(a) {
              super.size_ = a;
            }
            get size_() {
              const a = super.size_;
              a.width < MINIMUM_WIDTH$$module$build$src$core$field_input && (a.width = MINIMUM_WIDTH$$module$build$src$core$field_input);
              return a;
            }
            constructor(a, b, c) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.spellcheck_ = true;
              this.htmlInput_ = null;
              this.isTextValid_ = this.isBeingEdited_ = false;
              this.onInputWrapper = this.onKeyDownWrapper = this.valueWhenEditorWasOpened_ = null;
              this.fullBlockClickTarget_ = false;
              this.workspace_ = null;
              this.SERIALIZABLE = true;
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (c && this.configure_(c), this.setValue(a), b && this.setValidator(b));
            }
            configure_(a) {
              super.configure_(a);
              a.spellcheck !== void 0 && (this.spellcheck_ = a.spellcheck);
            }
            initView() {
              if (!this.getSourceBlock()) throw new UnattachedFieldError$$module$build$src$core$field();
              super.initView();
              this.isFullBlockField() && (this.clickTarget_ = this.sourceBlock_.getSvgRoot());
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyInputField");
            }
            isFullBlockField() {
              const a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              let b;
              return this.fullBlockClickTarget_ = !((b = this.getConstants()) == null || !b.FULL_BLOCK_FIELDS) && a.isSimpleReporter();
            }
            doValueInvalid_(a, b = true) {
              this.isBeingEdited_ && (this.isDirty_ = true, this.isTextValid_ = false, a = this.value_, this.value_ = this.valueWhenEditorWasOpened_, this.sourceBlock_ && isEnabled$$module$build$src$core$events$utils() && this.value_ !== a && b && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(this.sourceBlock_, "field", this.name || null, a, this.value_)));
            }
            doValueUpdate_(a) {
              this.isTextValid_ = this.isDirty_ = true;
              this.value_ = a;
            }
            applyColour() {
              const a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              this.getConstants().FULL_BLOCK_FIELDS && this.fieldGroup_ && (!this.isFullBlockField() && this.borderRect_ ? (this.borderRect_.style.display = "block", this.borderRect_.setAttribute("stroke", a.getColourTertiary())) : (this.borderRect_.style.display = "none", a.pathObject.svgPath.setAttribute("fill", this.getConstants().FIELD_BORDER_RECT_COLOUR)));
            }
            getSize() {
              let a;
              if ((a = this.getConstants()) == null ? 0 : a.FULL_BLOCK_FIELDS) this.render_(), this.isDirty_ = false;
              return super.getSize();
            }
            onLocationChange() {
              this.isBeingEdited_ && this.resizeEditor_();
            }
            render_() {
              super.render_();
              if (this.isBeingEdited_) {
                var a = this.htmlInput_;
                this.isTextValid_ ? (removeClass$$module$build$src$core$utils$dom(a, "blocklyInvalidInput"), setState$$module$build$src$core$utils$aria(a, State$$module$build$src$core$utils$aria.INVALID, false)) : (addClass$$module$build$src$core$utils$dom(a, "blocklyInvalidInput"), setState$$module$build$src$core$utils$aria(a, State$$module$build$src$core$utils$aria.INVALID, true));
              }
              a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              this.getConstants().FULL_BLOCK_FIELDS && a.applyColour();
            }
            setSpellcheck(a) {
              a !== this.spellcheck_ && (this.spellcheck_ = a, this.htmlInput_ && this.htmlInput_.setAttribute("spellcheck", this.spellcheck_));
            }
            showEditor_(a, b = false, c = true) {
              this.workspace_ = this.sourceBlock_.workspace;
              !b && this.workspace_.options.modalInputs && (MOBILE$$module$build$src$core$utils$useragent || ANDROID$$module$build$src$core$utils$useragent || IPAD$$module$build$src$core$utils$useragent) ? this.showPromptEditor() : this.showInlineEditor(b, c);
            }
            showPromptEditor() {
              prompt$$module$build$src$core$dialog(
                $.Msg$$module$build$src$core$msg.CHANGE_VALUE_TITLE,
                this.getText(),
                (a) => {
                  a !== null && this.setValue(this.getValueFromEditorText_(a));
                  this.onFinishEditing_(this.value_);
                }
              );
            }
            showInlineEditor(a, b) {
              const c = this.getSourceBlock();
              if (!c) throw new UnattachedFieldError$$module$build$src$core$field();
              show$$module$build$src$core$widgetdiv(this, c.RTL, this.widgetDispose_.bind(this), this.workspace_, b);
              this.htmlInput_ = this.widgetCreate_();
              this.isBeingEdited_ = true;
              this.valueWhenEditorWasOpened_ = this.value_;
              a || (this.htmlInput_.focus({ preventScroll: true }), this.htmlInput_.select());
            }
            widgetCreate_() {
              var a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              $.setGroup$$module$build$src$core$events$utils(true);
              const b = getDiv$$module$build$src$core$widgetdiv();
              var c = this.getClickTarget_();
              if (!c) throw Error("A click target has not been set.");
              addClass$$module$build$src$core$utils$dom(c, "blocklyEditing");
              c = document.createElement("input");
              c.className = "blocklyHtmlInput";
              c.setAttribute("spellcheck", this.spellcheck_);
              const d = this.workspace_.getAbsoluteScale();
              var e = this.getConstants().FIELD_TEXT_FONTSIZE * d + "pt";
              b.style.fontSize = e;
              c.style.fontSize = e;
              e = FieldInput$$module$build$src$core$field_input.BORDERRADIUS * d + "px";
              this.isFullBlockField() && (e = this.getScaledBBox(), e = (e.bottom - e.top) / 2 + "px", a = a.getParent() ? a.getParent().getColourTertiary() : this.sourceBlock_.getColourTertiary(), c.style.border = 1 * d + "px solid " + a, b.style.borderRadius = e, b.style.transition = "box-shadow 0.25s ease 0s", this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW && (b.style.boxShadow = "rgba(255, 255, 255, 0.3) 0 0 0 " + 4 * d + "px"));
              c.style.borderRadius = e;
              b.appendChild(c);
              c.value = c.defaultValue = this.getEditorText_(this.value_);
              c.setAttribute("data-untyped-default-value", String(this.value_));
              this.resizeEditor_();
              this.bindInputEvents_(c);
              return c;
            }
            widgetDispose_() {
              this.isBeingEdited_ = false;
              this.isTextValid_ = true;
              this.forceRerender();
              this.onFinishEditing_(this.value_);
              this.sourceBlock_ && isEnabled$$module$build$src$core$events$utils() && this.valueWhenEditorWasOpened_ !== null && this.valueWhenEditorWasOpened_ !== this.value_ && (fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_CHANGE))(
                this.sourceBlock_,
                "field",
                this.name || null,
                this.valueWhenEditorWasOpened_,
                this.value_
              )), this.valueWhenEditorWasOpened_ = null);
              $.setGroup$$module$build$src$core$events$utils(false);
              this.unbindInputEvents_();
              var a = getDiv$$module$build$src$core$widgetdiv().style;
              a.width = "auto";
              a.height = "auto";
              a.fontSize = "";
              a.transition = "";
              a.boxShadow = "";
              this.htmlInput_ = null;
              a = this.getClickTarget_();
              if (!a) throw Error("A click target has not been set.");
              removeClass$$module$build$src$core$utils$dom(a, "blocklyEditing");
            }
            onFinishEditing_(a) {
            }
            bindInputEvents_(a) {
              this.onKeyDownWrapper = conditionalBind$$module$build$src$core$browser_events(a, "keydown", this, this.onHtmlInputKeyDown_);
              this.onInputWrapper = conditionalBind$$module$build$src$core$browser_events(a, "input", this, this.onHtmlInputChange);
            }
            unbindInputEvents_() {
              this.onKeyDownWrapper && (unbind$$module$build$src$core$browser_events(this.onKeyDownWrapper), this.onKeyDownWrapper = null);
              this.onInputWrapper && (unbind$$module$build$src$core$browser_events(this.onInputWrapper), this.onInputWrapper = null);
            }
            onHtmlInputKeyDown_(a) {
              if (a.key === "Enter") hideIfOwner$$module$build$src$core$widgetdiv(this), hideWithoutAnimation$$module$build$src$core$dropdowndiv();
              else if (a.key === "Escape") this.setValue(this.htmlInput_.getAttribute("data-untyped-default-value"), false), hideIfOwner$$module$build$src$core$widgetdiv(this), hideWithoutAnimation$$module$build$src$core$dropdowndiv();
              else if (a.key === "Tab") {
                a.preventDefault();
                var b, c = (b = this.workspace_) == null ? void 0 : b.getCursor();
                b = (d) => (d instanceof FieldInput$$module$build$src$core$field_input || d instanceof BlockSvg$$module$build$src$core$block_svg && d.isSimpleReporter()) && d !== this.getSourceBlock();
                a = a.shiftKey ? c == null ? void 0 : c.getPreviousNode(this, b, false) : c == null ? void 0 : c.getNextNode(this, b, false);
                a = a instanceof BlockSvg$$module$build$src$core$block_svg && a.isSimpleReporter() ? a.getFields().next().value : a;
                a instanceof FieldInput$$module$build$src$core$field_input && (hideIfOwner$$module$build$src$core$widgetdiv(this), hideWithoutAnimation$$module$build$src$core$dropdowndiv(), c = a.getSourceBlock(), a.isFullBlockField() && c && c instanceof BlockSvg$$module$build$src$core$block_svg ? $.getFocusManager$$module$build$src$core$focus_manager().focusNode(c) : $.getFocusManager$$module$build$src$core$focus_manager().focusNode(a), a.showEditor());
              }
            }
            onHtmlInputChange(a) {
              a = this.value_;
              this.setValue(this.getValueFromEditorText_(this.htmlInput_.value), false);
              this.sourceBlock_ && isEnabled$$module$build$src$core$events$utils() && this.value_ !== a && fire$$module$build$src$core$events$utils(new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE))(
                this.sourceBlock_,
                this.name || null,
                a,
                this.value_
              ));
            }
            setEditorValue_(a, b = true) {
              this.isDirty_ = true;
              this.isBeingEdited_ && (this.htmlInput_.value = this.getEditorText_(a));
              this.setValue(a, b);
            }
            resizeEditor_() {
              finishQueuedRenders$$module$build$src$core$render_management().then(() => {
                const a = this.getSourceBlock();
                if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
                const b = getDiv$$module$build$src$core$widgetdiv(), c = this.getScaledBBox();
                b.style.width = c.right - c.left + "px";
                b.style.height = c.bottom - c.top + "px";
                const d = c.top;
                b.style.left = `${a.RTL ? c.right - b.offsetWidth : c.left}px`;
                b.style.top = `${d}px`;
              });
            }
            repositionForWindowResize() {
              let a;
              const b = (a = this.getSourceBlock()) == null ? void 0 : a.getRootBlock();
              if (!(b instanceof BlockSvg$$module$build$src$core$block_svg)) return false;
              bumpObjectIntoBounds$$module$build$src$core$bump_objects(this.workspace_, this.workspace_.getMetricsManager().getViewMetrics(true), b) || this.resizeEditor_();
              return true;
            }
            positionTextElement_(a, b) {
              const c = a * 2 + b;
              super.positionTextElement_(a + (c < MINIMUM_WIDTH$$module$build$src$core$field_input ? (MINIMUM_WIDTH$$module$build$src$core$field_input - c) / 2 : 0), b);
            }
            getText_() {
              return this.isBeingEdited_ && this.htmlInput_ ? this.htmlInput_.value : null;
            }
            getEditorText_(a) {
              return `${a}`;
            }
            getValueFromEditorText_(a) {
              return a;
            }
          };
          FieldInput$$module$build$src$core$field_input.BORDERRADIUS = 4;
          var module$build$src$core$field_input = {};
          module$build$src$core$field_input.FieldInput = FieldInput$$module$build$src$core$field_input;
          $.FieldTextInput$$module$build$src$core$field_textinput = class extends FieldInput$$module$build$src$core$field_input {
            constructor(a, b, c) {
              super(a, b, c);
            }
            initView() {
              super.initView();
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyTextInputField");
            }
            doClassValidation_(a) {
              return a === void 0 ? null : `${a}`;
            }
            static fromJson(a) {
              return new this(replaceMessageReferences$$module$build$src$core$utils$parsing(a.text), void 0, a);
            }
          };
          register$$module$build$src$core$field_registry("field_input", $.FieldTextInput$$module$build$src$core$field_textinput);
          $.FieldTextInput$$module$build$src$core$field_textinput.prototype.DEFAULT_VALUE = "";
          var module$build$src$core$field_textinput = {};
          module$build$src$core$field_textinput.FieldTextInput = $.FieldTextInput$$module$build$src$core$field_textinput;
          var BottomRow$$module$build$src$core$renderers$zelos$measurables$bottom_row = class extends BottomRow$$module$build$src$core$renderers$measurables$bottom_row {
            constructor(a) {
              super(a);
            }
            endsWithElemSpacer() {
              return false;
            }
            hasLeftSquareCorner(a) {
              return !!a.outputConnection;
            }
            hasRightSquareCorner(a) {
              return !!a.outputConnection && !a.statementInputCount && !a.nextConnection;
            }
          }, module$build$src$core$renderers$zelos$measurables$bottom_row = {};
          module$build$src$core$renderers$zelos$measurables$bottom_row.BottomRow = BottomRow$$module$build$src$core$renderers$zelos$measurables$bottom_row;
          var StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs = class extends StatementInput$$module$build$src$core$renderers$measurables$statement_input {
            constructor(a, b) {
              super(a, b);
              this.connectedBottomNextConnection = false;
              if (this.connectedBlock) {
                for (a = this.connectedBlock; b = a.getNextBlock(); ) a = b;
                a.nextConnection || (this.height = this.connectedBlockHeight, this.connectedBottomNextConnection = true);
              }
            }
          }, module$build$src$core$renderers$zelos$measurables$inputs = {};
          module$build$src$core$renderers$zelos$measurables$inputs.StatementInput = StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs;
          var RightConnectionShape$$module$build$src$core$renderers$zelos$measurables$row_elements = class extends Measurable$$module$build$src$core$renderers$measurables$base {
            constructor(a) {
              super(a);
              this.width = this.height = 0;
              this.type |= Types$$module$build$src$core$renderers$measurables$types.getType("RIGHT_CONNECTION");
            }
          }, module$build$src$core$renderers$zelos$measurables$row_elements = {};
          module$build$src$core$renderers$zelos$measurables$row_elements.RightConnectionShape = RightConnectionShape$$module$build$src$core$renderers$zelos$measurables$row_elements;
          var TopRow$$module$build$src$core$renderers$zelos$measurables$top_row = class extends TopRow$$module$build$src$core$renderers$measurables$top_row {
            constructor(a) {
              super(a);
            }
            endsWithElemSpacer() {
              return false;
            }
            hasLeftSquareCorner(a) {
              const b = (a.hat ? a.hat === "cap" : this.constants_.ADD_START_HATS) && !a.outputConnection && !a.previousConnection;
              return !!a.outputConnection || b;
            }
            hasRightSquareCorner(a) {
              return !!a.outputConnection && !a.statementInputCount && !a.nextConnection;
            }
          }, module$build$src$core$renderers$zelos$measurables$top_row = {};
          module$build$src$core$renderers$zelos$measurables$top_row.TopRow = TopRow$$module$build$src$core$renderers$zelos$measurables$top_row;
          var RenderInfo$$module$build$src$core$renderers$zelos$info = class extends RenderInfo$$module$build$src$core$renderers$common$info {
            constructor(a, b) {
              super(a, b);
              this.isInline = true;
              this.renderer_ = a;
              this.constants_ = this.renderer_.getConstants();
              this.topRow = new TopRow$$module$build$src$core$renderers$zelos$measurables$top_row(this.constants_);
              this.bottomRow = new BottomRow$$module$build$src$core$renderers$zelos$measurables$bottom_row(this.constants_);
              this.isMultiRow = !b.getInputsInline() || b.isCollapsed();
              this.hasStatementInput = b.statementInputCount > 0;
              this.rightSide = this.outputConnection ? new RightConnectionShape$$module$build$src$core$renderers$zelos$measurables$row_elements(this.constants_) : null;
              this.rightAlignedDummyInputs = /* @__PURE__ */ new WeakMap();
            }
            getRenderer() {
              return this.renderer_;
            }
            measure() {
              this.createRows_();
              this.addElemSpacing_();
              this.addRowSpacing_();
              this.adjustXPosition_();
              this.computeBounds_();
              this.alignRowElements_();
              this.finalize_();
            }
            shouldStartNewRow_(a, b) {
              return b ? b instanceof EndRowInput$$module$build$src$core$inputs$end_row_input || a instanceof StatementInput$$module$build$src$core$inputs$statement_input || b instanceof StatementInput$$module$build$src$core$inputs$statement_input ? true : a instanceof $.ValueInput$$module$build$src$core$inputs$value_input || a instanceof DummyInput$$module$build$src$core$inputs$dummy_input || a instanceof EndRowInput$$module$build$src$core$inputs$end_row_input ? !this.isInline || this.isMultiRow : false : false;
            }
            getDesiredRowWidth_(a) {
              return a.hasStatement ? this.width - this.startX - (this.constants_.INSIDE_CORNERS.rightWidth || 0) : super.getDesiredRowWidth_(a);
            }
            getInRowSpacing_(a, b) {
              return a && b || !this.outputConnection || !this.outputConnection.isDynamicShape || this.hasStatementInput || this.bottomRow.hasNextConnection ? !a && b && Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : a && Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) && b && (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b) || Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) ? b.notchOffset - this.constants_.CORNER_RADIUS : a && Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(a) && b && Types$$module$build$src$core$renderers$measurables$types.isHat(b) || a && Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : this.constants_.NO_PADDING;
            }
            getSpacerRowHeight_(a, b) {
              if (Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) && Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b)) return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;
              const c = Types$$module$build$src$core$renderers$measurables$types.isInputRow(a) && a.hasStatement, d = Types$$module$build$src$core$renderers$measurables$types.isInputRow(b) && b.hasStatement;
              return d || c ? (a = Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.INSIDE_CORNERS.rightHeight || 0), d && c ? Math.max(a, this.constants_.DUMMY_INPUT_MIN_HEIGHT) : a) : Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) ? a.hasPreviousConnection || this.outputConnection && !this.hasStatementInput ? this.constants_.NO_PADDING : Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b) ? this.outputConnection ? !b.hasNextConnection && this.hasStatementInput ? Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : this.constants_.NO_PADDING : Math.max(this.topRow.minHeight, Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.CORNER_RADIUS)) - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING;
            }
            getSpacerRowWidth_(a, b) {
              const c = this.width - this.startX;
              return Types$$module$build$src$core$renderers$measurables$types.isInputRow(a) && a.hasStatement || Types$$module$build$src$core$renderers$measurables$types.isInputRow(b) && b.hasStatement ? Math.max(c, this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH) : c;
            }
            getElemCenterline_(a, b) {
              if (a.hasStatement && !Types$$module$build$src$core$renderers$measurables$types.isSpacer(b) && !Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b)) return a.yPos + this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT / 2;
              if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b)) {
                const c = b.connectedBlock;
                if (c && c.outputConnection && c.nextConnection) return a.yPos + c.height / 2;
              }
              return super.getElemCenterline_(a, b);
            }
            addInput_(a, b) {
              if ((a instanceof DummyInput$$module$build$src$core$inputs$dummy_input || a instanceof EndRowInput$$module$build$src$core$inputs$end_row_input) && b.hasDummyInput && b.align === $.Align$$module$build$src$core$inputs$align.LEFT && a.align === $.Align$$module$build$src$core$inputs$align.RIGHT) this.rightAlignedDummyInputs.set(
                b,
                a
              );
              else if (a instanceof StatementInput$$module$build$src$core$inputs$statement_input) {
                b.elements.push(new StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs(this.constants_, a));
                b.hasStatement = true;
                b.align === null && (b.align = a.align);
                return;
              }
              super.addInput_(a, b);
            }
            addAlignmentPadding_(a, b) {
              if (this.rightAlignedDummyInputs.get(a)) {
                let c;
                for (let d = 0; d < a.elements.length; d++) {
                  const e = a.elements[d];
                  Types$$module$build$src$core$renderers$measurables$types.isSpacer(e) && (c = e);
                  if (Types$$module$build$src$core$renderers$measurables$types.isField(e) && e.parentInput === this.rightAlignedDummyInputs.get(a)) break;
                }
                if (c) {
                  c.width += b;
                  a.width += b;
                  return;
                }
              }
              super.addAlignmentPadding_(a, b);
            }
            adjustXPosition_() {
              const a = this.constants_.NOTCH_OFFSET_LEFT + this.constants_.NOTCH_WIDTH;
              let b = a;
              for (let e = 2; e < this.rows.length - 1; e += 2) {
                var c = this.rows[e - 1];
                const f = this.rows[e];
                var d = this.rows[e + 1];
                c = e === 2 ? !!this.topRow.hasPreviousConnection : !!c.followsStatement;
                d = e + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!d.precedesStatement;
                if (Types$$module$build$src$core$renderers$measurables$types.isInputRow(f) && f.hasStatement) {
                  f.measure();
                  let g, h;
                  b = f.width - ((h = (g = f.getLastInput()) == null ? void 0 : g.width) != null ? h : 0) + a;
                } else if (c && (e === 2 || d) && Types$$module$build$src$core$renderers$measurables$types.isInputRow(f) && !f.hasStatement) {
                  d = f.xPos;
                  c = null;
                  for (let g = 0; g < f.elements.length; g++) {
                    const h = f.elements[g];
                    Types$$module$build$src$core$renderers$measurables$types.isSpacer(h) && (c = h);
                    !(c && (Types$$module$build$src$core$renderers$measurables$types.isField(h) || Types$$module$build$src$core$renderers$measurables$types.isInput(h)) && d < b) || Types$$module$build$src$core$renderers$measurables$types.isField(h) && (h.field instanceof FieldLabel$$module$build$src$core$field_label || h.field instanceof FieldImage$$module$build$src$core$field_image) || (c.width += b - d);
                    d += h.width;
                  }
                }
              }
            }
            finalizeOutputConnection_() {
              if (this.outputConnection && this.outputConnection.isDynamicShape) {
                var a = this.outputConnection.shape;
                if ("isDynamic" in a && a.isDynamic) {
                  var b = 0;
                  for (var c = 0; c < this.rows.length; c++) {
                    const d = this.rows[c];
                    d.yPos = b;
                    b += d.height;
                  }
                  this.height = b;
                  c = this.bottomRow.hasNextConnection ? this.height - this.bottomRow.descenderHeight : this.height;
                  b = a.height(c);
                  c = a.width(c);
                  this.outputConnection.height = b;
                  this.outputConnection.width = c;
                  this.outputConnection.startX = c;
                  this.outputConnection.connectionOffsetY = a.connectionOffsetY(b);
                  this.outputConnection.connectionOffsetX = a.connectionOffsetX(c);
                  a = 0;
                  this.hasStatementInput || this.bottomRow.hasNextConnection || (a = c, this.rightSide.height = b, this.rightSide.width = a, this.rightSide.centerline = b / 2, this.rightSide.xPos = this.width + a);
                  this.startX = c;
                  this.width += c + a;
                  this.widthWithChildren += c + a;
                }
              }
            }
            finalizeHorizontalAlignment_() {
              if (this.outputConnection && !this.hasStatementInput && !this.bottomRow.hasNextConnection) {
                var a = 0;
                for (var b = 0; b < this.rows.length; b++) {
                  var c = this.rows[b];
                  if (!Types$$module$build$src$core$renderers$measurables$types.isInputRow(c)) continue;
                  a = c.elements[c.elements.length - 2];
                  let d = this.getNegativeSpacing_(c.elements[1]), e = this.getNegativeSpacing_(a);
                  a = d + e;
                  const f = this.constants_.MIN_BLOCK_WIDTH + this.outputConnection.width * 2;
                  this.width - a < f && (a = this.width - f, d = a / 2, e = a / 2);
                  c.elements.unshift(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, -d));
                  c.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, -e));
                }
                if (a) for (this.width -= a, this.widthWithChildren -= a, this.rightSide.xPos -= a, b = 0; b < this.rows.length; b++) c = this.rows[b], Types$$module$build$src$core$renderers$measurables$types.isTopOrBottomRow(c) && (c.elements[1].width -= a), c.width -= a, c.widthWithConnectedBlocks -= a;
              }
            }
            getNegativeSpacing_(a) {
              if (!a || !this.outputConnection) return 0;
              const b = this.outputConnection.width;
              var c = this.outputConnection.shape.type;
              const d = this.constants_;
              if (this.inputRows.length > 1) switch (c) {
                case d.SHAPES.ROUND:
                  return c = this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH, c = this.height / 2 > c ? c : this.height / 2, b - c * (1 - Math.sin(Math.acos((c - this.constants_.SMALL_PADDING) / c)));
                default:
                  return 0;
              }
              if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a)) {
                const e = a.connectedBlock;
                a = e ? e.pathObject.outputShapeType : a.shape.type;
                return a == null || e && e.outputConnection && (e.statementInputCount || e.nextConnection) || c === d.SHAPES.HEXAGONAL && c !== a ? 0 : b - this.constants_.SHAPE_IN_SHAPE_PADDING[c][a];
              }
              return Types$$module$build$src$core$renderers$measurables$types.isField(a) ? c === d.SHAPES.ROUND && a.field instanceof $.FieldTextInput$$module$build$src$core$field_textinput ? b - 2.75 * d.GRID_UNIT : b - this.constants_.SHAPE_IN_SHAPE_PADDING[c][0] : Types$$module$build$src$core$renderers$measurables$types.isIcon(a) ? this.constants_.SMALL_PADDING : 0;
            }
            finalizeVerticalAlignment_() {
              if (!this.outputConnection) for (let d = 2; d < this.rows.length - 1; d += 2) {
                const e = this.rows[d - 1], f = this.rows[d], g = this.rows[d + 1];
                var a = d === 2, b = d + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!g.precedesStatement;
                if (a ? this.topRow.hasPreviousConnection : e.followsStatement) {
                  var c = f.elements[1];
                  c = f.elements.length === 3 && c instanceof Field$$module$build$src$core$renderers$measurables$field && (c.field instanceof FieldLabel$$module$build$src$core$field_label || c.field instanceof FieldImage$$module$build$src$core$field_image);
                  if (!a && c) e.height -= this.constants_.SMALL_PADDING, g.height -= this.constants_.SMALL_PADDING, f.height -= this.constants_.MEDIUM_PADDING;
                  else if (!a && !b) e.height += this.constants_.SMALL_PADDING;
                  else if (b) {
                    a = false;
                    for (b = 0; b < f.elements.length; b++) if (c = f.elements[b], Types$$module$build$src$core$renderers$measurables$types.isInlineInput(c) && c.connectedBlock && !c.connectedBlock.isShadow() && c.connectedBlock.getHeightWidth().height >= 40) {
                      a = true;
                      break;
                    }
                    a && (e.height -= this.constants_.SMALL_PADDING, g.height -= this.constants_.SMALL_PADDING);
                  }
                }
              }
            }
            finalize_() {
              this.finalizeOutputConnection_();
              this.finalizeHorizontalAlignment_();
              this.finalizeVerticalAlignment_();
              super.finalize_();
              this.rightSide && (this.widthWithChildren += this.rightSide.width);
            }
          }, module$build$src$core$renderers$zelos$info = {};
          module$build$src$core$renderers$zelos$info.RenderInfo = RenderInfo$$module$build$src$core$renderers$zelos$info;
          var PathObject$$module$build$src$core$renderers$zelos$path_object = class extends PathObject$$module$build$src$core$renderers$common$path_object {
            constructor(a, b, c) {
              super(a, b, c);
              this.svgPathSelected = null;
              this.outlines = /* @__PURE__ */ new Map();
              this.remainingOutlines = /* @__PURE__ */ new Set();
              this.outputShapeType = null;
              this.constants = c;
            }
            setPath(a) {
              super.setPath(a);
              this.svgPathSelected && this.svgPathSelected.setAttribute("d", a);
            }
            applyColour(a) {
              super.applyColour(a);
              const b = a.getParent();
              a.isShadow() && b && this.svgPath.setAttribute("stroke", b.getColourTertiary());
              for (const c of this.outlines.values()) c.setAttribute("fill", this.style.colourTertiary);
            }
            flipRTL() {
              super.flipRTL();
              for (const a of this.outlines.values()) a.setAttribute("transform", "scale(-1 1)");
            }
            updateSelected(a) {
              this.setClass_("blocklySelected", a);
              a ? this.svgPathSelected || (this.svgPathSelected = this.svgPath.cloneNode(true), this.svgPathSelected.classList.add("blocklyPathSelected"), removeClass$$module$build$src$core$utils$dom(this.svgPathSelected, FocusManager$$module$build$src$core$focus_manager.ACTIVE_FOCUS_NODE_CSS_CLASS_NAME), removeClass$$module$build$src$core$utils$dom(this.svgPathSelected, FocusManager$$module$build$src$core$focus_manager.PASSIVE_FOCUS_NODE_CSS_CLASS_NAME), this.svgPathSelected.removeAttribute("tabindex"), this.svgPathSelected.removeAttribute("id"), this.svgRoot.appendChild(this.svgPathSelected)) : this.svgPathSelected && (this.svgRoot.removeChild(this.svgPathSelected), this.svgPathSelected = null);
            }
            updateReplacementFade(a) {
              this.setClass_("blocklyReplaceable", a);
            }
            updateShapeForInputHighlight(a, b) {
              a = a.getParentInput().name;
              (a = this.getOutlinePath(a)) && (b ? a.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : a.removeAttribute("filter"));
            }
            beginDrawing() {
              this.remainingOutlines.clear();
              for (const a of this.outlines.keys()) this.remainingOutlines.add(a);
            }
            endDrawing() {
              if (this.remainingOutlines.size) for (const a of this.remainingOutlines) this.removeOutlinePath(a);
              this.remainingOutlines.clear();
            }
            setOutlinePath(a, b) {
              a = this.getOutlinePath(a);
              a.setAttribute("d", b);
              a.setAttribute("fill", this.style.colourTertiary);
            }
            getOutlinePath(a) {
              this.outlines.has(a) || this.outlines.set(a, createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyOutlinePath", d: "" }, this.svgRoot));
              this.remainingOutlines.delete(a);
              return this.outlines.get(a);
            }
            removeOutlinePath(a) {
              let b, c;
              (b = this.outlines.get(a)) == null || (c = b.parentNode) == null || c.removeChild(this.outlines.get(a));
              this.outlines.delete(a);
            }
          }, module$build$src$core$renderers$zelos$path_object = {};
          module$build$src$core$renderers$zelos$path_object.PathObject = PathObject$$module$build$src$core$renderers$zelos$path_object;
          var Renderer$$module$build$src$core$renderers$zelos$renderer = class extends Renderer$$module$build$src$core$renderers$common$renderer {
            constructor(a) {
              super(a);
            }
            makeConstants_() {
              return new ConstantProvider$$module$build$src$core$renderers$zelos$constants();
            }
            makeRenderInfo_(a) {
              return new RenderInfo$$module$build$src$core$renderers$zelos$info(this, a);
            }
            makeDrawer_(a, b) {
              return new Drawer$$module$build$src$core$renderers$zelos$drawer(a, b);
            }
            makePathObject(a, b) {
              return new PathObject$$module$build$src$core$renderers$zelos$path_object(
                a,
                b,
                this.getConstants()
              );
            }
            getConstants() {
              return this.constants_;
            }
          };
          register$$module$build$src$core$renderers$common$block_rendering("zelos", Renderer$$module$build$src$core$renderers$zelos$renderer);
          var module$build$src$core$renderers$zelos$renderer = {};
          module$build$src$core$renderers$zelos$renderer.Renderer = Renderer$$module$build$src$core$renderers$zelos$renderer;
          var InsertionMarkerPreviewer$$module$build$src$core$insertion_marker_previewer = class {
            constructor(a) {
              this.staticConn = this.draggedConn = this.markerConn = this.fadedBlock = null;
              this.workspace = a.workspace;
            }
            previewReplacement(a, b, c) {
              $.disable$$module$build$src$core$events$utils();
              try {
                this.hidePreview(), this.fadedBlock = c, c.fadeForReplacement(true), this.workspace.getRenderer().shouldHighlightConnection(b) && (b.highlight(), this.staticConn = b);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
            }
            previewConnection(a, b) {
              if (a !== this.draggedConn || b !== this.staticConn) {
                $.disable$$module$build$src$core$events$utils();
                try {
                  this.hidePreview(), this.shouldUseMarkerPreview(a, b) && (this.markerConn = this.previewMarker(a, b)), this.workspace.getRenderer().shouldHighlightConnection(b) && b.highlight(), this.draggedConn = a, this.staticConn = b;
                } finally {
                  $.enable$$module$build$src$core$events$utils();
                }
              }
            }
            shouldUseMarkerPreview(a, b) {
              return b.type === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT || b.type === ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT || !(this.workspace.getRenderer() instanceof Renderer$$module$build$src$core$renderers$zelos$renderer);
            }
            previewMarker(a, b) {
              const c = a.getSourceBlock(), d = this.createInsertionMarker(c), e = this.getMatchingConnection(c, d, a);
              if (!e) return null;
              d.queueRender();
              triggerQueuedRenders$$module$build$src$core$render_management();
              e.connect(b);
              const f = { x: b.x - e.x, y: b.y - e.y }, g = e.getOffsetInBlock().clone();
              finishQueuedRenders$$module$build$src$core$render_management().then(() => {
                if (!d.isDeadOrDying()) {
                  $.disable$$module$build$src$core$events$utils();
                  try {
                    d == null || d.positionNearConnection(e, f, g), d == null || d.getSvgRoot().setAttribute("visibility", "visible");
                  } finally {
                    $.enable$$module$build$src$core$events$utils();
                  }
                }
              });
              return e;
            }
            serializeBlockToInsertionMarker(a) {
              const b = save$$module$build$src$core$serialization$blocks(a, { addCoordinates: false, addInputBlocks: false, addNextBlocks: false, doFullSerialization: false });
              if (!b) throw Error(`Failed to serialize source block. ${a.toDevString()}`);
              return b;
            }
            createInsertionMarker(a) {
              a = this.serializeBlockToInsertionMarker(a);
              a = append$$module$build$src$core$serialization$blocks(
                a,
                this.workspace
              );
              for (const b of a.getDescendants(false)) b.setInsertionMarker(true);
              a.initSvg();
              a.getSvgRoot().setAttribute("visibility", "hidden");
              return a;
            }
            getMatchingConnection(a, b, c) {
              a = a.getConnections_(true);
              b = b.getConnections_(true);
              if (a.length !== b.length) return null;
              for (let d = 0; d < a.length; d++) if (a[d] === c) return b[d];
              return null;
            }
            hidePreview() {
              $.disable$$module$build$src$core$events$utils();
              try {
                this.staticConn && (this.staticConn.unhighlight(), this.staticConn = null), this.fadedBlock && (this.fadedBlock.fadeForReplacement(false), this.fadedBlock = null), this.markerConn && (this.hideInsertionMarker(this.markerConn), this.draggedConn = this.markerConn = null);
              } finally {
                $.enable$$module$build$src$core$events$utils();
              }
            }
            hideInsertionMarker(a) {
              const b = a.getSourceBlock(), c = b.outputConnection;
              let d;
              if (((d = b.previousConnection) == null ? 0 : d.targetConnection) || (c == null ? 0 : c.targetConnection)) b.unplug(true);
              else {
                let e;
                (e = a.targetBlock()) == null || e.unplug(false);
              }
              b.dispose();
            }
            dispose() {
              this.hidePreview();
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.CONNECTION_PREVIEWER, DEFAULT$$module$build$src$core$registry, InsertionMarkerPreviewer$$module$build$src$core$insertion_marker_previewer);
          var module$build$src$core$insertion_marker_previewer = {};
          module$build$src$core$insertion_marker_previewer.InsertionMarkerPreviewer = InsertionMarkerPreviewer$$module$build$src$core$insertion_marker_previewer;
          var module$build$src$core$inputs = {};
          module$build$src$core$inputs.Align = $.Align$$module$build$src$core$inputs$align;
          module$build$src$core$inputs.DummyInput = DummyInput$$module$build$src$core$inputs$dummy_input;
          module$build$src$core$inputs.EndRowInput = EndRowInput$$module$build$src$core$inputs$end_row_input;
          module$build$src$core$inputs.Input = Input$$module$build$src$core$inputs$input;
          module$build$src$core$inputs.StatementInput = StatementInput$$module$build$src$core$inputs$statement_input;
          module$build$src$core$inputs.ValueInput = $.ValueInput$$module$build$src$core$inputs$value_input;
          module$build$src$core$inputs.inputTypes = $.inputTypes$$module$build$src$core$inputs$input_types;
          var documentEventsBound$$module$build$src$core$inject = false, module$build$src$core$inject = {};
          module$build$src$core$inject.inject = inject$$module$build$src$core$inject;
          var module$build$src$core$generator;
          $.CodeGenerator$$module$build$src$core$generator = class {
            constructor(a) {
              this.forBlock = /* @__PURE__ */ Object.create(null);
              this.FUNCTION_NAME_PLACEHOLDER_ = "{leCUI8hutHZI4480Dc}";
              this.STATEMENT_SUFFIX = this.STATEMENT_PREFIX = this.INFINITE_LOOP_TRAP = null;
              this.INDENT = "  ";
              this.COMMENT_WRAP = 60;
              this.ORDER_OVERRIDES = [];
              this.isInitialized = null;
              this.RESERVED_WORDS_ = "";
              this.definitions_ = /* @__PURE__ */ Object.create(null);
              this.functionNames_ = /* @__PURE__ */ Object.create(null);
              this.nameDB_ = void 0;
              this.name_ = a;
              this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ = new RegExp(
                this.FUNCTION_NAME_PLACEHOLDER_,
                "g"
              );
            }
            workspaceToCode(a) {
              a || (console.warn("No workspace specified in workspaceToCode call.  Guessing."), a = getMainWorkspace$$module$build$src$core$common());
              var b = [];
              this.init(a);
              a = a.getTopBlocks(true);
              for (let c = 0, d; d = a[c]; c++) {
                let e = this.blockToCode(d);
                Array.isArray(e) && (e = e[0]);
                e && (d.outputConnection && (e = this.scrubNakedValue(e), this.STATEMENT_PREFIX && !d.suppressPrefixSuffix && (e = this.injectId(this.STATEMENT_PREFIX, d) + e), this.STATEMENT_SUFFIX && !d.suppressPrefixSuffix && (e += this.injectId(
                  this.STATEMENT_SUFFIX,
                  d
                ))), b.push(e));
              }
              b = b.join("\n");
              b = this.finish(b);
              b = b.replace(/^\s+\n/, "");
              b = b.replace(/\n\s+$/, "\n");
              return b = b.replace(/[ \t]+\n/g, "\n");
            }
            prefixLines(a, b) {
              return b + a.replace(/(?!\n$)\n/g, "\n" + b);
            }
            allNestedComments(a) {
              const b = [];
              a = a.getDescendants(true);
              for (let c = 0; c < a.length; c++) {
                const d = a[c].getCommentText();
                d && b.push(d);
              }
              b.length && b.push("");
              return b.join("\n");
            }
            blockToCode(a, b) {
              this.isInitialized === false && console.warn("CodeGenerator init was not called before blockToCode was called.");
              if (!a) return "";
              if (!a.isEnabled()) return b ? "" : this.blockToCode(a.getNextBlock());
              if (a.isInsertionMarker()) return b ? "" : this.blockToCode(a.getChildren(false)[0]);
              var c = this.forBlock[a.type];
              if (typeof c !== "function") throw Error(`${this.name_} generator does not know how to generate code for block type "${a.type}".`);
              c = c.call(a, a, this);
              if (Array.isArray(c)) {
                if (!a.outputConnection) throw TypeError("Expecting string from statement block: " + a.type);
                return [this.scrub_(a, c[0], b), c[1]];
              }
              if (typeof c === "string") return this.STATEMENT_PREFIX && !a.suppressPrefixSuffix && (c = this.injectId(this.STATEMENT_PREFIX, a) + c), this.STATEMENT_SUFFIX && !a.suppressPrefixSuffix && (c += this.injectId(this.STATEMENT_SUFFIX, a)), this.scrub_(a, c, b);
              if (c === null) return "";
              throw SyntaxError("Invalid code generated: " + c);
            }
            valueToCode(a, b, c) {
              if (isNaN(c)) throw TypeError("Expecting valid order from block: " + a.type);
              var d = a.getInputTargetBlock(b);
              if (!d && !a.getInput(b)) throw ReferenceError(`Input "${b}" doesn't exist on "${a.type}"`);
              if (!d) return "";
              b = this.blockToCode(d);
              if (b === "") return "";
              if (!Array.isArray(b)) throw TypeError(`Expecting tuple from value block: ${d.type} See developers.google.com/blockly/guides/create-custom-blocks/generating-code for more information`);
              a = b[0];
              b = b[1];
              if (isNaN(b)) throw TypeError("Expecting valid order from value block: " + d.type);
              if (!a) return "";
              d = false;
              var e = Math.floor(c);
              const f = Math.floor(b);
              if (e <= f && (e !== f || e !== 0 && e !== 99)) {
                for (d = true, e = 0; e < this.ORDER_OVERRIDES.length; e++) if (this.ORDER_OVERRIDES[e][0] === c && this.ORDER_OVERRIDES[e][1] === b) {
                  d = false;
                  break;
                }
              }
              d && (a = "(" + a + ")");
              return a;
            }
            statementToCode(a, b) {
              const c = a.getInputTargetBlock(b);
              if (!c && !a.getInput(b)) throw ReferenceError(`Input "${b}" doesn't exist on "${a.type}"`);
              a = this.blockToCode(c);
              if (typeof a !== "string") throw TypeError("Expecting code from statement block: " + (c && c.type));
              a && (a = this.prefixLines(a, this.INDENT));
              return a;
            }
            addLoopTrap(a, b) {
              this.INFINITE_LOOP_TRAP && (a = this.prefixLines(this.injectId(this.INFINITE_LOOP_TRAP, b), this.INDENT) + a);
              this.STATEMENT_SUFFIX && !b.suppressPrefixSuffix && (a = this.prefixLines(this.injectId(this.STATEMENT_SUFFIX, b), this.INDENT) + a);
              this.STATEMENT_PREFIX && !b.suppressPrefixSuffix && (a += this.prefixLines(this.injectId(
                this.STATEMENT_PREFIX,
                b
              ), this.INDENT));
              return a;
            }
            injectId(a, b) {
              b = b.id.replace(/\$/g, "$$$$");
              return a.replace(/%1/g, "'" + b + "'");
            }
            addReservedWords(a) {
              this.RESERVED_WORDS_ += a + ",";
            }
            provideFunction_(a, b) {
              if (!this.definitions_[a]) {
                const c = this.nameDB_.getDistinctName(a, $.NameType$$module$build$src$core$names.PROCEDURE);
                this.functionNames_[a] = c;
                Array.isArray(b) && (b = b.join("\n"));
                b = b.trim().replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, c);
                let d;
                for (; d !== b; ) d = b, b = b.replace(/^(( {2})*) {2}/gm, "$1\0");
                b = b.replace(/\0/g, this.INDENT);
                this.definitions_[a] = b;
              }
              return this.functionNames_[a];
            }
            getVariableName(a) {
              return this.getName(a, $.NameType$$module$build$src$core$names.VARIABLE);
            }
            getProcedureName(a) {
              return this.getName(a, $.NameType$$module$build$src$core$names.PROCEDURE);
            }
            getName(a, b) {
              if (!this.nameDB_) throw Error("Name database is not defined. You must initialize `nameDB_` in your generator class and call `init` first.");
              return this.nameDB_.getName(a, b);
            }
            init(a) {
              this.definitions_ = /* @__PURE__ */ Object.create(null);
              this.functionNames_ = /* @__PURE__ */ Object.create(null);
            }
            scrub_(a, b, c) {
              return b;
            }
            finish(a) {
              this.definitions_ = /* @__PURE__ */ Object.create(null);
              this.functionNames_ = /* @__PURE__ */ Object.create(null);
              return a;
            }
            scrubNakedValue(a) {
              return a;
            }
          };
          module$build$src$core$generator = {};
          module$build$src$core$generator.CodeGenerator = $.CodeGenerator$$module$build$src$core$generator;
          var VerticalFlyout$$module$build$src$core$flyout_vertical = class extends Flyout$$module$build$src$core$flyout_base {
            constructor(a) {
              super(a);
            }
            setMetrics_(a) {
              if (this.isVisible()) {
                var b = this.workspace_.getMetricsManager(), c = b.getScrollMetrics(), d = b.getViewMetrics();
                b = b.getAbsoluteMetrics();
                typeof a.y === "number" && (this.workspace_.scrollY = -(c.top + (c.height - d.height) * a.y));
                this.workspace_.translate(this.workspace_.scrollX + b.left, this.workspace_.scrollY + b.top);
              }
            }
            getX() {
              if (!this.isVisible()) return 0;
              var a = this.targetWorkspace.getMetricsManager();
              const b = a.getAbsoluteMetrics(), c = a.getViewMetrics();
              a = a.getToolboxMetrics();
              return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.LEFT ? a.width : c.width - this.getWidth() : this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.LEFT ? 0 : c.width : this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.LEFT ? 0 : c.width + b.left - this.getWidth();
            }
            getY() {
              return 0;
            }
            position() {
              if (this.isVisible() && this.targetWorkspace.isVisible()) {
                var a = this.targetWorkspace.getMetricsManager().getViewMetrics();
                this.height_ = a.height;
                var b = this.getWidth() - this.CORNER_RADIUS;
                this.setBackgroundPath(b, a.height - 2 * this.CORNER_RADIUS);
                a = this.getX();
                b = this.getY();
                this.positionAt_(this.getWidth(), this.getHeight(), a, b);
              }
            }
            setBackgroundPath(a, b) {
              const c = this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.RIGHT;
              var d = a + this.CORNER_RADIUS;
              d = ["M " + (c ? d : 0) + ",0"];
              d.push("h", c ? -a : a);
              d.push(
                "a",
                this.CORNER_RADIUS,
                this.CORNER_RADIUS,
                0,
                0,
                c ? 0 : 1,
                c ? -this.CORNER_RADIUS : this.CORNER_RADIUS,
                this.CORNER_RADIUS
              );
              d.push("v", Math.max(0, b));
              d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, c ? 0 : 1, c ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS);
              d.push("h", c ? a : -a);
              d.push("z");
              this.svgBackground_.setAttribute("d", d.join(" "));
            }
            scrollToStart() {
              let a;
              (a = this.workspace_.scrollbar) == null || a.setY(0);
            }
            wheel_(a) {
              var b = getScrollDeltaPixels$$module$build$src$core$browser_events(a);
              if (b.y) {
                const c = this.workspace_.getMetricsManager(), d = c.getScrollMetrics();
                b = c.getViewMetrics().top - d.top + b.y;
                let e;
                (e = this.workspace_.scrollbar) == null || e.setY(b);
                hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv(this.workspace_);
                hideWithoutAnimation$$module$build$src$core$dropdowndiv();
              }
              a.preventDefault();
              a.stopPropagation();
            }
            layout_(a) {
              this.workspace_.scale = this.targetWorkspace.scale;
              var b = this.MARGIN;
              const c = this.RTL ? b : b + this.tabWidth_;
              for (const d of a) d.getElement().moveBy(c, b), b += d.getElement().getBoundingRectangle().getHeight();
            }
            isDragTowardWorkspace(a) {
              a = Math.atan2(a.y, a.x) / Math.PI * 180;
              const b = this.dragAngleRange_;
              return a < b && a > -b || a < -180 + b || a > 180 - b ? true : false;
            }
            getClientRect() {
              if (!this.svgGroup_ || this.autoClose || !this.isVisible()) return null;
              const a = this.svgGroup_.getBoundingClientRect(), b = a.left;
              return this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.LEFT ? new Rect$$module$build$src$core$utils$rect(-1e9, 1e9, -1e9, b + a.width) : new Rect$$module$build$src$core$utils$rect(-1e9, 1e9, b, 1e9);
            }
            reflowInternal_() {
              this.workspace_.scale = this.getFlyoutScale();
              let a = this.getContents().reduce((b, c) => Math.max(b, c.getElement().getBoundingRectangle().getWidth()), 0);
              a += this.MARGIN * 1.5 + this.tabWidth_;
              a *= this.workspace_.scale;
              a += Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness;
              if (this.getWidth() !== a) {
                if (this.RTL) for (const b of this.getContents()) {
                  const c = b.getElement().getBoundingRectangle().left, d = a / this.workspace_.scale - b.getElement().getBoundingRectangle().getWidth() - this.MARGIN - this.tabWidth_;
                  b.getElement().moveBy(d - c, 0);
                }
                this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== Position$$module$build$src$core$utils$toolbox.LEFT || this.targetWorkspace.translate(this.targetWorkspace.scrollX + a, this.targetWorkspace.scrollY);
                this.width_ = a;
                this.position();
                this.targetWorkspace.resizeContents();
                this.targetWorkspace.recordDragTargets();
              }
            }
          };
          VerticalFlyout$$module$build$src$core$flyout_vertical.registryName = "verticalFlyout";
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_VERTICAL_TOOLBOX, DEFAULT$$module$build$src$core$registry, VerticalFlyout$$module$build$src$core$flyout_vertical);
          var module$build$src$core$flyout_vertical = {};
          module$build$src$core$flyout_vertical.VerticalFlyout = VerticalFlyout$$module$build$src$core$flyout_vertical;
          var HorizontalFlyout$$module$build$src$core$flyout_horizontal = class extends Flyout$$module$build$src$core$flyout_base {
            constructor(a) {
              super(a);
              this.horizontalLayout = true;
            }
            setMetrics_(a) {
              if (this.isVisible()) {
                var b = this.workspace_.getMetricsManager(), c = b.getScrollMetrics(), d = b.getViewMetrics();
                b = b.getAbsoluteMetrics();
                typeof a.x === "number" && (this.workspace_.scrollX = -(c.left + (c.width - d.width) * a.x));
                this.workspace_.translate(this.workspace_.scrollX + b.left, this.workspace_.scrollY + b.top);
              }
            }
            getX() {
              return 0;
            }
            getY() {
              if (!this.isVisible()) return 0;
              var a = this.targetWorkspace.getMetricsManager();
              const b = a.getAbsoluteMetrics(), c = a.getViewMetrics();
              a = a.getToolboxMetrics();
              const d = this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.TOP;
              return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? d ? a.height : c.height - this.getHeight() : d ? 0 : c.height : d ? 0 : c.height + b.top - this.getHeight();
            }
            position() {
              if (this.isVisible() && this.targetWorkspace.isVisible()) {
                var a = this.targetWorkspace.getMetricsManager().getViewMetrics();
                this.width_ = a.width;
                a = a.width - 2 * this.CORNER_RADIUS;
                var b = this.getHeight() - this.CORNER_RADIUS;
                this.setBackgroundPath(a, b);
                a = this.getX();
                b = this.getY();
                this.positionAt_(this.getWidth(), this.getHeight(), a, b);
              }
            }
            setBackgroundPath(a, b) {
              const c = this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.TOP, d = ["M 0," + (c ? 0 : this.CORNER_RADIUS)];
              c ? (d.push("h", a + 2 * this.CORNER_RADIUS), d.push("v", b), d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, this.CORNER_RADIUS), d.push(
                "h",
                -a
              ), d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, -this.CORNER_RADIUS)) : (d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, -this.CORNER_RADIUS), d.push("h", a), d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, this.CORNER_RADIUS), d.push("v", b), d.push("h", -a - 2 * this.CORNER_RADIUS));
              d.push("z");
              this.svgBackground_.setAttribute("d", d.join(" "));
            }
            scrollToStart() {
              let a;
              (a = this.workspace_.scrollbar) == null || a.setX(this.RTL ? Infinity : 0);
            }
            wheel_(a) {
              var b = getScrollDeltaPixels$$module$build$src$core$browser_events(a);
              if (b = b.x || b.y) {
                const c = this.workspace_.getMetricsManager(), d = c.getScrollMetrics();
                b = c.getViewMetrics().left - d.left + b;
                let e;
                (e = this.workspace_.scrollbar) == null || e.setX(b);
                hideIfOwnerIsInWorkspace$$module$build$src$core$widgetdiv(this.workspace_);
                hideWithoutAnimation$$module$build$src$core$dropdowndiv();
              }
              a.preventDefault();
              a.stopPropagation();
            }
            layout_(a) {
              this.workspace_.scale = this.targetWorkspace.scale;
              const b = this.MARGIN;
              let c = b + this.tabWidth_;
              this.RTL && (a = a.reverse());
              for (const d of a) a = d.getElement().getBoundingRectangle(), a = this.RTL ? c + a.getWidth() : c, d.getElement().moveBy(a, b), c += d.getElement().getBoundingRectangle().getWidth();
            }
            isDragTowardWorkspace(a) {
              a = Math.atan2(a.y, a.x) / Math.PI * 180;
              const b = this.dragAngleRange_;
              return a < 90 + b && a > 90 - b || a > -90 - b && a < -90 + b ? true : false;
            }
            getClientRect() {
              if (!this.svgGroup_ || this.autoClose || !this.isVisible()) return null;
              const a = this.svgGroup_.getBoundingClientRect(), b = a.top;
              return this.toolboxPosition_ === Position$$module$build$src$core$utils$toolbox.TOP ? new Rect$$module$build$src$core$utils$rect(-1e9, b + a.height, -1e9, 1e9) : new Rect$$module$build$src$core$utils$rect(b, 1e9, -1e9, 1e9);
            }
            reflowInternal_() {
              this.workspace_.scale = this.getFlyoutScale();
              let a = this.getContents().reduce((b, c) => Math.max(b, c.getElement().getBoundingRectangle().getHeight()), 0);
              a += this.MARGIN * 1.5;
              a *= this.workspace_.scale;
              a += Scrollbar$$module$build$src$core$scrollbar.scrollbarThickness;
              this.getHeight() !== a && (this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== Position$$module$build$src$core$utils$toolbox.TOP || this.targetWorkspace.translate(this.targetWorkspace.scrollX, this.targetWorkspace.scrollY + a), this.height_ = a, this.position(), this.targetWorkspace.resizeContents(), this.targetWorkspace.recordDragTargets());
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_HORIZONTAL_TOOLBOX, DEFAULT$$module$build$src$core$registry, HorizontalFlyout$$module$build$src$core$flyout_horizontal);
          var module$build$src$core$flyout_horizontal = {};
          module$build$src$core$flyout_horizontal.HorizontalFlyout = HorizontalFlyout$$module$build$src$core$flyout_horizontal;
          var FieldVariable$$module$build$src$core$field_variable = class extends FieldDropdown$$module$build$src$core$field_dropdown {
            constructor(a, b, c, d, e) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.defaultType = "";
              this.variableTypes = [];
              this.variable = null;
              this.SERIALIZABLE = true;
              this.menuGenerator_ = FieldVariable$$module$build$src$core$field_variable.dropdownCreate;
              this.defaultVariableName = typeof a === "string" ? a : "";
              this.size_ = new Size$$module$build$src$core$utils$size(0, 0);
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (e ? this.configure_(e) : this.setTypes(c, d), b && this.setValidator(b));
            }
            configure_(a) {
              super.configure_(a);
              this.setTypes(a.variableTypes, a.defaultType);
            }
            initModel() {
              var a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              this.variable || (a = $.getOrCreateVariablePackage$$module$build$src$core$variables(a.workspace, null, this.defaultVariableName, this.defaultType), this.doValueUpdate_(a.getId()));
            }
            initView() {
              super.initView();
              addClass$$module$build$src$core$utils$dom(
                this.fieldGroup_,
                "blocklyVariableField"
              );
            }
            shouldAddBorderRect_() {
              const a = this.getSourceBlock();
              if (!a) throw new UnattachedFieldError$$module$build$src$core$field();
              return super.shouldAddBorderRect_() && (!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || a.type !== "variables_get");
            }
            fromXml(a) {
              var b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              const c = a.getAttribute("id"), d = a.textContent, e = a.getAttribute("variabletype") || a.getAttribute("variableType") || "";
              b = $.getOrCreateVariablePackage$$module$build$src$core$variables(
                b.workspace,
                c,
                d,
                e
              );
              if (e !== null && e !== b.getType()) throw Error("Serialized variable type with id '" + b.getId() + "' had type " + b.getType() + ", and does not match variable field that references it: " + domToText$$module$build$src$core$xml(a) + ".");
              this.setValue(b.getId());
            }
            toXml(a) {
              this.initModel();
              a.id = this.variable.getId();
              a.textContent = this.variable.getName();
              this.variable.getType() && a.setAttribute("variabletype", this.variable.getType());
              return a;
            }
            saveState(a) {
              var b = this.saveLegacyState(FieldVariable$$module$build$src$core$field_variable);
              if (b !== null) return b;
              this.initModel();
              b = { id: this.variable.getId() };
              a && (b.name = this.variable.getName(), b.type = this.variable.getType());
              return b;
            }
            loadState(a) {
              const b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              this.loadLegacyState(FieldVariable$$module$build$src$core$field_variable, a) || (a = $.getOrCreateVariablePackage$$module$build$src$core$variables(b.workspace, a.id || null, a.name, a.type || ""), this.setValue(a.getId()));
            }
            setSourceBlock(a) {
              if (a.isShadow()) throw Error("Variable fields are not allowed to exist on shadow blocks.");
              super.setSourceBlock(a);
            }
            getValue() {
              return this.variable ? this.variable.getId() : null;
            }
            getText() {
              return this.variable ? this.variable.getName() : "";
            }
            getVariable() {
              return this.variable;
            }
            getDefaultType() {
              return this.defaultType;
            }
            getValidator() {
              return this.variable ? this.validator_ : null;
            }
            doClassValidation_(a) {
              if (a === null) return null;
              var b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              b = $.getVariable$$module$build$src$core$variables(b.workspace, a);
              if (!b) return console.warn("Variable id doesn't point to a real variable! ID was " + a), null;
              b = b.getType();
              return this.typeIsAllowed(b) ? a : (console.warn("Variable type doesn't match this field!  Type was " + b), null);
            }
            doValueUpdate_(a) {
              const b = this.getSourceBlock();
              if (!b) throw new UnattachedFieldError$$module$build$src$core$field();
              this.variable = $.getVariable$$module$build$src$core$variables(b.workspace, a);
              super.doValueUpdate_(a);
            }
            typeIsAllowed(a) {
              const b = this.getVariableTypes();
              if (!b) return true;
              for (let c = 0; c < b.length; c++) if (a === b[c]) return true;
              return false;
            }
            getVariableTypes() {
              if (this.variableTypes) return this.variableTypes;
              if (!this.sourceBlock_ || this.sourceBlock_.isDeadOrDying()) return [""];
              let a = this.sourceBlock_.workspace.getVariableMap().getTypes();
              if (this.sourceBlock_.isInFlyout) {
                const b = this.sourceBlock_.workspace.getPotentialVariableMap();
                if (!b) return a;
                a = Array.from(/* @__PURE__ */ new Set([...a, ...b.getTypes()]));
              }
              return a;
            }
            setTypes(a = null, b = "") {
              var c = this.getText();
              if (Array.isArray(a)) {
                if (a.length === 0) throw Error(`'variableTypes' of field variable ${c} was an empty list. If you want to include all variable types, pass 'null' instead.`);
                c = false;
                for (let d = 0; d < a.length; d++) a[d] === b && (c = true);
                if (!c) throw Error("Invalid default type '" + b + "' in the definition of a FieldVariable");
              } else if (a !== null) throw Error(`'variableTypes' was not an array or null in the definition of FieldVariable ${c}`);
              this.defaultType = b;
              this.variableTypes = a;
            }
            refreshVariableName() {
              this.forceRerender();
            }
            onItemSelected_(a, b) {
              a = b.getValue();
              if (this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying()) {
                if (a === RENAME_VARIABLE_ID$$module$build$src$core$internal_constants && this.variable) {
                  $.renameVariable$$module$build$src$core$variables(
                    this.sourceBlock_.workspace,
                    this.variable
                  );
                  return;
                }
                if (a === DELETE_VARIABLE_ID$$module$build$src$core$internal_constants && this.variable) {
                  a = this.variable.getWorkspace();
                  $.deleteVariable$$module$build$src$core$variables(a, this.variable, this.sourceBlock_);
                  return;
                }
              }
              this.setValue(a);
            }
            referencesVariables() {
              return true;
            }
            static fromJson(a) {
              return new this(replaceMessageReferences$$module$build$src$core$utils$parsing(a.variable), void 0, void 0, void 0, a);
            }
            static dropdownCreate() {
              if (!this.variable) throw Error("Tried to call dropdownCreate on a variable field with no variable selected.");
              const a = this.getText();
              let b = [];
              var c = this.getSourceBlock();
              if (c && !c.isDeadOrDying()) {
                c = c.workspace;
                const f = this.getVariableTypes();
                for (let g = 0; g < f.length; g++) {
                  const h = f[g], k = c.getVariableMap().getVariablesOfType(h);
                  b = b.concat(k);
                  if (c.isFlyout) {
                    var d = void 0, e = void 0;
                    b = b.concat((e = (d = c.getPotentialVariableMap()) == null ? void 0 : d.getVariablesOfType(h)) != null ? e : []);
                  }
                }
              }
              b.sort(compareByName$$module$build$src$core$variables);
              d = [];
              for (e = 0; e < b.length; e++) d[e] = [b[e].getName(), b[e].getId()];
              d.push([
                $.Msg$$module$build$src$core$msg.RENAME_VARIABLE,
                RENAME_VARIABLE_ID$$module$build$src$core$internal_constants
              ]);
              $.Msg$$module$build$src$core$msg.DELETE_VARIABLE && d.push([$.Msg$$module$build$src$core$msg.DELETE_VARIABLE.replace("%1", a), DELETE_VARIABLE_ID$$module$build$src$core$internal_constants]);
              return d;
            }
          };
          register$$module$build$src$core$field_registry("field_variable", FieldVariable$$module$build$src$core$field_variable);
          var module$build$src$core$field_variable = {};
          module$build$src$core$field_variable.FieldVariable = FieldVariable$$module$build$src$core$field_variable;
          var FieldNumber$$module$build$src$core$field_number = class extends FieldInput$$module$build$src$core$field_input {
            constructor(a, b, c, d, e, f) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.min_ = -Infinity;
              this.max_ = Infinity;
              this.precision_ = 0;
              this.decimalPlaces = null;
              this.spellcheck_ = false;
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (f ? this.configure_(f) : this.setConstraints(b, c, d), this.setValue(a), e && this.setValidator(e));
            }
            configure_(a) {
              super.configure_(a);
              this.setMinInternal(a.min);
              this.setMaxInternal(a.max);
              this.setPrecisionInternal(a.precision);
            }
            setConstraints(a, b, c) {
              this.setMinInternal(a);
              this.setMaxInternal(b);
              this.setPrecisionInternal(c);
              this.setValue(this.getValue());
            }
            setMin(a) {
              this.setMinInternal(a);
              this.setValue(this.getValue());
            }
            setMinInternal(a) {
              a == null ? this.min_ = -Infinity : (a = Number(a), isNaN(a) || (this.min_ = a));
            }
            getMin() {
              return this.min_;
            }
            setMax(a) {
              this.setMaxInternal(a);
              this.setValue(this.getValue());
            }
            setMaxInternal(a) {
              a == null ? this.max_ = Infinity : (a = Number(a), isNaN(a) || (this.max_ = a));
            }
            getMax() {
              return this.max_;
            }
            setPrecision(a) {
              this.setPrecisionInternal(a);
              this.setValue(this.getValue());
            }
            setPrecisionInternal(a) {
              this.precision_ = Number(a) || 0;
              let b = String(this.precision_);
              b.includes("e") && (b = this.precision_.toLocaleString("en-US", { maximumFractionDigits: 20 }));
              const c = b.indexOf(".");
              this.decimalPlaces = c === -1 ? a ? 0 : null : b.length - c - 1;
            }
            getPrecision() {
              return this.precision_;
            }
            doClassValidation_(a) {
              if (a === null) return null;
              a = `${a}`.replace(/O/gi, "0");
              a = a.replace(/,/g, "");
              a = a.replace(/infinity/i, "Infinity");
              a = Number(a || 0);
              if (isNaN(a)) return null;
              a = Math.min(Math.max(
                a,
                this.min_
              ), this.max_);
              this.precision_ && isFinite(a) && (a = Math.round(a / this.precision_) * this.precision_);
              this.decimalPlaces !== null && (a = Number(a.toFixed(this.decimalPlaces)));
              return a;
            }
            widgetCreate_() {
              const a = super.widgetCreate_();
              this.min_ > -Infinity && (a.min = `${this.min_}`, setState$$module$build$src$core$utils$aria(a, State$$module$build$src$core$utils$aria.VALUEMIN, this.min_));
              this.max_ < Infinity && (a.max = `${this.max_}`, setState$$module$build$src$core$utils$aria(
                a,
                State$$module$build$src$core$utils$aria.VALUEMAX,
                this.max_
              ));
              return a;
            }
            initView() {
              super.initView();
              this.fieldGroup_ && addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyNumberField");
            }
            static fromJson(a) {
              return new this(a.value, void 0, void 0, void 0, void 0, a);
            }
          };
          register$$module$build$src$core$field_registry("field_number", FieldNumber$$module$build$src$core$field_number);
          FieldNumber$$module$build$src$core$field_number.prototype.DEFAULT_VALUE = 0;
          var module$build$src$core$field_number = {};
          module$build$src$core$field_number.FieldNumber = FieldNumber$$module$build$src$core$field_number;
          var FieldLabelSerializable$$module$build$src$core$field_label_serializable = class extends FieldLabel$$module$build$src$core$field_label {
            constructor(a, b, c) {
              super(String(a != null ? a : ""), b, c);
              this.EDITABLE = false;
              this.SERIALIZABLE = true;
            }
            static fromJson(a) {
              return new this(replaceMessageReferences$$module$build$src$core$utils$parsing(a.text), void 0, a);
            }
          };
          register$$module$build$src$core$field_registry("field_label_serializable", FieldLabelSerializable$$module$build$src$core$field_label_serializable);
          var module$build$src$core$field_label_serializable = {};
          module$build$src$core$field_label_serializable.FieldLabelSerializable = FieldLabelSerializable$$module$build$src$core$field_label_serializable;
          var FieldCheckbox$$module$build$src$core$field_checkbox = class extends Field$$module$build$src$core$field {
            constructor(a, b, c) {
              super(Field$$module$build$src$core$field.SKIP_SETUP);
              this.SERIALIZABLE = true;
              this.value_ = this.value_;
              this.checkChar = FieldCheckbox$$module$build$src$core$field_checkbox.CHECK_CHAR;
              a !== Field$$module$build$src$core$field.SKIP_SETUP && (c && this.configure_(c), this.setValue(a), b && this.setValidator(b));
            }
            configure_(a) {
              super.configure_(a);
              a.checkCharacter && (this.checkChar = a.checkCharacter);
            }
            saveState() {
              const a = this.saveLegacyState(FieldCheckbox$$module$build$src$core$field_checkbox);
              return a !== null ? a : this.getValueBoolean();
            }
            initView() {
              super.initView();
              const a = this.getTextElement();
              addClass$$module$build$src$core$utils$dom(this.fieldGroup_, "blocklyCheckboxField");
              a.style.display = this.value_ ? "block" : "none";
            }
            render_() {
              this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_());
              this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET);
            }
            getDisplayText_() {
              return this.checkChar;
            }
            setCheckCharacter(a) {
              this.checkChar = a || FieldCheckbox$$module$build$src$core$field_checkbox.CHECK_CHAR;
              this.forceRerender();
            }
            showEditor_() {
              this.setValue(!this.value_);
            }
            doClassValidation_(a) {
              return a === true || a === "TRUE" ? "TRUE" : a === false || a === "FALSE" ? "FALSE" : null;
            }
            doValueUpdate_(a) {
              this.value_ = this.convertValueToBool(a);
              this.textElement_ && (this.textElement_.style.display = this.value_ ? "block" : "none");
            }
            getValue() {
              return this.value_ ? "TRUE" : "FALSE";
            }
            getValueBoolean() {
              return this.value_;
            }
            getText() {
              return String(this.convertValueToBool(this.value_));
            }
            convertValueToBool(a) {
              return typeof a === "string" ? a === "TRUE" : !!a;
            }
            static fromJson(a) {
              return new this(a.checked, void 0, a);
            }
          };
          FieldCheckbox$$module$build$src$core$field_checkbox.CHECK_CHAR = "\u2713";
          register$$module$build$src$core$field_registry("field_checkbox", FieldCheckbox$$module$build$src$core$field_checkbox);
          FieldCheckbox$$module$build$src$core$field_checkbox.prototype.DEFAULT_VALUE = false;
          var module$build$src$core$field_checkbox = {};
          module$build$src$core$field_checkbox.FieldCheckbox = FieldCheckbox$$module$build$src$core$field_checkbox;
          var Dragger$$module$build$src$core$dragging$dragger = class {
            constructor(a, b) {
              this.draggable = a;
              this.workspace = b;
              this.dragTarget = null;
              this.startLoc = a.getRelativeToSurfaceXY();
            }
            onDragStart(a) {
              $.getGroup$$module$build$src$core$events$utils() || $.setGroup$$module$build$src$core$events$utils(true);
              this.draggable.startDrag(a);
            }
            onDrag(a, b) {
              this.moveDraggable(a, b);
              b = this.getRoot(this.draggable);
              isDeletable$$module$build$src$core$interfaces$i_deletable(b) && b.setDeleteStyle(this.wouldDeleteDraggable(a, b));
              this.updateDragTarget(a);
            }
            updateDragTarget(a) {
              a = this.workspace.getDragTarget(a);
              const b = this.getRoot(this.draggable);
              if (this.dragTarget !== a) {
                let c;
                (c = this.dragTarget) == null || c.onDragExit(b);
                a == null || a.onDragEnter(b);
              }
              a == null || a.onDragOver(b);
              this.dragTarget = a;
            }
            moveDraggable(a, b) {
              b = this.pixelsToWorkspaceUnits(b);
              b = Coordinate$$module$build$src$core$utils$coordinate.sum(this.startLoc, b);
              this.draggable.drag(b, a);
            }
            wouldDeleteDraggable(a, b) {
              return (a = this.workspace.getDragTarget(a)) && this.workspace.getComponentManager().hasCapability(a.id, ComponentManager$$module$build$src$core$component_manager.Capability.DELETE_AREA) ? a.wouldDelete(b) : false;
            }
            onDragEnd(a) {
              const b = $.getGroup$$module$build$src$core$events$utils();
              var c = this.workspace.getDragTarget(a);
              const d = this.getRoot(this.draggable);
              if (c) {
                let e;
                (e = this.dragTarget) == null || e.onDrop(d);
              }
              this.shouldReturnToStart(a, d) && this.draggable.revertDrag();
              (c = isDeletable$$module$build$src$core$interfaces$i_deletable(d) && this.wouldDeleteDraggable(a, d)) && this.draggable instanceof BlockSvg$$module$build$src$core$block_svg && disposeUiEffect$$module$build$src$core$block_animations(this.draggable.getRootBlock());
              this.draggable.endDrag(a);
              c && isDeletable$$module$build$src$core$interfaces$i_deletable(d) && ($.setGroup$$module$build$src$core$events$utils(b), d.dispose());
              $.setGroup$$module$build$src$core$events$utils(false);
              !c && isFocusableNode$$module$build$src$core$interfaces$i_focusable_node(this.draggable) && $.getFocusManager$$module$build$src$core$focus_manager().focusNode(this.draggable);
            }
            getRoot(a) {
              return a instanceof BlockSvg$$module$build$src$core$block_svg ? a.getRootBlock() : a;
            }
            shouldReturnToStart(a, b) {
              return (a = this.workspace.getDragTarget(a)) ? a.shouldPreventMove(b) : false;
            }
            pixelsToWorkspaceUnits(a) {
              a = new Coordinate$$module$build$src$core$utils$coordinate(a.x / this.workspace.scale, a.y / this.workspace.scale);
              this.workspace.isMutator && a.scale(1 / this.workspace.options.parentWorkspace.scale);
              return a;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.BLOCK_DRAGGER, DEFAULT$$module$build$src$core$registry, Dragger$$module$build$src$core$dragging$dragger);
          var module$build$src$core$dragging$dragger = {};
          module$build$src$core$dragging$dragger.Dragger = Dragger$$module$build$src$core$dragging$dragger;
          var module$build$src$core$dragging = {};
          module$build$src$core$dragging.BlockDragStrategy = BlockDragStrategy$$module$build$src$core$dragging$block_drag_strategy;
          module$build$src$core$dragging.BubbleDragStrategy = BubbleDragStrategy$$module$build$src$core$dragging$bubble_drag_strategy;
          module$build$src$core$dragging.CommentDragStrategy = CommentDragStrategy$$module$build$src$core$dragging$comment_drag_strategy;
          module$build$src$core$dragging.Dragger = Dragger$$module$build$src$core$dragging$dragger;
          var BlockDrag$$module$build$src$core$events$events_block_drag = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c) {
              super(a ? a.workspace.id : void 0);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_DRAG;
              a && (this.blockId = a.id, this.isStart = b, this.blocks = c);
            }
            toJson() {
              const a = super.toJson();
              if (this.isStart === void 0) throw Error("Whether this event is the start of a drag is undefined. Either pass the value to the constructor, or call fromJson");
              if (this.blockId === void 0) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              a.isStart = this.isStart;
              a.blockId = this.blockId;
              a.blocks = this.blocks;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockDrag$$module$build$src$core$events$events_block_drag());
              b.isStart = a.isStart;
              b.blockId = a.blockId;
              b.blocks = a.blocks;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_DRAG, BlockDrag$$module$build$src$core$events$events_block_drag);
          var module$build$src$core$events$events_block_drag = {};
          module$build$src$core$events$events_block_drag.BlockDrag = BlockDrag$$module$build$src$core$events$events_block_drag;
          var BlockFieldIntermediateChange$$module$build$src$core$events$events_block_field_intermediate_change = class extends BlockBase$$module$build$src$core$events$events_block_base {
            constructor(a, b, c, d) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE;
              this.recordUndo = false;
              a && (this.name = b, this.oldValue = c, this.newValue = d);
            }
            toJson() {
              const a = super.toJson();
              if (!this.name) throw Error("The changed field name is undefined. Either pass a name to the constructor, or call fromJson.");
              a.name = this.name;
              a.oldValue = this.oldValue;
              a.newValue = this.newValue;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockFieldIntermediateChange$$module$build$src$core$events$events_block_field_intermediate_change());
              b.name = a.name;
              b.oldValue = a.oldValue;
              b.newValue = a.newValue;
              return b;
            }
            isNull() {
              return this.oldValue === this.newValue;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              b = b.getBlockById(this.blockId);
              if (!b) throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
              a = a ? this.newValue : this.oldValue;
              (b = b.getField(this.name)) ? b.setValue(a) : console.warn("Can't set non-existent field: " + this.name);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE, BlockFieldIntermediateChange$$module$build$src$core$events$events_block_field_intermediate_change);
          var module$build$src$core$events$events_block_field_intermediate_change = {};
          module$build$src$core$events$events_block_field_intermediate_change.BlockFieldIntermediateChange = BlockFieldIntermediateChange$$module$build$src$core$events$events_block_field_intermediate_change;
          var BlockMove$$module$build$src$core$events$events_block_move = class extends BlockBase$$module$build$src$core$events$events_block_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.BLOCK_MOVE;
              a && (a.isShadow() && (this.recordUndo = false), a = this.currentLocation(), this.oldParentId = a.parentId, this.oldInputName = a.inputName, this.oldCoordinate = a.coordinate);
            }
            toJson() {
              const a = super.toJson();
              a.oldParentId = this.oldParentId;
              a.oldInputName = this.oldInputName;
              this.oldCoordinate && (a.oldCoordinate = `${Math.round(this.oldCoordinate.x)}, ${Math.round(this.oldCoordinate.y)}`);
              a.newParentId = this.newParentId;
              a.newInputName = this.newInputName;
              this.newCoordinate && (a.newCoordinate = `${Math.round(this.newCoordinate.x)}, ${Math.round(this.newCoordinate.y)}`);
              this.reason && (a.reason = this.reason);
              this.recordUndo || (a.recordUndo = this.recordUndo);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BlockMove$$module$build$src$core$events$events_block_move());
              b.oldParentId = a.oldParentId;
              b.oldInputName = a.oldInputName;
              a.oldCoordinate && (c = a.oldCoordinate.split(","), b.oldCoordinate = new Coordinate$$module$build$src$core$utils$coordinate(Number(c[0]), Number(c[1])));
              b.newParentId = a.newParentId;
              b.newInputName = a.newInputName;
              a.newCoordinate && (c = a.newCoordinate.split(","), b.newCoordinate = new Coordinate$$module$build$src$core$utils$coordinate(Number(c[0]), Number(c[1])));
              a.reason !== void 0 && (b.reason = a.reason);
              a.recordUndo !== void 0 && (b.recordUndo = a.recordUndo);
              return b;
            }
            recordNew() {
              const a = this.currentLocation();
              this.newParentId = a.parentId;
              this.newInputName = a.inputName;
              this.newCoordinate = a.coordinate;
            }
            setReason(a) {
              this.reason = a;
            }
            currentLocation() {
              var a = this.getEventWorkspace_();
              if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              var b = a.getBlockById(this.blockId);
              if (!b) throw Error("The block associated with the block move event could not be found");
              a = {};
              const c = b.getParent();
              if (c) {
                if (a.parentId = c.id, b = c.getInputWithBlock(b)) a.inputName = b.name;
              } else a.coordinate = b.getRelativeToSurfaceXY();
              return a;
            }
            isNull() {
              return this.oldParentId === this.newParentId && this.oldInputName === this.newInputName && Coordinate$$module$build$src$core$utils$coordinate.equals(this.oldCoordinate, this.newCoordinate);
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.blockId) throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
              var c = b.getBlockById(this.blockId);
              if (c) {
                var d = a ? this.newParentId : this.oldParentId, e = a ? this.newInputName : this.oldInputName;
                a = a ? this.newCoordinate : this.oldCoordinate;
                if (d) {
                  var f = b.getBlockById(d);
                  if (!f) {
                    console.warn("Can't connect to non-existent block: " + d);
                    return;
                  }
                }
                c.getParent() && c.unplug();
                if (a) e = c.getRelativeToSurfaceXY(), c.moveBy(a.x - e.x, a.y - e.y, this.reason);
                else {
                  b = c.outputConnection;
                  if (!b || c.previousConnection && c.previousConnection.isConnected()) b = c.previousConnection;
                  let g, h;
                  c = (h = b) == null ? void 0 : h.type;
                  if (e) {
                    if (c = f.getInput(e)) g = c.connection;
                  } else c === ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT && (g = f.nextConnection);
                  g && b ? b.connect(g) : console.warn("Can't connect to non-existent input: " + e);
                }
              } else console.warn("Can't move non-existent block: " + this.blockId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BLOCK_MOVE, BlockMove$$module$build$src$core$events$events_block_move);
          var module$build$src$core$events$events_block_move = {};
          module$build$src$core$events$events_block_move.BlockMove = BlockMove$$module$build$src$core$events$events_block_move;
          var BubbleOpen$$module$build$src$core$events$events_bubble_open = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c) {
              super(a ? a.workspace.id : void 0);
              this.type = EventType$$module$build$src$core$events$type.BUBBLE_OPEN;
              a && (this.blockId = a.id, this.isOpen = b, this.bubbleType = c);
            }
            toJson() {
              const a = super.toJson();
              if (this.isOpen === void 0) throw Error("Whether this event is for opening the bubble is undefined. Either pass the value to the constructor, or call fromJson");
              if (!this.bubbleType) throw Error("The type of bubble is undefined. Either pass the value to the constructor, or call fromJson");
              a.isOpen = this.isOpen;
              a.bubbleType = this.bubbleType;
              a.blockId = this.blockId || "";
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new BubbleOpen$$module$build$src$core$events$events_bubble_open());
              b.isOpen = a.isOpen;
              b.bubbleType = a.bubbleType;
              b.blockId = a.blockId;
              return b;
            }
          }, BubbleType$$module$build$src$core$events$events_bubble_open;
          (function(a) {
            a.MUTATOR = "mutator";
            a.COMMENT = "comment";
            a.WARNING = "warning";
          })(BubbleType$$module$build$src$core$events$events_bubble_open || (BubbleType$$module$build$src$core$events$events_bubble_open = {}));
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.BUBBLE_OPEN, BubbleOpen$$module$build$src$core$events$events_bubble_open);
          var module$build$src$core$events$events_bubble_open = {};
          module$build$src$core$events$events_bubble_open.BubbleOpen = BubbleOpen$$module$build$src$core$events$events_bubble_open;
          module$build$src$core$events$events_bubble_open.BubbleType = BubbleType$$module$build$src$core$events$events_bubble_open;
          var CommentBase$$module$build$src$core$events$events_comment_base = class extends Abstract$$module$build$src$core$events$events_abstract {
            constructor(a) {
              super();
              this.isBlank = !a;
              a && (this.commentId = a.id, this.workspaceId = a.workspace.id, this.group = $.getGroup$$module$build$src$core$events$utils(), this.recordUndo = getRecordUndo$$module$build$src$core$events$utils());
            }
            toJson() {
              const a = super.toJson();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              a.commentId = this.commentId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentBase$$module$build$src$core$events$events_comment_base());
              b.commentId = a.commentId;
              return b;
            }
            static CommentCreateDeleteHelper(a, b) {
              const c = a.getEventWorkspace_();
              if (b) {
                if (!a.json) throw Error("Encountered a comment event without proper json");
                append$$module$build$src$core$serialization$workspace_comments(a.json, c);
              } else {
                if (!a.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
                (b = c.getCommentById(a.commentId)) ? b.dispose() : console.warn("Can't delete non-existent comment: " + a.commentId);
              }
            }
          }, module$build$src$core$events$events_comment_base = {};
          module$build$src$core$events$events_comment_base.CommentBase = CommentBase$$module$build$src$core$events$events_comment_base;
          var CommentChange$$module$build$src$core$events$events_comment_change = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a, b, c) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_CHANGE;
              a && (this.oldContents_ = typeof b === "undefined" ? "" : b, this.newContents_ = typeof c === "undefined" ? "" : c);
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldContents_) throw Error("The old contents is undefined. Either pass a value to the constructor, or call fromJson");
              if (!this.newContents_) throw Error("The new contents is undefined. Either pass a value to the constructor, or call fromJson");
              a.oldContents = this.oldContents_;
              a.newContents = this.newContents_;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentChange$$module$build$src$core$events$events_comment_change());
              b.oldContents_ = a.oldContents;
              b.newContents_ = a.newContents;
              return b;
            }
            isNull() {
              return this.oldContents_ === this.newContents_;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              if (b = b.getCommentById(this.commentId)) {
                var c = a ? this.newContents_ : this.oldContents_;
                if (c === void 0) {
                  if (a) throw Error("The new contents is undefined. Either pass a value to the constructor, or call fromJson");
                  throw Error("The old contents is undefined. Either pass a value to the constructor, or call fromJson");
                }
                b.setText(c);
              } else console.warn("Can't change non-existent comment: " + this.commentId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_CHANGE, CommentChange$$module$build$src$core$events$events_comment_change);
          var module$build$src$core$events$events_comment_change = {};
          module$build$src$core$events$events_comment_change.CommentChange = CommentChange$$module$build$src$core$events$events_comment_change;
          var CommentCollapse$$module$build$src$core$events$events_comment_collapse = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a, b) {
              super(a);
              this.newCollapsed = b;
              this.type = EventType$$module$build$src$core$events$type.COMMENT_COLLAPSE;
            }
            toJson() {
              const a = super.toJson();
              if (this.newCollapsed === void 0) throw Error("The new collapse value undefined. Either call recordNew, or call fromJson");
              a.newCollapsed = this.newCollapsed;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(
                a,
                b,
                c != null ? c : new CommentCollapse$$module$build$src$core$events$events_comment_collapse()
              );
              b.newCollapsed = a.newCollapsed;
              return b;
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              (b = b.getCommentById(this.commentId)) ? b.setCollapsed(a ? !!this.newCollapsed : !this.newCollapsed) : console.warn("Can't collapse or uncollapse non-existent comment: " + this.commentId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_COLLAPSE, CommentCollapse$$module$build$src$core$events$events_comment_collapse);
          var module$build$src$core$events$events_comment_collapse = {};
          module$build$src$core$events$events_comment_collapse.CommentCollapse = CommentCollapse$$module$build$src$core$events$events_comment_collapse;
          var CommentCreate$$module$build$src$core$events$events_comment_create = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_CREATE;
              a && (this.xml = saveWorkspaceComment$$module$build$src$core$xml(a), this.json = save$$module$build$src$core$serialization$workspace_comments(a, { addCoordinates: true }));
            }
            toJson() {
              const a = super.toJson();
              if (!this.xml) throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
              if (!this.json) throw Error("The comment JSON is undefined. Either pass a block to the constructor, or call fromJson");
              a.xml = domToText$$module$build$src$core$xml(this.xml);
              a.json = this.json;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentCreate$$module$build$src$core$events$events_comment_create());
              b.xml = $.textToDom$$module$build$src$core$utils$xml(a.xml);
              b.json = a.json;
              return b;
            }
            run(a) {
              CommentBase$$module$build$src$core$events$events_comment_base.CommentCreateDeleteHelper(
                this,
                a
              );
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_CREATE, CommentCreate$$module$build$src$core$events$events_comment_create);
          var module$build$src$core$events$events_comment_create = {};
          module$build$src$core$events$events_comment_create.CommentCreate = CommentCreate$$module$build$src$core$events$events_comment_create;
          var CommentDelete$$module$build$src$core$events$events_comment_delete = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_DELETE;
              a && (this.xml = saveWorkspaceComment$$module$build$src$core$xml(a), this.json = save$$module$build$src$core$serialization$workspace_comments(a, { addCoordinates: true }));
            }
            run(a) {
              CommentBase$$module$build$src$core$events$events_comment_base.CommentCreateDeleteHelper(this, !a);
            }
            toJson() {
              const a = super.toJson();
              if (!this.xml) throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
              if (!this.json) throw Error("The comment JSON is undefined. Either pass a block to the constructor, or call fromJson");
              a.xml = domToText$$module$build$src$core$xml(this.xml);
              a.json = this.json;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentDelete$$module$build$src$core$events$events_comment_delete());
              b.xml = $.textToDom$$module$build$src$core$utils$xml(a.xml);
              b.json = a.json;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_DELETE, CommentDelete$$module$build$src$core$events$events_comment_delete);
          var module$build$src$core$events$events_comment_delete = {};
          module$build$src$core$events$events_comment_delete.CommentDelete = CommentDelete$$module$build$src$core$events$events_comment_delete;
          var CommentDrag$$module$build$src$core$events$events_comment_drag = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b) {
              super(a ? a.workspace.id : void 0);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_DRAG;
              a && (this.commentId = a.id, this.isStart = b);
            }
            toJson() {
              const a = super.toJson();
              if (this.isStart === void 0) throw Error("Whether this event is the start of a drag is undefined. Either pass the value to the constructor, or call fromJson");
              if (this.commentId === void 0) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              a.isStart = this.isStart;
              a.commentId = this.commentId;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentDrag$$module$build$src$core$events$events_comment_drag());
              b.isStart = a.isStart;
              b.commentId = a.commentId;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_DRAG, CommentDrag$$module$build$src$core$events$events_comment_drag);
          var module$build$src$core$events$events_comment_drag = {};
          module$build$src$core$events$events_comment_drag.CommentDrag = CommentDrag$$module$build$src$core$events$events_comment_drag;
          var CommentMove$$module$build$src$core$events$events_comment_move = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_MOVE;
              a && (this.comment_ = a, this.oldCoordinate_ = a.getRelativeToSurfaceXY());
            }
            recordNew() {
              if (this.newCoordinate_) throw Error("Tried to record the new position of a comment on the same event twice.");
              if (!this.comment_) throw Error("The comment is undefined. Pass a comment to the constructor if you want to use the record functionality");
              this.newCoordinate_ = this.comment_.getRelativeToSurfaceXY();
            }
            setReason(a) {
              this.reason = a;
            }
            setOldCoordinate(a) {
              this.oldCoordinate_ = a;
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldCoordinate_) throw Error("The old comment position is undefined. Either pass a comment to the constructor, or call fromJson");
              if (!this.newCoordinate_) throw Error("The new comment position is undefined. Either call recordNew, or call fromJson");
              a.oldCoordinate = `${Math.round(this.oldCoordinate_.x)}, ${Math.round(this.oldCoordinate_.y)}`;
              a.newCoordinate = Math.round(this.newCoordinate_.x) + "," + Math.round(this.newCoordinate_.y);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentMove$$module$build$src$core$events$events_comment_move());
              c = a.oldCoordinate.split(",");
              b.oldCoordinate_ = new Coordinate$$module$build$src$core$utils$coordinate(Number(c[0]), Number(c[1]));
              c = a.newCoordinate.split(",");
              b.newCoordinate_ = new Coordinate$$module$build$src$core$utils$coordinate(Number(c[0]), Number(c[1]));
              return b;
            }
            isNull() {
              return Coordinate$$module$build$src$core$utils$coordinate.equals(
                this.oldCoordinate_,
                this.newCoordinate_
              );
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              if (b = b.getCommentById(this.commentId)) {
                a = a ? this.newCoordinate_ : this.oldCoordinate_;
                if (!a) throw Error("Either oldCoordinate_ or newCoordinate_ is undefined. Either pass a comment to the constructor and call recordNew, or call fromJson");
                b.moveTo(a);
              } else console.warn("Can't move non-existent comment: " + this.commentId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_MOVE, CommentMove$$module$build$src$core$events$events_comment_move);
          var module$build$src$core$events$events_comment_move = {};
          module$build$src$core$events$events_comment_move.CommentMove = CommentMove$$module$build$src$core$events$events_comment_move;
          var CommentResize$$module$build$src$core$events$events_comment_resize = class extends CommentBase$$module$build$src$core$events$events_comment_base {
            constructor(a) {
              super(a);
              this.type = EventType$$module$build$src$core$events$type.COMMENT_RESIZE;
              a && (this.oldSize = a.getSize());
            }
            recordCurrentSizeAsNewSize() {
              if (this.newSize) throw Error("Tried to record the new size of a comment on the same event twice.");
              var a = this.getEventWorkspace_();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              a = a.getCommentById(this.commentId);
              if (!a) throw Error("The comment associated with the comment resize event could not be found");
              this.newSize = a.getSize();
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldSize) throw Error("The old comment size is undefined. Either pass a comment to the constructor, or call fromJson");
              if (!this.newSize) throw Error("The new comment size is undefined. Either call recordCurrentSizeAsNewSize, or call fromJson");
              a.oldWidth = Math.round(this.oldSize.width);
              a.oldHeight = Math.round(this.oldSize.height);
              a.newWidth = Math.round(this.newSize.width);
              a.newHeight = Math.round(this.newSize.height);
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new CommentResize$$module$build$src$core$events$events_comment_resize());
              b.oldSize = new Size$$module$build$src$core$utils$size(a.oldWidth, a.oldHeight);
              b.newSize = new Size$$module$build$src$core$utils$size(a.newWidth, a.newHeight);
              return b;
            }
            isNull() {
              return Size$$module$build$src$core$utils$size.equals(this.oldSize, this.newSize);
            }
            run(a) {
              var b = this.getEventWorkspace_();
              if (!this.commentId) throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
              if (b = b.getCommentById(this.commentId)) {
                a = a ? this.newSize : this.oldSize;
                if (!a) throw Error("Either oldSize or newSize is undefined. Either pass a comment to the constructor and call recordCurrentSizeAsNewSize, or call fromJson");
                b.setSize(a);
              } else console.warn("Can't resize non-existent comment: " + this.commentId);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.COMMENT_RESIZE, CommentResize$$module$build$src$core$events$events_comment_resize);
          var module$build$src$core$events$events_comment_resize = {};
          module$build$src$core$events$events_comment_resize.CommentResize = CommentResize$$module$build$src$core$events$events_comment_resize;
          var ToolboxItemSelect$$module$build$src$core$events$events_toolbox_item_select = class extends UiBase$$module$build$src$core$events$events_ui_base {
            constructor(a, b, c) {
              super(c);
              this.type = EventType$$module$build$src$core$events$type.TOOLBOX_ITEM_SELECT;
              this.oldItem = a != null ? a : void 0;
              this.newItem = b != null ? b : void 0;
            }
            toJson() {
              const a = super.toJson();
              a.oldItem = this.oldItem;
              a.newItem = this.newItem;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new ToolboxItemSelect$$module$build$src$core$events$events_toolbox_item_select());
              b.oldItem = a.oldItem;
              b.newItem = a.newItem;
              return b;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.TOOLBOX_ITEM_SELECT, ToolboxItemSelect$$module$build$src$core$events$events_toolbox_item_select);
          var module$build$src$core$events$events_toolbox_item_select = {};
          module$build$src$core$events$events_toolbox_item_select.ToolboxItemSelect = ToolboxItemSelect$$module$build$src$core$events$events_toolbox_item_select;
          var VarTypeChange$$module$build$src$core$events$events_var_type_change = class extends VarBase$$module$build$src$core$events$events_var_base {
            constructor(a, b, c) {
              super(a);
              this.oldType = b;
              this.newType = c;
              this.type = EventType$$module$build$src$core$events$type.VAR_TYPE_CHANGE;
            }
            toJson() {
              const a = super.toJson();
              if (!this.oldType || !this.newType) throw Error("The variable's types are undefined. Either pass them to the constructor, or call fromJson");
              a.oldType = this.oldType;
              a.newType = this.newType;
              return a;
            }
            static fromJson(a, b, c) {
              b = super.fromJson(a, b, c != null ? c : new VarTypeChange$$module$build$src$core$events$events_var_type_change());
              b.oldType = a.oldType;
              b.newType = a.newType;
              return b;
            }
            run(a) {
              const b = this.getEventWorkspace_();
              if (!this.varId) throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
              if (!this.oldType || !this.newType) throw Error("The variable's types are undefined. Either pass them to the constructor, or call fromJson");
              const c = b.getVariableMap().getVariableById(this.varId);
              c && (a ? b.getVariableMap().changeVariableType(c, this.newType) : b.getVariableMap().changeVariableType(c, this.oldType));
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.VAR_TYPE_CHANGE, VarTypeChange$$module$build$src$core$events$events_var_type_change);
          var module$build$src$core$events$events_var_type_change = {};
          module$build$src$core$events$events_var_type_change.VarTypeChange = VarTypeChange$$module$build$src$core$events$events_var_type_change;
          var FinishedLoading$$module$build$src$core$events$workspace_events = class extends Abstract$$module$build$src$core$events$events_abstract {
            constructor(a) {
              super();
              this.isBlank = true;
              this.recordUndo = false;
              this.type = EventType$$module$build$src$core$events$type.FINISHED_LOADING;
              this.isBlank = !!a;
              a && (this.workspaceId = a.id);
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.EVENT, EventType$$module$build$src$core$events$type.FINISHED_LOADING, FinishedLoading$$module$build$src$core$events$workspace_events);
          var module$build$src$core$events$workspace_events = {};
          module$build$src$core$events$workspace_events.FinishedLoading = FinishedLoading$$module$build$src$core$events$workspace_events;
          var BLOCK_DRAG$$module$build$src$core$events$events, BLOCK_FIELD_INTERMEDIATE_CHANGE$$module$build$src$core$events$events, BUBBLE_OPEN$$module$build$src$core$events$events, CHANGE$$module$build$src$core$events$events, CLICK$$module$build$src$core$events$events, COMMENT_CHANGE$$module$build$src$core$events$events, COMMENT_CREATE$$module$build$src$core$events$events, COMMENT_DELETE$$module$build$src$core$events$events, COMMENT_MOVE$$module$build$src$core$events$events, COMMENT_RESIZE$$module$build$src$core$events$events, COMMENT_DRAG$$module$build$src$core$events$events, CREATE$$module$build$src$core$events$events, DELETE$$module$build$src$core$events$events, FINISHED_LOADING$$module$build$src$core$events$events, MOVE$$module$build$src$core$events$events, SELECTED$$module$build$src$core$events$events, THEME_CHANGE$$module$build$src$core$events$events, TOOLBOX_ITEM_SELECT$$module$build$src$core$events$events, TRASHCAN_OPEN$$module$build$src$core$events$events, UI$$module$build$src$core$events$events, VAR_CREATE$$module$build$src$core$events$events, VAR_DELETE$$module$build$src$core$events$events, VAR_RENAME$$module$build$src$core$events$events, VIEWPORT_CHANGE$$module$build$src$core$events$events, module$build$src$core$events$events;
          $.BLOCK_CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_CHANGE;
          $.BLOCK_CREATE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_CREATE;
          $.BLOCK_DELETE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_DELETE;
          BLOCK_DRAG$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_DRAG;
          $.BLOCK_MOVE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_MOVE;
          BLOCK_FIELD_INTERMEDIATE_CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_FIELD_INTERMEDIATE_CHANGE;
          BUBBLE_OPEN$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BUBBLE_OPEN;
          CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_CHANGE;
          CLICK$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.CLICK;
          COMMENT_CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_CHANGE;
          COMMENT_CREATE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_CREATE;
          COMMENT_DELETE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_DELETE;
          COMMENT_MOVE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_MOVE;
          COMMENT_RESIZE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_RESIZE;
          COMMENT_DRAG$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.COMMENT_DRAG;
          CREATE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_CREATE;
          DELETE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_DELETE;
          FINISHED_LOADING$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.FINISHED_LOADING;
          MOVE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.BLOCK_MOVE;
          SELECTED$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.SELECTED;
          THEME_CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.THEME_CHANGE;
          TOOLBOX_ITEM_SELECT$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.TOOLBOX_ITEM_SELECT;
          TRASHCAN_OPEN$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.TRASHCAN_OPEN;
          UI$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.UI;
          VAR_CREATE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.VAR_CREATE;
          VAR_DELETE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.VAR_DELETE;
          VAR_RENAME$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.VAR_RENAME;
          VIEWPORT_CHANGE$$module$build$src$core$events$events = EventType$$module$build$src$core$events$type.VIEWPORT_CHANGE;
          module$build$src$core$events$events = {};
          module$build$src$core$events$events.Abstract = Abstract$$module$build$src$core$events$events_abstract;
          module$build$src$core$events$events.BLOCK_CHANGE = $.BLOCK_CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.BLOCK_CREATE = $.BLOCK_CREATE$$module$build$src$core$events$events;
          module$build$src$core$events$events.BLOCK_DELETE = $.BLOCK_DELETE$$module$build$src$core$events$events;
          module$build$src$core$events$events.BLOCK_DRAG = BLOCK_DRAG$$module$build$src$core$events$events;
          module$build$src$core$events$events.BLOCK_FIELD_INTERMEDIATE_CHANGE = BLOCK_FIELD_INTERMEDIATE_CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.BLOCK_MOVE = $.BLOCK_MOVE$$module$build$src$core$events$events;
          module$build$src$core$events$events.BUBBLE_OPEN = BUBBLE_OPEN$$module$build$src$core$events$events;
          module$build$src$core$events$events.BUMP_EVENTS = BUMP_EVENTS$$module$build$src$core$events$type;
          module$build$src$core$events$events.BlockBase = BlockBase$$module$build$src$core$events$events_block_base;
          module$build$src$core$events$events.BlockChange = BlockChange$$module$build$src$core$events$events_block_change;
          module$build$src$core$events$events.BlockCreate = BlockCreate$$module$build$src$core$events$events_block_create;
          module$build$src$core$events$events.BlockDelete = BlockDelete$$module$build$src$core$events$events_block_delete;
          module$build$src$core$events$events.BlockDrag = BlockDrag$$module$build$src$core$events$events_block_drag;
          module$build$src$core$events$events.BlockFieldIntermediateChange = BlockFieldIntermediateChange$$module$build$src$core$events$events_block_field_intermediate_change;
          module$build$src$core$events$events.BlockMove = BlockMove$$module$build$src$core$events$events_block_move;
          module$build$src$core$events$events.BubbleOpen = BubbleOpen$$module$build$src$core$events$events_bubble_open;
          module$build$src$core$events$events.BubbleType = BubbleType$$module$build$src$core$events$events_bubble_open;
          module$build$src$core$events$events.CHANGE = CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.CLICK = CLICK$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_CHANGE = COMMENT_CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_CREATE = COMMENT_CREATE$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_DELETE = COMMENT_DELETE$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_DRAG = COMMENT_DRAG$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_MOVE = COMMENT_MOVE$$module$build$src$core$events$events;
          module$build$src$core$events$events.COMMENT_RESIZE = COMMENT_RESIZE$$module$build$src$core$events$events;
          module$build$src$core$events$events.CREATE = CREATE$$module$build$src$core$events$events;
          module$build$src$core$events$events.Click = Click$$module$build$src$core$events$events_click;
          module$build$src$core$events$events.ClickTarget = ClickTarget$$module$build$src$core$events$events_click;
          module$build$src$core$events$events.CommentBase = CommentBase$$module$build$src$core$events$events_comment_base;
          module$build$src$core$events$events.CommentChange = CommentChange$$module$build$src$core$events$events_comment_change;
          module$build$src$core$events$events.CommentCollapse = CommentCollapse$$module$build$src$core$events$events_comment_collapse;
          module$build$src$core$events$events.CommentCreate = CommentCreate$$module$build$src$core$events$events_comment_create;
          module$build$src$core$events$events.CommentDelete = CommentDelete$$module$build$src$core$events$events_comment_delete;
          module$build$src$core$events$events.CommentDrag = CommentDrag$$module$build$src$core$events$events_comment_drag;
          module$build$src$core$events$events.CommentMove = CommentMove$$module$build$src$core$events$events_comment_move;
          module$build$src$core$events$events.CommentResize = CommentResize$$module$build$src$core$events$events_comment_resize;
          module$build$src$core$events$events.DELETE = DELETE$$module$build$src$core$events$events;
          module$build$src$core$events$events.FINISHED_LOADING = FINISHED_LOADING$$module$build$src$core$events$events;
          module$build$src$core$events$events.FinishedLoading = FinishedLoading$$module$build$src$core$events$workspace_events;
          module$build$src$core$events$events.MOVE = MOVE$$module$build$src$core$events$events;
          module$build$src$core$events$events.SELECTED = SELECTED$$module$build$src$core$events$events;
          module$build$src$core$events$events.Selected = Selected$$module$build$src$core$events$events_selected;
          module$build$src$core$events$events.THEME_CHANGE = THEME_CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.TOOLBOX_ITEM_SELECT = TOOLBOX_ITEM_SELECT$$module$build$src$core$events$events;
          module$build$src$core$events$events.TRASHCAN_OPEN = TRASHCAN_OPEN$$module$build$src$core$events$events;
          module$build$src$core$events$events.ThemeChange = ThemeChange$$module$build$src$core$events$events_theme_change;
          module$build$src$core$events$events.ToolboxItemSelect = ToolboxItemSelect$$module$build$src$core$events$events_toolbox_item_select;
          module$build$src$core$events$events.TrashcanOpen = TrashcanOpen$$module$build$src$core$events$events_trashcan_open;
          module$build$src$core$events$events.UI = UI$$module$build$src$core$events$events;
          module$build$src$core$events$events.UiBase = UiBase$$module$build$src$core$events$events_ui_base;
          module$build$src$core$events$events.VAR_CREATE = VAR_CREATE$$module$build$src$core$events$events;
          module$build$src$core$events$events.VAR_DELETE = VAR_DELETE$$module$build$src$core$events$events;
          module$build$src$core$events$events.VAR_RENAME = VAR_RENAME$$module$build$src$core$events$events;
          module$build$src$core$events$events.VIEWPORT_CHANGE = VIEWPORT_CHANGE$$module$build$src$core$events$events;
          module$build$src$core$events$events.VarBase = VarBase$$module$build$src$core$events$events_var_base;
          module$build$src$core$events$events.VarCreate = VarCreate$$module$build$src$core$events$events_var_create;
          module$build$src$core$events$events.VarDelete = VarDelete$$module$build$src$core$events$events_var_delete;
          module$build$src$core$events$events.VarRename = VarRename$$module$build$src$core$events$events_var_rename;
          module$build$src$core$events$events.VarTypeChange = VarTypeChange$$module$build$src$core$events$events_var_type_change;
          module$build$src$core$events$events.ViewportChange = ViewportChange$$module$build$src$core$events$events_viewport;
          module$build$src$core$events$events.clearPendingUndo = clearPendingUndo$$module$build$src$core$events$utils;
          module$build$src$core$events$events.disable = $.disable$$module$build$src$core$events$utils;
          module$build$src$core$events$events.disableOrphans = disableOrphans$$module$build$src$core$events$utils;
          module$build$src$core$events$events.enable = $.enable$$module$build$src$core$events$utils;
          module$build$src$core$events$events.filter = filter$$module$build$src$core$events$utils;
          module$build$src$core$events$events.fire = fire$$module$build$src$core$events$utils;
          module$build$src$core$events$events.fromJson = fromJson$$module$build$src$core$events$utils;
          module$build$src$core$events$events.get = get$$module$build$src$core$events$utils;
          module$build$src$core$events$events.getDescendantIds = getDescendantIds$$module$build$src$core$events$utils;
          module$build$src$core$events$events.getGroup = $.getGroup$$module$build$src$core$events$utils;
          module$build$src$core$events$events.getRecordUndo = getRecordUndo$$module$build$src$core$events$utils;
          module$build$src$core$events$events.isEnabled = isEnabled$$module$build$src$core$events$utils;
          module$build$src$core$events$events.setGroup = $.setGroup$$module$build$src$core$events$utils;
          module$build$src$core$events$events.setRecordUndo = $.setRecordUndo$$module$build$src$core$events$utils;
          var module$build$src$core$renderers$zelos$zelos = {};
          module$build$src$core$renderers$zelos$zelos.BottomRow = BottomRow$$module$build$src$core$renderers$zelos$measurables$bottom_row;
          module$build$src$core$renderers$zelos$zelos.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$zelos$constants;
          module$build$src$core$renderers$zelos$zelos.Drawer = Drawer$$module$build$src$core$renderers$zelos$drawer;
          module$build$src$core$renderers$zelos$zelos.PathObject = PathObject$$module$build$src$core$renderers$zelos$path_object;
          module$build$src$core$renderers$zelos$zelos.RenderInfo = RenderInfo$$module$build$src$core$renderers$zelos$info;
          module$build$src$core$renderers$zelos$zelos.Renderer = Renderer$$module$build$src$core$renderers$zelos$renderer;
          module$build$src$core$renderers$zelos$zelos.RightConnectionShape = RightConnectionShape$$module$build$src$core$renderers$zelos$measurables$row_elements;
          module$build$src$core$renderers$zelos$zelos.StatementInput = StatementInput$$module$build$src$core$renderers$zelos$measurables$inputs;
          module$build$src$core$renderers$zelos$zelos.TopRow = TopRow$$module$build$src$core$renderers$zelos$measurables$top_row;
          registerDefaultOptions$$module$build$src$core$contextmenu_items();
          var module$build$src$core$contextmenu_items = {};
          module$build$src$core$contextmenu_items.registerCleanup = registerCleanup$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCollapse = registerCollapse$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCollapseExpandBlock = registerCollapseExpandBlock$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerComment = registerComment$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCommentCreate = registerCommentCreate$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCommentDelete = registerCommentDelete$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCommentDuplicate = registerCommentDuplicate$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerCommentOptions = registerCommentOptions$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerDefaultOptions = registerDefaultOptions$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerDelete = registerDelete$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerDeleteAll = registerDeleteAll$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerDisable = registerDisable$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerDuplicate = registerDuplicate$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerExpand = registerExpand$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerHelp = registerHelp$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerInline = registerInline$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerRedo = registerRedo$$module$build$src$core$contextmenu_items;
          module$build$src$core$contextmenu_items.registerUndo = registerUndo$$module$build$src$core$contextmenu_items;
          var BUTTON_TYPE$$module$build$src$core$button_flyout_inflater = "button", ButtonFlyoutInflater$$module$build$src$core$button_flyout_inflater = class {
            load(a, b) {
              a = new FlyoutButton$$module$build$src$core$flyout_button(b.getWorkspace(), b.targetWorkspace, a, false);
              a.show();
              return new FlyoutItem$$module$build$src$core$flyout_item(a, BUTTON_TYPE$$module$build$src$core$button_flyout_inflater);
            }
            gapForItem(a, b) {
              return b;
            }
            disposeItem(a) {
              a = a.getElement();
              a instanceof FlyoutButton$$module$build$src$core$flyout_button && a.dispose();
            }
            getType() {
              return BUTTON_TYPE$$module$build$src$core$button_flyout_inflater;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUT_INFLATER, BUTTON_TYPE$$module$build$src$core$button_flyout_inflater, ButtonFlyoutInflater$$module$build$src$core$button_flyout_inflater);
          var module$build$src$core$button_flyout_inflater = {};
          module$build$src$core$button_flyout_inflater.ButtonFlyoutInflater = ButtonFlyoutInflater$$module$build$src$core$button_flyout_inflater;
          var module$build$src$core$bubbles = {};
          module$build$src$core$bubbles.Bubble = Bubble$$module$build$src$core$bubbles$bubble;
          module$build$src$core$bubbles.MiniWorkspaceBubble = MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble;
          module$build$src$core$bubbles.TextBubble = TextBubble$$module$build$src$core$bubbles$text_bubble;
          module$build$src$core$bubbles.TextInputBubble = TextInputBubble$$module$build$src$core$bubbles$textinput_bubble;
          var module$build$src$core$blockly_options = {};
          var WORKSPACE_AT_BLOCK_CAPACITY_DISABLED_REASON$$module$build$src$core$block_flyout_inflater = "WORKSPACE_AT_BLOCK_CAPACITY", BLOCK_TYPE$$module$build$src$core$block_flyout_inflater = "block", BlockFlyoutInflater$$module$build$src$core$block_flyout_inflater = class {
            constructor() {
              this.permanentlyDisabledBlocks = /* @__PURE__ */ new Set();
              this.listeners = /* @__PURE__ */ new Map();
              this.capacityWrapper = this.filterFlyoutBasedOnCapacity.bind(this);
            }
            load(a, b) {
              this.setFlyout(b);
              a = this.createBlock(a, b.getWorkspace());
              a.isEnabled() ? this.updateStateBasedOnCapacity(a) : this.permanentlyDisabledBlocks.add(a);
              a.getDescendants(false).forEach((c) => c.isInFlyout = true);
              this.addBlockListeners(a);
              return new FlyoutItem$$module$build$src$core$flyout_item(a, BLOCK_TYPE$$module$build$src$core$block_flyout_inflater);
            }
            createBlock(a, b) {
              a.blockxml ? (a = typeof a.blockxml === "string" ? $.textToDom$$module$build$src$core$utils$xml(a.blockxml) : a.blockxml, b = domToBlockInternal$$module$build$src$core$xml(a, b)) : (a.enabled === void 0 && (a.enabled = a.disabled !== "true" && a.disabled !== true), a.disabledReasons === void 0 && a.enabled === false && (a.disabledReasons = [MANUALLY_DISABLED$$module$build$src$core$constants]), "x" in a && delete a.x, "y" in a && delete a.y, b = appendInternal$$module$build$src$core$serialization$blocks(a, b));
              return b;
            }
            gapForItem(a, b) {
              let c;
              a.gap ? c = parseInt(String(a.gap)) : a.blockxml && (a = typeof a.blockxml === "string" ? $.textToDom$$module$build$src$core$utils$xml(a.blockxml) : a.blockxml, c = parseInt(a.getAttribute("gap")));
              return !c || isNaN(c) ? b : c;
            }
            disposeItem(a) {
              a = a.getElement();
              a instanceof BlockSvg$$module$build$src$core$block_svg && (this.removeListeners(a.id), a.dispose(false, false));
            }
            removeListeners(a) {
              let b;
              ((b = this.listeners.get(a)) != null ? b : []).forEach((c) => unbind$$module$build$src$core$browser_events(c));
              this.listeners.delete(a);
            }
            setFlyout(a) {
              if (this.flyout !== a) {
                if (this.flyout) {
                  let c;
                  (c = this.flyout.targetWorkspace) == null || c.removeChangeListener(this.capacityWrapper);
                }
                this.flyout = a;
                var b;
                (b = this.flyout.targetWorkspace) == null || b.addChangeListener(this.capacityWrapper);
              }
            }
            updateStateBasedOnCapacity(a) {
              let b, c;
              const d = (b = this.flyout) == null ? void 0 : (c = b.targetWorkspace) == null ? void 0 : c.isCapacityAvailable(getBlockTypeCounts$$module$build$src$core$common(a));
              for (; a; ) a.setDisabledReason(!d, WORKSPACE_AT_BLOCK_CAPACITY_DISABLED_REASON$$module$build$src$core$block_flyout_inflater), a = a.getNextBlock();
            }
            addBlockListeners(a) {
              const b = [];
              b.push(conditionalBind$$module$build$src$core$browser_events(a.getSvgRoot(), "pointerdown", a, (c) => {
                let d, e;
                const f = (d = this.flyout) == null ? void 0 : (e = d.targetWorkspace) == null ? void 0 : e.getGesture(c);
                f && this.flyout && (f.setStartBlock(a), f.handleFlyoutStart(c, this.flyout));
              }));
              b.push(bind$$module$build$src$core$browser_events(a.getSvgRoot(), "pointermove", null, () => {
                let c, d;
                ((c = this.flyout) == null ? 0 : (d = c.targetWorkspace) == null ? 0 : d.isDragging()) || a.addSelect();
              }));
              b.push(bind$$module$build$src$core$browser_events(a.getSvgRoot(), "pointerleave", null, () => {
                let c, d;
                ((c = this.flyout) == null ? 0 : (d = c.targetWorkspace) == null ? 0 : d.isDragging()) || a.removeSelect();
              }));
              this.listeners.set(a.id, b);
            }
            filterFlyoutBasedOnCapacity(a) {
              !this.flyout || a && a.type !== EventType$$module$build$src$core$events$type.BLOCK_CREATE && a.type !== EventType$$module$build$src$core$events$type.BLOCK_DELETE || this.flyout.getWorkspace().getTopBlocks(false).forEach((b) => {
                this.permanentlyDisabledBlocks.has(b) || this.updateStateBasedOnCapacity(b);
              });
            }
            getType() {
              return BLOCK_TYPE$$module$build$src$core$block_flyout_inflater;
            }
          };
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUT_INFLATER, BLOCK_TYPE$$module$build$src$core$block_flyout_inflater, BlockFlyoutInflater$$module$build$src$core$block_flyout_inflater);
          var module$build$src$core$block_flyout_inflater = {};
          module$build$src$core$block_flyout_inflater.BlockFlyoutInflater = BlockFlyoutInflater$$module$build$src$core$block_flyout_inflater;
          var module$build$src$core$interfaces$i_paster = {};
          module$build$src$core$interfaces$i_paster.isPaster = isPaster$$module$build$src$core$interfaces$i_paster;
          var module$build$src$core$interfaces$i_rendered_element = {};
          module$build$src$core$interfaces$i_rendered_element.isRenderedElement = isRenderedElement$$module$build$src$core$interfaces$i_rendered_element;
          var ConstantProvider$$module$build$src$core$renderers$geras$constants = class extends ConstantProvider$$module$build$src$core$renderers$common$constants {
            constructor() {
              super();
              this.FIELD_TEXT_BASELINE_CENTER = false;
              this.DARK_PATH_OFFSET = 1;
              this.MAX_BOTTOM_WIDTH = 30;
              this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT / 2;
            }
            getCSS_(a) {
              return super.getCSS_(a).concat([
                `${a} .blocklyInsertionMarker>.blocklyPathLight,`,
                `${a} .blocklyInsertionMarker>.blocklyPathDark {`,
                `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`,
                "stroke: none;",
                "}"
              ]);
            }
          }, module$build$src$core$renderers$geras$constants = {};
          module$build$src$core$renderers$geras$constants.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$geras$constants;
          var Highlighter$$module$build$src$core$renderers$geras$highlighter = class {
            constructor(a) {
              this.inlineSteps_ = this.steps_ = "";
              this.info_ = a;
              this.RTL_ = this.info_.RTL;
              a = a.getRenderer();
              this.constants_ = a.getConstants();
              this.highlightConstants_ = a.getHighlightConstants();
              this.highlightOffset = this.highlightConstants_.OFFSET;
              this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER;
              this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER;
              this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB;
              this.notchPaths_ = this.highlightConstants_.NOTCH;
              this.startPaths_ = this.highlightConstants_.START_HAT;
              this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH;
            }
            getPath() {
              return this.steps_ + "\n" + this.inlineSteps_;
            }
            drawTopCorner(a) {
              this.steps_ += moveBy$$module$build$src$core$utils$svg_paths(a.xPos, this.info_.startY);
              for (let b = 0, c; c = a.elements[b]; b++) Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(c) ? this.steps_ += this.highlightConstants_.START_POINT : Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(c) ? this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_) : Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(c) ? this.steps_ += this.notchPaths_.pathLeft : Types$$module$build$src$core$renderers$measurables$types.isHat(c) ? this.steps_ += this.startPaths_.path(this.RTL_) : Types$$module$build$src$core$renderers$measurables$types.isSpacer(c) && c.width !== 0 && (this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", c.xPos + c.width - this.highlightOffset));
              this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths(
                "H",
                a.xPos + a.width - this.highlightOffset
              );
            }
            drawJaggedEdge_(a) {
              this.info_.RTL && (this.steps_ += this.jaggedTeethPaths_.pathLeft + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a.height - this.jaggedTeethPaths_.height - this.highlightOffset));
            }
            drawValueInput(a) {
              const b = a.getLastInput();
              if (this.RTL_) {
                const c = a.height - b.connectionHeight;
                this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(b.xPos + b.width - this.highlightOffset, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_) + lineOnAxis$$module$build$src$core$utils$svg_paths(
                  "v",
                  c
                );
              } else this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(b.xPos + b.width, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_);
            }
            drawStatementInput(a) {
              const b = a.getLastInput();
              if (b) if (this.RTL_) {
                const c = a.height - 2 * this.insideCornerPaths_.height;
                this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(b.xPos, a.yPos) + this.insideCornerPaths_.pathTop(this.RTL_) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", c) + this.insideCornerPaths_.pathBottom(this.RTL_) + lineTo$$module$build$src$core$utils$svg_paths(a.width - b.xPos - this.insideCornerPaths_.width, 0);
              } else this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(b.xPos, a.yPos + a.height) + this.insideCornerPaths_.pathBottom(this.RTL_) + lineTo$$module$build$src$core$utils$svg_paths(a.width - b.xPos - this.insideCornerPaths_.width, 0);
            }
            drawRightSideRow(a) {
              const b = a.xPos + a.width - this.highlightOffset;
              a instanceof SpacerRow$$module$build$src$core$renderers$measurables$spacer_row && a.followsStatement && (this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", b));
              this.RTL_ && (this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", b), a.height > this.highlightOffset && (this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.yPos + a.height - this.highlightOffset)));
            }
            drawBottomRow(a) {
              if (this.RTL_) this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.baseline - this.highlightOffset);
              else {
                const b = this.info_.bottomRow.elements[0];
                Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(b) ? this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(a.xPos + this.highlightOffset, a.baseline - this.highlightOffset) : Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(b) && (this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(a.xPos, a.baseline), this.steps_ += this.outsideCornerPaths_.bottomLeft());
              }
            }
            drawLeft() {
              var a = this.info_.outputConnection;
              a && (a = a.connectionOffsetY + a.height, this.RTL_ ? this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(this.info_.startX, a) : (this.steps_ += moveTo$$module$build$src$core$utils$svg_paths(this.info_.startX + this.highlightOffset, this.info_.bottomRow.baseline - this.highlightOffset), this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a)), this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_));
              this.RTL_ || (a = this.info_.topRow, Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a.elements[0]) ? this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", this.outsideCornerPaths_.height) : this.steps_ += lineOnAxis$$module$build$src$core$utils$svg_paths("V", a.capline + this.highlightOffset));
            }
            drawInlineInput(a) {
              const b = this.highlightOffset, c = a.xPos + a.connectionWidth;
              var d = a.centerline - a.height / 2;
              const e = a.width - a.connectionWidth, f = d + b;
              this.RTL_ ? (d = a.connectionOffsetY - b, a = a.height - (a.connectionOffsetY + a.connectionHeight) + b, this.inlineSteps_ += moveTo$$module$build$src$core$utils$svg_paths(c - b, f) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", d) + this.puzzleTabPaths_.pathDown(this.RTL_) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a) + lineOnAxis$$module$build$src$core$utils$svg_paths("h", e)) : this.inlineSteps_ += moveTo$$module$build$src$core$utils$svg_paths(a.xPos + a.width + b, f) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", a.height) + lineOnAxis$$module$build$src$core$utils$svg_paths("h", -e) + moveTo$$module$build$src$core$utils$svg_paths(c, d + a.connectionOffsetY) + this.puzzleTabPaths_.pathDown(this.RTL_);
            }
          }, module$build$src$core$renderers$geras$highlighter = {};
          module$build$src$core$renderers$geras$highlighter.Highlighter = Highlighter$$module$build$src$core$renderers$geras$highlighter;
          var Drawer$$module$build$src$core$renderers$geras$drawer = class extends Drawer$$module$build$src$core$renderers$common$drawer {
            constructor(a, b) {
              super(a, b);
              this.highlighter_ = new Highlighter$$module$build$src$core$renderers$geras$highlighter(b);
            }
            draw() {
              this.drawOutline_();
              this.drawInternals_();
              this.updateConnectionHighlights();
              const a = this.block_.pathObject;
              a.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
              a.setHighlightPath(this.highlighter_.getPath());
              this.info_.RTL && a.flipRTL();
              this.recordSizeOnBlock_();
            }
            drawTop_() {
              this.highlighter_.drawTopCorner(this.info_.topRow);
              this.highlighter_.drawRightSideRow(this.info_.topRow);
              super.drawTop_();
            }
            drawJaggedEdge_(a) {
              this.highlighter_.drawJaggedEdge_(a);
              super.drawJaggedEdge_(a);
            }
            drawValueInput_(a) {
              this.highlighter_.drawValueInput(a);
              super.drawValueInput_(a);
            }
            drawStatementInput_(a) {
              this.highlighter_.drawStatementInput(a);
              super.drawStatementInput_(a);
            }
            drawRightSideRow_(a) {
              this.highlighter_.drawRightSideRow(a);
              this.outlinePath_ += lineOnAxis$$module$build$src$core$utils$svg_paths("H", a.xPos + a.width) + lineOnAxis$$module$build$src$core$utils$svg_paths(
                "V",
                a.yPos + a.height
              );
            }
            drawBottom_() {
              this.highlighter_.drawBottomRow(this.info_.bottomRow);
              super.drawBottom_();
            }
            drawLeft_() {
              this.highlighter_.drawLeft();
              super.drawLeft_();
            }
            drawInlineInput_(a) {
              this.highlighter_.drawInlineInput(a);
              super.drawInlineInput_(a);
            }
            positionInlineInputConnection_(a) {
              const b = a.centerline - a.height / 2;
              if (a.connectionModel) {
                let c = a.xPos + a.connectionWidth + this.constants_.DARK_PATH_OFFSET;
                this.info_.RTL && (c *= -1);
                a.connectionModel.setOffsetInBlock(c, b + a.connectionOffsetY + this.constants_.DARK_PATH_OFFSET);
              }
            }
            positionStatementInputConnection_(a) {
              const b = a.getLastInput();
              if (b == null ? 0 : b.connectionModel) {
                let c = a.xPos + a.statementEdge + b.notchOffset;
                c = this.info_.RTL ? c * -1 : c + this.constants_.DARK_PATH_OFFSET;
                b.connectionModel.setOffsetInBlock(c, a.yPos + this.constants_.DARK_PATH_OFFSET);
              }
            }
            positionExternalValueConnection_(a) {
              const b = a.getLastInput();
              if (b && b.connectionModel) {
                let c = a.xPos + a.width + this.constants_.DARK_PATH_OFFSET;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos);
              }
            }
            positionNextConnection_() {
              const a = this.info_.bottomRow;
              if (a.connection) {
                const b = a.connection, c = b.xPos;
                b.connectionModel.setOffsetInBlock((this.info_.RTL ? -c : c) + this.constants_.DARK_PATH_OFFSET / 2, a.baseline + this.constants_.DARK_PATH_OFFSET);
              }
            }
          }, module$build$src$core$renderers$geras$drawer = {};
          module$build$src$core$renderers$geras$drawer.Drawer = Drawer$$module$build$src$core$renderers$geras$drawer;
          var HighlightConstantProvider$$module$build$src$core$renderers$geras$highlight_constants = class {
            constructor(a) {
              this.OFFSET = 0.5;
              this.constantProvider = a;
              this.START_POINT = moveBy$$module$build$src$core$utils$svg_paths(this.OFFSET, this.OFFSET);
            }
            init() {
              this.INSIDE_CORNER = this.makeInsideCorner();
              this.OUTSIDE_CORNER = this.makeOutsideCorner();
              this.PUZZLE_TAB = this.makePuzzleTab();
              this.NOTCH = this.makeNotch();
              this.JAGGED_TEETH = this.makeJaggedTeeth();
              this.START_HAT = this.makeStartHat();
            }
            makeInsideCorner() {
              const a = this.constantProvider.CORNER_RADIUS, b = this.OFFSET, c = (1 - Math.SQRT1_2) * (a + b) - b, d = moveBy$$module$build$src$core$utils$svg_paths(c, c) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a, point$$module$build$src$core$utils$svg_paths(-c - b, a - c)), e = arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a + b, point$$module$build$src$core$utils$svg_paths(a + b, a + b)), f = moveBy$$module$build$src$core$utils$svg_paths(c, -c) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,0", a + b, point$$module$build$src$core$utils$svg_paths(a - c, c + b));
              return { width: a + b, height: a, pathTop(g) {
                return g ? d : "";
              }, pathBottom(g) {
                return g ? e : f;
              } };
            }
            makeOutsideCorner() {
              const a = this.constantProvider.CORNER_RADIUS, b = this.OFFSET, c = (1 - Math.SQRT1_2) * (a - b) + b, d = moveBy$$module$build$src$core$utils$svg_paths(c, c) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a - b, point$$module$build$src$core$utils$svg_paths(a - c, -c + b)), e = moveBy$$module$build$src$core$utils$svg_paths(b, a) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a - b, point$$module$build$src$core$utils$svg_paths(a, -a + b)), f = -c, g = moveBy$$module$build$src$core$utils$svg_paths(c, f) + arc$$module$build$src$core$utils$svg_paths("a", "0 0,1", a - b, point$$module$build$src$core$utils$svg_paths(-c + b, -f - a));
              return { height: a, topLeft(h) {
                return h ? d : e;
              }, bottomLeft() {
                return g;
              } };
            }
            makePuzzleTab() {
              const a = this.constantProvider.TAB_WIDTH, b = this.constantProvider.TAB_HEIGHT, c = moveBy$$module$build$src$core$utils$svg_paths(-2, -b + 2.5 + 0.9) + lineTo$$module$build$src$core$utils$svg_paths(a * -0.45, -2.1), d = lineOnAxis$$module$build$src$core$utils$svg_paths(
                "v",
                2.5
              ) + moveBy$$module$build$src$core$utils$svg_paths(-a * 0.97, 2.5) + curve$$module$build$src$core$utils$svg_paths("q", [point$$module$build$src$core$utils$svg_paths(-a * 0.05, 10), point$$module$build$src$core$utils$svg_paths(a * 0.3, 9.5)]) + moveBy$$module$build$src$core$utils$svg_paths(a * 0.67, -1.9) + lineOnAxis$$module$build$src$core$utils$svg_paths("v", 2.5), e = lineOnAxis$$module$build$src$core$utils$svg_paths("v", -1.5) + moveBy$$module$build$src$core$utils$svg_paths(a * -0.92, -0.5) + curve$$module$build$src$core$utils$svg_paths(
                "q",
                [point$$module$build$src$core$utils$svg_paths(a * -0.19, -5.5), point$$module$build$src$core$utils$svg_paths(0, -11)]
              ) + moveBy$$module$build$src$core$utils$svg_paths(a * 0.92, 1), f = moveBy$$module$build$src$core$utils$svg_paths(-5, b - 0.7) + lineTo$$module$build$src$core$utils$svg_paths(a * 0.46, -2.1);
              return { width: a, height: b, pathUp(g) {
                return g ? c : e;
              }, pathDown(g) {
                return g ? d : f;
              } };
            }
            makeNotch() {
              return { pathLeft: lineOnAxis$$module$build$src$core$utils$svg_paths("h", this.OFFSET) + this.constantProvider.NOTCH.pathLeft };
            }
            makeJaggedTeeth() {
              return { pathLeft: lineTo$$module$build$src$core$utils$svg_paths(
                5.1,
                2.6
              ) + moveBy$$module$build$src$core$utils$svg_paths(-10.2, 6.8) + lineTo$$module$build$src$core$utils$svg_paths(5.1, 2.6), height: 12, width: 10.2 };
            }
            makeStartHat() {
              const a = this.constantProvider.START_HAT.height, b = moveBy$$module$build$src$core$utils$svg_paths(25, -8.7) + curve$$module$build$src$core$utils$svg_paths("c", [point$$module$build$src$core$utils$svg_paths(29.7, -6.2), point$$module$build$src$core$utils$svg_paths(57.2, -0.5), point$$module$build$src$core$utils$svg_paths(75, 8.7)]), c = curve$$module$build$src$core$utils$svg_paths(
                "c",
                [point$$module$build$src$core$utils$svg_paths(17.8, -9.2), point$$module$build$src$core$utils$svg_paths(45.3, -14.9), point$$module$build$src$core$utils$svg_paths(75, -8.7)]
              ) + moveTo$$module$build$src$core$utils$svg_paths(100.5, a + 0.5);
              return { path(d) {
                return d ? b : c;
              } };
            }
          }, module$build$src$core$renderers$geras$highlight_constants = {};
          module$build$src$core$renderers$geras$highlight_constants.HighlightConstantProvider = HighlightConstantProvider$$module$build$src$core$renderers$geras$highlight_constants;
          var InlineInput$$module$build$src$core$renderers$geras$measurables$inline_input = class extends InlineInput$$module$build$src$core$renderers$measurables$inline_input {
            constructor(a, b) {
              super(a, b);
              this.constants_ = a;
              this.connectedBlock && (this.width += this.constants_.DARK_PATH_OFFSET, this.height += this.constants_.DARK_PATH_OFFSET);
            }
          }, module$build$src$core$renderers$geras$measurables$inline_input = {};
          module$build$src$core$renderers$geras$measurables$inline_input.InlineInput = InlineInput$$module$build$src$core$renderers$geras$measurables$inline_input;
          var StatementInput$$module$build$src$core$renderers$geras$measurables$statement_input = class extends StatementInput$$module$build$src$core$renderers$measurables$statement_input {
            constructor(a, b) {
              super(a, b);
              this.constants_ = a;
              this.connectedBlock && (this.height += this.constants_.DARK_PATH_OFFSET);
            }
          }, module$build$src$core$renderers$geras$measurables$statement_input = {};
          module$build$src$core$renderers$geras$measurables$statement_input.StatementInput = StatementInput$$module$build$src$core$renderers$geras$measurables$statement_input;
          var RenderInfo$$module$build$src$core$renderers$geras$info = class extends RenderInfo$$module$build$src$core$renderers$common$info {
            constructor(a, b) {
              super(a, b);
              this.renderer_ = a;
            }
            getRenderer() {
              return this.renderer_;
            }
            populateBottomRow_() {
              super.populateBottomRow_();
              this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1] instanceof StatementInput$$module$build$src$core$inputs$statement_input || (this.bottomRow.minHeight = this.constants_.MEDIUM_PADDING - this.constants_.DARK_PATH_OFFSET);
            }
            addInput_(a, b) {
              if (this.isInline && a instanceof $.ValueInput$$module$build$src$core$inputs$value_input) b.elements.push(new InlineInput$$module$build$src$core$renderers$geras$measurables$inline_input(this.constants_, a)), b.hasInlineInput = true;
              else if (a instanceof StatementInput$$module$build$src$core$inputs$statement_input) b.elements.push(new StatementInput$$module$build$src$core$renderers$geras$measurables$statement_input(this.constants_, a)), b.hasStatement = true;
              else if (a instanceof $.ValueInput$$module$build$src$core$inputs$value_input) b.elements.push(new ExternalValueInput$$module$build$src$core$renderers$measurables$external_value_input(
                this.constants_,
                a
              )), b.hasExternalInput = true;
              else if (a instanceof DummyInput$$module$build$src$core$inputs$dummy_input || a instanceof EndRowInput$$module$build$src$core$inputs$end_row_input) b.minHeight = Math.max(b.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT), b.hasDummyInput = true;
              this.isInline || b.align !== null || (b.align = a.align);
            }
            addElemSpacing_() {
              let a = false;
              for (let c = 0, d; d = this.rows[c]; c++) d.hasExternalInput && (a = true);
              for (let c = 0, d; d = this.rows[c]; c++) {
                var b = d.elements;
                d.elements = [];
                d.startsWithElemSpacer() && d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(
                  this.constants_,
                  this.getInRowSpacing_(null, b[0])
                ));
                if (b.length) {
                  for (let e = 0; e < b.length - 1; e++) {
                    d.elements.push(b[e]);
                    const f = this.getInRowSpacing_(b[e], b[e + 1]);
                    d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, f));
                  }
                  d.elements.push(b[b.length - 1]);
                  d.endsWithElemSpacer() && (b = this.getInRowSpacing_(b[b.length - 1], null), a && d.hasDummyInput && (b += this.constants_.TAB_WIDTH), d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(
                    this.constants_,
                    b
                  )));
                }
              }
            }
            getInRowSpacing_(a, b) {
              if (!a) return b && Types$$module$build$src$core$renderers$measurables$types.isField(b) && b.isEditable ? this.constants_.MEDIUM_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) ? this.constants_.MEDIUM_LARGE_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
              if (!Types$$module$build$src$core$renderers$measurables$types.isInput(a) && (!b || Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b))) return Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.isEditable ? a.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : Types$$module$build$src$core$renderers$measurables$types.isIcon(a) ? this.constants_.LARGE_PADDING * 2 + 1 : Types$$module$build$src$core$renderers$measurables$types.isHat(a) ? this.constants_.NO_PADDING : Types$$module$build$src$core$renderers$measurables$types.isPreviousOrNextConnection(a) ? this.constants_.LARGE_PADDING : Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) ? this.constants_.MIN_BLOCK_WIDTH : Types$$module$build$src$core$renderers$measurables$types.isJaggedEdge(a) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isInput(a) && !b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isExternalInput(a)) return this.constants_.NO_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a)) return this.constants_.LARGE_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(a)) return this.constants_.NO_PADDING;
              }
              if (!Types$$module$build$src$core$renderers$measurables$types.isInput(a) && b && Types$$module$build$src$core$renderers$measurables$types.isInput(b)) {
                if (Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.isEditable) {
                  if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) || Types$$module$build$src$core$renderers$measurables$types.isExternalInput(b)) return this.constants_.SMALL_PADDING;
                } else {
                  if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) || Types$$module$build$src$core$renderers$measurables$types.isExternalInput(b)) return this.constants_.MEDIUM_LARGE_PADDING;
                  if (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b)) return this.constants_.LARGE_PADDING;
                }
                return this.constants_.LARGE_PADDING - 1;
              }
              if (Types$$module$build$src$core$renderers$measurables$types.isIcon(a) && b && !Types$$module$build$src$core$renderers$measurables$types.isInput(b)) return this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a) && b && Types$$module$build$src$core$renderers$measurables$types.isField(b)) return b.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(a) && b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isHat(b)) return this.constants_.NO_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b)) return b.notchOffset;
                if (Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) return b.notchOffset + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;
              }
              if (Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) && b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b)) return b.notchOffset - this.constants_.CORNER_RADIUS;
                if (Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) return b.notchOffset - this.constants_.CORNER_RADIUS + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;
              }
              return Types$$module$build$src$core$renderers$measurables$types.isField(a) && b && Types$$module$build$src$core$renderers$measurables$types.isField(b) && a.isEditable === b.isEditable ? a.width === 0 ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isJaggedEdge(b) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
            }
            getSpacerRowHeight_(a, b) {
              return Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) && Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) || Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b) ? this.constants_.NO_PADDING : a.hasExternalInput && b.hasExternalInput ? this.constants_.LARGE_PADDING : !a.hasStatement && b.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : a.hasStatement && b.hasStatement || !a.hasStatement && b.hasDummyInput || a.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
            }
            getElemCenterline_(a, b) {
              if (Types$$module$build$src$core$renderers$measurables$types.isSpacer(b)) return a.yPos + b.height / 2;
              if (Types$$module$build$src$core$renderers$measurables$types.isBottomRow(a)) return a = a.yPos + a.height - a.descenderHeight, Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2;
              if (Types$$module$build$src$core$renderers$measurables$types.isTopRow(a)) return Types$$module$build$src$core$renderers$measurables$types.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2;
              let c = a.yPos;
              Types$$module$build$src$core$renderers$measurables$types.isField(b) || Types$$module$build$src$core$renderers$measurables$types.isIcon(b) ? (c += b.height / 2, (a.hasInlineInput || a.hasStatement) && b.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <= a.height && (c += this.constants_.TALL_INPUT_FIELD_OFFSET_Y)) : c = Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) ? c + b.height / 2 : c + a.height / 2;
              return c;
            }
            alignRowElements_() {
              if (this.isInline) {
                var a = 0, b = /* @__PURE__ */ new WeakMap(), c = null;
                for (let d = this.rows.length - 1, e; e = this.rows[d]; d--) b.set(e, a), Types$$module$build$src$core$renderers$measurables$types.isInputRow(e) && (e.hasStatement && this.alignStatementRow_(e), c && c.hasStatement && e.width < c.width ? b.set(e, c.width) : a = e.hasStatement ? e.width : Math.max(a, e.width), c = e);
                a = 0;
                for (let d = 0, e; e = this.rows[d]; d++) e.hasStatement ? a = this.getDesiredRowWidth_(e) : Types$$module$build$src$core$renderers$measurables$types.isSpacer(e) ? e.width = Math.max(a, b.get(e)) : (c = e.width, a = Math.max(a, b.get(e)) - c, a > 0 && this.addAlignmentPadding_(e, a), a = e.width);
              } else super.alignRowElements_();
            }
            getDesiredRowWidth_(a) {
              return this.isInline && a.hasStatement ? this.statementEdge + this.constants_.MAX_BOTTOM_WIDTH + this.startX : super.getDesiredRowWidth_(a);
            }
            finalize_() {
              let a = 0, b = 0;
              for (let d = 0, e; e = this.rows[d]; d++) {
                e.yPos = b;
                e.xPos = this.startX;
                b += e.height;
                a = Math.max(a, e.widthWithConnectedBlocks);
                var c = b - this.topRow.ascenderHeight;
                e === this.bottomRow && c < this.constants_.MIN_BLOCK_HEIGHT && (c = this.constants_.MIN_BLOCK_HEIGHT - c, this.bottomRow.height += c, b += c);
                this.recordElemPositions_(e);
              }
              this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (c = this.block_.nextConnection.targetBlock()) && (a = Math.max(a, c.getHeightWidth().width - this.constants_.DARK_PATH_OFFSET));
              this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
              this.widthWithChildren = a + this.startX + this.constants_.DARK_PATH_OFFSET;
              this.width += this.constants_.DARK_PATH_OFFSET;
              this.height = b + this.constants_.DARK_PATH_OFFSET;
              this.startY = this.topRow.capline;
            }
          }, module$build$src$core$renderers$geras$info = {};
          module$build$src$core$renderers$geras$info.RenderInfo = RenderInfo$$module$build$src$core$renderers$geras$info;
          var PathObject$$module$build$src$core$renderers$geras$path_object = class extends PathObject$$module$build$src$core$renderers$common$path_object {
            constructor(a, b, c) {
              super(a, b, c);
              this.constants = c;
              this.colourDark = "#000000";
              this.svgPathDark = createSvgElement$$module$build$src$core$utils$dom(Svg$$module$build$src$core$utils$svg.PATH, { "class": "blocklyPathDark", transform: "translate(1,1)" });
              this.svgRoot.insertBefore(this.svgPathDark, this.svgPath);
              this.svgPathLight = createSvgElement$$module$build$src$core$utils$dom(
                Svg$$module$build$src$core$utils$svg.PATH,
                { "class": "blocklyPathLight" },
                this.svgRoot
              );
            }
            setPath(a) {
              this.svgPath.setAttribute("d", a);
              this.svgPathDark.setAttribute("d", a);
            }
            setHighlightPath(a) {
              this.svgPathLight.setAttribute("d", a);
            }
            flipRTL() {
              this.svgPath.setAttribute("transform", "scale(-1 1)");
              this.svgPathLight.setAttribute("transform", "scale(-1 1)");
              this.svgPathDark.setAttribute("transform", "translate(1,1) scale(-1 1)");
            }
            applyColour(a) {
              this.svgPathLight.style.display = "";
              this.svgPathDark.style.display = "";
              if (!this.style.colourTertiary) throw Error("The renderer did not properly initialize the tertiary colour of the block style");
              this.svgPathLight.setAttribute("stroke", this.style.colourTertiary);
              this.svgPathDark.setAttribute("fill", this.colourDark);
              super.applyColour(a);
              this.svgPath.setAttribute("stroke", "none");
            }
            setStyle(a) {
              this.style = a;
              this.colourDark = blend$$module$build$src$core$utils$colour("#000", this.style.colourPrimary, 0.2) || this.colourDark;
            }
            updateHighlighted(a) {
              super.updateHighlighted(a);
              this.svgPathLight.style.display = a ? "none" : "inline";
            }
            updateShadow_(a) {
              if (a) {
                this.svgPathLight.style.display = "none";
                if (!this.style.colourSecondary) throw Error("The renderer did not properly initialize the secondary colour of the block style block style");
                this.svgPathDark.setAttribute("fill", this.style.colourSecondary);
                this.svgPath.setAttribute("stroke", "none");
                this.svgPath.setAttribute("fill", this.style.colourSecondary);
              }
            }
            updateDisabled_(a) {
              super.updateDisabled_(a);
              a && this.svgPath.setAttribute("stroke", "none");
            }
          }, module$build$src$core$renderers$geras$path_object = {};
          module$build$src$core$renderers$geras$path_object.PathObject = PathObject$$module$build$src$core$renderers$geras$path_object;
          var Renderer$$module$build$src$core$renderers$geras$renderer = class extends Renderer$$module$build$src$core$renderers$common$renderer {
            constructor(a) {
              super(a);
              this.highlightConstants = null;
            }
            init(a, b) {
              super.init(a, b);
              this.highlightConstants = this.makeHighlightConstants_();
              this.highlightConstants.init();
            }
            refreshDom(a, b, c) {
              super.refreshDom(a, b, c);
              this.getHighlightConstants().init();
            }
            makeConstants_() {
              return new ConstantProvider$$module$build$src$core$renderers$geras$constants();
            }
            makeRenderInfo_(a) {
              return new RenderInfo$$module$build$src$core$renderers$geras$info(
                this,
                a
              );
            }
            makeDrawer_(a, b) {
              return new Drawer$$module$build$src$core$renderers$geras$drawer(a, b);
            }
            makePathObject(a, b) {
              return new PathObject$$module$build$src$core$renderers$geras$path_object(a, b, this.getConstants());
            }
            makeHighlightConstants_() {
              return new HighlightConstantProvider$$module$build$src$core$renderers$geras$highlight_constants(this.getConstants());
            }
            getHighlightConstants() {
              if (!this.highlightConstants) throw Error("Cannot access the highlight constants because init has not been called");
              return this.highlightConstants;
            }
          };
          register$$module$build$src$core$renderers$common$block_rendering("geras", Renderer$$module$build$src$core$renderers$geras$renderer);
          var module$build$src$core$renderers$geras$renderer = {};
          module$build$src$core$renderers$geras$renderer.Renderer = Renderer$$module$build$src$core$renderers$geras$renderer;
          var module$build$src$core$renderers$geras$geras = {};
          module$build$src$core$renderers$geras$geras.ConstantProvider = ConstantProvider$$module$build$src$core$renderers$geras$constants;
          module$build$src$core$renderers$geras$geras.Drawer = Drawer$$module$build$src$core$renderers$geras$drawer;
          module$build$src$core$renderers$geras$geras.HighlightConstantProvider = HighlightConstantProvider$$module$build$src$core$renderers$geras$highlight_constants;
          module$build$src$core$renderers$geras$geras.Highlighter = Highlighter$$module$build$src$core$renderers$geras$highlighter;
          module$build$src$core$renderers$geras$geras.InlineInput = InlineInput$$module$build$src$core$renderers$geras$measurables$inline_input;
          module$build$src$core$renderers$geras$geras.PathObject = PathObject$$module$build$src$core$renderers$geras$path_object;
          module$build$src$core$renderers$geras$geras.RenderInfo = RenderInfo$$module$build$src$core$renderers$geras$info;
          module$build$src$core$renderers$geras$geras.Renderer = Renderer$$module$build$src$core$renderers$geras$renderer;
          module$build$src$core$renderers$geras$geras.StatementInput = StatementInput$$module$build$src$core$renderers$geras$measurables$statement_input;
          var RenderInfo$$module$build$src$core$renderers$thrasos$info = class extends RenderInfo$$module$build$src$core$renderers$common$info {
            constructor(a, b) {
              super(a, b);
            }
            getRenderer() {
              return this.renderer_;
            }
            addElemSpacing_() {
              let a = false;
              for (var b = 0; b < this.rows.length; b++) if (this.rows[b].hasExternalInput) {
                a = true;
                break;
              }
              for (b = 0; b < this.rows.length; b++) {
                const d = this.rows[b];
                var c = d.elements;
                d.elements = [];
                d.startsWithElemSpacer() && d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(
                  this.constants_,
                  this.getInRowSpacing_(null, c[0])
                ));
                if (c.length) {
                  for (let e = 0; e < c.length - 1; e++) {
                    d.elements.push(c[e]);
                    const f = this.getInRowSpacing_(c[e], c[e + 1]);
                    d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(this.constants_, f));
                  }
                  d.elements.push(c[c.length - 1]);
                  d.endsWithElemSpacer() && (c = this.getInRowSpacing_(c[c.length - 1], null), a && d.hasDummyInput && (c += this.constants_.TAB_WIDTH), d.elements.push(new InRowSpacer$$module$build$src$core$renderers$measurables$in_row_spacer(
                    this.constants_,
                    c
                  )));
                }
              }
            }
            getInRowSpacing_(a, b) {
              if (!a) return b && Types$$module$build$src$core$renderers$measurables$types.isField(b) && b.isEditable ? this.constants_.MEDIUM_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) ? this.constants_.MEDIUM_LARGE_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
              if (!Types$$module$build$src$core$renderers$measurables$types.isInput(a) && !b) return Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.isEditable ? a.width === 0 ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : Types$$module$build$src$core$renderers$measurables$types.isIcon(a) ? this.constants_.LARGE_PADDING * 2 + 1 : Types$$module$build$src$core$renderers$measurables$types.isHat(a) ? this.constants_.NO_PADDING : Types$$module$build$src$core$renderers$measurables$types.isPreviousOrNextConnection(a) ? this.constants_.LARGE_PADDING : Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) ? this.constants_.MIN_BLOCK_WIDTH : Types$$module$build$src$core$renderers$measurables$types.isJaggedEdge(a) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isInput(a) && !b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isExternalInput(a)) return this.constants_.NO_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a)) return this.constants_.LARGE_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(a)) return this.constants_.NO_PADDING;
              }
              if (!Types$$module$build$src$core$renderers$measurables$types.isInput(a) && b && Types$$module$build$src$core$renderers$measurables$types.isInput(b)) {
                if (Types$$module$build$src$core$renderers$measurables$types.isField(a) && a.isEditable) {
                  if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) || Types$$module$build$src$core$renderers$measurables$types.isExternalInput(b)) return this.constants_.SMALL_PADDING;
                } else {
                  if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(b) || Types$$module$build$src$core$renderers$measurables$types.isExternalInput(b)) return this.constants_.MEDIUM_LARGE_PADDING;
                  if (Types$$module$build$src$core$renderers$measurables$types.isStatementInput(b)) return this.constants_.LARGE_PADDING;
                }
                return this.constants_.LARGE_PADDING - 1;
              }
              if (Types$$module$build$src$core$renderers$measurables$types.isIcon(a) && b && !Types$$module$build$src$core$renderers$measurables$types.isInput(b)) return this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isInlineInput(a) && b && Types$$module$build$src$core$renderers$measurables$types.isField(b)) return b.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
              if (Types$$module$build$src$core$renderers$measurables$types.isLeftSquareCorner(a) && b) {
                if (Types$$module$build$src$core$renderers$measurables$types.isHat(b)) return this.constants_.NO_PADDING;
                if (Types$$module$build$src$core$renderers$measurables$types.isPreviousConnection(b) || Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b)) return b.notchOffset;
              }
              return Types$$module$build$src$core$renderers$measurables$types.isLeftRoundedCorner(a) && b ? b.notchOffset - this.constants_.CORNER_RADIUS : Types$$module$build$src$core$renderers$measurables$types.isField(a) && b && Types$$module$build$src$core$renderers$measurables$types.isField(b) && a.isEditable === b.isEditable ? a.width === 0 ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING : b && Types$$module$build$src$core$renderers$measurables$types.isJaggedEdge(b) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
            }
            getSpacerRowHeight_(a, b) {
              return Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) && Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : Types$$module$build$src$core$renderers$measurables$types.isTopRow(a) || Types$$module$build$src$core$renderers$measurables$types.isBottomRow(b) ? this.constants_.NO_PADDING : a.hasExternalInput && b.hasExternalInput ? this.constants_.LARGE_PADDING : !a.hasStatement && b.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : a.hasStatement && b.hasStatement || a.hasDummyInput || b.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING;
            }
            getElemCenterline_(a, b) {
              if (Types$$module$build$src$core$renderers$measurables$types.isSpacer(b)) return a.yPos + b.height / 2;
              if (Types$$module$build$src$core$renderers$measurables$types.isBottomRow(a)) return a = a.yPos + a.height - a.descenderHeight, Types$$module$build$src$core$renderers$measurables$types.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2;
              if (Types$$module$build$src$core$renderers$measurables$types.isTopRow(a)) return Types$$module$build$src$core$renderers$measurables$types.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2;
              let c = a.yPos;
              return c = Types$$module$build$src$core$renderers$measurables$types.isField(b) && a.hasStatement ? c + (this.constants_.TALL_INPUT_FIELD_OFFSET_Y + b.height / 2) : c + a.height / 2;
            }
            finalize_() {
              let a = 0, b = 0;
              for (var c = 0; c < this.rows.length; c++) {
                const e = this.rows[c];
                e.yPos = b;
                e.xPos = this.startX;
                b += e.height;
                a = Math.max(a, e.widthWithConnectedBlocks);
                var d = b - this.topRow.ascenderHeight;
                e === this.bottomRow && d < this.constants_.MIN_BLOCK_HEIGHT && (d = this.constants_.MIN_BLOCK_HEIGHT - d, this.bottomRow.height += d, b += d);
                this.recordElemPositions_(e);
              }
              this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (c = this.block_.nextConnection.targetBlock()) && (a = Math.max(a, c.getHeightWidth().width));
              this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
              this.widthWithChildren = a + this.startX;
              this.height = b;
              this.startY = this.topRow.capline;
            }
          }, module$build$src$core$renderers$thrasos$info = {};
          module$build$src$core$renderers$thrasos$info.RenderInfo = RenderInfo$$module$build$src$core$renderers$thrasos$info;
          var Renderer$$module$build$src$core$renderers$thrasos$renderer = class extends Renderer$$module$build$src$core$renderers$common$renderer {
            constructor(a) {
              super(a);
            }
            makeRenderInfo_(a) {
              return new RenderInfo$$module$build$src$core$renderers$thrasos$info(this, a);
            }
          };
          register$$module$build$src$core$renderers$common$block_rendering("thrasos", Renderer$$module$build$src$core$renderers$thrasos$renderer);
          var module$build$src$core$renderers$thrasos$renderer = {};
          module$build$src$core$renderers$thrasos$renderer.Renderer = Renderer$$module$build$src$core$renderers$thrasos$renderer;
          var module$build$src$core$renderers$thrasos$thrasos = {};
          module$build$src$core$renderers$thrasos$thrasos.RenderInfo = RenderInfo$$module$build$src$core$renderers$thrasos$info;
          module$build$src$core$renderers$thrasos$thrasos.Renderer = Renderer$$module$build$src$core$renderers$thrasos$renderer;
          var defaultBlockStyles$$module$build$src$core$theme$zelos = {
            colour_blocks: { colourPrimary: "#CF63CF", colourSecondary: "#C94FC9", colourTertiary: "#BD42BD" },
            list_blocks: { colourPrimary: "#9966FF", colourSecondary: "#855CD6", colourTertiary: "#774DCB" },
            logic_blocks: { colourPrimary: "#4C97FF", colourSecondary: "#4280D7", colourTertiary: "#3373CC" },
            loop_blocks: { colourPrimary: "#0fBD8C", colourSecondary: "#0DA57A", colourTertiary: "#0B8E69" },
            math_blocks: { colourPrimary: "#59C059", colourSecondary: "#46B946", colourTertiary: "#389438" },
            procedure_blocks: { colourPrimary: "#FF6680", colourSecondary: "#FF4D6A", colourTertiary: "#FF3355" },
            text_blocks: { colourPrimary: "#FFBF00", colourSecondary: "#E6AC00", colourTertiary: "#CC9900" },
            variable_blocks: { colourPrimary: "#FF8C1A", colourSecondary: "#FF8000", colourTertiary: "#DB6E00" },
            variable_dynamic_blocks: { colourPrimary: "#FF8C1A", colourSecondary: "#FF8000", colourTertiary: "#DB6E00" },
            hat_blocks: { colourPrimary: "#4C97FF", colourSecondary: "#4280D7", colourTertiary: "#3373CC", hat: "cap" }
          }, categoryStyles$$module$build$src$core$theme$zelos = { colour_category: { colour: "#CF63CF" }, list_category: { colour: "#9966FF" }, logic_category: { colour: "#4C97FF" }, loop_category: { colour: "#0fBD8C" }, math_category: { colour: "#59C059" }, procedure_category: { colour: "#FF6680" }, text_category: { colour: "#FFBF00" }, variable_category: { colour: "#FF8C1A" }, variable_dynamic_category: { colour: "#FF8C1A" } }, Zelos$$module$build$src$core$theme$zelos = new Theme$$module$build$src$core$theme("zelos", defaultBlockStyles$$module$build$src$core$theme$zelos, categoryStyles$$module$build$src$core$theme$zelos), module$build$src$core$theme$zelos = { Zelos: Zelos$$module$build$src$core$theme$zelos };
          var module$build$src$core$theme$themes = { Classic: Classic$$module$build$src$core$theme$classic, Zelos: Zelos$$module$build$src$core$theme$zelos };
          var ToolboxItem$$module$build$src$core$toolbox$toolbox_item = class {
            constructor(a, b, c) {
              this.id_ = a.toolboxitemid || getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.level_ = (this.parent_ = c || null) ? this.parent_.getLevel() + 1 : 0;
              this.toolboxItemDef_ = a;
              this.parentToolbox_ = b;
              this.workspace_ = this.parentToolbox_.getWorkspace();
            }
            init() {
            }
            getDiv() {
              return null;
            }
            getClickTarget() {
              return null;
            }
            getId() {
              return this.id_;
            }
            getParent() {
              return null;
            }
            getLevel() {
              return this.level_;
            }
            isSelectable() {
              return false;
            }
            isCollapsible() {
              return false;
            }
            dispose() {
            }
            setVisible_(a) {
            }
            getFocusableElement() {
              const a = this.getDiv();
              if (!a) throw Error("Trying to access toolbox item before DOM is initialized.");
              if (!(a instanceof HTMLElement)) throw Error("Toolbox item div is unexpectedly not an HTML element.");
              return a;
            }
            getFocusableTree() {
              return this.parentToolbox_;
            }
            onNodeFocus() {
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
          }, module$build$src$core$toolbox$toolbox_item = {};
          module$build$src$core$toolbox$toolbox_item.ToolboxItem = ToolboxItem$$module$build$src$core$toolbox$toolbox_item;
          var ToolboxCategory$$module$build$src$core$toolbox$category = class extends ToolboxItem$$module$build$src$core$toolbox$toolbox_item {
            constructor(a, b, c) {
              super(a, b, c);
              this.colour_ = this.name_ = "";
              this.labelDom_ = this.iconDom_ = this.rowContents_ = this.rowDiv_ = this.htmlDiv_ = null;
              this.isDisabled_ = this.isHidden_ = false;
              this.flyoutItems_ = [];
              this.cssConfig_ = this.makeDefaultCssConfig_();
            }
            init() {
              this.parseCategoryDef_(this.toolboxItemDef_);
              this.parseContents_(this.toolboxItemDef_);
              this.createDom_();
              this.toolboxItemDef_.hidden === "true" && this.hide();
            }
            makeDefaultCssConfig_() {
              return { container: "blocklyToolboxCategoryContainer", row: "blocklyToolboxCategory", rowcontentcontainer: "blocklyTreeRowContentContainer", icon: "blocklyToolboxCategoryIcon", label: "blocklyToolboxCategoryLabel", contents: "blocklyToolboxCategoryGroup", selected: "blocklyToolboxSelected", openicon: "blocklyToolboxCategoryIconOpen", closedicon: "blocklyToolboxCategoryIconClosed" };
            }
            parseContents_(a) {
              if ("custom" in a) this.flyoutItems_ = a.custom;
              else if (a = a.contents) for (let b = 0; b < a.length; b++) {
                const c = a[b];
                Array.isArray(this.flyoutItems_) && this.flyoutItems_.push(c);
              }
            }
            parseCategoryDef_(a) {
              this.name_ = "name" in a ? replaceMessageReferences$$module$build$src$core$utils$parsing(a.name) : "";
              this.colour_ = this.getColour_(a);
              Object.assign(this.cssConfig_, a.cssconfig || a.cssConfig);
            }
            createDom_() {
              this.htmlDiv_ = this.createContainer_();
              setRole$$module$build$src$core$utils$aria(this.htmlDiv_, Role$$module$build$src$core$utils$aria.TREEITEM);
              setState$$module$build$src$core$utils$aria(
                this.htmlDiv_,
                State$$module$build$src$core$utils$aria.SELECTED,
                false
              );
              setState$$module$build$src$core$utils$aria(this.htmlDiv_, State$$module$build$src$core$utils$aria.LEVEL, this.level_ + 1);
              this.rowDiv_ = this.createRowContainer_();
              this.rowDiv_.style.pointerEvents = "auto";
              this.htmlDiv_.appendChild(this.rowDiv_);
              this.rowContents_ = this.createRowContentsContainer_();
              this.rowContents_.style.pointerEvents = "none";
              this.rowDiv_.appendChild(this.rowContents_);
              this.iconDom_ = this.createIconDom_();
              setRole$$module$build$src$core$utils$aria(
                this.iconDom_,
                Role$$module$build$src$core$utils$aria.PRESENTATION
              );
              this.rowContents_.appendChild(this.iconDom_);
              this.labelDom_ = this.createLabelDom_(this.name_);
              this.rowContents_.appendChild(this.labelDom_);
              const a = this.labelDom_.getAttribute("id");
              a && setState$$module$build$src$core$utils$aria(this.htmlDiv_, State$$module$build$src$core$utils$aria.LABELLEDBY, a);
              this.addColourBorder_(this.colour_);
              return this.htmlDiv_;
            }
            createContainer_() {
              const a = document.createElement("div");
              a.tabIndex = -1;
              a.id = this.getId();
              const b = this.cssConfig_.container;
              b && addClass$$module$build$src$core$utils$dom(a, b);
              return a;
            }
            createRowContainer_() {
              const a = document.createElement("div");
              var b = this.cssConfig_.row;
              b && addClass$$module$build$src$core$utils$dom(a, b);
              b = `${ToolboxCategory$$module$build$src$core$toolbox$category.nestedPadding * this.getLevel()}px`;
              this.workspace_.RTL ? a.style.paddingRight = b : a.style.paddingLeft = b;
              return a;
            }
            createRowContentsContainer_() {
              const a = document.createElement("div"), b = this.cssConfig_.rowcontentcontainer;
              b && addClass$$module$build$src$core$utils$dom(
                a,
                b
              );
              return a;
            }
            createIconDom_() {
              const a = document.createElement("span");
              if (!this.parentToolbox_.isHorizontal()) {
                const b = this.cssConfig_.icon;
                b && addClass$$module$build$src$core$utils$dom(a, b);
              }
              a.style.display = "inline-block";
              return a;
            }
            createLabelDom_(a) {
              const b = document.createElement("span");
              b.setAttribute("id", this.getId() + ".label");
              b.textContent = a;
              (a = this.cssConfig_.label) && addClass$$module$build$src$core$utils$dom(b, a);
              return b;
            }
            refreshTheme() {
              this.colour_ = this.getColour_(this.toolboxItemDef_);
              this.addColourBorder_(this.colour_);
            }
            addColourBorder_(a) {
              a && (a = ToolboxCategory$$module$build$src$core$toolbox$category.borderWidth + "px solid " + (a || "#ddd"), this.workspace_.RTL ? this.rowDiv_.style.borderRight = a : this.rowDiv_.style.borderLeft = a);
            }
            getColour_(a) {
              const b = a.categorystyle || a.categoryStyle;
              if ((a = a.colour) && b) console.warn('Toolbox category "' + this.name_ + '" must not have both a style and a colour');
              else {
                if (b) return this.getColourfromStyle(b);
                if (a) return this.parseColour(a);
              }
              return "";
            }
            getColourfromStyle(a) {
              var b = this.workspace_.getTheme();
              if (a && b) {
                if ((b = b.categoryStyles[a]) && b.colour) return this.parseColour(b.colour);
                console.warn('Style "' + a + '" must exist and contain a colour value');
              }
              return "";
            }
            getClickTarget() {
              return this.rowDiv_;
            }
            parseColour(a) {
              a = replaceMessageReferences$$module$build$src$core$utils$parsing(a);
              if (a == null || a === "") return "";
              var b = Number(a);
              if (isNaN(b)) {
                if (b = parse$$module$build$src$core$utils$colour(a)) return b;
                console.warn('Toolbox category "' + this.name_ + '" has unrecognized colour attribute: ' + a);
                return "";
              }
              return hueToHex$$module$build$src$core$utils$colour(b);
            }
            openIcon_(a) {
              if (a) {
                var b = this.cssConfig_.closedicon;
                b && removeClasses$$module$build$src$core$utils$dom(a, b);
                (b = this.cssConfig_.openicon) && addClass$$module$build$src$core$utils$dom(a, b);
              }
            }
            closeIcon_(a) {
              if (a) {
                var b = this.cssConfig_.openicon;
                b && removeClasses$$module$build$src$core$utils$dom(a, b);
                (b = this.cssConfig_.closedicon) && addClass$$module$build$src$core$utils$dom(a, b);
              }
            }
            setVisible_(a) {
              this.htmlDiv_.style.display = a ? "block" : "none";
              this.isHidden_ = !a;
              this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection();
            }
            hide() {
              this.setVisible_(false);
            }
            show() {
              this.setVisible_(true);
            }
            isVisible() {
              return !this.isHidden_ && this.allAncestorsExpanded_();
            }
            allAncestorsExpanded_() {
              let a = this;
              for (; a.getParent(); ) if (a = a.getParent(), !a.isExpanded()) return false;
              return true;
            }
            isSelectable() {
              return this.isVisible() && !this.isDisabled_;
            }
            onClick(a) {
            }
            setSelected(a) {
              if (this.rowDiv_) {
                var b = this.cssConfig_.selected;
                if (a) {
                  const c = this.parseColour(ToolboxCategory$$module$build$src$core$toolbox$category.defaultBackgroundColour);
                  this.rowDiv_.style.backgroundColor = this.colour_ || c;
                  b && addClass$$module$build$src$core$utils$dom(this.rowDiv_, b);
                } else this.rowDiv_.style.backgroundColor = "", b && removeClass$$module$build$src$core$utils$dom(this.rowDiv_, b);
                setState$$module$build$src$core$utils$aria(this.htmlDiv_, State$$module$build$src$core$utils$aria.SELECTED, a);
              }
            }
            setDisabled(a) {
              this.isDisabled_ = a;
              this.getDiv().setAttribute("disabled", `${a}`);
              a ? this.getDiv().setAttribute("disabled", "true") : this.getDiv().removeAttribute("disabled");
            }
            getName() {
              return this.name_;
            }
            getParent() {
              return this.parent_;
            }
            getDiv() {
              return this.htmlDiv_;
            }
            getContents() {
              return this.flyoutItems_;
            }
            updateFlyoutContents(a) {
              this.flyoutItems_ = [];
              this.toolboxItemDef_ = typeof a === "string" ? { kind: this.toolboxItemDef_.kind, custom: a, id: this.toolboxItemDef_.id, categorystyle: this.toolboxItemDef_.categorystyle, colour: this.toolboxItemDef_.colour, cssconfig: this.toolboxItemDef_.cssconfig, hidden: this.toolboxItemDef_.hidden } : {
                kind: this.toolboxItemDef_.kind,
                name: "name" in this.toolboxItemDef_ ? this.toolboxItemDef_.name : "",
                contents: convertFlyoutDefToJsonArray$$module$build$src$core$utils$toolbox(a),
                id: this.toolboxItemDef_.id,
                categorystyle: this.toolboxItemDef_.categorystyle,
                colour: this.toolboxItemDef_.colour,
                cssconfig: this.toolboxItemDef_.cssconfig,
                hidden: this.toolboxItemDef_.hidden
              };
              this.parseContents_(this.toolboxItemDef_);
            }
            dispose() {
              removeNode$$module$build$src$core$utils$dom(this.htmlDiv_);
            }
          };
          ToolboxCategory$$module$build$src$core$toolbox$category.registrationName = "category";
          ToolboxCategory$$module$build$src$core$toolbox$category.nestedPadding = 19;
          ToolboxCategory$$module$build$src$core$toolbox$category.borderWidth = 8;
          ToolboxCategory$$module$build$src$core$toolbox$category.defaultBackgroundColour = "#57e";
          register$$module$build$src$core$css('\n.blocklyToolboxCategory:not(.blocklyToolboxSelected):hover {\n  background-color: rgba(255, 255, 255, .2);\n}\n\n.blocklyToolbox[layout="h"] .blocklyToolboxCategoryContainer {\n  margin: 1px 5px 1px 0;\n}\n\n.blocklyToolbox[dir="RTL"][layout="h"] .blocklyToolboxCategoryContainer {\n  margin: 1px 0 1px 5px;\n}\n\n.blocklyToolboxCategory {\n  height: 22px;\n  line-height: 22px;\n  margin-bottom: 3px;\n  padding-right: 8px;\n  white-space: nowrap;\n}\n\n.blocklyToolbox[dir="RTL"] .blocklyToolboxCategory {\n  margin-left: 8px;\n  padding-right: 0;\n}\n\n.blocklyToolboxCategoryIcon {\n  background-image: url(<<<PATH>>>/sprites.png);\n  height: 16px;\n  vertical-align: middle;\n  visibility: hidden;\n  width: 16px;\n}\n\n.blocklyToolboxCategoryIconClosed {\n  background-position: -32px -1px;\n}\n\n.blocklyToolbox[dir="RTL"] .blocklyToolboxCategoryIconClosed {\n  background-position: 0 -1px;\n}\n\n.blocklyToolboxSelected>.blocklyToolboxCategoryIconClosed {\n  background-position: -32px -17px;\n}\n\n.blocklyToolbox[dir="RTL"] .blocklyToolboxSelected>.blocklyToolboxCategoryIconClosed {\n  background-position: 0 -17px;\n}\n\n.blocklyToolboxCategoryIconOpen {\n  background-position: -16px -1px;\n}\n\n.blocklyToolboxSelected>.blocklyToolboxCategoryIconOpen {\n  background-position: -16px -17px;\n}\n\n.blocklyToolboxCategoryLabel {\n  cursor: default;\n  font: 16px sans-serif;\n  padding: 0 3px;\n  vertical-align: middle;\n}\n\n.blocklyToolboxDelete .blocklyToolboxCategoryLabel {\n  cursor: url("<<<PATH>>>/handdelete.cur"), auto;\n}\n\n.blocklyToolboxSelected .blocklyToolboxCategoryLabel {\n  color: #fff;\n}\n');
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, ToolboxCategory$$module$build$src$core$toolbox$category.registrationName, ToolboxCategory$$module$build$src$core$toolbox$category);
          var module$build$src$core$toolbox$category = {};
          module$build$src$core$toolbox$category.ToolboxCategory = ToolboxCategory$$module$build$src$core$toolbox$category;
          var ToolboxSeparator$$module$build$src$core$toolbox$separator = class extends ToolboxItem$$module$build$src$core$toolbox$toolbox_item {
            constructor(a, b) {
              super(a, b);
              this.cssConfig_ = { container: "blocklyTreeSeparator" };
              this.htmlDiv = null;
              Object.assign(this.cssConfig_, a.cssconfig || a.cssConfig);
            }
            init() {
              this.createDom_();
            }
            createDom_() {
              const a = document.createElement("div");
              a.tabIndex = -1;
              a.id = this.getId();
              const b = this.cssConfig_.container;
              b && addClass$$module$build$src$core$utils$dom(a, b);
              return this.htmlDiv = a;
            }
            getDiv() {
              return this.htmlDiv;
            }
            dispose() {
              removeNode$$module$build$src$core$utils$dom(this.htmlDiv);
            }
          };
          ToolboxSeparator$$module$build$src$core$toolbox$separator.registrationName = "sep";
          register$$module$build$src$core$css('\n.blocklyTreeSeparator {\n  border-bottom: solid #e5e5e5 1px;\n  height: 0;\n  margin: 5px 0;\n}\n\n.blocklyToolbox[layout="h"] .blocklyTreeSeparator {\n  border-right: solid #e5e5e5 1px;\n  border-bottom: none;\n  height: auto;\n  margin: 0 5px 0 5px;\n  padding: 5px 0;\n  width: 0;\n}\n');
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, ToolboxSeparator$$module$build$src$core$toolbox$separator.registrationName, ToolboxSeparator$$module$build$src$core$toolbox$separator);
          var module$build$src$core$toolbox$separator = {};
          module$build$src$core$toolbox$separator.ToolboxSeparator = ToolboxSeparator$$module$build$src$core$toolbox$separator;
          var CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category = class extends ToolboxCategory$$module$build$src$core$toolbox$category {
            constructor(a, b, c) {
              super(a, b, c);
              this.subcategoriesDiv_ = null;
              this.expanded_ = false;
              this.toolboxItems_ = [];
            }
            makeDefaultCssConfig_() {
              const a = super.makeDefaultCssConfig_();
              a.contents = "blocklyToolboxCategoryGroup";
              return a;
            }
            parseContents_(a) {
              if ("custom" in a) this.flyoutItems_ = a.custom;
              else {
                const b = a.contents;
                if (b) {
                  this.flyoutItems_ = [];
                  a = true;
                  for (let c = 0; c < b.length; c++) {
                    const d = b[c];
                    !hasItem$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, d.kind) || d.kind.toLowerCase() === ToolboxSeparator$$module$build$src$core$toolbox$separator.registrationName && a ? (this.flyoutItems_.push(d), a = true) : (this.createToolboxItem(d), a = false);
                  }
                }
              }
            }
            createToolboxItem(a) {
              let b = a.kind;
              b.toUpperCase() === "CATEGORY" && isCategoryCollapsible$$module$build$src$core$utils$toolbox(a) && (b = CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category.registrationName);
              a = new (getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, b))(a, this.parentToolbox_, this);
              this.toolboxItems_.push(a);
            }
            init() {
              super.init();
              this.setExpanded(this.toolboxItemDef_.expanded === "true" || this.toolboxItemDef_.expanded === true);
            }
            createDom_() {
              super.createDom_();
              const a = this.getChildToolboxItems();
              this.subcategoriesDiv_ = this.createSubCategoriesDom_(a);
              setRole$$module$build$src$core$utils$aria(this.subcategoriesDiv_, Role$$module$build$src$core$utils$aria.GROUP);
              this.htmlDiv_.appendChild(this.subcategoriesDiv_);
              this.closeIcon_(this.iconDom_);
              setState$$module$build$src$core$utils$aria(this.htmlDiv_, State$$module$build$src$core$utils$aria.EXPANDED, false);
              return this.htmlDiv_;
            }
            createIconDom_() {
              const a = document.createElement("span");
              if (!this.parentToolbox_.isHorizontal()) {
                const b = this.cssConfig_.icon;
                b && addClass$$module$build$src$core$utils$dom(a, b);
                a.style.visibility = "visible";
              }
              a.style.display = "inline-block";
              return a;
            }
            createSubCategoriesDom_(a) {
              const b = document.createElement("div");
              b.style.display = "none";
              var c = this.cssConfig_.contents;
              c && addClass$$module$build$src$core$utils$dom(b, c);
              for (c = 0; c < a.length; c++) {
                const d = a[c];
                d.init();
                const e = d.getDiv();
                b.appendChild(e);
                if (d.getClickTarget) {
                  let f;
                  (f = d.getClickTarget()) == null || f.setAttribute("id", d.getId());
                }
              }
              return b;
            }
            setExpanded(a) {
              if (this.expanded_ !== a) {
                if (this.expanded_ = a) this.subcategoriesDiv_.style.display = "block", this.openIcon_(this.iconDom_);
                else {
                  let b;
                  (b = this.parentToolbox_.getFlyout()) == null || b.setVisible(false);
                  this.subcategoriesDiv_.style.display = "none";
                  this.closeIcon_(this.iconDom_);
                }
                setState$$module$build$src$core$utils$aria(this.htmlDiv_, State$$module$build$src$core$utils$aria.EXPANDED, a);
                this.parentToolbox_.handleToolboxItemResize();
              }
            }
            setVisible_(a) {
              this.htmlDiv_.style.display = a ? "block" : "none";
              const b = this.getChildToolboxItems();
              for (let c = 0; c < b.length; c++) b[c].setVisible_(a);
              this.isHidden_ = !a;
              this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection();
            }
            isExpanded() {
              return this.expanded_;
            }
            isCollapsible() {
              return true;
            }
            onClick(a) {
              this.toggleExpanded();
            }
            toggleExpanded() {
              this.setExpanded(!this.expanded_);
            }
            getDiv() {
              return this.htmlDiv_;
            }
            getChildToolboxItems() {
              return this.toolboxItems_;
            }
          };
          CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category.registrationName = "collapsibleCategory";
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category.registrationName, CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category);
          var module$build$src$core$toolbox$collapsible_category = {};
          module$build$src$core$toolbox$collapsible_category.CollapsibleToolboxCategory = CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category;
          var module$build$src$core$interfaces$i_selectable_toolbox_item = {};
          module$build$src$core$interfaces$i_selectable_toolbox_item.isSelectableToolboxItem = isSelectableToolboxItem$$module$build$src$core$interfaces$i_selectable_toolbox_item;
          var Toolbox$$module$build$src$core$toolbox$toolbox = class extends DeleteArea$$module$build$src$core$delete_area {
            constructor(a) {
              super();
              this.id = "toolbox";
              this.contentsDiv_ = this.HtmlDiv = null;
              this.isVisible_ = false;
              this.height_ = this.width_ = 0;
              this.flyout = null;
              this.contents = /* @__PURE__ */ new Map();
              this.previouslySelectedItem_ = this.selectedItem_ = null;
              this.boundEvents_ = [];
              this.workspace_ = a;
              this.toolboxDef_ = a.options.languageTree || { contents: [] };
              this.horizontalLayout = a.options.horizontalLayout;
              this.RTL = a.options.RTL;
              this.toolboxPosition = a.options.toolboxPosition;
            }
            onShortcut(a) {
              return false;
            }
            init() {
              var a = this.workspace_;
              const b = a.getParentSvg();
              this.flyout = this.createFlyout_();
              this.HtmlDiv = this.createDom_(this.workspace_);
              const c = this.flyout.createDom("svg");
              addClass$$module$build$src$core$utils$dom(c, "blocklyToolboxFlyout");
              insertAfter$$module$build$src$core$utils$dom(c, b);
              this.setVisible(true);
              this.flyout.init(a);
              this.render(this.toolboxDef_);
              a = a.getThemeManager();
              a.subscribe(this.HtmlDiv, "toolboxBackgroundColour", "background-color");
              a.subscribe(
                this.HtmlDiv,
                "toolboxForegroundColour",
                "color"
              );
              this.workspace_.getComponentManager().addComponent({ component: this, weight: ComponentManager$$module$build$src$core$component_manager.ComponentWeight.TOOLBOX_WEIGHT, capabilities: [ComponentManager$$module$build$src$core$component_manager.Capability.AUTOHIDEABLE, ComponentManager$$module$build$src$core$component_manager.Capability.DELETE_AREA, ComponentManager$$module$build$src$core$component_manager.Capability.DRAG_TARGET] });
              $.getFocusManager$$module$build$src$core$focus_manager().registerTree(
                this,
                true
              );
            }
            createDom_(a) {
              a = a.getParentSvg();
              const b = this.createContainer_();
              b.id = getNextUniqueId$$module$build$src$core$utils$idgenerator();
              this.contentsDiv_ = this.createContentsContainer_();
              setRole$$module$build$src$core$utils$aria(this.contentsDiv_, Role$$module$build$src$core$utils$aria.TREE);
              b.appendChild(this.contentsDiv_);
              a.parentNode.insertBefore(b, a);
              this.attachEvents_(b, this.contentsDiv_);
              return b;
            }
            createContainer_() {
              const a = document.createElement("div");
              a.setAttribute("layout", this.isHorizontal() ? "h" : "v");
              addClass$$module$build$src$core$utils$dom(a, "blocklyToolbox");
              a.setAttribute("dir", this.RTL ? "RTL" : "LTR");
              return a;
            }
            createContentsContainer_() {
              const a = document.createElement("div");
              addClass$$module$build$src$core$utils$dom(a, "blocklyToolboxCategoryGroup");
              this.isHorizontal() && (a.style.flexDirection = "row");
              return a;
            }
            attachEvents_(a, b) {
              a = conditionalBind$$module$build$src$core$browser_events(a, "pointerdown", this, this.onClick_, false);
              this.boundEvents_.push(a);
              b = conditionalBind$$module$build$src$core$browser_events(
                b,
                "keydown",
                this,
                this.onKeyDown_,
                false
              );
              this.boundEvents_.push(b);
            }
            onClick_(a) {
              if (isRightButton$$module$build$src$core$browser_events(a) || a.target === this.HtmlDiv) getMainWorkspace$$module$build$src$core$common().hideChaff(false);
              else {
                var b = a.target.getAttribute("id");
                b && (b = this.getToolboxItemById(b), b.isSelectable() && (this.setSelectedItem(b), b.onClick(a)));
                getMainWorkspace$$module$build$src$core$common().hideChaff(true);
              }
              clearTouchIdentifier$$module$build$src$core$touch();
            }
            onKeyDown_(a) {
              let b = false;
              switch (a.key) {
                case "ArrowDown":
                  b = this.selectNext();
                  break;
                case "ArrowUp":
                  b = this.selectPrevious();
                  break;
                case "ArrowLeft":
                  b = this.selectParent();
                  break;
                case "ArrowRight":
                  b = this.selectChild();
                  break;
                case "Enter":
                case " ":
                  this.selectedItem_ && this.selectedItem_.isCollapsible() && (this.selectedItem_.toggleExpanded(), b = true);
                  break;
                default:
                  b = false;
              }
              !b && this.selectedItem_ && this.selectedItem_.onKeyDown && (b = this.selectedItem_.onKeyDown(a));
              b && a.preventDefault();
            }
            createFlyout_() {
              const a = this.workspace_, b = a.copyOptionsForFlyout();
              b.toolboxPosition = a.options.toolboxPosition;
              return new (a.horizontalLayout ? getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_HORIZONTAL_TOOLBOX, a.options, true) : getClassFromOptions$$module$build$src$core$registry(Type$$module$build$src$core$registry.FLYOUTS_VERTICAL_TOOLBOX, a.options, true))(b);
            }
            render(a) {
              this.toolboxDef_ = a;
              this.contents.forEach((b) => b.dispose());
              this.contents.clear();
              this.renderContents_(a.contents);
              this.position();
              this.handleToolboxItemResize();
            }
            renderContents_(a) {
              const b = document.createDocumentFragment();
              for (let c = 0; c < a.length; c++) this.createToolboxItem(a[c], b);
              this.contentsDiv_.appendChild(b);
            }
            createToolboxItem(a, b) {
              var c = a.kind;
              c.toUpperCase() === "CATEGORY" && isCategoryCollapsible$$module$build$src$core$utils$toolbox(a) && (c = CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category.registrationName);
              if (c = getClass$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX_ITEM, c.toLowerCase())) a = new c(a, this), a.init(), this.addToolboxItem_(a), (c = a.getDiv()) && b.appendChild(c), a.getClickTarget() && a.getClickTarget().setAttribute("id", a.getId());
            }
            addToolboxItem_(a) {
              this.contents.set(a.getId(), a);
              if (a.isCollapsible()) {
                a = a.getChildToolboxItems();
                for (let b = 0; b < a.length; b++) this.addToolboxItem_(a[b]);
              }
            }
            getToolboxItems() {
              return [...this.contents.values()];
            }
            addStyle(a) {
              a && this.HtmlDiv && addClass$$module$build$src$core$utils$dom(this.HtmlDiv, a);
            }
            removeStyle(a) {
              a && this.HtmlDiv && removeClass$$module$build$src$core$utils$dom(this.HtmlDiv, a);
            }
            getClientRect() {
              if (!this.HtmlDiv || !this.isVisible_) return null;
              var a = this.HtmlDiv.getBoundingClientRect();
              const b = a.top, c = b + a.height, d = a.left;
              a = d + a.width;
              return this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.TOP ? new Rect$$module$build$src$core$utils$rect(-1e7, c, -1e7, 1e7) : this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.BOTTOM ? new Rect$$module$build$src$core$utils$rect(b, 1e7, -1e7, 1e7) : this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.LEFT ? new Rect$$module$build$src$core$utils$rect(-1e7, 1e7, -1e7, a) : new Rect$$module$build$src$core$utils$rect(
                -1e7,
                1e7,
                d,
                1e7
              );
            }
            wouldDelete(a) {
              a instanceof BlockSvg$$module$build$src$core$block_svg ? this.updateWouldDelete_(!a.getParent() && a.isDeletable()) : this.updateWouldDelete_(isDeletable$$module$build$src$core$interfaces$i_deletable(a) && a.isDeletable());
              return this.wouldDelete_;
            }
            onDragEnter(a) {
              this.updateCursorDeleteStyle_(true);
            }
            onDragExit(a) {
              this.updateCursorDeleteStyle_(false);
            }
            onDrop(a) {
              this.updateCursorDeleteStyle_(false);
            }
            updateWouldDelete_(a) {
              a !== this.wouldDelete_ && (this.updateCursorDeleteStyle_(false), this.wouldDelete_ = a, this.updateCursorDeleteStyle_(true));
            }
            updateCursorDeleteStyle_(a) {
              const b = this.wouldDelete_ ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
              a ? this.addStyle(b) : this.removeStyle(b);
            }
            getToolboxItemById(a) {
              return this.contents.get(a) || null;
            }
            getWidth() {
              return this.width_;
            }
            getHeight() {
              return this.height_;
            }
            getFlyout() {
              return this.flyout;
            }
            getWorkspace() {
              return this.workspace_;
            }
            getSelectedItem() {
              return this.selectedItem_;
            }
            getPreviouslySelectedItem() {
              return this.previouslySelectedItem_;
            }
            isHorizontal() {
              return this.horizontalLayout;
            }
            position() {
              const a = this.workspace_.getMetrics(), b = this.HtmlDiv;
              b && (this.horizontalLayout ? (b.style.left = "0", b.style.height = "auto", b.style.width = "100%", this.height_ = b.offsetHeight, this.width_ = a.viewWidth, this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.TOP ? b.style.top = "0" : b.style.bottom = "0") : (this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.RIGHT ? b.style.right = "0" : b.style.left = "0", b.style.height = "100%", this.width_ = b.offsetWidth, this.height_ = a.viewHeight), this.flyout.position());
            }
            handleToolboxItemResize() {
              const a = this.workspace_;
              var b = this.HtmlDiv.getBoundingClientRect();
              const c = this.getFlyout(), d = this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.LEFT ? a.scrollX + b.width + ((c == null ? 0 : c.isVisible()) ? c.getWidth() : 0) : a.scrollX;
              b = this.toolboxPosition === Position$$module$build$src$core$utils$toolbox.TOP ? a.scrollY + b.height + ((c == null ? 0 : c.isVisible()) ? c.getHeight() : 0) : a.scrollY;
              a.translate(d, b);
              svgResize$$module$build$src$core$common(a);
            }
            clearSelection() {
              this.setSelectedItem(null);
            }
            refreshTheme() {
              this.contents.forEach((a) => {
                a.refreshTheme && a.refreshTheme();
              });
            }
            refreshSelection() {
              this.selectedItem_ && this.selectedItem_.isSelectable() && this.selectedItem_.getContents().length && this.flyout.show(this.selectedItem_.getContents());
            }
            setVisible(a) {
              this.isVisible_ !== a && (this.HtmlDiv.style.display = a ? "block" : "none", this.isVisible_ = a, this.workspace_.recordDragTargets());
            }
            autoHide(a) {
              !a && this.flyout && this.flyout.autoClose && this.clearSelection();
            }
            setSelectedItem(a) {
              const b = this.selectedItem_;
              !a && !b || a && !isSelectableToolboxItem$$module$build$src$core$interfaces$i_selectable_toolbox_item(a) || (this.shouldDeselectItem_(b, a) && b !== null && this.deselectItem_(b), this.shouldSelectItem_(b, a) && a !== null && this.selectItem_(b, a), this.updateFlyout_(b, a), this.fireSelectEvent(b, a));
            }
            shouldDeselectItem_(a, b) {
              return a !== null && (!a.isCollapsible() || a !== b);
            }
            shouldSelectItem_(a, b) {
              return b !== null && b !== a;
            }
            deselectItem_(a) {
              this.selectedItem_ = null;
              this.previouslySelectedItem_ = a;
              a.setSelected(false);
              setState$$module$build$src$core$utils$aria(this.contentsDiv_, State$$module$build$src$core$utils$aria.ACTIVEDESCENDANT, "");
            }
            selectItem_(a, b) {
              this.selectedItem_ = b;
              this.previouslySelectedItem_ = a;
              b.setSelected(true);
              setState$$module$build$src$core$utils$aria(this.contentsDiv_, State$$module$build$src$core$utils$aria.ACTIVEDESCENDANT, b.getId());
            }
            selectItemByPosition(a) {
              (a = this.getToolboxItems()[a]) && this.setSelectedItem(a);
            }
            updateFlyout_(a, b) {
              b && (a !== b || b.isCollapsible()) && b.getContents().length ? (this.flyout.show(b.getContents()), this.flyout.scrollToStart()) : this.flyout.hide();
            }
            fireSelectEvent(a, b) {
              const c = a && a.getName();
              let d = b && b.getName();
              a === b && (d = null);
              a = new (get$$module$build$src$core$events$utils(EventType$$module$build$src$core$events$type.TOOLBOX_ITEM_SELECT))(c, d, this.workspace_.id);
              fire$$module$build$src$core$events$utils(a);
            }
            selectParent() {
              return this.selectedItem_ ? this.selectedItem_.isCollapsible() && this.selectedItem_.isExpanded() ? (this.selectedItem_.toggleExpanded(), true) : this.selectedItem_.getParent() && this.selectedItem_.getParent().isSelectable() ? (this.setSelectedItem(this.selectedItem_.getParent()), true) : false : false;
            }
            selectChild() {
              if (!this.selectedItem_ || !this.selectedItem_.isCollapsible()) return false;
              const a = this.selectedItem_;
              a.isExpanded() ? this.selectNext() : a.toggleExpanded();
              return true;
            }
            selectNext() {
              if (!this.selectedItem_) return false;
              const a = [...this.contents.values()];
              let b = a.indexOf(this.selectedItem_) + 1;
              if (b > -1 && b < a.length) {
                let c = a[b];
                for (; c && !c.isSelectable(); ) c = a[++b];
                if (c && c.isSelectable()) return this.setSelectedItem(c), true;
              }
              return false;
            }
            selectPrevious() {
              if (!this.selectedItem_) return false;
              const a = [...this.contents.values()];
              let b = a.indexOf(this.selectedItem_) - 1;
              if (b > -1 && b < a.length) {
                let c = a[b];
                for (; c && !c.isSelectable(); ) c = a[--b];
                if (c && c.isSelectable()) return this.setSelectedItem(c), true;
              }
              return false;
            }
            dispose() {
              this.workspace_.getComponentManager().removeComponent("toolbox");
              this.flyout.dispose();
              this.contents.forEach((a) => a.dispose());
              for (let a = 0; a < this.boundEvents_.length; a++) unbind$$module$build$src$core$browser_events(this.boundEvents_[a]);
              this.boundEvents_ = [];
              this.contents.clear();
              this.HtmlDiv && (this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv), removeNode$$module$build$src$core$utils$dom(this.HtmlDiv));
              $.getFocusManager$$module$build$src$core$focus_manager().unregisterTree(this);
            }
            getFocusableElement() {
              if (!this.HtmlDiv) throw Error("Toolbox DOM has not yet been created.");
              return this.HtmlDiv;
            }
            getFocusableTree() {
              return this;
            }
            onNodeFocus() {
            }
            onNodeBlur() {
            }
            canBeFocused() {
              return true;
            }
            getRootFocusableNode() {
              return this;
            }
            getRestoredFocusableNode(a) {
              if (!a || a === this) {
                let b;
                return (b = this.getToolboxItems().find((c) => c.isSelectable())) != null ? b : null;
              }
              return null;
            }
            getNestedTrees() {
              return [];
            }
            lookUpFocusableNode(a) {
              return this.getToolboxItemById(a);
            }
            onTreeFocus(a, b) {
              a !== this ? this.getSelectedItem() !== a && this.setSelectedItem(a) : this.clearSelection();
            }
            onTreeBlur(a) {
              let b;
              a && a === ((b = this.flyout) == null ? void 0 : b.getWorkspace()) || this.autoHide(false);
            }
          };
          register$$module$build$src$core$css('\n.blocklyToolboxDelete {\n  cursor: url("<<<PATH>>>/handdelete.cur"), auto;\n}\n\n.blocklyToolboxGrab {\n  cursor: url("<<<PATH>>>/handclosed.cur"), auto;\n  cursor: grabbing;\n  cursor: -webkit-grabbing;\n}\n\n/* Category tree in Toolbox. */\n.blocklyToolbox {\n  box-sizing: border-box;\n  user-select: none;\n  -ms-user-select: none;\n  -webkit-user-select: none;\n  background-color: #ddd;\n  overflow-x: visible;\n  overflow-y: auto;\n  padding: 4px 0 4px 0;\n  position: absolute;\n  z-index: 70;  /* so blocks go under toolbox when dragging */\n  -webkit-tap-highlight-color: transparent;  /* issue #1345 */\n}\n\n.blocklyToolboxCategoryGroup {\n  display: flex;\n  flex-wrap: wrap;\n  flex-direction: column;\n}\n\n.blocklyToolboxCategoryGroup:focus {\n  outline: none;\n}\n');
          register$$module$build$src$core$registry(Type$$module$build$src$core$registry.TOOLBOX, DEFAULT$$module$build$src$core$registry, Toolbox$$module$build$src$core$toolbox$toolbox);
          var module$build$src$core$toolbox$toolbox = {};
          module$build$src$core$toolbox$toolbox.Toolbox = Toolbox$$module$build$src$core$toolbox$toolbox;
          var module$build$src$core$interfaces$i_navigation_policy = {};
          var VERSION$$module$build$src$core$blockly = "12.3.1", INPUT_VALUE$$module$build$src$core$blockly = ConnectionType$$module$build$src$core$connection_type.INPUT_VALUE, OUTPUT_VALUE$$module$build$src$core$blockly = ConnectionType$$module$build$src$core$connection_type.OUTPUT_VALUE, NEXT_STATEMENT$$module$build$src$core$blockly = ConnectionType$$module$build$src$core$connection_type.NEXT_STATEMENT, PREVIOUS_STATEMENT$$module$build$src$core$blockly = ConnectionType$$module$build$src$core$connection_type.PREVIOUS_STATEMENT, TOOLBOX_AT_TOP$$module$build$src$core$blockly = Position$$module$build$src$core$utils$toolbox.TOP, TOOLBOX_AT_BOTTOM$$module$build$src$core$blockly = Position$$module$build$src$core$utils$toolbox.BOTTOM, TOOLBOX_AT_LEFT$$module$build$src$core$blockly = Position$$module$build$src$core$utils$toolbox.LEFT, TOOLBOX_AT_RIGHT$$module$build$src$core$blockly = Position$$module$build$src$core$utils$toolbox.RIGHT, svgResize$$module$build$src$core$blockly = svgResize$$module$build$src$core$common, getMainWorkspace$$module$build$src$core$blockly = getMainWorkspace$$module$build$src$core$common, getSelected$$module$build$src$core$blockly = getSelected$$module$build$src$core$common, defineBlocksWithJsonArray$$module$build$src$core$blockly = defineBlocksWithJsonArray$$module$build$src$core$common, setParentContainer$$module$build$src$core$blockly = setParentContainer$$module$build$src$core$common, COLLAPSE_CHARS$$module$build$src$core$blockly = COLLAPSE_CHARS$$module$build$src$core$internal_constants, OPPOSITE_TYPE$$module$build$src$core$blockly = OPPOSITE_TYPE$$module$build$src$core$internal_constants, RENAME_VARIABLE_ID$$module$build$src$core$blockly = RENAME_VARIABLE_ID$$module$build$src$core$internal_constants, DELETE_VARIABLE_ID$$module$build$src$core$blockly = DELETE_VARIABLE_ID$$module$build$src$core$internal_constants, COLLAPSED_INPUT_NAME$$module$build$src$core$blockly = COLLAPSED_INPUT_NAME$$module$build$src$core$constants, COLLAPSED_FIELD_NAME$$module$build$src$core$blockly = COLLAPSED_FIELD_NAME$$module$build$src$core$constants, VARIABLE_CATEGORY_NAME$$module$build$src$core$blockly = CATEGORY_NAME$$module$build$src$core$variables, VARIABLE_DYNAMIC_CATEGORY_NAME$$module$build$src$core$blockly = CATEGORY_NAME$$module$build$src$core$variables_dynamic, PROCEDURE_CATEGORY_NAME$$module$build$src$core$blockly = CATEGORY_NAME$$module$build$src$core$procedures;
          Workspace$$module$build$src$core$workspace.prototype.newBlock = function(a, b) {
            return new Block$$module$build$src$core$block(this, a, b);
          };
          WorkspaceSvg$$module$build$src$core$workspace_svg.prototype.newBlock = function(a, b) {
            return new BlockSvg$$module$build$src$core$block_svg(this, a, b);
          };
          Workspace$$module$build$src$core$workspace.prototype.newComment = function(a) {
            return new WorkspaceComment$$module$build$src$core$comments$workspace_comment(this, a);
          };
          WorkspaceSvg$$module$build$src$core$workspace_svg.prototype.newComment = function(a) {
            return new RenderedWorkspaceComment$$module$build$src$core$comments$rendered_workspace_comment(this, a);
          };
          WorkspaceSvg$$module$build$src$core$workspace_svg.newTrashcan = function(a) {
            return new Trashcan$$module$build$src$core$trashcan(a);
          };
          MiniWorkspaceBubble$$module$build$src$core$bubbles$mini_workspace_bubble.prototype.newWorkspaceSvg = function(a) {
            return new WorkspaceSvg$$module$build$src$core$workspace_svg(a);
          };
          $.Names$$module$build$src$core$names.prototype.populateProcedures = function(a) {
            a = allProcedures$$module$build$src$core$procedures(a);
            a = a[0].concat(a[1]);
            for (let b = 0; b < a.length; b++) this.getName(a[b][0], $.Names$$module$build$src$core$names.NameType.PROCEDURE);
          };
          var DropDownDiv$$module$build$src$core$blockly = module$build$src$core$dropdowndiv, module$build$src$core$blockly = {};
          module$build$src$core$blockly.Block = Block$$module$build$src$core$block;
          module$build$src$core$blockly.BlockFlyoutInflater = BlockFlyoutInflater$$module$build$src$core$block_flyout_inflater;
          module$build$src$core$blockly.BlockNavigationPolicy = BlockNavigationPolicy$$module$build$src$core$keyboard_nav$block_navigation_policy;
          module$build$src$core$blockly.BlockSvg = BlockSvg$$module$build$src$core$block_svg;
          module$build$src$core$blockly.Blocks = Blocks$$module$build$src$core$blocks;
          module$build$src$core$blockly.ButtonFlyoutInflater = ButtonFlyoutInflater$$module$build$src$core$button_flyout_inflater;
          module$build$src$core$blockly.COLLAPSED_FIELD_NAME = COLLAPSED_FIELD_NAME$$module$build$src$core$constants;
          module$build$src$core$blockly.COLLAPSED_INPUT_NAME = COLLAPSED_INPUT_NAME$$module$build$src$core$constants;
          module$build$src$core$blockly.COLLAPSE_CHARS = COLLAPSE_CHARS$$module$build$src$core$internal_constants;
          module$build$src$core$blockly.CodeGenerator = $.CodeGenerator$$module$build$src$core$generator;
          module$build$src$core$blockly.CollapsibleToolboxCategory = CollapsibleToolboxCategory$$module$build$src$core$toolbox$collapsible_category;
          module$build$src$core$blockly.ComponentManager = ComponentManager$$module$build$src$core$component_manager;
          module$build$src$core$blockly.Connection = Connection$$module$build$src$core$connection;
          module$build$src$core$blockly.ConnectionChecker = ConnectionChecker$$module$build$src$core$connection_checker;
          module$build$src$core$blockly.ConnectionDB = ConnectionDB$$module$build$src$core$connection_db;
          module$build$src$core$blockly.ConnectionNavigationPolicy = ConnectionNavigationPolicy$$module$build$src$core$keyboard_nav$connection_navigation_policy;
          module$build$src$core$blockly.ConnectionType = ConnectionType$$module$build$src$core$connection_type;
          module$build$src$core$blockly.ContextMenu = module$build$src$core$contextmenu;
          module$build$src$core$blockly.ContextMenuItems = module$build$src$core$contextmenu_items;
          module$build$src$core$blockly.ContextMenuRegistry = ContextMenuRegistry$$module$build$src$core$contextmenu_registry;
          module$build$src$core$blockly.Css = module$build$src$core$css;
          module$build$src$core$blockly.DELETE_VARIABLE_ID = DELETE_VARIABLE_ID$$module$build$src$core$internal_constants;
          module$build$src$core$blockly.DeleteArea = DeleteArea$$module$build$src$core$delete_area;
          module$build$src$core$blockly.DragTarget = DragTarget$$module$build$src$core$drag_target;
          module$build$src$core$blockly.DropDownDiv = module$build$src$core$dropdowndiv;
          module$build$src$core$blockly.Events = module$build$src$core$events$events;
          module$build$src$core$blockly.Extensions = module$build$src$core$extensions;
          module$build$src$core$blockly.Field = Field$$module$build$src$core$field;
          module$build$src$core$blockly.FieldCheckbox = FieldCheckbox$$module$build$src$core$field_checkbox;
          module$build$src$core$blockly.FieldDropdown = FieldDropdown$$module$build$src$core$field_dropdown;
          module$build$src$core$blockly.FieldImage = FieldImage$$module$build$src$core$field_image;
          module$build$src$core$blockly.FieldLabel = FieldLabel$$module$build$src$core$field_label;
          module$build$src$core$blockly.FieldLabelSerializable = FieldLabelSerializable$$module$build$src$core$field_label_serializable;
          module$build$src$core$blockly.FieldNavigationPolicy = FieldNavigationPolicy$$module$build$src$core$keyboard_nav$field_navigation_policy;
          module$build$src$core$blockly.FieldNumber = FieldNumber$$module$build$src$core$field_number;
          module$build$src$core$blockly.FieldTextInput = $.FieldTextInput$$module$build$src$core$field_textinput;
          module$build$src$core$blockly.FieldVariable = FieldVariable$$module$build$src$core$field_variable;
          module$build$src$core$blockly.Flyout = Flyout$$module$build$src$core$flyout_base;
          module$build$src$core$blockly.FlyoutButton = FlyoutButton$$module$build$src$core$flyout_button;
          module$build$src$core$blockly.FlyoutButtonNavigationPolicy = FlyoutButtonNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_button_navigation_policy;
          module$build$src$core$blockly.FlyoutItem = FlyoutItem$$module$build$src$core$flyout_item;
          module$build$src$core$blockly.FlyoutMetricsManager = FlyoutMetricsManager$$module$build$src$core$flyout_metrics_manager;
          module$build$src$core$blockly.FlyoutNavigationPolicy = FlyoutNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_navigation_policy;
          module$build$src$core$blockly.FlyoutNavigator = FlyoutNavigator$$module$build$src$core$flyout_navigator;
          module$build$src$core$blockly.FlyoutSeparator = FlyoutSeparator$$module$build$src$core$flyout_separator;
          module$build$src$core$blockly.FlyoutSeparatorNavigationPolicy = FlyoutSeparatorNavigationPolicy$$module$build$src$core$keyboard_nav$flyout_separator_navigation_policy;
          module$build$src$core$blockly.FocusManager = FocusManager$$module$build$src$core$focus_manager;
          module$build$src$core$blockly.FocusableTreeTraverser = FocusableTreeTraverser$$module$build$src$core$utils$focusable_tree_traverser;
          module$build$src$core$blockly.Generator = $.CodeGenerator$$module$build$src$core$generator;
          module$build$src$core$blockly.Gesture = Gesture$$module$build$src$core$gesture;
          module$build$src$core$blockly.Grid = Grid$$module$build$src$core$grid;
          module$build$src$core$blockly.HorizontalFlyout = HorizontalFlyout$$module$build$src$core$flyout_horizontal;
          module$build$src$core$blockly.INPUT_VALUE = INPUT_VALUE$$module$build$src$core$blockly;
          module$build$src$core$blockly.Input = Input$$module$build$src$core$inputs$input;
          module$build$src$core$blockly.InsertionMarkerPreviewer = InsertionMarkerPreviewer$$module$build$src$core$insertion_marker_previewer;
          module$build$src$core$blockly.KeyboardNavigationController = KeyboardNavigationController$$module$build$src$core$keyboard_navigation_controller;
          module$build$src$core$blockly.LabelFlyoutInflater = LabelFlyoutInflater$$module$build$src$core$label_flyout_inflater;
          module$build$src$core$blockly.LineCursor = LineCursor$$module$build$src$core$keyboard_nav$line_cursor;
          module$build$src$core$blockly.Marker = Marker$$module$build$src$core$keyboard_nav$marker;
          module$build$src$core$blockly.MarkerManager = MarkerManager$$module$build$src$core$marker_manager;
          module$build$src$core$blockly.Menu = Menu$$module$build$src$core$menu;
          module$build$src$core$blockly.MenuItem = MenuItem$$module$build$src$core$menuitem;
          module$build$src$core$blockly.MetricsManager = MetricsManager$$module$build$src$core$metrics_manager;
          module$build$src$core$blockly.Msg = $.Msg$$module$build$src$core$msg;
          module$build$src$core$blockly.NEXT_STATEMENT = NEXT_STATEMENT$$module$build$src$core$blockly;
          module$build$src$core$blockly.Names = $.Names$$module$build$src$core$names;
          module$build$src$core$blockly.Navigator = Navigator$$module$build$src$core$navigator;
          module$build$src$core$blockly.OPPOSITE_TYPE = OPPOSITE_TYPE$$module$build$src$core$internal_constants;
          module$build$src$core$blockly.OUTPUT_VALUE = OUTPUT_VALUE$$module$build$src$core$blockly;
          module$build$src$core$blockly.Options = Options$$module$build$src$core$options;
          module$build$src$core$blockly.PREVIOUS_STATEMENT = PREVIOUS_STATEMENT$$module$build$src$core$blockly;
          module$build$src$core$blockly.PROCEDURE_CATEGORY_NAME = CATEGORY_NAME$$module$build$src$core$procedures;
          module$build$src$core$blockly.Procedures = module$build$src$core$procedures;
          module$build$src$core$blockly.RENAME_VARIABLE_ID = RENAME_VARIABLE_ID$$module$build$src$core$internal_constants;
          module$build$src$core$blockly.RenderedConnection = RenderedConnection$$module$build$src$core$rendered_connection;
          module$build$src$core$blockly.Scrollbar = Scrollbar$$module$build$src$core$scrollbar;
          module$build$src$core$blockly.ScrollbarPair = ScrollbarPair$$module$build$src$core$scrollbar_pair;
          module$build$src$core$blockly.SeparatorFlyoutInflater = SeparatorFlyoutInflater$$module$build$src$core$separator_flyout_inflater;
          module$build$src$core$blockly.ShortcutItems = module$build$src$core$shortcut_items;
          module$build$src$core$blockly.ShortcutRegistry = ShortcutRegistry$$module$build$src$core$shortcut_registry;
          module$build$src$core$blockly.TOOLBOX_AT_BOTTOM = TOOLBOX_AT_BOTTOM$$module$build$src$core$blockly;
          module$build$src$core$blockly.TOOLBOX_AT_LEFT = TOOLBOX_AT_LEFT$$module$build$src$core$blockly;
          module$build$src$core$blockly.TOOLBOX_AT_RIGHT = TOOLBOX_AT_RIGHT$$module$build$src$core$blockly;
          module$build$src$core$blockly.TOOLBOX_AT_TOP = TOOLBOX_AT_TOP$$module$build$src$core$blockly;
          module$build$src$core$blockly.Theme = Theme$$module$build$src$core$theme;
          module$build$src$core$blockly.ThemeManager = ThemeManager$$module$build$src$core$theme_manager;
          module$build$src$core$blockly.Themes = module$build$src$core$theme$themes;
          module$build$src$core$blockly.Toast = Toast$$module$build$src$core$toast;
          module$build$src$core$blockly.Toolbox = Toolbox$$module$build$src$core$toolbox$toolbox;
          module$build$src$core$blockly.ToolboxCategory = ToolboxCategory$$module$build$src$core$toolbox$category;
          module$build$src$core$blockly.ToolboxItem = ToolboxItem$$module$build$src$core$toolbox$toolbox_item;
          module$build$src$core$blockly.ToolboxSeparator = ToolboxSeparator$$module$build$src$core$toolbox$separator;
          module$build$src$core$blockly.Tooltip = module$build$src$core$tooltip;
          module$build$src$core$blockly.Touch = module$build$src$core$touch;
          module$build$src$core$blockly.Trashcan = Trashcan$$module$build$src$core$trashcan;
          module$build$src$core$blockly.UnattachedFieldError = UnattachedFieldError$$module$build$src$core$field;
          module$build$src$core$blockly.VARIABLE_CATEGORY_NAME = CATEGORY_NAME$$module$build$src$core$variables;
          module$build$src$core$blockly.VARIABLE_DYNAMIC_CATEGORY_NAME = CATEGORY_NAME$$module$build$src$core$variables_dynamic;
          module$build$src$core$blockly.VERSION = VERSION$$module$build$src$core$blockly;
          module$build$src$core$blockly.VariableMap = VariableMap$$module$build$src$core$variable_map;
          module$build$src$core$blockly.VariableModel = VariableModel$$module$build$src$core$variable_model;
          module$build$src$core$blockly.Variables = module$build$src$core$variables;
          module$build$src$core$blockly.VariablesDynamic = module$build$src$core$variables_dynamic;
          module$build$src$core$blockly.VerticalFlyout = VerticalFlyout$$module$build$src$core$flyout_vertical;
          module$build$src$core$blockly.WidgetDiv = module$build$src$core$widgetdiv;
          module$build$src$core$blockly.Workspace = Workspace$$module$build$src$core$workspace;
          module$build$src$core$blockly.WorkspaceAudio = WorkspaceAudio$$module$build$src$core$workspace_audio;
          module$build$src$core$blockly.WorkspaceDragger = WorkspaceDragger$$module$build$src$core$workspace_dragger;
          module$build$src$core$blockly.WorkspaceNavigationPolicy = WorkspaceNavigationPolicy$$module$build$src$core$keyboard_nav$workspace_navigation_policy;
          module$build$src$core$blockly.WorkspaceSvg = WorkspaceSvg$$module$build$src$core$workspace_svg;
          module$build$src$core$blockly.Xml = module$build$src$core$xml;
          module$build$src$core$blockly.ZoomControls = ZoomControls$$module$build$src$core$zoom_controls;
          module$build$src$core$blockly.blockAnimations = module$build$src$core$block_animations;
          module$build$src$core$blockly.blockRendering = module$build$src$core$renderers$common$block_rendering;
          module$build$src$core$blockly.browserEvents = module$build$src$core$browser_events;
          module$build$src$core$blockly.bubbles = module$build$src$core$bubbles;
          module$build$src$core$blockly.bumpObjects = module$build$src$core$bump_objects;
          module$build$src$core$blockly.clipboard = module$build$src$core$clipboard;
          module$build$src$core$blockly.comments = module$build$src$core$comments;
          module$build$src$core$blockly.common = module$build$src$core$common;
          module$build$src$core$blockly.config = $.config$$module$build$src$core$config;
          module$build$src$core$blockly.constants = module$build$src$core$constants;
          module$build$src$core$blockly.defineBlocksWithJsonArray = defineBlocksWithJsonArray$$module$build$src$core$common;
          module$build$src$core$blockly.dialog = module$build$src$core$dialog;
          module$build$src$core$blockly.dragging = module$build$src$core$dragging;
          module$build$src$core$blockly.fieldRegistry = module$build$src$core$field_registry;
          module$build$src$core$blockly.geras = module$build$src$core$renderers$geras$geras;
          module$build$src$core$blockly.getFocusManager = $.getFocusManager$$module$build$src$core$focus_manager;
          module$build$src$core$blockly.getMainWorkspace = getMainWorkspace$$module$build$src$core$common;
          module$build$src$core$blockly.getSelected = getSelected$$module$build$src$core$common;
          module$build$src$core$blockly.hasBubble = hasBubble$$module$build$src$core$interfaces$i_has_bubble;
          module$build$src$core$blockly.hideChaff = hideChaff$$module$build$src$core$blockly;
          module$build$src$core$blockly.icons = module$build$src$core$icons;
          module$build$src$core$blockly.inject = inject$$module$build$src$core$inject;
          module$build$src$core$blockly.inputs = module$build$src$core$inputs;
          module$build$src$core$blockly.isCopyable = isCopyable$$module$build$src$core$interfaces$i_copyable;
          module$build$src$core$blockly.isDeletable = isDeletable$$module$build$src$core$interfaces$i_deletable;
          module$build$src$core$blockly.isDraggable = isDraggable$$module$build$src$core$interfaces$i_draggable;
          module$build$src$core$blockly.isIcon = isIcon$$module$build$src$core$interfaces$i_icon;
          module$build$src$core$blockly.isObservable = isObservable$$module$build$src$core$interfaces$i_observable;
          module$build$src$core$blockly.isPaster = isPaster$$module$build$src$core$interfaces$i_paster;
          module$build$src$core$blockly.isRenderedElement = isRenderedElement$$module$build$src$core$interfaces$i_rendered_element;
          module$build$src$core$blockly.isSelectable = isSelectable$$module$build$src$core$interfaces$i_selectable;
          module$build$src$core$blockly.isSerializable = isSerializable$$module$build$src$core$interfaces$i_serializable;
          module$build$src$core$blockly.isVariableBackedParameterModel = isVariableBackedParameterModel$$module$build$src$core$interfaces$i_variable_backed_parameter_model;
          module$build$src$core$blockly.keyboardNavigationController = keyboardNavigationController$$module$build$src$core$keyboard_navigation_controller;
          module$build$src$core$blockly.layers = module$build$src$core$layers;
          module$build$src$core$blockly.navigateBlock = navigateBlock$$module$build$src$core$keyboard_nav$block_navigation_policy;
          module$build$src$core$blockly.navigateStacks = navigateStacks$$module$build$src$core$keyboard_nav$block_navigation_policy;
          module$build$src$core$blockly.procedures = module$build$src$core$procedures;
          module$build$src$core$blockly.registry = module$build$src$core$registry;
          module$build$src$core$blockly.renderManagement = module$build$src$core$render_management;
          module$build$src$core$blockly.serialization = module$build$src$core$serialization;
          module$build$src$core$blockly.setLocale = setLocale$$module$build$src$core$msg;
          module$build$src$core$blockly.setParentContainer = setParentContainer$$module$build$src$core$common;
          module$build$src$core$blockly.svgResize = svgResize$$module$build$src$core$common;
          module$build$src$core$blockly.thrasos = module$build$src$core$renderers$thrasos$thrasos;
          module$build$src$core$blockly.uiPosition = module$build$src$core$positionable_helpers;
          module$build$src$core$blockly.utils = module$build$src$core$utils;
          module$build$src$core$blockly.zelos = module$build$src$core$renderers$zelos$zelos;
          var module$build$src$core$utils$metrics = {};
          var module$build$src$core$renderers$common$i_path_object = {};
          var module$build$src$core$interfaces$i_variable_model = {};
          var module$build$src$core$interfaces$i_variable_map = {};
          var module$build$src$core$interfaces$i_toolbox_item = {};
          var module$build$src$core$interfaces$i_toolbox = {};
          var module$build$src$core$interfaces$i_styleable = {};
          var module$build$src$core$interfaces$i_serializer = {};
          var module$build$src$core$interfaces$i_registrable = {};
          var module$build$src$core$interfaces$i_procedure_model = {};
          var module$build$src$core$interfaces$i_procedure_map = {};
          var module$build$src$core$interfaces$i_positionable = {};
          var module$build$src$core$interfaces$i_parameter_model = {};
          var module$build$src$core$interfaces$i_movable = {};
          var module$build$src$core$interfaces$i_metrics_manager = {};
          var module$build$src$core$interfaces$i_keyboard_accessible = {};
          var module$build$src$core$interfaces$i_focusable_tree = {};
          module$build$src$core$interfaces$i_focusable_tree.isFocusableTree = isFocusableTree$$module$build$src$core$interfaces$i_focusable_tree;
          var module$build$src$core$interfaces$i_flyout_inflater = {};
          var module$build$src$core$interfaces$i_flyout = {};
          var module$build$src$core$interfaces$i_dragger = {};
          var module$build$src$core$interfaces$i_drag_target = {};
          var module$build$src$core$interfaces$i_delete_area = {};
          var module$build$src$core$interfaces$i_contextmenu = {};
          var module$build$src$core$interfaces$i_connection_previewer = {};
          var module$build$src$core$interfaces$i_connection_checker = {};
          var module$build$src$core$interfaces$i_component = {};
          var module$build$src$core$interfaces$i_collapsible_toolbox_item = {};
          var module$build$src$core$interfaces$i_bubble = {};
          var module$build$src$core$interfaces$i_bounded_element = {};
          module$build$src$core$blockly.__namespace__ = $;
          return module$build$src$core$blockly;
        });
      }
    });
    var require_en = __commonJS2({
      "node_modules/.pnpm/blockly@12.3.1/node_modules/blockly/msg/en.js"(exports, module) {
        (function(root2, factory) {
          if (typeof define === "function" && define.amd) {
            define([], factory);
          } else if (typeof exports === "object") {
            module.exports = factory();
          } else {
            var messages = factory();
            for (var key in messages) {
              root2.Blockly.Msg[key] = messages[key];
            }
          }
        })(exports, function() {
          "use strict";
          var Blockly2 = Blockly2 || { Msg: /* @__PURE__ */ Object.create(null) };
          Blockly2.Msg["ADD_COMMENT"] = "Add Comment";
          Blockly2.Msg["ALT_KEY"] = "Alt";
          Blockly2.Msg["CANNOT_DELETE_VARIABLE_PROCEDURE"] = "Can't delete the variable '%1' because it's part of the definition of the function '%2'";
          Blockly2.Msg["CHANGE_VALUE_TITLE"] = "Change value:";
          Blockly2.Msg["CHROME_OS"] = "ChromeOS";
          Blockly2.Msg["CLEAN_UP"] = "Clean up Blocks";
          Blockly2.Msg["CLOSE"] = "Close";
          Blockly2.Msg["COLLAPSED_WARNINGS_WARNING"] = "Collapsed blocks contain warnings.";
          Blockly2.Msg["COLLAPSE_ALL"] = "Collapse Blocks";
          Blockly2.Msg["COLLAPSE_BLOCK"] = "Collapse Block";
          Blockly2.Msg["COLOUR_BLEND_COLOUR1"] = "colour 1";
          Blockly2.Msg["COLOUR_BLEND_COLOUR2"] = "colour 2";
          Blockly2.Msg["COLOUR_BLEND_HELPURL"] = "https://meyerweb.com/eric/tools/color-blend/#:::rgbp";
          Blockly2.Msg["COLOUR_BLEND_RATIO"] = "ratio";
          Blockly2.Msg["COLOUR_BLEND_TITLE"] = "blend";
          Blockly2.Msg["COLOUR_BLEND_TOOLTIP"] = "Blends two colours together with a given ratio (0.0 - 1.0).";
          Blockly2.Msg["COLOUR_PICKER_HELPURL"] = "https://en.wikipedia.org/wiki/Color";
          Blockly2.Msg["COLOUR_PICKER_TOOLTIP"] = "Choose a colour from the palette.";
          Blockly2.Msg["COLOUR_RANDOM_HELPURL"] = "http://randomcolour.com";
          Blockly2.Msg["COLOUR_RANDOM_TITLE"] = "random colour";
          Blockly2.Msg["COLOUR_RANDOM_TOOLTIP"] = "Choose a colour at random.";
          Blockly2.Msg["COLOUR_RGB_BLUE"] = "blue";
          Blockly2.Msg["COLOUR_RGB_GREEN"] = "green";
          Blockly2.Msg["COLOUR_RGB_HELPURL"] = "https://www.december.com/html/spec/colorpercompact.html";
          Blockly2.Msg["COLOUR_RGB_RED"] = "red";
          Blockly2.Msg["COLOUR_RGB_TITLE"] = "colour with";
          Blockly2.Msg["COLOUR_RGB_TOOLTIP"] = "Create a colour with the specified amount of red, green, and blue. All values must be between 0 and 100.";
          Blockly2.Msg["COMMAND_KEY"] = "\u2318 Command";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#loop-termination-blocks";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK"] = "break out of loop";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE"] = "continue with next iteration of loop";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK"] = "Break out of the containing loop.";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE"] = "Skip the rest of this loop, and continue with the next iteration.";
          Blockly2.Msg["CONTROLS_FLOW_STATEMENTS_WARNING"] = "Warning: This block may only be used within a loop.";
          Blockly2.Msg["CONTROLS_FOREACH_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#for-each";
          Blockly2.Msg["CONTROLS_FOREACH_TITLE"] = "for each item %1 in list %2";
          Blockly2.Msg["CONTROLS_FOREACH_TOOLTIP"] = "For each item in a list, set the variable '%1' to the item, and then do some statements.";
          Blockly2.Msg["CONTROLS_FOR_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#count-with";
          Blockly2.Msg["CONTROLS_FOR_TITLE"] = "count with %1 from %2 to %3 by %4";
          Blockly2.Msg["CONTROLS_FOR_TOOLTIP"] = "Have the variable '%1' take on the values from the start number to the end number, counting by the specified interval, and do the specified blocks.";
          Blockly2.Msg["CONTROLS_IF_ELSEIF_TOOLTIP"] = "Add a condition to the if block.";
          Blockly2.Msg["CONTROLS_IF_ELSE_TOOLTIP"] = "Add a final, catch-all condition to the if block.";
          Blockly2.Msg["CONTROLS_IF_HELPURL"] = "https://github.com/google/blockly/wiki/IfElse";
          Blockly2.Msg["CONTROLS_IF_IF_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this if block.";
          Blockly2.Msg["CONTROLS_IF_MSG_ELSE"] = "else";
          Blockly2.Msg["CONTROLS_IF_MSG_ELSEIF"] = "else if";
          Blockly2.Msg["CONTROLS_IF_MSG_IF"] = "if";
          Blockly2.Msg["CONTROLS_IF_TOOLTIP_1"] = "If a value is true, then do some statements.";
          Blockly2.Msg["CONTROLS_IF_TOOLTIP_2"] = "If a value is true, then do the first block of statements. Otherwise, do the second block of statements.";
          Blockly2.Msg["CONTROLS_IF_TOOLTIP_3"] = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements.";
          Blockly2.Msg["CONTROLS_IF_TOOLTIP_4"] = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements. If none of the values are true, do the last block of statements.";
          Blockly2.Msg["CONTROLS_REPEAT_HELPURL"] = "https://en.wikipedia.org/wiki/For_loop";
          Blockly2.Msg["CONTROLS_REPEAT_INPUT_DO"] = "do";
          Blockly2.Msg["CONTROLS_REPEAT_TITLE"] = "repeat %1 times";
          Blockly2.Msg["CONTROLS_REPEAT_TOOLTIP"] = "Do some statements several times.";
          Blockly2.Msg["CONTROLS_WHILEUNTIL_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#repeat";
          Blockly2.Msg["CONTROLS_WHILEUNTIL_OPERATOR_UNTIL"] = "repeat until";
          Blockly2.Msg["CONTROLS_WHILEUNTIL_OPERATOR_WHILE"] = "repeat while";
          Blockly2.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL"] = "While a value is false, then do some statements.";
          Blockly2.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_WHILE"] = "While a value is true, then do some statements.";
          Blockly2.Msg["CONTROL_KEY"] = "Ctrl";
          Blockly2.Msg["COPY_SHORTCUT"] = "Copy";
          Blockly2.Msg["CUT_SHORTCUT"] = "Cut";
          Blockly2.Msg["DELETE_ALL_BLOCKS"] = "Delete all %1 blocks?";
          Blockly2.Msg["DELETE_BLOCK"] = "Delete Block";
          Blockly2.Msg["DELETE_VARIABLE"] = "Delete the '%1' variable";
          Blockly2.Msg["DELETE_VARIABLE_CONFIRMATION"] = "Delete %1 uses of the '%2' variable?";
          Blockly2.Msg["DELETE_X_BLOCKS"] = "Delete %1 Blocks";
          Blockly2.Msg["DIALOG_CANCEL"] = "Cancel";
          Blockly2.Msg["DIALOG_OK"] = "OK";
          Blockly2.Msg["DISABLE_BLOCK"] = "Disable Block";
          Blockly2.Msg["DUPLICATE_BLOCK"] = "Duplicate";
          Blockly2.Msg["DUPLICATE_COMMENT"] = "Duplicate Comment";
          Blockly2.Msg["EDIT_BLOCK_CONTENTS"] = "Edit Block contents";
          Blockly2.Msg["ENABLE_BLOCK"] = "Enable Block";
          Blockly2.Msg["EXPAND_ALL"] = "Expand Blocks";
          Blockly2.Msg["EXPAND_BLOCK"] = "Expand Block";
          Blockly2.Msg["EXTERNAL_INPUTS"] = "External Inputs";
          Blockly2.Msg["HELP"] = "Help";
          Blockly2.Msg["HELP_PROMPT"] = "Press %1 for help on keyboard controls";
          Blockly2.Msg["INLINE_INPUTS"] = "Inline Inputs";
          Blockly2.Msg["KEYBOARD_NAV_CONSTRAINED_MOVE_HINT"] = "Use the arrow keys to move, then %1 to accept the position";
          Blockly2.Msg["KEYBOARD_NAV_COPIED_HINT"] = "Copied. Press %1 to paste.";
          Blockly2.Msg["KEYBOARD_NAV_CUT_HINT"] = "Cut. Press %1 to paste.";
          Blockly2.Msg["KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT"] = "Hold %1 and use arrow keys to move freely, then %2 to accept the position";
          Blockly2.Msg["LINUX"] = "Linux";
          Blockly2.Msg["LISTS_CREATE_EMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-empty-list";
          Blockly2.Msg["LISTS_CREATE_EMPTY_TITLE"] = "create empty list";
          Blockly2.Msg["LISTS_CREATE_EMPTY_TOOLTIP"] = "Returns a list, of length 0, containing no data records";
          Blockly2.Msg["LISTS_CREATE_WITH_CONTAINER_TITLE_ADD"] = "list";
          Blockly2.Msg["LISTS_CREATE_WITH_CONTAINER_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this list block.";
          Blockly2.Msg["LISTS_CREATE_WITH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
          Blockly2.Msg["LISTS_CREATE_WITH_INPUT_WITH"] = "create list with";
          Blockly2.Msg["LISTS_CREATE_WITH_ITEM_TOOLTIP"] = "Add an item to the list.";
          Blockly2.Msg["LISTS_CREATE_WITH_TOOLTIP"] = "Create a list with any number of items.";
          Blockly2.Msg["LISTS_GET_INDEX_FIRST"] = "first";
          Blockly2.Msg["LISTS_GET_INDEX_FROM_END"] = "# from end";
          Blockly2.Msg["LISTS_GET_INDEX_FROM_START"] = "#";
          Blockly2.Msg["LISTS_GET_INDEX_GET"] = "get";
          Blockly2.Msg["LISTS_GET_INDEX_GET_REMOVE"] = "get and remove";
          Blockly2.Msg["LISTS_GET_INDEX_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list";
          Blockly2.Msg["LISTS_GET_INDEX_LAST"] = "last";
          Blockly2.Msg["LISTS_GET_INDEX_RANDOM"] = "random";
          Blockly2.Msg["LISTS_GET_INDEX_REMOVE"] = "remove";
          Blockly2.Msg["LISTS_GET_INDEX_TAIL"] = "";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FIRST"] = "Returns the first item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FROM"] = "Returns the item at the specified position in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_LAST"] = "Returns the last item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_RANDOM"] = "Returns a random item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST"] = "Removes and returns the first item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM"] = "Removes and returns the item at the specified position in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST"] = "Removes and returns the last item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM"] = "Removes and returns a random item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST"] = "Removes the first item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM"] = "Removes the item at the specified position in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST"] = "Removes the last item in a list.";
          Blockly2.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM"] = "Removes a random item in a list.";
          Blockly2.Msg["LISTS_GET_SUBLIST_END_FROM_END"] = "to # from end";
          Blockly2.Msg["LISTS_GET_SUBLIST_END_FROM_START"] = "to #";
          Blockly2.Msg["LISTS_GET_SUBLIST_END_LAST"] = "to last";
          Blockly2.Msg["LISTS_GET_SUBLIST_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-a-sublist";
          Blockly2.Msg["LISTS_GET_SUBLIST_START_FIRST"] = "get sub-list from first";
          Blockly2.Msg["LISTS_GET_SUBLIST_START_FROM_END"] = "get sub-list from # from end";
          Blockly2.Msg["LISTS_GET_SUBLIST_START_FROM_START"] = "get sub-list from #";
          Blockly2.Msg["LISTS_GET_SUBLIST_TAIL"] = "";
          Blockly2.Msg["LISTS_GET_SUBLIST_TOOLTIP"] = "Creates a copy of the specified portion of a list.";
          Blockly2.Msg["LISTS_INDEX_FROM_END_TOOLTIP"] = "%1 is the last item.";
          Blockly2.Msg["LISTS_INDEX_FROM_START_TOOLTIP"] = "%1 is the first item.";
          Blockly2.Msg["LISTS_INDEX_OF_FIRST"] = "find first occurrence of item";
          Blockly2.Msg["LISTS_INDEX_OF_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#finding-items-in-a-list";
          Blockly2.Msg["LISTS_INDEX_OF_LAST"] = "find last occurrence of item";
          Blockly2.Msg["LISTS_INDEX_OF_TOOLTIP"] = "Returns the index of the first/last occurrence of the item in the list. Returns %1 if item is not found.";
          Blockly2.Msg["LISTS_INLIST"] = "in list";
          Blockly2.Msg["LISTS_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#is-empty";
          Blockly2.Msg["LISTS_ISEMPTY_TITLE"] = "%1 is empty";
          Blockly2.Msg["LISTS_ISEMPTY_TOOLTIP"] = "Returns true if the list is empty.";
          Blockly2.Msg["LISTS_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#length-of";
          Blockly2.Msg["LISTS_LENGTH_TITLE"] = "length of %1";
          Blockly2.Msg["LISTS_LENGTH_TOOLTIP"] = "Returns the length of a list.";
          Blockly2.Msg["LISTS_REPEAT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
          Blockly2.Msg["LISTS_REPEAT_TITLE"] = "create list with item %1 repeated %2 times";
          Blockly2.Msg["LISTS_REPEAT_TOOLTIP"] = "Creates a list consisting of the given value repeated the specified number of times.";
          Blockly2.Msg["LISTS_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#reversing-a-list";
          Blockly2.Msg["LISTS_REVERSE_MESSAGE0"] = "reverse %1";
          Blockly2.Msg["LISTS_REVERSE_TOOLTIP"] = "Reverse a copy of a list.";
          Blockly2.Msg["LISTS_SET_INDEX_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#in-list--set";
          Blockly2.Msg["LISTS_SET_INDEX_INPUT_TO"] = "as";
          Blockly2.Msg["LISTS_SET_INDEX_INSERT"] = "insert at";
          Blockly2.Msg["LISTS_SET_INDEX_SET"] = "set";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST"] = "Inserts the item at the start of a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_FROM"] = "Inserts the item at the specified position in a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_LAST"] = "Append the item to the end of a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM"] = "Inserts the item randomly in a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_SET_FIRST"] = "Sets the first item in a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_SET_FROM"] = "Sets the item at the specified position in a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_SET_LAST"] = "Sets the last item in a list.";
          Blockly2.Msg["LISTS_SET_INDEX_TOOLTIP_SET_RANDOM"] = "Sets a random item in a list.";
          Blockly2.Msg["LISTS_SORT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#sorting-a-list";
          Blockly2.Msg["LISTS_SORT_ORDER_ASCENDING"] = "ascending";
          Blockly2.Msg["LISTS_SORT_ORDER_DESCENDING"] = "descending";
          Blockly2.Msg["LISTS_SORT_TITLE"] = "sort %1 %2 %3";
          Blockly2.Msg["LISTS_SORT_TOOLTIP"] = "Sort a copy of a list.";
          Blockly2.Msg["LISTS_SORT_TYPE_IGNORECASE"] = "alphabetic, ignore case";
          Blockly2.Msg["LISTS_SORT_TYPE_NUMERIC"] = "numeric";
          Blockly2.Msg["LISTS_SORT_TYPE_TEXT"] = "alphabetic";
          Blockly2.Msg["LISTS_SPLIT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists";
          Blockly2.Msg["LISTS_SPLIT_LIST_FROM_TEXT"] = "make list from text";
          Blockly2.Msg["LISTS_SPLIT_TEXT_FROM_LIST"] = "make text from list";
          Blockly2.Msg["LISTS_SPLIT_TOOLTIP_JOIN"] = "Join a list of texts into one text, separated by a delimiter.";
          Blockly2.Msg["LISTS_SPLIT_TOOLTIP_SPLIT"] = "Split text into a list of texts, breaking at each delimiter.";
          Blockly2.Msg["LISTS_SPLIT_WITH_DELIMITER"] = "with delimiter";
          Blockly2.Msg["LOGIC_BOOLEAN_FALSE"] = "false";
          Blockly2.Msg["LOGIC_BOOLEAN_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#values";
          Blockly2.Msg["LOGIC_BOOLEAN_TOOLTIP"] = "Returns either true or false.";
          Blockly2.Msg["LOGIC_BOOLEAN_TRUE"] = "true";
          Blockly2.Msg["LOGIC_COMPARE_HELPURL"] = "https://en.wikipedia.org/wiki/Inequality_(mathematics)";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_EQ"] = "Return true if both inputs equal each other.";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_GT"] = "Return true if the first input is greater than the second input.";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_GTE"] = "Return true if the first input is greater than or equal to the second input.";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_LT"] = "Return true if the first input is smaller than the second input.";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_LTE"] = "Return true if the first input is smaller than or equal to the second input.";
          Blockly2.Msg["LOGIC_COMPARE_TOOLTIP_NEQ"] = "Return true if both inputs are not equal to each other.";
          Blockly2.Msg["LOGIC_NEGATE_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#not";
          Blockly2.Msg["LOGIC_NEGATE_TITLE"] = "not %1";
          Blockly2.Msg["LOGIC_NEGATE_TOOLTIP"] = "Returns true if the input is false. Returns false if the input is true.";
          Blockly2.Msg["LOGIC_NULL"] = "null";
          Blockly2.Msg["LOGIC_NULL_HELPURL"] = "https://en.wikipedia.org/wiki/Nullable_type";
          Blockly2.Msg["LOGIC_NULL_TOOLTIP"] = "Returns null.";
          Blockly2.Msg["LOGIC_OPERATION_AND"] = "and";
          Blockly2.Msg["LOGIC_OPERATION_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#logical-operations";
          Blockly2.Msg["LOGIC_OPERATION_OR"] = "or";
          Blockly2.Msg["LOGIC_OPERATION_TOOLTIP_AND"] = "Return true if both inputs are true.";
          Blockly2.Msg["LOGIC_OPERATION_TOOLTIP_OR"] = "Return true if at least one of the inputs is true.";
          Blockly2.Msg["LOGIC_TERNARY_CONDITION"] = "test";
          Blockly2.Msg["LOGIC_TERNARY_HELPURL"] = "https://en.wikipedia.org/wiki/%3F:";
          Blockly2.Msg["LOGIC_TERNARY_IF_FALSE"] = "if false";
          Blockly2.Msg["LOGIC_TERNARY_IF_TRUE"] = "if true";
          Blockly2.Msg["LOGIC_TERNARY_TOOLTIP"] = "Check the condition in 'test'. If the condition is true, returns the 'if true' value; otherwise returns the 'if false' value.";
          Blockly2.Msg["MAC_OS"] = "macOS";
          Blockly2.Msg["MATH_ADDITION_SYMBOL"] = "+";
          Blockly2.Msg["MATH_ARITHMETIC_HELPURL"] = "https://en.wikipedia.org/wiki/Arithmetic";
          Blockly2.Msg["MATH_ARITHMETIC_TOOLTIP_ADD"] = "Return the sum of the two numbers.";
          Blockly2.Msg["MATH_ARITHMETIC_TOOLTIP_DIVIDE"] = "Return the quotient of the two numbers.";
          Blockly2.Msg["MATH_ARITHMETIC_TOOLTIP_MINUS"] = "Return the difference of the two numbers.";
          Blockly2.Msg["MATH_ARITHMETIC_TOOLTIP_MULTIPLY"] = "Return the product of the two numbers.";
          Blockly2.Msg["MATH_ARITHMETIC_TOOLTIP_POWER"] = "Return the first number raised to the power of the second number.";
          Blockly2.Msg["MATH_ATAN2_HELPURL"] = "https://en.wikipedia.org/wiki/Atan2";
          Blockly2.Msg["MATH_ATAN2_TITLE"] = "atan2 of X:%1 Y:%2";
          Blockly2.Msg["MATH_ATAN2_TOOLTIP"] = "Return the arctangent of point (X, Y) in degrees from -180 to 180.";
          Blockly2.Msg["MATH_CHANGE_HELPURL"] = "https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter";
          Blockly2.Msg["MATH_CHANGE_TITLE"] = "change %1 by %2";
          Blockly2.Msg["MATH_CHANGE_TOOLTIP"] = "Add a number to variable '%1'.";
          Blockly2.Msg["MATH_CONSTANT_HELPURL"] = "https://en.wikipedia.org/wiki/Mathematical_constant";
          Blockly2.Msg["MATH_CONSTANT_TOOLTIP"] = "Return one of the common constants: \u03C0 (3.141\u2026), e (2.718\u2026), \u03C6 (1.618\u2026), sqrt(2) (1.414\u2026), sqrt(\xBD) (0.707\u2026), or \u221E (infinity).";
          Blockly2.Msg["MATH_CONSTRAIN_HELPURL"] = "https://en.wikipedia.org/wiki/Clamping_(graphics)";
          Blockly2.Msg["MATH_CONSTRAIN_TITLE"] = "constrain %1 low %2 high %3";
          Blockly2.Msg["MATH_CONSTRAIN_TOOLTIP"] = "Constrain a number to be between the specified limits (inclusive).";
          Blockly2.Msg["MATH_DIVISION_SYMBOL"] = "\xF7";
          Blockly2.Msg["MATH_IS_DIVISIBLE_BY"] = "is divisible by";
          Blockly2.Msg["MATH_IS_EVEN"] = "is even";
          Blockly2.Msg["MATH_IS_NEGATIVE"] = "is negative";
          Blockly2.Msg["MATH_IS_ODD"] = "is odd";
          Blockly2.Msg["MATH_IS_POSITIVE"] = "is positive";
          Blockly2.Msg["MATH_IS_PRIME"] = "is prime";
          Blockly2.Msg["MATH_IS_TOOLTIP"] = "Check if a number is an even, odd, prime, whole, positive, negative, or if it is divisible by certain number. Returns true or false.";
          Blockly2.Msg["MATH_IS_WHOLE"] = "is whole";
          Blockly2.Msg["MATH_MODULO_HELPURL"] = "https://en.wikipedia.org/wiki/Modulo_operation";
          Blockly2.Msg["MATH_MODULO_TITLE"] = "remainder of %1 \xF7 %2";
          Blockly2.Msg["MATH_MODULO_TOOLTIP"] = "Return the remainder from dividing the two numbers.";
          Blockly2.Msg["MATH_MULTIPLICATION_SYMBOL"] = "\xD7";
          Blockly2.Msg["MATH_NUMBER_HELPURL"] = "https://en.wikipedia.org/wiki/Number";
          Blockly2.Msg["MATH_NUMBER_TOOLTIP"] = "A number.";
          Blockly2.Msg["MATH_ONLIST_HELPURL"] = "";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_AVERAGE"] = "average of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_MAX"] = "max of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_MEDIAN"] = "median of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_MIN"] = "min of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_MODE"] = "modes of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_RANDOM"] = "random item of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_STD_DEV"] = "standard deviation of list";
          Blockly2.Msg["MATH_ONLIST_OPERATOR_SUM"] = "sum of list";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_AVERAGE"] = "Return the average (arithmetic mean) of the numeric values in the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_MAX"] = "Return the largest number in the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_MEDIAN"] = "Return the median number in the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_MIN"] = "Return the smallest number in the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_MODE"] = "Return a list of the most common item(s) in the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_RANDOM"] = "Return a random element from the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_STD_DEV"] = "Return the standard deviation of the list.";
          Blockly2.Msg["MATH_ONLIST_TOOLTIP_SUM"] = "Return the sum of all the numbers in the list.";
          Blockly2.Msg["MATH_POWER_SYMBOL"] = "^";
          Blockly2.Msg["MATH_RANDOM_FLOAT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
          Blockly2.Msg["MATH_RANDOM_FLOAT_TITLE_RANDOM"] = "random fraction";
          Blockly2.Msg["MATH_RANDOM_FLOAT_TOOLTIP"] = "Return a random fraction between 0.0 (inclusive) and 1.0 (exclusive).";
          Blockly2.Msg["MATH_RANDOM_INT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
          Blockly2.Msg["MATH_RANDOM_INT_TITLE"] = "random integer from %1 to %2";
          Blockly2.Msg["MATH_RANDOM_INT_TOOLTIP"] = "Return a random integer between the two specified limits, inclusive.";
          Blockly2.Msg["MATH_ROUND_HELPURL"] = "https://en.wikipedia.org/wiki/Rounding";
          Blockly2.Msg["MATH_ROUND_OPERATOR_ROUND"] = "round";
          Blockly2.Msg["MATH_ROUND_OPERATOR_ROUNDDOWN"] = "round down";
          Blockly2.Msg["MATH_ROUND_OPERATOR_ROUNDUP"] = "round up";
          Blockly2.Msg["MATH_ROUND_TOOLTIP"] = "Round a number up or down.";
          Blockly2.Msg["MATH_SINGLE_HELPURL"] = "https://en.wikipedia.org/wiki/Square_root";
          Blockly2.Msg["MATH_SINGLE_OP_ABSOLUTE"] = "absolute";
          Blockly2.Msg["MATH_SINGLE_OP_ROOT"] = "square root";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_ABS"] = "Return the absolute value of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_EXP"] = "Return e to the power of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_LN"] = "Return the natural logarithm of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_LOG10"] = "Return the base 10 logarithm of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_NEG"] = "Return the negation of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_POW10"] = "Return 10 to the power of a number.";
          Blockly2.Msg["MATH_SINGLE_TOOLTIP_ROOT"] = "Return the square root of a number.";
          Blockly2.Msg["MATH_SUBTRACTION_SYMBOL"] = "-";
          Blockly2.Msg["MATH_TRIG_ACOS"] = "acos";
          Blockly2.Msg["MATH_TRIG_ASIN"] = "asin";
          Blockly2.Msg["MATH_TRIG_ATAN"] = "atan";
          Blockly2.Msg["MATH_TRIG_COS"] = "cos";
          Blockly2.Msg["MATH_TRIG_HELPURL"] = "https://en.wikipedia.org/wiki/Trigonometric_functions";
          Blockly2.Msg["MATH_TRIG_SIN"] = "sin";
          Blockly2.Msg["MATH_TRIG_TAN"] = "tan";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_ACOS"] = "Return the arccosine of a number.";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_ASIN"] = "Return the arcsine of a number.";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_ATAN"] = "Return the arctangent of a number.";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_COS"] = "Return the cosine of a degree (not radian).";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_SIN"] = "Return the sine of a degree (not radian).";
          Blockly2.Msg["MATH_TRIG_TOOLTIP_TAN"] = "Return the tangent of a degree (not radian).";
          Blockly2.Msg["MOVE_BLOCK"] = "Move Block";
          Blockly2.Msg["NEW_COLOUR_VARIABLE"] = "Create colour variable...";
          Blockly2.Msg["NEW_NUMBER_VARIABLE"] = "Create number variable...";
          Blockly2.Msg["NEW_STRING_VARIABLE"] = "Create string variable...";
          Blockly2.Msg["NEW_VARIABLE"] = "Create variable...";
          Blockly2.Msg["NEW_VARIABLE_TITLE"] = "New variable name:";
          Blockly2.Msg["NEW_VARIABLE_TYPE_TITLE"] = "New variable type:";
          Blockly2.Msg["OPTION_KEY"] = "\u2325 Option";
          Blockly2.Msg["ORDINAL_NUMBER_SUFFIX"] = "";
          Blockly2.Msg["PASTE_SHORTCUT"] = "Paste";
          Blockly2.Msg["PROCEDURES_ALLOW_STATEMENTS"] = "allow statements";
          Blockly2.Msg["PROCEDURES_BEFORE_PARAMS"] = "with:";
          Blockly2.Msg["PROCEDURES_CALLNORETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
          Blockly2.Msg["PROCEDURES_CALLNORETURN_TOOLTIP"] = "Run the user-defined function '%1'.";
          Blockly2.Msg["PROCEDURES_CALLRETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
          Blockly2.Msg["PROCEDURES_CALLRETURN_TOOLTIP"] = "Run the user-defined function '%1' and use its output.";
          Blockly2.Msg["PROCEDURES_CALL_BEFORE_PARAMS"] = "with:";
          Blockly2.Msg["PROCEDURES_CALL_DISABLED_DEF_WARNING"] = "Can't run the user-defined function '%1' because the definition block is disabled.";
          Blockly2.Msg["PROCEDURES_CREATE_DO"] = "Create '%1'";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_COMMENT"] = "Describe this function...";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_DO"] = "";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"] = "do something";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_TITLE"] = "to";
          Blockly2.Msg["PROCEDURES_DEFNORETURN_TOOLTIP"] = "Creates a function with no output.";
          Blockly2.Msg["PROCEDURES_DEFRETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
          Blockly2.Msg["PROCEDURES_DEFRETURN_RETURN"] = "return";
          Blockly2.Msg["PROCEDURES_DEFRETURN_TOOLTIP"] = "Creates a function with an output.";
          Blockly2.Msg["PROCEDURES_DEF_DUPLICATE_WARNING"] = "Warning: This function has duplicate parameters.";
          Blockly2.Msg["PROCEDURES_HIGHLIGHT_DEF"] = "Highlight function definition";
          Blockly2.Msg["PROCEDURES_IFRETURN_HELPURL"] = "https://c2.com/cgi/wiki?GuardClause";
          Blockly2.Msg["PROCEDURES_IFRETURN_TOOLTIP"] = "If a value is true, then return a second value.";
          Blockly2.Msg["PROCEDURES_IFRETURN_WARNING"] = "Warning: This block may be used only within a function definition.";
          Blockly2.Msg["PROCEDURES_MUTATORARG_TITLE"] = "input name:";
          Blockly2.Msg["PROCEDURES_MUTATORARG_TOOLTIP"] = "Add an input to the function.";
          Blockly2.Msg["PROCEDURES_MUTATORCONTAINER_TITLE"] = "inputs";
          Blockly2.Msg["PROCEDURES_MUTATORCONTAINER_TOOLTIP"] = "Add, remove, or reorder inputs to this function.";
          Blockly2.Msg["REDO"] = "Redo";
          Blockly2.Msg["REMOVE_COMMENT"] = "Remove Comment";
          Blockly2.Msg["RENAME_VARIABLE"] = "Rename variable...";
          Blockly2.Msg["RENAME_VARIABLE_TITLE"] = "Rename all '%1' variables to:";
          Blockly2.Msg["SHORTCUTS_CODE_NAVIGATION"] = "Code navigation";
          Blockly2.Msg["SHORTCUTS_EDITING"] = "Editing";
          Blockly2.Msg["SHORTCUTS_GENERAL"] = "General";
          Blockly2.Msg["TEXT_APPEND_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
          Blockly2.Msg["TEXT_APPEND_TITLE"] = "to %1 append text %2";
          Blockly2.Msg["TEXT_APPEND_TOOLTIP"] = "Append some text to variable '%1'.";
          Blockly2.Msg["TEXT_CHANGECASE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#adjusting-text-case";
          Blockly2.Msg["TEXT_CHANGECASE_OPERATOR_LOWERCASE"] = "to lower case";
          Blockly2.Msg["TEXT_CHANGECASE_OPERATOR_TITLECASE"] = "to Title Case";
          Blockly2.Msg["TEXT_CHANGECASE_OPERATOR_UPPERCASE"] = "to UPPER CASE";
          Blockly2.Msg["TEXT_CHANGECASE_TOOLTIP"] = "Return a copy of the text in a different case.";
          Blockly2.Msg["TEXT_CHARAT_FIRST"] = "get first letter";
          Blockly2.Msg["TEXT_CHARAT_FROM_END"] = "get letter # from end";
          Blockly2.Msg["TEXT_CHARAT_FROM_START"] = "get letter #";
          Blockly2.Msg["TEXT_CHARAT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-text";
          Blockly2.Msg["TEXT_CHARAT_LAST"] = "get last letter";
          Blockly2.Msg["TEXT_CHARAT_RANDOM"] = "get random letter";
          Blockly2.Msg["TEXT_CHARAT_TAIL"] = "";
          Blockly2.Msg["TEXT_CHARAT_TITLE"] = "in text %1 %2";
          Blockly2.Msg["TEXT_CHARAT_TOOLTIP"] = "Returns the letter at the specified position.";
          Blockly2.Msg["TEXT_COUNT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#counting-substrings";
          Blockly2.Msg["TEXT_COUNT_MESSAGE0"] = "count %1 in %2";
          Blockly2.Msg["TEXT_COUNT_TOOLTIP"] = "Count how many times some text occurs within some other text.";
          Blockly2.Msg["TEXT_CREATE_JOIN_ITEM_TOOLTIP"] = "Add an item to the text.";
          Blockly2.Msg["TEXT_CREATE_JOIN_TITLE_JOIN"] = "join";
          Blockly2.Msg["TEXT_CREATE_JOIN_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this text block.";
          Blockly2.Msg["TEXT_GET_SUBSTRING_END_FROM_END"] = "to letter # from end";
          Blockly2.Msg["TEXT_GET_SUBSTRING_END_FROM_START"] = "to letter #";
          Blockly2.Msg["TEXT_GET_SUBSTRING_END_LAST"] = "to last letter";
          Blockly2.Msg["TEXT_GET_SUBSTRING_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text";
          Blockly2.Msg["TEXT_GET_SUBSTRING_INPUT_IN_TEXT"] = "in text";
          Blockly2.Msg["TEXT_GET_SUBSTRING_START_FIRST"] = "get substring from first letter";
          Blockly2.Msg["TEXT_GET_SUBSTRING_START_FROM_END"] = "get substring from letter # from end";
          Blockly2.Msg["TEXT_GET_SUBSTRING_START_FROM_START"] = "get substring from letter #";
          Blockly2.Msg["TEXT_GET_SUBSTRING_TAIL"] = "";
          Blockly2.Msg["TEXT_GET_SUBSTRING_TOOLTIP"] = "Returns a specified portion of the text.";
          Blockly2.Msg["TEXT_INDEXOF_HELPURL"] = "https://github.com/google/blockly/wiki/Text#finding-text";
          Blockly2.Msg["TEXT_INDEXOF_OPERATOR_FIRST"] = "find first occurrence of text";
          Blockly2.Msg["TEXT_INDEXOF_OPERATOR_LAST"] = "find last occurrence of text";
          Blockly2.Msg["TEXT_INDEXOF_TITLE"] = "in text %1 %2 %3";
          Blockly2.Msg["TEXT_INDEXOF_TOOLTIP"] = "Returns the index of the first/last occurrence of the first text in the second text. Returns %1 if text is not found.";
          Blockly2.Msg["TEXT_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Text#checking-for-empty-text";
          Blockly2.Msg["TEXT_ISEMPTY_TITLE"] = "%1 is empty";
          Blockly2.Msg["TEXT_ISEMPTY_TOOLTIP"] = "Returns true if the provided text is empty.";
          Blockly2.Msg["TEXT_JOIN_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-creation";
          Blockly2.Msg["TEXT_JOIN_TITLE_CREATEWITH"] = "create text with";
          Blockly2.Msg["TEXT_JOIN_TOOLTIP"] = "Create a piece of text by joining together any number of items.";
          Blockly2.Msg["TEXT_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
          Blockly2.Msg["TEXT_LENGTH_TITLE"] = "length of %1";
          Blockly2.Msg["TEXT_LENGTH_TOOLTIP"] = "Returns the number of letters (including spaces) in the provided text.";
          Blockly2.Msg["TEXT_PRINT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#printing-text";
          Blockly2.Msg["TEXT_PRINT_TITLE"] = "print %1";
          Blockly2.Msg["TEXT_PRINT_TOOLTIP"] = "Print the specified text, number or other value.";
          Blockly2.Msg["TEXT_PROMPT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#getting-input-from-the-user";
          Blockly2.Msg["TEXT_PROMPT_TOOLTIP_NUMBER"] = "Prompt for user for a number.";
          Blockly2.Msg["TEXT_PROMPT_TOOLTIP_TEXT"] = "Prompt for user for some text.";
          Blockly2.Msg["TEXT_PROMPT_TYPE_NUMBER"] = "prompt for number with message";
          Blockly2.Msg["TEXT_PROMPT_TYPE_TEXT"] = "prompt for text with message";
          Blockly2.Msg["TEXT_REPLACE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#replacing-substrings";
          Blockly2.Msg["TEXT_REPLACE_MESSAGE0"] = "replace %1 with %2 in %3";
          Blockly2.Msg["TEXT_REPLACE_TOOLTIP"] = "Replace all occurances of some text within some other text.";
          Blockly2.Msg["TEXT_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#reversing-text";
          Blockly2.Msg["TEXT_REVERSE_MESSAGE0"] = "reverse %1";
          Blockly2.Msg["TEXT_REVERSE_TOOLTIP"] = "Reverses the order of the characters in the text.";
          Blockly2.Msg["TEXT_TEXT_HELPURL"] = "https://en.wikipedia.org/wiki/String_(computer_science)";
          Blockly2.Msg["TEXT_TEXT_TOOLTIP"] = "A letter, word, or line of text.";
          Blockly2.Msg["TEXT_TRIM_HELPURL"] = "https://github.com/google/blockly/wiki/Text#trimming-removing-spaces";
          Blockly2.Msg["TEXT_TRIM_OPERATOR_BOTH"] = "trim spaces from both sides of";
          Blockly2.Msg["TEXT_TRIM_OPERATOR_LEFT"] = "trim spaces from left side of";
          Blockly2.Msg["TEXT_TRIM_OPERATOR_RIGHT"] = "trim spaces from right side of";
          Blockly2.Msg["TEXT_TRIM_TOOLTIP"] = "Return a copy of the text with spaces removed from one or both ends.";
          Blockly2.Msg["TODAY"] = "Today";
          Blockly2.Msg["UNDO"] = "Undo";
          Blockly2.Msg["UNKNOWN"] = "Unknown";
          Blockly2.Msg["UNNAMED_KEY"] = "unnamed";
          Blockly2.Msg["VARIABLES_DEFAULT_NAME"] = "item";
          Blockly2.Msg["VARIABLES_GET_CREATE_SET"] = "Create 'set %1'";
          Blockly2.Msg["VARIABLES_GET_HELPURL"] = "https://github.com/google/blockly/wiki/Variables#get";
          Blockly2.Msg["VARIABLES_GET_TOOLTIP"] = "Returns the value of this variable.";
          Blockly2.Msg["VARIABLES_SET"] = "set %1 to %2";
          Blockly2.Msg["VARIABLES_SET_CREATE_GET"] = "Create 'get %1'";
          Blockly2.Msg["VARIABLES_SET_HELPURL"] = "https://github.com/google/blockly/wiki/Variables#set";
          Blockly2.Msg["VARIABLES_SET_TOOLTIP"] = "Sets this variable to be equal to the input.";
          Blockly2.Msg["VARIABLE_ALREADY_EXISTS"] = "A variable named '%1' already exists.";
          Blockly2.Msg["VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"] = "A variable named '%1' already exists for another type: '%2'.";
          Blockly2.Msg["VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER"] = "A variable named '%1' already exists as a parameter in the procedure '%2'.";
          Blockly2.Msg["WINDOWS"] = "Windows";
          Blockly2.Msg["WORKSPACE_ARIA_LABEL"] = "Blockly Workspace";
          Blockly2.Msg["WORKSPACE_COMMENT_DEFAULT_TEXT"] = "Say something...";
          Blockly2.Msg["CONTROLS_FOREACH_INPUT_DO"] = Blockly2.Msg["CONTROLS_REPEAT_INPUT_DO"];
          Blockly2.Msg["CONTROLS_FOR_INPUT_DO"] = Blockly2.Msg["CONTROLS_REPEAT_INPUT_DO"];
          Blockly2.Msg["CONTROLS_IF_ELSEIF_TITLE_ELSEIF"] = Blockly2.Msg["CONTROLS_IF_MSG_ELSEIF"];
          Blockly2.Msg["CONTROLS_IF_ELSE_TITLE_ELSE"] = Blockly2.Msg["CONTROLS_IF_MSG_ELSE"];
          Blockly2.Msg["CONTROLS_IF_IF_TITLE_IF"] = Blockly2.Msg["CONTROLS_IF_MSG_IF"];
          Blockly2.Msg["CONTROLS_IF_MSG_THEN"] = Blockly2.Msg["CONTROLS_REPEAT_INPUT_DO"];
          Blockly2.Msg["CONTROLS_WHILEUNTIL_INPUT_DO"] = Blockly2.Msg["CONTROLS_REPEAT_INPUT_DO"];
          Blockly2.Msg["LISTS_CREATE_WITH_ITEM_TITLE"] = Blockly2.Msg["VARIABLES_DEFAULT_NAME"];
          Blockly2.Msg["LISTS_GET_INDEX_INPUT_IN_LIST"] = Blockly2.Msg["LISTS_INLIST"];
          Blockly2.Msg["LISTS_GET_SUBLIST_INPUT_IN_LIST"] = Blockly2.Msg["LISTS_INLIST"];
          Blockly2.Msg["LISTS_INDEX_OF_INPUT_IN_LIST"] = Blockly2.Msg["LISTS_INLIST"];
          Blockly2.Msg["LISTS_SET_INDEX_INPUT_IN_LIST"] = Blockly2.Msg["LISTS_INLIST"];
          Blockly2.Msg["MATH_CHANGE_TITLE_ITEM"] = Blockly2.Msg["VARIABLES_DEFAULT_NAME"];
          Blockly2.Msg["PROCEDURES_DEFRETURN_COMMENT"] = Blockly2.Msg["PROCEDURES_DEFNORETURN_COMMENT"];
          Blockly2.Msg["PROCEDURES_DEFRETURN_DO"] = Blockly2.Msg["PROCEDURES_DEFNORETURN_DO"];
          Blockly2.Msg["PROCEDURES_DEFRETURN_PROCEDURE"] = Blockly2.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"];
          Blockly2.Msg["PROCEDURES_DEFRETURN_TITLE"] = Blockly2.Msg["PROCEDURES_DEFNORETURN_TITLE"];
          Blockly2.Msg["TEXT_APPEND_VARIABLE"] = Blockly2.Msg["VARIABLES_DEFAULT_NAME"];
          Blockly2.Msg["TEXT_CREATE_JOIN_ITEM_TITLE_ITEM"] = Blockly2.Msg["VARIABLES_DEFAULT_NAME"];
          Blockly2.Msg["COLOUR_HUE"] = "20";
          Blockly2.Msg["LISTS_HUE"] = "260";
          Blockly2.Msg["LOGIC_HUE"] = "210";
          Blockly2.Msg["LOOPS_HUE"] = "120";
          Blockly2.Msg["MATH_HUE"] = "230";
          Blockly2.Msg["PROCEDURES_HUE"] = "290";
          Blockly2.Msg["TEXTS_HUE"] = "160";
          Blockly2.Msg["VARIABLES_DYNAMIC_HUE"] = "310";
          Blockly2.Msg["VARIABLES_HUE"] = "330";
          return Blockly2.Msg;
        });
      }
    });
    var import_blockly_compressed = __toESM2(require_blockly_compressed(), 1);
    var {
      Block,
      BlockFlyoutInflater,
      BlockNavigationPolicy,
      BlockSvg,
      Blocks,
      ButtonFlyoutInflater,
      COLLAPSED_FIELD_NAME,
      COLLAPSED_INPUT_NAME,
      COLLAPSE_CHARS,
      CodeGenerator,
      CollapsibleToolboxCategory,
      ComponentManager,
      Connection,
      ConnectionChecker,
      ConnectionDB,
      ConnectionNavigationPolicy,
      ConnectionType,
      ContextMenu,
      ContextMenuItems,
      ContextMenuRegistry,
      Css,
      DELETE_VARIABLE_ID,
      DeleteArea,
      DragTarget,
      DropDownDiv,
      Events,
      Extensions,
      Field,
      FieldCheckbox,
      FieldDropdown,
      FieldImage,
      FieldLabel,
      FieldLabelSerializable,
      FieldNavigationPolicy,
      FieldNumber,
      FieldTextInput,
      FieldVariable,
      Flyout,
      FlyoutButton,
      FlyoutButtonNavigationPolicy,
      FlyoutItem,
      FlyoutMetricsManager,
      FlyoutNavigationPolicy,
      FlyoutNavigator,
      FlyoutSeparator,
      FlyoutSeparatorNavigationPolicy,
      FocusManager,
      FocusableTreeTraverser,
      Generator,
      Gesture,
      Grid,
      HorizontalFlyout,
      INPUT_VALUE,
      Input,
      InsertionMarkerPreviewer,
      KeyboardNavigationController,
      LabelFlyoutInflater,
      LineCursor,
      Marker,
      MarkerManager,
      Menu,
      MenuItem,
      MetricsManager,
      Msg,
      NEXT_STATEMENT,
      Names,
      Navigator,
      OPPOSITE_TYPE,
      OUTPUT_VALUE,
      Options,
      PREVIOUS_STATEMENT,
      PROCEDURE_CATEGORY_NAME,
      Procedures,
      RENAME_VARIABLE_ID,
      RenderedConnection,
      Scrollbar,
      ScrollbarPair,
      SeparatorFlyoutInflater,
      ShortcutItems,
      ShortcutRegistry,
      TOOLBOX_AT_BOTTOM,
      TOOLBOX_AT_LEFT,
      TOOLBOX_AT_RIGHT,
      TOOLBOX_AT_TOP,
      Theme,
      ThemeManager,
      Themes,
      Toast,
      Toolbox,
      ToolboxCategory,
      ToolboxItem,
      ToolboxSeparator,
      Tooltip,
      Touch,
      Trashcan,
      UnattachedFieldError,
      VARIABLE_CATEGORY_NAME,
      VARIABLE_DYNAMIC_CATEGORY_NAME,
      VERSION,
      VariableMap,
      VariableModel,
      Variables,
      VariablesDynamic,
      VerticalFlyout,
      WidgetDiv,
      Workspace,
      WorkspaceAudio,
      WorkspaceDragger,
      WorkspaceNavigationPolicy,
      WorkspaceSvg,
      Xml,
      ZoomControls,
      blockAnimations,
      blockRendering,
      browserEvents,
      bubbles,
      bumpObjects,
      clipboard,
      comments,
      common,
      config,
      constants,
      defineBlocksWithJsonArray,
      dialog,
      dragging,
      fieldRegistry,
      geras,
      getFocusManager,
      getMainWorkspace,
      getSelected,
      hasBubble,
      hideChaff,
      icons,
      inject,
      inputs,
      isCopyable,
      isDeletable,
      isDraggable,
      isIcon,
      isObservable,
      isPaster,
      isRenderedElement,
      isSelectable,
      isSerializable,
      isVariableBackedParameterModel,
      keyboardNavigationController,
      layers,
      navigateBlock,
      navigateStacks,
      procedures,
      registry,
      renderManagement,
      serialization,
      setLocale,
      setParentContainer,
      svgResize,
      thrasos,
      uiPosition,
      utils,
      zelos
    } = import_blockly_compressed.default;
    var en_exports = {};
    __export(en_exports, {
      ADD_COMMENT: () => ADD_COMMENT,
      ALT_KEY: () => ALT_KEY,
      CANNOT_DELETE_VARIABLE_PROCEDURE: () => CANNOT_DELETE_VARIABLE_PROCEDURE,
      CHANGE_VALUE_TITLE: () => CHANGE_VALUE_TITLE,
      CHROME_OS: () => CHROME_OS,
      CLEAN_UP: () => CLEAN_UP,
      CLOSE: () => CLOSE,
      COLLAPSED_WARNINGS_WARNING: () => COLLAPSED_WARNINGS_WARNING,
      COLLAPSE_ALL: () => COLLAPSE_ALL,
      COLLAPSE_BLOCK: () => COLLAPSE_BLOCK,
      COLOUR_BLEND_COLOUR1: () => COLOUR_BLEND_COLOUR1,
      COLOUR_BLEND_COLOUR2: () => COLOUR_BLEND_COLOUR2,
      COLOUR_BLEND_HELPURL: () => COLOUR_BLEND_HELPURL,
      COLOUR_BLEND_RATIO: () => COLOUR_BLEND_RATIO,
      COLOUR_BLEND_TITLE: () => COLOUR_BLEND_TITLE,
      COLOUR_BLEND_TOOLTIP: () => COLOUR_BLEND_TOOLTIP,
      COLOUR_HUE: () => COLOUR_HUE,
      COLOUR_PICKER_HELPURL: () => COLOUR_PICKER_HELPURL,
      COLOUR_PICKER_TOOLTIP: () => COLOUR_PICKER_TOOLTIP,
      COLOUR_RANDOM_HELPURL: () => COLOUR_RANDOM_HELPURL,
      COLOUR_RANDOM_TITLE: () => COLOUR_RANDOM_TITLE,
      COLOUR_RANDOM_TOOLTIP: () => COLOUR_RANDOM_TOOLTIP,
      COLOUR_RGB_BLUE: () => COLOUR_RGB_BLUE,
      COLOUR_RGB_GREEN: () => COLOUR_RGB_GREEN,
      COLOUR_RGB_HELPURL: () => COLOUR_RGB_HELPURL,
      COLOUR_RGB_RED: () => COLOUR_RGB_RED,
      COLOUR_RGB_TITLE: () => COLOUR_RGB_TITLE,
      COLOUR_RGB_TOOLTIP: () => COLOUR_RGB_TOOLTIP,
      COMMAND_KEY: () => COMMAND_KEY,
      CONTROLS_FLOW_STATEMENTS_HELPURL: () => CONTROLS_FLOW_STATEMENTS_HELPURL,
      CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK: () => CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK,
      CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE: () => CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE,
      CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK: () => CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,
      CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE: () => CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE,
      CONTROLS_FLOW_STATEMENTS_WARNING: () => CONTROLS_FLOW_STATEMENTS_WARNING,
      CONTROLS_FOREACH_HELPURL: () => CONTROLS_FOREACH_HELPURL,
      CONTROLS_FOREACH_INPUT_DO: () => CONTROLS_FOREACH_INPUT_DO,
      CONTROLS_FOREACH_TITLE: () => CONTROLS_FOREACH_TITLE,
      CONTROLS_FOREACH_TOOLTIP: () => CONTROLS_FOREACH_TOOLTIP,
      CONTROLS_FOR_HELPURL: () => CONTROLS_FOR_HELPURL,
      CONTROLS_FOR_INPUT_DO: () => CONTROLS_FOR_INPUT_DO,
      CONTROLS_FOR_TITLE: () => CONTROLS_FOR_TITLE,
      CONTROLS_FOR_TOOLTIP: () => CONTROLS_FOR_TOOLTIP,
      CONTROLS_IF_ELSEIF_TITLE_ELSEIF: () => CONTROLS_IF_ELSEIF_TITLE_ELSEIF,
      CONTROLS_IF_ELSEIF_TOOLTIP: () => CONTROLS_IF_ELSEIF_TOOLTIP,
      CONTROLS_IF_ELSE_TITLE_ELSE: () => CONTROLS_IF_ELSE_TITLE_ELSE,
      CONTROLS_IF_ELSE_TOOLTIP: () => CONTROLS_IF_ELSE_TOOLTIP,
      CONTROLS_IF_HELPURL: () => CONTROLS_IF_HELPURL,
      CONTROLS_IF_IF_TITLE_IF: () => CONTROLS_IF_IF_TITLE_IF,
      CONTROLS_IF_IF_TOOLTIP: () => CONTROLS_IF_IF_TOOLTIP,
      CONTROLS_IF_MSG_ELSE: () => CONTROLS_IF_MSG_ELSE,
      CONTROLS_IF_MSG_ELSEIF: () => CONTROLS_IF_MSG_ELSEIF,
      CONTROLS_IF_MSG_IF: () => CONTROLS_IF_MSG_IF,
      CONTROLS_IF_MSG_THEN: () => CONTROLS_IF_MSG_THEN,
      CONTROLS_IF_TOOLTIP_1: () => CONTROLS_IF_TOOLTIP_1,
      CONTROLS_IF_TOOLTIP_2: () => CONTROLS_IF_TOOLTIP_2,
      CONTROLS_IF_TOOLTIP_3: () => CONTROLS_IF_TOOLTIP_3,
      CONTROLS_IF_TOOLTIP_4: () => CONTROLS_IF_TOOLTIP_4,
      CONTROLS_REPEAT_HELPURL: () => CONTROLS_REPEAT_HELPURL,
      CONTROLS_REPEAT_INPUT_DO: () => CONTROLS_REPEAT_INPUT_DO,
      CONTROLS_REPEAT_TITLE: () => CONTROLS_REPEAT_TITLE,
      CONTROLS_REPEAT_TOOLTIP: () => CONTROLS_REPEAT_TOOLTIP,
      CONTROLS_WHILEUNTIL_HELPURL: () => CONTROLS_WHILEUNTIL_HELPURL,
      CONTROLS_WHILEUNTIL_INPUT_DO: () => CONTROLS_WHILEUNTIL_INPUT_DO,
      CONTROLS_WHILEUNTIL_OPERATOR_UNTIL: () => CONTROLS_WHILEUNTIL_OPERATOR_UNTIL,
      CONTROLS_WHILEUNTIL_OPERATOR_WHILE: () => CONTROLS_WHILEUNTIL_OPERATOR_WHILE,
      CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL: () => CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL,
      CONTROLS_WHILEUNTIL_TOOLTIP_WHILE: () => CONTROLS_WHILEUNTIL_TOOLTIP_WHILE,
      CONTROL_KEY: () => CONTROL_KEY,
      COPY_SHORTCUT: () => COPY_SHORTCUT,
      CUT_SHORTCUT: () => CUT_SHORTCUT,
      DELETE_ALL_BLOCKS: () => DELETE_ALL_BLOCKS,
      DELETE_BLOCK: () => DELETE_BLOCK,
      DELETE_VARIABLE: () => DELETE_VARIABLE,
      DELETE_VARIABLE_CONFIRMATION: () => DELETE_VARIABLE_CONFIRMATION,
      DELETE_X_BLOCKS: () => DELETE_X_BLOCKS,
      DIALOG_CANCEL: () => DIALOG_CANCEL,
      DIALOG_OK: () => DIALOG_OK,
      DISABLE_BLOCK: () => DISABLE_BLOCK,
      DUPLICATE_BLOCK: () => DUPLICATE_BLOCK,
      DUPLICATE_COMMENT: () => DUPLICATE_COMMENT,
      EDIT_BLOCK_CONTENTS: () => EDIT_BLOCK_CONTENTS,
      ENABLE_BLOCK: () => ENABLE_BLOCK,
      EXPAND_ALL: () => EXPAND_ALL,
      EXPAND_BLOCK: () => EXPAND_BLOCK,
      EXTERNAL_INPUTS: () => EXTERNAL_INPUTS,
      HELP: () => HELP,
      HELP_PROMPT: () => HELP_PROMPT,
      INLINE_INPUTS: () => INLINE_INPUTS,
      KEYBOARD_NAV_CONSTRAINED_MOVE_HINT: () => KEYBOARD_NAV_CONSTRAINED_MOVE_HINT,
      KEYBOARD_NAV_COPIED_HINT: () => KEYBOARD_NAV_COPIED_HINT,
      KEYBOARD_NAV_CUT_HINT: () => KEYBOARD_NAV_CUT_HINT,
      KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT: () => KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT,
      LINUX: () => LINUX,
      LISTS_CREATE_EMPTY_HELPURL: () => LISTS_CREATE_EMPTY_HELPURL,
      LISTS_CREATE_EMPTY_TITLE: () => LISTS_CREATE_EMPTY_TITLE,
      LISTS_CREATE_EMPTY_TOOLTIP: () => LISTS_CREATE_EMPTY_TOOLTIP,
      LISTS_CREATE_WITH_CONTAINER_TITLE_ADD: () => LISTS_CREATE_WITH_CONTAINER_TITLE_ADD,
      LISTS_CREATE_WITH_CONTAINER_TOOLTIP: () => LISTS_CREATE_WITH_CONTAINER_TOOLTIP,
      LISTS_CREATE_WITH_HELPURL: () => LISTS_CREATE_WITH_HELPURL,
      LISTS_CREATE_WITH_INPUT_WITH: () => LISTS_CREATE_WITH_INPUT_WITH,
      LISTS_CREATE_WITH_ITEM_TITLE: () => LISTS_CREATE_WITH_ITEM_TITLE,
      LISTS_CREATE_WITH_ITEM_TOOLTIP: () => LISTS_CREATE_WITH_ITEM_TOOLTIP,
      LISTS_CREATE_WITH_TOOLTIP: () => LISTS_CREATE_WITH_TOOLTIP,
      LISTS_GET_INDEX_FIRST: () => LISTS_GET_INDEX_FIRST,
      LISTS_GET_INDEX_FROM_END: () => LISTS_GET_INDEX_FROM_END,
      LISTS_GET_INDEX_FROM_START: () => LISTS_GET_INDEX_FROM_START,
      LISTS_GET_INDEX_GET: () => LISTS_GET_INDEX_GET,
      LISTS_GET_INDEX_GET_REMOVE: () => LISTS_GET_INDEX_GET_REMOVE,
      LISTS_GET_INDEX_HELPURL: () => LISTS_GET_INDEX_HELPURL,
      LISTS_GET_INDEX_INPUT_IN_LIST: () => LISTS_GET_INDEX_INPUT_IN_LIST,
      LISTS_GET_INDEX_LAST: () => LISTS_GET_INDEX_LAST,
      LISTS_GET_INDEX_RANDOM: () => LISTS_GET_INDEX_RANDOM,
      LISTS_GET_INDEX_REMOVE: () => LISTS_GET_INDEX_REMOVE,
      LISTS_GET_INDEX_TAIL: () => LISTS_GET_INDEX_TAIL,
      LISTS_GET_INDEX_TOOLTIP_GET_FIRST: () => LISTS_GET_INDEX_TOOLTIP_GET_FIRST,
      LISTS_GET_INDEX_TOOLTIP_GET_FROM: () => LISTS_GET_INDEX_TOOLTIP_GET_FROM,
      LISTS_GET_INDEX_TOOLTIP_GET_LAST: () => LISTS_GET_INDEX_TOOLTIP_GET_LAST,
      LISTS_GET_INDEX_TOOLTIP_GET_RANDOM: () => LISTS_GET_INDEX_TOOLTIP_GET_RANDOM,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST: () => LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM: () => LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST: () => LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM: () => LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST: () => LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM: () => LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST: () => LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM: () => LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM,
      LISTS_GET_SUBLIST_END_FROM_END: () => LISTS_GET_SUBLIST_END_FROM_END,
      LISTS_GET_SUBLIST_END_FROM_START: () => LISTS_GET_SUBLIST_END_FROM_START,
      LISTS_GET_SUBLIST_END_LAST: () => LISTS_GET_SUBLIST_END_LAST,
      LISTS_GET_SUBLIST_HELPURL: () => LISTS_GET_SUBLIST_HELPURL,
      LISTS_GET_SUBLIST_INPUT_IN_LIST: () => LISTS_GET_SUBLIST_INPUT_IN_LIST,
      LISTS_GET_SUBLIST_START_FIRST: () => LISTS_GET_SUBLIST_START_FIRST,
      LISTS_GET_SUBLIST_START_FROM_END: () => LISTS_GET_SUBLIST_START_FROM_END,
      LISTS_GET_SUBLIST_START_FROM_START: () => LISTS_GET_SUBLIST_START_FROM_START,
      LISTS_GET_SUBLIST_TAIL: () => LISTS_GET_SUBLIST_TAIL,
      LISTS_GET_SUBLIST_TOOLTIP: () => LISTS_GET_SUBLIST_TOOLTIP,
      LISTS_HUE: () => LISTS_HUE,
      LISTS_INDEX_FROM_END_TOOLTIP: () => LISTS_INDEX_FROM_END_TOOLTIP,
      LISTS_INDEX_FROM_START_TOOLTIP: () => LISTS_INDEX_FROM_START_TOOLTIP,
      LISTS_INDEX_OF_FIRST: () => LISTS_INDEX_OF_FIRST,
      LISTS_INDEX_OF_HELPURL: () => LISTS_INDEX_OF_HELPURL,
      LISTS_INDEX_OF_INPUT_IN_LIST: () => LISTS_INDEX_OF_INPUT_IN_LIST,
      LISTS_INDEX_OF_LAST: () => LISTS_INDEX_OF_LAST,
      LISTS_INDEX_OF_TOOLTIP: () => LISTS_INDEX_OF_TOOLTIP,
      LISTS_INLIST: () => LISTS_INLIST,
      LISTS_ISEMPTY_HELPURL: () => LISTS_ISEMPTY_HELPURL,
      LISTS_ISEMPTY_TITLE: () => LISTS_ISEMPTY_TITLE,
      LISTS_ISEMPTY_TOOLTIP: () => LISTS_ISEMPTY_TOOLTIP,
      LISTS_LENGTH_HELPURL: () => LISTS_LENGTH_HELPURL,
      LISTS_LENGTH_TITLE: () => LISTS_LENGTH_TITLE,
      LISTS_LENGTH_TOOLTIP: () => LISTS_LENGTH_TOOLTIP,
      LISTS_REPEAT_HELPURL: () => LISTS_REPEAT_HELPURL,
      LISTS_REPEAT_TITLE: () => LISTS_REPEAT_TITLE,
      LISTS_REPEAT_TOOLTIP: () => LISTS_REPEAT_TOOLTIP,
      LISTS_REVERSE_HELPURL: () => LISTS_REVERSE_HELPURL,
      LISTS_REVERSE_MESSAGE0: () => LISTS_REVERSE_MESSAGE0,
      LISTS_REVERSE_TOOLTIP: () => LISTS_REVERSE_TOOLTIP,
      LISTS_SET_INDEX_HELPURL: () => LISTS_SET_INDEX_HELPURL,
      LISTS_SET_INDEX_INPUT_IN_LIST: () => LISTS_SET_INDEX_INPUT_IN_LIST,
      LISTS_SET_INDEX_INPUT_TO: () => LISTS_SET_INDEX_INPUT_TO,
      LISTS_SET_INDEX_INSERT: () => LISTS_SET_INDEX_INSERT,
      LISTS_SET_INDEX_SET: () => LISTS_SET_INDEX_SET,
      LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST: () => LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST,
      LISTS_SET_INDEX_TOOLTIP_INSERT_FROM: () => LISTS_SET_INDEX_TOOLTIP_INSERT_FROM,
      LISTS_SET_INDEX_TOOLTIP_INSERT_LAST: () => LISTS_SET_INDEX_TOOLTIP_INSERT_LAST,
      LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM: () => LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM,
      LISTS_SET_INDEX_TOOLTIP_SET_FIRST: () => LISTS_SET_INDEX_TOOLTIP_SET_FIRST,
      LISTS_SET_INDEX_TOOLTIP_SET_FROM: () => LISTS_SET_INDEX_TOOLTIP_SET_FROM,
      LISTS_SET_INDEX_TOOLTIP_SET_LAST: () => LISTS_SET_INDEX_TOOLTIP_SET_LAST,
      LISTS_SET_INDEX_TOOLTIP_SET_RANDOM: () => LISTS_SET_INDEX_TOOLTIP_SET_RANDOM,
      LISTS_SORT_HELPURL: () => LISTS_SORT_HELPURL,
      LISTS_SORT_ORDER_ASCENDING: () => LISTS_SORT_ORDER_ASCENDING,
      LISTS_SORT_ORDER_DESCENDING: () => LISTS_SORT_ORDER_DESCENDING,
      LISTS_SORT_TITLE: () => LISTS_SORT_TITLE,
      LISTS_SORT_TOOLTIP: () => LISTS_SORT_TOOLTIP,
      LISTS_SORT_TYPE_IGNORECASE: () => LISTS_SORT_TYPE_IGNORECASE,
      LISTS_SORT_TYPE_NUMERIC: () => LISTS_SORT_TYPE_NUMERIC,
      LISTS_SORT_TYPE_TEXT: () => LISTS_SORT_TYPE_TEXT,
      LISTS_SPLIT_HELPURL: () => LISTS_SPLIT_HELPURL,
      LISTS_SPLIT_LIST_FROM_TEXT: () => LISTS_SPLIT_LIST_FROM_TEXT,
      LISTS_SPLIT_TEXT_FROM_LIST: () => LISTS_SPLIT_TEXT_FROM_LIST,
      LISTS_SPLIT_TOOLTIP_JOIN: () => LISTS_SPLIT_TOOLTIP_JOIN,
      LISTS_SPLIT_TOOLTIP_SPLIT: () => LISTS_SPLIT_TOOLTIP_SPLIT,
      LISTS_SPLIT_WITH_DELIMITER: () => LISTS_SPLIT_WITH_DELIMITER,
      LOGIC_BOOLEAN_FALSE: () => LOGIC_BOOLEAN_FALSE,
      LOGIC_BOOLEAN_HELPURL: () => LOGIC_BOOLEAN_HELPURL,
      LOGIC_BOOLEAN_TOOLTIP: () => LOGIC_BOOLEAN_TOOLTIP,
      LOGIC_BOOLEAN_TRUE: () => LOGIC_BOOLEAN_TRUE,
      LOGIC_COMPARE_HELPURL: () => LOGIC_COMPARE_HELPURL,
      LOGIC_COMPARE_TOOLTIP_EQ: () => LOGIC_COMPARE_TOOLTIP_EQ,
      LOGIC_COMPARE_TOOLTIP_GT: () => LOGIC_COMPARE_TOOLTIP_GT,
      LOGIC_COMPARE_TOOLTIP_GTE: () => LOGIC_COMPARE_TOOLTIP_GTE,
      LOGIC_COMPARE_TOOLTIP_LT: () => LOGIC_COMPARE_TOOLTIP_LT,
      LOGIC_COMPARE_TOOLTIP_LTE: () => LOGIC_COMPARE_TOOLTIP_LTE,
      LOGIC_COMPARE_TOOLTIP_NEQ: () => LOGIC_COMPARE_TOOLTIP_NEQ,
      LOGIC_HUE: () => LOGIC_HUE,
      LOGIC_NEGATE_HELPURL: () => LOGIC_NEGATE_HELPURL,
      LOGIC_NEGATE_TITLE: () => LOGIC_NEGATE_TITLE,
      LOGIC_NEGATE_TOOLTIP: () => LOGIC_NEGATE_TOOLTIP,
      LOGIC_NULL: () => LOGIC_NULL,
      LOGIC_NULL_HELPURL: () => LOGIC_NULL_HELPURL,
      LOGIC_NULL_TOOLTIP: () => LOGIC_NULL_TOOLTIP,
      LOGIC_OPERATION_AND: () => LOGIC_OPERATION_AND,
      LOGIC_OPERATION_HELPURL: () => LOGIC_OPERATION_HELPURL,
      LOGIC_OPERATION_OR: () => LOGIC_OPERATION_OR,
      LOGIC_OPERATION_TOOLTIP_AND: () => LOGIC_OPERATION_TOOLTIP_AND,
      LOGIC_OPERATION_TOOLTIP_OR: () => LOGIC_OPERATION_TOOLTIP_OR,
      LOGIC_TERNARY_CONDITION: () => LOGIC_TERNARY_CONDITION,
      LOGIC_TERNARY_HELPURL: () => LOGIC_TERNARY_HELPURL,
      LOGIC_TERNARY_IF_FALSE: () => LOGIC_TERNARY_IF_FALSE,
      LOGIC_TERNARY_IF_TRUE: () => LOGIC_TERNARY_IF_TRUE,
      LOGIC_TERNARY_TOOLTIP: () => LOGIC_TERNARY_TOOLTIP,
      LOOPS_HUE: () => LOOPS_HUE,
      MAC_OS: () => MAC_OS,
      MATH_ADDITION_SYMBOL: () => MATH_ADDITION_SYMBOL,
      MATH_ARITHMETIC_HELPURL: () => MATH_ARITHMETIC_HELPURL,
      MATH_ARITHMETIC_TOOLTIP_ADD: () => MATH_ARITHMETIC_TOOLTIP_ADD,
      MATH_ARITHMETIC_TOOLTIP_DIVIDE: () => MATH_ARITHMETIC_TOOLTIP_DIVIDE,
      MATH_ARITHMETIC_TOOLTIP_MINUS: () => MATH_ARITHMETIC_TOOLTIP_MINUS,
      MATH_ARITHMETIC_TOOLTIP_MULTIPLY: () => MATH_ARITHMETIC_TOOLTIP_MULTIPLY,
      MATH_ARITHMETIC_TOOLTIP_POWER: () => MATH_ARITHMETIC_TOOLTIP_POWER,
      MATH_ATAN2_HELPURL: () => MATH_ATAN2_HELPURL,
      MATH_ATAN2_TITLE: () => MATH_ATAN2_TITLE,
      MATH_ATAN2_TOOLTIP: () => MATH_ATAN2_TOOLTIP,
      MATH_CHANGE_HELPURL: () => MATH_CHANGE_HELPURL,
      MATH_CHANGE_TITLE: () => MATH_CHANGE_TITLE,
      MATH_CHANGE_TITLE_ITEM: () => MATH_CHANGE_TITLE_ITEM,
      MATH_CHANGE_TOOLTIP: () => MATH_CHANGE_TOOLTIP,
      MATH_CONSTANT_HELPURL: () => MATH_CONSTANT_HELPURL,
      MATH_CONSTANT_TOOLTIP: () => MATH_CONSTANT_TOOLTIP,
      MATH_CONSTRAIN_HELPURL: () => MATH_CONSTRAIN_HELPURL,
      MATH_CONSTRAIN_TITLE: () => MATH_CONSTRAIN_TITLE,
      MATH_CONSTRAIN_TOOLTIP: () => MATH_CONSTRAIN_TOOLTIP,
      MATH_DIVISION_SYMBOL: () => MATH_DIVISION_SYMBOL,
      MATH_HUE: () => MATH_HUE,
      MATH_IS_DIVISIBLE_BY: () => MATH_IS_DIVISIBLE_BY,
      MATH_IS_EVEN: () => MATH_IS_EVEN,
      MATH_IS_NEGATIVE: () => MATH_IS_NEGATIVE,
      MATH_IS_ODD: () => MATH_IS_ODD,
      MATH_IS_POSITIVE: () => MATH_IS_POSITIVE,
      MATH_IS_PRIME: () => MATH_IS_PRIME,
      MATH_IS_TOOLTIP: () => MATH_IS_TOOLTIP,
      MATH_IS_WHOLE: () => MATH_IS_WHOLE,
      MATH_MODULO_HELPURL: () => MATH_MODULO_HELPURL,
      MATH_MODULO_TITLE: () => MATH_MODULO_TITLE,
      MATH_MODULO_TOOLTIP: () => MATH_MODULO_TOOLTIP,
      MATH_MULTIPLICATION_SYMBOL: () => MATH_MULTIPLICATION_SYMBOL,
      MATH_NUMBER_HELPURL: () => MATH_NUMBER_HELPURL,
      MATH_NUMBER_TOOLTIP: () => MATH_NUMBER_TOOLTIP,
      MATH_ONLIST_HELPURL: () => MATH_ONLIST_HELPURL,
      MATH_ONLIST_OPERATOR_AVERAGE: () => MATH_ONLIST_OPERATOR_AVERAGE,
      MATH_ONLIST_OPERATOR_MAX: () => MATH_ONLIST_OPERATOR_MAX,
      MATH_ONLIST_OPERATOR_MEDIAN: () => MATH_ONLIST_OPERATOR_MEDIAN,
      MATH_ONLIST_OPERATOR_MIN: () => MATH_ONLIST_OPERATOR_MIN,
      MATH_ONLIST_OPERATOR_MODE: () => MATH_ONLIST_OPERATOR_MODE,
      MATH_ONLIST_OPERATOR_RANDOM: () => MATH_ONLIST_OPERATOR_RANDOM,
      MATH_ONLIST_OPERATOR_STD_DEV: () => MATH_ONLIST_OPERATOR_STD_DEV,
      MATH_ONLIST_OPERATOR_SUM: () => MATH_ONLIST_OPERATOR_SUM,
      MATH_ONLIST_TOOLTIP_AVERAGE: () => MATH_ONLIST_TOOLTIP_AVERAGE,
      MATH_ONLIST_TOOLTIP_MAX: () => MATH_ONLIST_TOOLTIP_MAX,
      MATH_ONLIST_TOOLTIP_MEDIAN: () => MATH_ONLIST_TOOLTIP_MEDIAN,
      MATH_ONLIST_TOOLTIP_MIN: () => MATH_ONLIST_TOOLTIP_MIN,
      MATH_ONLIST_TOOLTIP_MODE: () => MATH_ONLIST_TOOLTIP_MODE,
      MATH_ONLIST_TOOLTIP_RANDOM: () => MATH_ONLIST_TOOLTIP_RANDOM,
      MATH_ONLIST_TOOLTIP_STD_DEV: () => MATH_ONLIST_TOOLTIP_STD_DEV,
      MATH_ONLIST_TOOLTIP_SUM: () => MATH_ONLIST_TOOLTIP_SUM,
      MATH_POWER_SYMBOL: () => MATH_POWER_SYMBOL,
      MATH_RANDOM_FLOAT_HELPURL: () => MATH_RANDOM_FLOAT_HELPURL,
      MATH_RANDOM_FLOAT_TITLE_RANDOM: () => MATH_RANDOM_FLOAT_TITLE_RANDOM,
      MATH_RANDOM_FLOAT_TOOLTIP: () => MATH_RANDOM_FLOAT_TOOLTIP,
      MATH_RANDOM_INT_HELPURL: () => MATH_RANDOM_INT_HELPURL,
      MATH_RANDOM_INT_TITLE: () => MATH_RANDOM_INT_TITLE,
      MATH_RANDOM_INT_TOOLTIP: () => MATH_RANDOM_INT_TOOLTIP,
      MATH_ROUND_HELPURL: () => MATH_ROUND_HELPURL,
      MATH_ROUND_OPERATOR_ROUND: () => MATH_ROUND_OPERATOR_ROUND,
      MATH_ROUND_OPERATOR_ROUNDDOWN: () => MATH_ROUND_OPERATOR_ROUNDDOWN,
      MATH_ROUND_OPERATOR_ROUNDUP: () => MATH_ROUND_OPERATOR_ROUNDUP,
      MATH_ROUND_TOOLTIP: () => MATH_ROUND_TOOLTIP,
      MATH_SINGLE_HELPURL: () => MATH_SINGLE_HELPURL,
      MATH_SINGLE_OP_ABSOLUTE: () => MATH_SINGLE_OP_ABSOLUTE,
      MATH_SINGLE_OP_ROOT: () => MATH_SINGLE_OP_ROOT,
      MATH_SINGLE_TOOLTIP_ABS: () => MATH_SINGLE_TOOLTIP_ABS,
      MATH_SINGLE_TOOLTIP_EXP: () => MATH_SINGLE_TOOLTIP_EXP,
      MATH_SINGLE_TOOLTIP_LN: () => MATH_SINGLE_TOOLTIP_LN,
      MATH_SINGLE_TOOLTIP_LOG10: () => MATH_SINGLE_TOOLTIP_LOG10,
      MATH_SINGLE_TOOLTIP_NEG: () => MATH_SINGLE_TOOLTIP_NEG,
      MATH_SINGLE_TOOLTIP_POW10: () => MATH_SINGLE_TOOLTIP_POW10,
      MATH_SINGLE_TOOLTIP_ROOT: () => MATH_SINGLE_TOOLTIP_ROOT,
      MATH_SUBTRACTION_SYMBOL: () => MATH_SUBTRACTION_SYMBOL,
      MATH_TRIG_ACOS: () => MATH_TRIG_ACOS,
      MATH_TRIG_ASIN: () => MATH_TRIG_ASIN,
      MATH_TRIG_ATAN: () => MATH_TRIG_ATAN,
      MATH_TRIG_COS: () => MATH_TRIG_COS,
      MATH_TRIG_HELPURL: () => MATH_TRIG_HELPURL,
      MATH_TRIG_SIN: () => MATH_TRIG_SIN,
      MATH_TRIG_TAN: () => MATH_TRIG_TAN,
      MATH_TRIG_TOOLTIP_ACOS: () => MATH_TRIG_TOOLTIP_ACOS,
      MATH_TRIG_TOOLTIP_ASIN: () => MATH_TRIG_TOOLTIP_ASIN,
      MATH_TRIG_TOOLTIP_ATAN: () => MATH_TRIG_TOOLTIP_ATAN,
      MATH_TRIG_TOOLTIP_COS: () => MATH_TRIG_TOOLTIP_COS,
      MATH_TRIG_TOOLTIP_SIN: () => MATH_TRIG_TOOLTIP_SIN,
      MATH_TRIG_TOOLTIP_TAN: () => MATH_TRIG_TOOLTIP_TAN,
      MOVE_BLOCK: () => MOVE_BLOCK,
      NEW_COLOUR_VARIABLE: () => NEW_COLOUR_VARIABLE,
      NEW_NUMBER_VARIABLE: () => NEW_NUMBER_VARIABLE,
      NEW_STRING_VARIABLE: () => NEW_STRING_VARIABLE,
      NEW_VARIABLE: () => NEW_VARIABLE,
      NEW_VARIABLE_TITLE: () => NEW_VARIABLE_TITLE,
      NEW_VARIABLE_TYPE_TITLE: () => NEW_VARIABLE_TYPE_TITLE,
      OPTION_KEY: () => OPTION_KEY,
      ORDINAL_NUMBER_SUFFIX: () => ORDINAL_NUMBER_SUFFIX,
      PASTE_SHORTCUT: () => PASTE_SHORTCUT,
      PROCEDURES_ALLOW_STATEMENTS: () => PROCEDURES_ALLOW_STATEMENTS,
      PROCEDURES_BEFORE_PARAMS: () => PROCEDURES_BEFORE_PARAMS,
      PROCEDURES_CALLNORETURN_HELPURL: () => PROCEDURES_CALLNORETURN_HELPURL,
      PROCEDURES_CALLNORETURN_TOOLTIP: () => PROCEDURES_CALLNORETURN_TOOLTIP,
      PROCEDURES_CALLRETURN_HELPURL: () => PROCEDURES_CALLRETURN_HELPURL,
      PROCEDURES_CALLRETURN_TOOLTIP: () => PROCEDURES_CALLRETURN_TOOLTIP,
      PROCEDURES_CALL_BEFORE_PARAMS: () => PROCEDURES_CALL_BEFORE_PARAMS,
      PROCEDURES_CALL_DISABLED_DEF_WARNING: () => PROCEDURES_CALL_DISABLED_DEF_WARNING,
      PROCEDURES_CREATE_DO: () => PROCEDURES_CREATE_DO,
      PROCEDURES_DEFNORETURN_COMMENT: () => PROCEDURES_DEFNORETURN_COMMENT,
      PROCEDURES_DEFNORETURN_DO: () => PROCEDURES_DEFNORETURN_DO,
      PROCEDURES_DEFNORETURN_HELPURL: () => PROCEDURES_DEFNORETURN_HELPURL,
      PROCEDURES_DEFNORETURN_PROCEDURE: () => PROCEDURES_DEFNORETURN_PROCEDURE,
      PROCEDURES_DEFNORETURN_TITLE: () => PROCEDURES_DEFNORETURN_TITLE,
      PROCEDURES_DEFNORETURN_TOOLTIP: () => PROCEDURES_DEFNORETURN_TOOLTIP,
      PROCEDURES_DEFRETURN_COMMENT: () => PROCEDURES_DEFRETURN_COMMENT,
      PROCEDURES_DEFRETURN_DO: () => PROCEDURES_DEFRETURN_DO,
      PROCEDURES_DEFRETURN_HELPURL: () => PROCEDURES_DEFRETURN_HELPURL,
      PROCEDURES_DEFRETURN_PROCEDURE: () => PROCEDURES_DEFRETURN_PROCEDURE,
      PROCEDURES_DEFRETURN_RETURN: () => PROCEDURES_DEFRETURN_RETURN,
      PROCEDURES_DEFRETURN_TITLE: () => PROCEDURES_DEFRETURN_TITLE,
      PROCEDURES_DEFRETURN_TOOLTIP: () => PROCEDURES_DEFRETURN_TOOLTIP,
      PROCEDURES_DEF_DUPLICATE_WARNING: () => PROCEDURES_DEF_DUPLICATE_WARNING,
      PROCEDURES_HIGHLIGHT_DEF: () => PROCEDURES_HIGHLIGHT_DEF,
      PROCEDURES_HUE: () => PROCEDURES_HUE,
      PROCEDURES_IFRETURN_HELPURL: () => PROCEDURES_IFRETURN_HELPURL,
      PROCEDURES_IFRETURN_TOOLTIP: () => PROCEDURES_IFRETURN_TOOLTIP,
      PROCEDURES_IFRETURN_WARNING: () => PROCEDURES_IFRETURN_WARNING,
      PROCEDURES_MUTATORARG_TITLE: () => PROCEDURES_MUTATORARG_TITLE,
      PROCEDURES_MUTATORARG_TOOLTIP: () => PROCEDURES_MUTATORARG_TOOLTIP,
      PROCEDURES_MUTATORCONTAINER_TITLE: () => PROCEDURES_MUTATORCONTAINER_TITLE,
      PROCEDURES_MUTATORCONTAINER_TOOLTIP: () => PROCEDURES_MUTATORCONTAINER_TOOLTIP,
      REDO: () => REDO,
      REMOVE_COMMENT: () => REMOVE_COMMENT,
      RENAME_VARIABLE: () => RENAME_VARIABLE,
      RENAME_VARIABLE_TITLE: () => RENAME_VARIABLE_TITLE,
      SHORTCUTS_CODE_NAVIGATION: () => SHORTCUTS_CODE_NAVIGATION,
      SHORTCUTS_EDITING: () => SHORTCUTS_EDITING,
      SHORTCUTS_GENERAL: () => SHORTCUTS_GENERAL,
      TEXTS_HUE: () => TEXTS_HUE,
      TEXT_APPEND_HELPURL: () => TEXT_APPEND_HELPURL,
      TEXT_APPEND_TITLE: () => TEXT_APPEND_TITLE,
      TEXT_APPEND_TOOLTIP: () => TEXT_APPEND_TOOLTIP,
      TEXT_APPEND_VARIABLE: () => TEXT_APPEND_VARIABLE,
      TEXT_CHANGECASE_HELPURL: () => TEXT_CHANGECASE_HELPURL,
      TEXT_CHANGECASE_OPERATOR_LOWERCASE: () => TEXT_CHANGECASE_OPERATOR_LOWERCASE,
      TEXT_CHANGECASE_OPERATOR_TITLECASE: () => TEXT_CHANGECASE_OPERATOR_TITLECASE,
      TEXT_CHANGECASE_OPERATOR_UPPERCASE: () => TEXT_CHANGECASE_OPERATOR_UPPERCASE,
      TEXT_CHANGECASE_TOOLTIP: () => TEXT_CHANGECASE_TOOLTIP,
      TEXT_CHARAT_FIRST: () => TEXT_CHARAT_FIRST,
      TEXT_CHARAT_FROM_END: () => TEXT_CHARAT_FROM_END,
      TEXT_CHARAT_FROM_START: () => TEXT_CHARAT_FROM_START,
      TEXT_CHARAT_HELPURL: () => TEXT_CHARAT_HELPURL,
      TEXT_CHARAT_LAST: () => TEXT_CHARAT_LAST,
      TEXT_CHARAT_RANDOM: () => TEXT_CHARAT_RANDOM,
      TEXT_CHARAT_TAIL: () => TEXT_CHARAT_TAIL,
      TEXT_CHARAT_TITLE: () => TEXT_CHARAT_TITLE,
      TEXT_CHARAT_TOOLTIP: () => TEXT_CHARAT_TOOLTIP,
      TEXT_COUNT_HELPURL: () => TEXT_COUNT_HELPURL,
      TEXT_COUNT_MESSAGE0: () => TEXT_COUNT_MESSAGE0,
      TEXT_COUNT_TOOLTIP: () => TEXT_COUNT_TOOLTIP,
      TEXT_CREATE_JOIN_ITEM_TITLE_ITEM: () => TEXT_CREATE_JOIN_ITEM_TITLE_ITEM,
      TEXT_CREATE_JOIN_ITEM_TOOLTIP: () => TEXT_CREATE_JOIN_ITEM_TOOLTIP,
      TEXT_CREATE_JOIN_TITLE_JOIN: () => TEXT_CREATE_JOIN_TITLE_JOIN,
      TEXT_CREATE_JOIN_TOOLTIP: () => TEXT_CREATE_JOIN_TOOLTIP,
      TEXT_GET_SUBSTRING_END_FROM_END: () => TEXT_GET_SUBSTRING_END_FROM_END,
      TEXT_GET_SUBSTRING_END_FROM_START: () => TEXT_GET_SUBSTRING_END_FROM_START,
      TEXT_GET_SUBSTRING_END_LAST: () => TEXT_GET_SUBSTRING_END_LAST,
      TEXT_GET_SUBSTRING_HELPURL: () => TEXT_GET_SUBSTRING_HELPURL,
      TEXT_GET_SUBSTRING_INPUT_IN_TEXT: () => TEXT_GET_SUBSTRING_INPUT_IN_TEXT,
      TEXT_GET_SUBSTRING_START_FIRST: () => TEXT_GET_SUBSTRING_START_FIRST,
      TEXT_GET_SUBSTRING_START_FROM_END: () => TEXT_GET_SUBSTRING_START_FROM_END,
      TEXT_GET_SUBSTRING_START_FROM_START: () => TEXT_GET_SUBSTRING_START_FROM_START,
      TEXT_GET_SUBSTRING_TAIL: () => TEXT_GET_SUBSTRING_TAIL,
      TEXT_GET_SUBSTRING_TOOLTIP: () => TEXT_GET_SUBSTRING_TOOLTIP,
      TEXT_INDEXOF_HELPURL: () => TEXT_INDEXOF_HELPURL,
      TEXT_INDEXOF_OPERATOR_FIRST: () => TEXT_INDEXOF_OPERATOR_FIRST,
      TEXT_INDEXOF_OPERATOR_LAST: () => TEXT_INDEXOF_OPERATOR_LAST,
      TEXT_INDEXOF_TITLE: () => TEXT_INDEXOF_TITLE,
      TEXT_INDEXOF_TOOLTIP: () => TEXT_INDEXOF_TOOLTIP,
      TEXT_ISEMPTY_HELPURL: () => TEXT_ISEMPTY_HELPURL,
      TEXT_ISEMPTY_TITLE: () => TEXT_ISEMPTY_TITLE,
      TEXT_ISEMPTY_TOOLTIP: () => TEXT_ISEMPTY_TOOLTIP,
      TEXT_JOIN_HELPURL: () => TEXT_JOIN_HELPURL,
      TEXT_JOIN_TITLE_CREATEWITH: () => TEXT_JOIN_TITLE_CREATEWITH,
      TEXT_JOIN_TOOLTIP: () => TEXT_JOIN_TOOLTIP,
      TEXT_LENGTH_HELPURL: () => TEXT_LENGTH_HELPURL,
      TEXT_LENGTH_TITLE: () => TEXT_LENGTH_TITLE,
      TEXT_LENGTH_TOOLTIP: () => TEXT_LENGTH_TOOLTIP,
      TEXT_PRINT_HELPURL: () => TEXT_PRINT_HELPURL,
      TEXT_PRINT_TITLE: () => TEXT_PRINT_TITLE,
      TEXT_PRINT_TOOLTIP: () => TEXT_PRINT_TOOLTIP,
      TEXT_PROMPT_HELPURL: () => TEXT_PROMPT_HELPURL,
      TEXT_PROMPT_TOOLTIP_NUMBER: () => TEXT_PROMPT_TOOLTIP_NUMBER,
      TEXT_PROMPT_TOOLTIP_TEXT: () => TEXT_PROMPT_TOOLTIP_TEXT,
      TEXT_PROMPT_TYPE_NUMBER: () => TEXT_PROMPT_TYPE_NUMBER,
      TEXT_PROMPT_TYPE_TEXT: () => TEXT_PROMPT_TYPE_TEXT,
      TEXT_REPLACE_HELPURL: () => TEXT_REPLACE_HELPURL,
      TEXT_REPLACE_MESSAGE0: () => TEXT_REPLACE_MESSAGE0,
      TEXT_REPLACE_TOOLTIP: () => TEXT_REPLACE_TOOLTIP,
      TEXT_REVERSE_HELPURL: () => TEXT_REVERSE_HELPURL,
      TEXT_REVERSE_MESSAGE0: () => TEXT_REVERSE_MESSAGE0,
      TEXT_REVERSE_TOOLTIP: () => TEXT_REVERSE_TOOLTIP,
      TEXT_TEXT_HELPURL: () => TEXT_TEXT_HELPURL,
      TEXT_TEXT_TOOLTIP: () => TEXT_TEXT_TOOLTIP,
      TEXT_TRIM_HELPURL: () => TEXT_TRIM_HELPURL,
      TEXT_TRIM_OPERATOR_BOTH: () => TEXT_TRIM_OPERATOR_BOTH,
      TEXT_TRIM_OPERATOR_LEFT: () => TEXT_TRIM_OPERATOR_LEFT,
      TEXT_TRIM_OPERATOR_RIGHT: () => TEXT_TRIM_OPERATOR_RIGHT,
      TEXT_TRIM_TOOLTIP: () => TEXT_TRIM_TOOLTIP,
      TODAY: () => TODAY,
      UNDO: () => UNDO,
      UNKNOWN: () => UNKNOWN,
      UNNAMED_KEY: () => UNNAMED_KEY,
      VARIABLES_DEFAULT_NAME: () => VARIABLES_DEFAULT_NAME,
      VARIABLES_DYNAMIC_HUE: () => VARIABLES_DYNAMIC_HUE,
      VARIABLES_GET_CREATE_SET: () => VARIABLES_GET_CREATE_SET,
      VARIABLES_GET_HELPURL: () => VARIABLES_GET_HELPURL,
      VARIABLES_GET_TOOLTIP: () => VARIABLES_GET_TOOLTIP,
      VARIABLES_HUE: () => VARIABLES_HUE,
      VARIABLES_SET: () => VARIABLES_SET,
      VARIABLES_SET_CREATE_GET: () => VARIABLES_SET_CREATE_GET,
      VARIABLES_SET_HELPURL: () => VARIABLES_SET_HELPURL,
      VARIABLES_SET_TOOLTIP: () => VARIABLES_SET_TOOLTIP,
      VARIABLE_ALREADY_EXISTS: () => VARIABLE_ALREADY_EXISTS,
      VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE: () => VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,
      VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER: () => VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER,
      WINDOWS: () => WINDOWS,
      WORKSPACE_ARIA_LABEL: () => WORKSPACE_ARIA_LABEL,
      WORKSPACE_COMMENT_DEFAULT_TEXT: () => WORKSPACE_COMMENT_DEFAULT_TEXT
    });
    var import_en = __toESM2(require_en(), 1);
    var {
      LOGIC_HUE,
      LOOPS_HUE,
      MATH_HUE,
      TEXTS_HUE,
      LISTS_HUE,
      COLOUR_HUE,
      VARIABLES_HUE,
      VARIABLES_DYNAMIC_HUE,
      PROCEDURES_HUE,
      VARIABLES_DEFAULT_NAME,
      UNNAMED_KEY,
      TODAY,
      DUPLICATE_BLOCK,
      ADD_COMMENT,
      REMOVE_COMMENT,
      DUPLICATE_COMMENT,
      EXTERNAL_INPUTS,
      INLINE_INPUTS,
      DELETE_BLOCK,
      DELETE_X_BLOCKS,
      DELETE_ALL_BLOCKS,
      CLEAN_UP,
      CLOSE,
      COLLAPSE_BLOCK,
      COLLAPSE_ALL,
      EXPAND_BLOCK,
      EXPAND_ALL,
      DISABLE_BLOCK,
      ENABLE_BLOCK,
      HELP,
      UNDO,
      REDO,
      CHANGE_VALUE_TITLE,
      RENAME_VARIABLE,
      RENAME_VARIABLE_TITLE,
      NEW_VARIABLE,
      NEW_STRING_VARIABLE,
      NEW_NUMBER_VARIABLE,
      NEW_COLOUR_VARIABLE,
      NEW_VARIABLE_TYPE_TITLE,
      NEW_VARIABLE_TITLE,
      VARIABLE_ALREADY_EXISTS,
      VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,
      VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER,
      DELETE_VARIABLE_CONFIRMATION,
      CANNOT_DELETE_VARIABLE_PROCEDURE,
      DELETE_VARIABLE,
      COLOUR_PICKER_HELPURL,
      COLOUR_PICKER_TOOLTIP,
      COLOUR_RANDOM_HELPURL,
      COLOUR_RANDOM_TITLE,
      COLOUR_RANDOM_TOOLTIP,
      COLOUR_RGB_HELPURL,
      COLOUR_RGB_TITLE,
      COLOUR_RGB_RED,
      COLOUR_RGB_GREEN,
      COLOUR_RGB_BLUE,
      COLOUR_RGB_TOOLTIP,
      COLOUR_BLEND_HELPURL,
      COLOUR_BLEND_TITLE,
      COLOUR_BLEND_COLOUR1,
      COLOUR_BLEND_COLOUR2,
      COLOUR_BLEND_RATIO,
      COLOUR_BLEND_TOOLTIP,
      CONTROLS_REPEAT_HELPURL,
      CONTROLS_REPEAT_TITLE,
      CONTROLS_REPEAT_INPUT_DO,
      CONTROLS_REPEAT_TOOLTIP,
      CONTROLS_WHILEUNTIL_HELPURL,
      CONTROLS_WHILEUNTIL_INPUT_DO,
      CONTROLS_WHILEUNTIL_OPERATOR_WHILE,
      CONTROLS_WHILEUNTIL_OPERATOR_UNTIL,
      CONTROLS_WHILEUNTIL_TOOLTIP_WHILE,
      CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL,
      CONTROLS_FOR_HELPURL,
      CONTROLS_FOR_TOOLTIP,
      CONTROLS_FOR_TITLE,
      CONTROLS_FOR_INPUT_DO,
      CONTROLS_FOREACH_HELPURL,
      CONTROLS_FOREACH_TITLE,
      CONTROLS_FOREACH_INPUT_DO,
      CONTROLS_FOREACH_TOOLTIP,
      CONTROLS_FLOW_STATEMENTS_HELPURL,
      CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK,
      CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE,
      CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,
      CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE,
      CONTROLS_FLOW_STATEMENTS_WARNING,
      CONTROLS_IF_HELPURL,
      CONTROLS_IF_TOOLTIP_1,
      CONTROLS_IF_TOOLTIP_2,
      CONTROLS_IF_TOOLTIP_3,
      CONTROLS_IF_TOOLTIP_4,
      CONTROLS_IF_MSG_IF,
      CONTROLS_IF_MSG_ELSEIF,
      CONTROLS_IF_MSG_ELSE,
      CONTROLS_IF_MSG_THEN,
      CONTROLS_IF_IF_TITLE_IF,
      CONTROLS_IF_IF_TOOLTIP,
      CONTROLS_IF_ELSEIF_TITLE_ELSEIF,
      CONTROLS_IF_ELSEIF_TOOLTIP,
      CONTROLS_IF_ELSE_TITLE_ELSE,
      CONTROLS_IF_ELSE_TOOLTIP,
      LOGIC_COMPARE_HELPURL,
      LOGIC_COMPARE_TOOLTIP_EQ,
      LOGIC_COMPARE_TOOLTIP_NEQ,
      LOGIC_COMPARE_TOOLTIP_LT,
      LOGIC_COMPARE_TOOLTIP_LTE,
      LOGIC_COMPARE_TOOLTIP_GT,
      LOGIC_COMPARE_TOOLTIP_GTE,
      LOGIC_OPERATION_HELPURL,
      LOGIC_OPERATION_TOOLTIP_AND,
      LOGIC_OPERATION_AND,
      LOGIC_OPERATION_TOOLTIP_OR,
      LOGIC_OPERATION_OR,
      LOGIC_NEGATE_HELPURL,
      LOGIC_NEGATE_TITLE,
      LOGIC_NEGATE_TOOLTIP,
      LOGIC_BOOLEAN_HELPURL,
      LOGIC_BOOLEAN_TRUE,
      LOGIC_BOOLEAN_FALSE,
      LOGIC_BOOLEAN_TOOLTIP,
      LOGIC_NULL_HELPURL,
      LOGIC_NULL,
      LOGIC_NULL_TOOLTIP,
      LOGIC_TERNARY_HELPURL,
      LOGIC_TERNARY_CONDITION,
      LOGIC_TERNARY_IF_TRUE,
      LOGIC_TERNARY_IF_FALSE,
      LOGIC_TERNARY_TOOLTIP,
      MATH_NUMBER_HELPURL,
      MATH_NUMBER_TOOLTIP,
      MATH_ADDITION_SYMBOL,
      MATH_SUBTRACTION_SYMBOL,
      MATH_DIVISION_SYMBOL,
      MATH_MULTIPLICATION_SYMBOL,
      MATH_POWER_SYMBOL,
      MATH_TRIG_SIN,
      MATH_TRIG_COS,
      MATH_TRIG_TAN,
      MATH_TRIG_ASIN,
      MATH_TRIG_ACOS,
      MATH_TRIG_ATAN,
      MATH_ARITHMETIC_HELPURL,
      MATH_ARITHMETIC_TOOLTIP_ADD,
      MATH_ARITHMETIC_TOOLTIP_MINUS,
      MATH_ARITHMETIC_TOOLTIP_MULTIPLY,
      MATH_ARITHMETIC_TOOLTIP_DIVIDE,
      MATH_ARITHMETIC_TOOLTIP_POWER,
      MATH_SINGLE_HELPURL,
      MATH_SINGLE_OP_ROOT,
      MATH_SINGLE_TOOLTIP_ROOT,
      MATH_SINGLE_OP_ABSOLUTE,
      MATH_SINGLE_TOOLTIP_ABS,
      MATH_SINGLE_TOOLTIP_NEG,
      MATH_SINGLE_TOOLTIP_LN,
      MATH_SINGLE_TOOLTIP_LOG10,
      MATH_SINGLE_TOOLTIP_EXP,
      MATH_SINGLE_TOOLTIP_POW10,
      MATH_TRIG_HELPURL,
      MATH_TRIG_TOOLTIP_SIN,
      MATH_TRIG_TOOLTIP_COS,
      MATH_TRIG_TOOLTIP_TAN,
      MATH_TRIG_TOOLTIP_ASIN,
      MATH_TRIG_TOOLTIP_ACOS,
      MATH_TRIG_TOOLTIP_ATAN,
      MATH_CONSTANT_HELPURL,
      MATH_CONSTANT_TOOLTIP,
      MATH_IS_EVEN,
      MATH_IS_ODD,
      MATH_IS_PRIME,
      MATH_IS_WHOLE,
      MATH_IS_POSITIVE,
      MATH_IS_NEGATIVE,
      MATH_IS_DIVISIBLE_BY,
      MATH_IS_TOOLTIP,
      MATH_CHANGE_HELPURL,
      MATH_CHANGE_TITLE,
      MATH_CHANGE_TITLE_ITEM,
      MATH_CHANGE_TOOLTIP,
      MATH_ROUND_HELPURL,
      MATH_ROUND_TOOLTIP,
      MATH_ROUND_OPERATOR_ROUND,
      MATH_ROUND_OPERATOR_ROUNDUP,
      MATH_ROUND_OPERATOR_ROUNDDOWN,
      MATH_ONLIST_HELPURL,
      MATH_ONLIST_OPERATOR_SUM,
      MATH_ONLIST_TOOLTIP_SUM,
      MATH_ONLIST_OPERATOR_MIN,
      MATH_ONLIST_TOOLTIP_MIN,
      MATH_ONLIST_OPERATOR_MAX,
      MATH_ONLIST_TOOLTIP_MAX,
      MATH_ONLIST_OPERATOR_AVERAGE,
      MATH_ONLIST_TOOLTIP_AVERAGE,
      MATH_ONLIST_OPERATOR_MEDIAN,
      MATH_ONLIST_TOOLTIP_MEDIAN,
      MATH_ONLIST_OPERATOR_MODE,
      MATH_ONLIST_TOOLTIP_MODE,
      MATH_ONLIST_OPERATOR_STD_DEV,
      MATH_ONLIST_TOOLTIP_STD_DEV,
      MATH_ONLIST_OPERATOR_RANDOM,
      MATH_ONLIST_TOOLTIP_RANDOM,
      MATH_MODULO_HELPURL,
      MATH_MODULO_TITLE,
      MATH_MODULO_TOOLTIP,
      MATH_CONSTRAIN_HELPURL,
      MATH_CONSTRAIN_TITLE,
      MATH_CONSTRAIN_TOOLTIP,
      MATH_RANDOM_INT_HELPURL,
      MATH_RANDOM_INT_TITLE,
      MATH_RANDOM_INT_TOOLTIP,
      MATH_RANDOM_FLOAT_HELPURL,
      MATH_RANDOM_FLOAT_TITLE_RANDOM,
      MATH_RANDOM_FLOAT_TOOLTIP,
      MATH_ATAN2_HELPURL,
      MATH_ATAN2_TITLE,
      MATH_ATAN2_TOOLTIP,
      TEXT_TEXT_HELPURL,
      TEXT_TEXT_TOOLTIP,
      TEXT_JOIN_HELPURL,
      TEXT_JOIN_TITLE_CREATEWITH,
      TEXT_JOIN_TOOLTIP,
      TEXT_CREATE_JOIN_TITLE_JOIN,
      TEXT_CREATE_JOIN_TOOLTIP,
      TEXT_CREATE_JOIN_ITEM_TITLE_ITEM,
      TEXT_CREATE_JOIN_ITEM_TOOLTIP,
      TEXT_APPEND_HELPURL,
      TEXT_APPEND_TITLE,
      TEXT_APPEND_VARIABLE,
      TEXT_APPEND_TOOLTIP,
      TEXT_LENGTH_HELPURL,
      TEXT_LENGTH_TITLE,
      TEXT_LENGTH_TOOLTIP,
      TEXT_ISEMPTY_HELPURL,
      TEXT_ISEMPTY_TITLE,
      TEXT_ISEMPTY_TOOLTIP,
      TEXT_INDEXOF_HELPURL,
      TEXT_INDEXOF_TOOLTIP,
      TEXT_INDEXOF_TITLE,
      TEXT_INDEXOF_OPERATOR_FIRST,
      TEXT_INDEXOF_OPERATOR_LAST,
      TEXT_CHARAT_HELPURL,
      TEXT_CHARAT_TITLE,
      TEXT_CHARAT_FROM_START,
      TEXT_CHARAT_FROM_END,
      TEXT_CHARAT_FIRST,
      TEXT_CHARAT_LAST,
      TEXT_CHARAT_RANDOM,
      TEXT_CHARAT_TAIL,
      TEXT_CHARAT_TOOLTIP,
      TEXT_GET_SUBSTRING_TOOLTIP,
      TEXT_GET_SUBSTRING_HELPURL,
      TEXT_GET_SUBSTRING_INPUT_IN_TEXT,
      TEXT_GET_SUBSTRING_START_FROM_START,
      TEXT_GET_SUBSTRING_START_FROM_END,
      TEXT_GET_SUBSTRING_START_FIRST,
      TEXT_GET_SUBSTRING_END_FROM_START,
      TEXT_GET_SUBSTRING_END_FROM_END,
      TEXT_GET_SUBSTRING_END_LAST,
      TEXT_GET_SUBSTRING_TAIL,
      TEXT_CHANGECASE_HELPURL,
      TEXT_CHANGECASE_TOOLTIP,
      TEXT_CHANGECASE_OPERATOR_UPPERCASE,
      TEXT_CHANGECASE_OPERATOR_LOWERCASE,
      TEXT_CHANGECASE_OPERATOR_TITLECASE,
      TEXT_TRIM_HELPURL,
      TEXT_TRIM_TOOLTIP,
      TEXT_TRIM_OPERATOR_BOTH,
      TEXT_TRIM_OPERATOR_LEFT,
      TEXT_TRIM_OPERATOR_RIGHT,
      TEXT_PRINT_HELPURL,
      TEXT_PRINT_TITLE,
      TEXT_PRINT_TOOLTIP,
      TEXT_PROMPT_HELPURL,
      TEXT_PROMPT_TYPE_TEXT,
      TEXT_PROMPT_TYPE_NUMBER,
      TEXT_PROMPT_TOOLTIP_NUMBER,
      TEXT_PROMPT_TOOLTIP_TEXT,
      TEXT_COUNT_MESSAGE0,
      TEXT_COUNT_HELPURL,
      TEXT_COUNT_TOOLTIP,
      TEXT_REPLACE_MESSAGE0,
      TEXT_REPLACE_HELPURL,
      TEXT_REPLACE_TOOLTIP,
      TEXT_REVERSE_MESSAGE0,
      TEXT_REVERSE_HELPURL,
      TEXT_REVERSE_TOOLTIP,
      LISTS_CREATE_EMPTY_HELPURL,
      LISTS_CREATE_EMPTY_TITLE,
      LISTS_CREATE_EMPTY_TOOLTIP,
      LISTS_CREATE_WITH_HELPURL,
      LISTS_CREATE_WITH_TOOLTIP,
      LISTS_CREATE_WITH_INPUT_WITH,
      LISTS_CREATE_WITH_CONTAINER_TITLE_ADD,
      LISTS_CREATE_WITH_CONTAINER_TOOLTIP,
      LISTS_CREATE_WITH_ITEM_TITLE,
      LISTS_CREATE_WITH_ITEM_TOOLTIP,
      LISTS_REPEAT_HELPURL,
      LISTS_REPEAT_TOOLTIP,
      LISTS_REPEAT_TITLE,
      LISTS_LENGTH_HELPURL,
      LISTS_LENGTH_TITLE,
      LISTS_LENGTH_TOOLTIP,
      LISTS_ISEMPTY_HELPURL,
      LISTS_ISEMPTY_TITLE,
      LISTS_ISEMPTY_TOOLTIP,
      LISTS_INLIST,
      LISTS_INDEX_OF_HELPURL,
      LISTS_INDEX_OF_INPUT_IN_LIST,
      LISTS_INDEX_OF_FIRST,
      LISTS_INDEX_OF_LAST,
      LISTS_INDEX_OF_TOOLTIP,
      LISTS_GET_INDEX_HELPURL,
      LISTS_GET_INDEX_GET,
      LISTS_GET_INDEX_GET_REMOVE,
      LISTS_GET_INDEX_REMOVE,
      LISTS_GET_INDEX_FROM_START,
      LISTS_GET_INDEX_FROM_END,
      LISTS_GET_INDEX_FIRST,
      LISTS_GET_INDEX_LAST,
      LISTS_GET_INDEX_RANDOM,
      LISTS_GET_INDEX_TAIL,
      LISTS_GET_INDEX_INPUT_IN_LIST,
      LISTS_INDEX_FROM_START_TOOLTIP,
      LISTS_INDEX_FROM_END_TOOLTIP,
      LISTS_GET_INDEX_TOOLTIP_GET_FROM,
      LISTS_GET_INDEX_TOOLTIP_GET_FIRST,
      LISTS_GET_INDEX_TOOLTIP_GET_LAST,
      LISTS_GET_INDEX_TOOLTIP_GET_RANDOM,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST,
      LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST,
      LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM,
      LISTS_SET_INDEX_HELPURL,
      LISTS_SET_INDEX_INPUT_IN_LIST,
      LISTS_SET_INDEX_SET,
      LISTS_SET_INDEX_INSERT,
      LISTS_SET_INDEX_INPUT_TO,
      LISTS_SET_INDEX_TOOLTIP_SET_FROM,
      LISTS_SET_INDEX_TOOLTIP_SET_FIRST,
      LISTS_SET_INDEX_TOOLTIP_SET_LAST,
      LISTS_SET_INDEX_TOOLTIP_SET_RANDOM,
      LISTS_SET_INDEX_TOOLTIP_INSERT_FROM,
      LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST,
      LISTS_SET_INDEX_TOOLTIP_INSERT_LAST,
      LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM,
      LISTS_GET_SUBLIST_HELPURL,
      LISTS_GET_SUBLIST_INPUT_IN_LIST,
      LISTS_GET_SUBLIST_START_FROM_START,
      LISTS_GET_SUBLIST_START_FROM_END,
      LISTS_GET_SUBLIST_START_FIRST,
      LISTS_GET_SUBLIST_END_FROM_START,
      LISTS_GET_SUBLIST_END_FROM_END,
      LISTS_GET_SUBLIST_END_LAST,
      LISTS_GET_SUBLIST_TAIL,
      LISTS_GET_SUBLIST_TOOLTIP,
      LISTS_SORT_HELPURL,
      LISTS_SORT_TITLE,
      LISTS_SORT_TOOLTIP,
      LISTS_SORT_ORDER_ASCENDING,
      LISTS_SORT_ORDER_DESCENDING,
      LISTS_SORT_TYPE_NUMERIC,
      LISTS_SORT_TYPE_TEXT,
      LISTS_SORT_TYPE_IGNORECASE,
      LISTS_SPLIT_HELPURL,
      LISTS_SPLIT_LIST_FROM_TEXT,
      LISTS_SPLIT_TEXT_FROM_LIST,
      LISTS_SPLIT_WITH_DELIMITER,
      LISTS_SPLIT_TOOLTIP_SPLIT,
      LISTS_SPLIT_TOOLTIP_JOIN,
      LISTS_REVERSE_HELPURL,
      LISTS_REVERSE_MESSAGE0,
      LISTS_REVERSE_TOOLTIP,
      ORDINAL_NUMBER_SUFFIX,
      VARIABLES_GET_HELPURL,
      VARIABLES_GET_TOOLTIP,
      VARIABLES_GET_CREATE_SET,
      VARIABLES_SET_HELPURL,
      VARIABLES_SET,
      VARIABLES_SET_TOOLTIP,
      VARIABLES_SET_CREATE_GET,
      PROCEDURES_DEFNORETURN_HELPURL,
      PROCEDURES_DEFNORETURN_TITLE,
      PROCEDURES_DEFNORETURN_PROCEDURE,
      PROCEDURES_BEFORE_PARAMS,
      PROCEDURES_CALL_BEFORE_PARAMS,
      PROCEDURES_CALL_DISABLED_DEF_WARNING,
      PROCEDURES_DEFNORETURN_DO,
      PROCEDURES_DEFNORETURN_TOOLTIP,
      PROCEDURES_DEFNORETURN_COMMENT,
      PROCEDURES_DEFRETURN_HELPURL,
      PROCEDURES_DEFRETURN_TITLE,
      PROCEDURES_DEFRETURN_PROCEDURE,
      PROCEDURES_DEFRETURN_DO,
      PROCEDURES_DEFRETURN_COMMENT,
      PROCEDURES_DEFRETURN_RETURN,
      PROCEDURES_DEFRETURN_TOOLTIP,
      PROCEDURES_ALLOW_STATEMENTS,
      PROCEDURES_DEF_DUPLICATE_WARNING,
      PROCEDURES_CALLNORETURN_HELPURL,
      PROCEDURES_CALLNORETURN_TOOLTIP,
      PROCEDURES_CALLRETURN_HELPURL,
      PROCEDURES_CALLRETURN_TOOLTIP,
      PROCEDURES_MUTATORCONTAINER_TITLE,
      PROCEDURES_MUTATORCONTAINER_TOOLTIP,
      PROCEDURES_MUTATORARG_TITLE,
      PROCEDURES_MUTATORARG_TOOLTIP,
      PROCEDURES_HIGHLIGHT_DEF,
      PROCEDURES_CREATE_DO,
      PROCEDURES_IFRETURN_TOOLTIP,
      PROCEDURES_IFRETURN_HELPURL,
      PROCEDURES_IFRETURN_WARNING,
      WORKSPACE_COMMENT_DEFAULT_TEXT,
      WORKSPACE_ARIA_LABEL,
      COLLAPSED_WARNINGS_WARNING,
      DIALOG_OK,
      DIALOG_CANCEL,
      EDIT_BLOCK_CONTENTS,
      MOVE_BLOCK,
      WINDOWS,
      MAC_OS,
      CHROME_OS,
      LINUX,
      UNKNOWN,
      CONTROL_KEY,
      COMMAND_KEY,
      OPTION_KEY,
      ALT_KEY,
      CUT_SHORTCUT,
      COPY_SHORTCUT,
      PASTE_SHORTCUT,
      HELP_PROMPT,
      SHORTCUTS_GENERAL,
      SHORTCUTS_EDITING,
      SHORTCUTS_CODE_NAVIGATION,
      KEYBOARD_NAV_UNCONSTRAINED_MOVE_HINT,
      KEYBOARD_NAV_CONSTRAINED_MOVE_HINT,
      KEYBOARD_NAV_COPIED_HINT,
      KEYBOARD_NAV_CUT_HINT
    } = import_en.default;
    var definitions = [
      // BoolTrue - true literal
      {
        type: "ground_bool_true",
        tooltip: "Boolean true literal",
        message0: "true",
        output: "Ground",
        colour: "160"
      },
      // BoolFalse - false literal
      {
        type: "ground_bool_false",
        tooltip: "Boolean false literal",
        message0: "false",
        output: "Ground",
        colour: "160"
      },
      // GroundInt - integer literal
      {
        type: "ground_int",
        tooltip: "Integer literal",
        message0: "%1",
        args0: [
          {
            type: "field_number",
            name: "VALUE",
            value: 0,
            precision: 1
          }
        ],
        output: "Ground",
        colour: "230"
      },
      // GroundString - string literal
      {
        type: "ground_string",
        tooltip: "String literal",
        message0: '"%1"',
        args0: [
          {
            type: "field_input",
            name: "VALUE",
            text: ""
          }
        ],
        output: "Ground",
        colour: "160"
      },
      // GroundUri - URI literal
      {
        type: "ground_uri",
        tooltip: "URI literal",
        message0: "`%1`",
        args0: [
          {
            type: "field_input",
            name: "VALUE",
            text: ""
          }
        ],
        output: "Ground",
        colour: "290"
      },
      // SimpleTypes
      {
        type: "simple_type_bool",
        tooltip: "Bool type",
        message0: "Bool",
        output: "SimpleType",
        colour: "160"
      },
      {
        type: "simple_type_int",
        tooltip: "Int type",
        message0: "Int",
        output: "SimpleType",
        colour: "230"
      },
      {
        type: "simple_type_string",
        tooltip: "String type",
        message0: "String",
        output: "SimpleType",
        colour: "160"
      },
      {
        type: "simple_type_uri",
        tooltip: "Uri type",
        message0: "Uri",
        output: "SimpleType",
        colour: "290"
      },
      {
        type: "simple_type_byte_array",
        tooltip: "ByteArray type",
        message0: "ByteArray",
        output: "SimpleType",
        colour: "290"
      }
    ];
    var ground_default = common.createBlockDefinitionsFromJsonArray(definitions);
    var definitions2 = [
      // NameWildcard - wildcard name "_"
      {
        type: "name_wildcard",
        tooltip: "Wildcard name pattern",
        message0: "_",
        output: "Name",
        colour: "65"
      },
      // NameVar - variable name
      {
        type: "name_var",
        tooltip: "Variable name",
        message0: "%1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          }
        ],
        output: "Name",
        colour: "65"
      },
      // NameQuote - quoted process @Proc
      {
        type: "name_quote",
        tooltip: "Quote process to name: @Proc",
        message0: "@ %1",
        args0: [
          {
            type: "input_value",
            name: "PROC",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Name",
        colour: "65"
      },
      // NameDecl - simple name declaration
      {
        type: "name_decl_simple",
        tooltip: "Simple name declaration",
        message0: "%1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          }
        ],
        output: "NameDecl",
        colour: "65"
      },
      // NameDeclUrn - name declaration with URN
      {
        type: "name_decl_urn",
        tooltip: "Name declaration with URN",
        message0: "%1 ( `%2` )",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          },
          {
            type: "field_input",
            name: "URN",
            text: ""
          }
        ],
        output: "NameDecl",
        colour: "65"
      },
      // NameRemainder - for variadic patterns
      {
        type: "name_remainder",
        tooltip: "Name remainder pattern ...@var",
        message0: "...@ %1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "rest"
          }
        ],
        output: "NameRemainder",
        colour: "65"
      }
    ];
    var names_default = common.createBlockDefinitionsFromJsonArray(definitions2);
    var definitions3 = [
      // CollectList - list collection [Proc, ...]
      {
        type: "collect_list",
        tooltip: "List collection: [elements...]",
        message0: "[ %1 ]",
        args0: [
          {
            type: "input_value",
            name: "ELEMENTS",
            check: "ProcList"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // CollectList with remainder
      {
        type: "collect_list_remainder",
        tooltip: "List with remainder: [elements...rest]",
        message0: "[ %1 ...%2 ]",
        args0: [
          {
            type: "input_value",
            name: "ELEMENTS",
            check: "ProcList"
          },
          {
            type: "field_input",
            name: "REMAINDER",
            text: "rest"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // TupleSingle - single element tuple (x,)
      {
        type: "tuple_single",
        tooltip: "Single element tuple: (element,)",
        message0: "( %1 ,)",
        args0: [
          {
            type: "input_value",
            name: "ELEMENT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // TupleMultiple - multiple element tuple
      {
        type: "tuple_multiple",
        tooltip: "Tuple: (element, elements...)",
        message0: "( %1 , %2 )",
        args0: [
          {
            type: "input_value",
            name: "FIRST",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "REST",
            check: "ProcList"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // CollectSet - set collection Set(...)
      {
        type: "collect_set",
        tooltip: "Set collection: Set(elements...)",
        message0: "Set( %1 )",
        args0: [
          {
            type: "input_value",
            name: "ELEMENTS",
            check: "ProcList"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // CollectMap - map collection {key: value, ...}
      {
        type: "collect_map",
        tooltip: "Map collection: {key: value, ...}",
        message0: "{ %1 }",
        args0: [
          {
            type: "input_value",
            name: "PAIRS",
            check: "KeyValuePairList"
          }
        ],
        inputsInline: true,
        output: "Collection",
        colour: "260"
      },
      // KeyValuePair - single key-value pair
      {
        type: "key_value_pair",
        tooltip: "Key-value pair: key: value",
        message0: "%1 : %2",
        args0: [
          {
            type: "input_value",
            name: "KEY",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "VALUE",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "KeyValuePair",
        colour: "260"
      },
      // ProcList - list of processes (for args)
      {
        type: "proc_list",
        tooltip: "List of processes",
        message0: "%1 , %2",
        args0: [
          {
            type: "input_value",
            name: "ITEM",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "NEXT",
            check: ["ProcList", "Proc"]
          }
        ],
        inputsInline: true,
        output: "ProcList",
        colour: "260"
      },
      // ProcRemainder - process remainder for collections
      {
        type: "proc_remainder",
        tooltip: "Process remainder: ...var",
        message0: "...%1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "rest"
          }
        ],
        output: "ProcRemainder",
        colour: "260"
      },
      // NameList - list of names (for bindings)
      {
        type: "name_list",
        tooltip: "List of names",
        message0: "%1 , %2",
        args0: [
          {
            type: "input_value",
            name: "ITEM",
            check: "Name"
          },
          {
            type: "input_value",
            name: "NEXT",
            check: ["NameList", "Name"]
          }
        ],
        inputsInline: true,
        output: "NameList",
        colour: "65"
      }
    ];
    var collections_default = common.createBlockDefinitionsFromJsonArray(definitions3);
    var definitions4 = [
      // LinearBind - simple linear bind: names <- source
      {
        type: "linear_bind",
        tooltip: "Linear bind: pattern <- channel",
        message0: "%1 <- %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "LinearBind",
        colour: "210"
      },
      // LinearBind with receive-send source: names <- channel?!
      {
        type: "linear_bind_receive_send",
        tooltip: "Linear bind with receive-send: pattern <- channel?!",
        message0: "%1 <- %2 ?!",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "LinearBind",
        colour: "210"
      },
      // LinearBind with send-receive source: names <- channel!?(args)
      {
        type: "linear_bind_send_receive",
        tooltip: "Linear bind with send-receive: pattern <- channel!?(args)",
        message0: "%1 <- %2 !?( %3 )",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: "ProcList"
          }
        ],
        inputsInline: true,
        output: "LinearBind",
        colour: "210"
      },
      // RepeatedBind - repeated bind: names <= source
      {
        type: "repeated_bind",
        tooltip: "Repeated bind: pattern <= channel",
        message0: "%1 <= %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "RepeatedBind",
        colour: "210"
      },
      // PeekBind - peek bind: names <<- source
      {
        type: "peek_bind",
        tooltip: "Peek bind: pattern <<- channel",
        message0: "%1 <<- %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "PeekBind",
        colour: "210"
      },
      // ReceiptLinear - linear receipt wrapper
      {
        type: "receipt_linear",
        tooltip: "Linear receipt",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "BINDS",
            check: "LinearBind"
          }
        ],
        inputsInline: true,
        output: "Receipt",
        colour: "210"
      },
      // ReceiptRepeated - repeated receipt wrapper
      {
        type: "receipt_repeated",
        tooltip: "Repeated receipt",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "BINDS",
            check: "RepeatedBind"
          }
        ],
        inputsInline: true,
        output: "Receipt",
        colour: "210"
      },
      // ReceiptPeek - peek receipt wrapper
      {
        type: "receipt_peek",
        tooltip: "Peek receipt",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "BINDS",
            check: "PeekBind"
          }
        ],
        inputsInline: true,
        output: "Receipt",
        colour: "210"
      },
      // Concurrent binds with &
      {
        type: "concurrent_binds",
        tooltip: "Concurrent binds: bind1 & bind2",
        message0: "%1 & %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: ["LinearBind", "RepeatedBind", "PeekBind"]
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: ["LinearBind", "RepeatedBind", "PeekBind"]
          }
        ],
        inputsInline: true,
        output: ["LinearBind", "RepeatedBind", "PeekBind"],
        colour: "210"
      },
      // Sequential receipts with ;
      {
        type: "sequential_receipts",
        tooltip: "Sequential receipts: receipt1 ; receipt2",
        message0: "%1 ; %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Receipt"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Receipt"
          }
        ],
        inputsInline: true,
        output: "Receipt",
        colour: "210"
      },
      // Symmetric linear bind: names <-> source
      {
        type: "linear_bind_symm",
        tooltip: "Symmetric linear bind: pattern <-> channel",
        message0: "%1 <-> %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "LinearBindSymm",
        colour: "210"
      },
      // Symmetric repeated bind: names <=> source
      {
        type: "repeated_bind_symm",
        tooltip: "Symmetric repeated bind: pattern <=> channel",
        message0: "%1 <=> %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "RepeatedBindSymm",
        colour: "210"
      },
      // Symmetric peek bind: names <<->> source
      {
        type: "peek_bind_symm",
        tooltip: "Symmetric peek bind: pattern <<->> channel",
        message0: "%1 <<->> %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "SOURCE",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "PeekBindSymm",
        colour: "210"
      }
    ];
    var receipts_default = common.createBlockDefinitionsFromJsonArray(definitions4);
    var definitions5 = [
      // PIf - if statement without else
      {
        type: "proc_if",
        tooltip: "Conditional: if (condition) body",
        message0: "if ( %1 ) %2",
        args0: [
          {
            type: "input_value",
            name: "CONDITION",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PIfElse - if statement with else
      {
        type: "proc_if_else",
        tooltip: "Conditional: if (condition) then else",
        message0: "if ( %1 ) %2 else %3",
        args0: [
          {
            type: "input_value",
            name: "CONDITION",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "THEN_BODY",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "ELSE_BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PMatch - match expression
      {
        type: "proc_match",
        tooltip: "Pattern match: match expr { cases }",
        message0: "match %1 { %2 }",
        args0: [
          {
            type: "input_value",
            name: "EXPR",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "CASES",
            check: "Case"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // CaseImpl - match case
      {
        type: "case",
        tooltip: "Match case: pattern => body",
        message0: "%1 => %2",
        args0: [
          {
            type: "input_value",
            name: "PATTERN",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Case",
        nextStatement: "Case",
        colour: "208bfe"
      },
      // PChoice - select statement
      {
        type: "proc_select",
        tooltip: "Select: select { branches }",
        message0: "select { %1 }",
        args0: [
          {
            type: "input_statement",
            name: "BRANCHES",
            check: "Branch"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // BranchImpl - select branch
      {
        type: "branch",
        tooltip: "Select branch: receipt => body",
        message0: "%1 => %2",
        args0: [
          {
            type: "input_value",
            name: "RECEIPT",
            check: "LinearBind"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Branch",
        nextStatement: "Branch",
        colour: "208bfe"
      }
    ];
    var control_default = common.createBlockDefinitionsFromJsonArray(definitions5);
    var definitions6 = [
      // PNew - new name declaration
      {
        type: "proc_new",
        tooltip: "New: new names in body",
        message0: "new %1 in %2",
        args0: [
          {
            type: "input_value",
            name: "NAMES",
            check: ["NameDecl", "NameDeclList"]
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // NameDeclList - comma-separated name declarations
      {
        type: "name_decl_list",
        tooltip: "Name declarations: name1, name2, ...",
        message0: "%1 , %2",
        args0: [
          {
            type: "input_value",
            name: "ITEM",
            check: "NameDecl"
          },
          {
            type: "input_value",
            name: "NEXT",
            check: ["NameDeclList", "NameDecl"]
          }
        ],
        inputsInline: true,
        output: "NameDeclList",
        colour: "65"
      },
      // PLet - let declaration
      {
        type: "proc_let",
        tooltip: "Let: let decls in body",
        message0: "let %1 in { %2 }",
        args0: [
          {
            type: "input_value",
            name: "DECLS",
            check: "Decl"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // DeclImpl - let declaration binding
      {
        type: "decl",
        tooltip: "Declaration: names <- procs",
        message0: "%1 <- %2",
        args0: [
          {
            type: "input_value",
            name: "NAMES",
            check: ["Name", "NameList"]
          },
          {
            type: "input_value",
            name: "PROCS",
            check: ["Proc", "ProcList"]
          }
        ],
        inputsInline: true,
        output: "Decl",
        colour: "208bfe"
      },
      // Linear declarations with ;
      {
        type: "linear_decls",
        tooltip: "Linear declarations: decl1 ; decl2",
        message0: "%1 ; %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Decl"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Decl"
          }
        ],
        inputsInline: true,
        output: "Decl",
        colour: "208bfe"
      },
      // Concurrent declarations with &
      {
        type: "conc_decls",
        tooltip: "Concurrent declarations: decl1 & decl2",
        message0: "%1 & %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Decl"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Decl"
          }
        ],
        inputsInline: true,
        output: "Decl",
        colour: "208bfe"
      },
      // PContr - contract definition
      {
        type: "proc_contract",
        tooltip: "Contract: contract name(params) = { body }",
        message0: "contract %1 ( %2 ) = { %3 }",
        args0: [
          {
            type: "input_value",
            name: "NAME",
            check: "Name"
          },
          {
            type: "input_value",
            name: "PARAMS",
            check: ["Name", "NameList"]
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "1B9461"
      },
      // Contract with remainder
      {
        type: "proc_contract_remainder",
        tooltip: "Contract with remainder: contract name(params...rest) = { body }",
        message0: "contract %1 ( %2 ...@ %3 ) = { %4 }",
        args0: [
          {
            type: "input_value",
            name: "NAME",
            check: "Name"
          },
          {
            type: "input_value",
            name: "PARAMS",
            check: ["Name", "NameList"]
          },
          {
            type: "field_input",
            name: "REMAINDER",
            text: "rest"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "1B9461"
      },
      // PBundle - bundle
      {
        type: "proc_bundle_write",
        tooltip: "Write-only bundle: bundle+ { body }",
        message0: "bundle+ { %1 }",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      {
        type: "proc_bundle_read",
        tooltip: "Read-only bundle: bundle- { body }",
        message0: "bundle- { %1 }",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      {
        type: "proc_bundle_equiv",
        tooltip: "Equivalence bundle: bundle0 { body }",
        message0: "bundle0 { %1 }",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      {
        type: "proc_bundle_rw",
        tooltip: "Read-write bundle: bundle { body }",
        message0: "bundle { %1 }",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      }
    ];
    var declarations_default = common.createBlockDefinitionsFromJsonArray(definitions6);
    var definitions7 = [
      // === Root Block ===
      // Root block that serves as the entry point for all processes
      {
        type: "proc_root",
        tooltip: "Root process - all blocks must connect to this",
        message0: "Root %1",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        colour: "0",
        deletable: false
      },
      // === Basic Process Types ===
      // PNil - nil process
      {
        type: "proc_nil",
        tooltip: "Nil process",
        message0: "Nil",
        output: "Proc",
        colour: "208bfe"
      },
      // PGround - ground value as process
      {
        type: "proc_ground",
        tooltip: "Ground value as process",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "VALUE",
            check: "Ground"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PCollect - collection as process
      {
        type: "proc_collect",
        tooltip: "Collection as process",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "VALUE",
            check: "Collection"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PVar - process variable
      {
        type: "proc_var",
        tooltip: "Process variable",
        message0: "%1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          }
        ],
        output: "Proc",
        colour: "208bfe"
      },
      // ProcVarWildcard - wildcard variable
      {
        type: "proc_var_wildcard",
        tooltip: "Wildcard process variable",
        message0: "_",
        output: "Proc",
        colour: "208bfe"
      },
      // PVarRef - variable reference (=var or =*var)
      {
        type: "proc_var_ref",
        tooltip: "Variable reference: =var",
        message0: "= %1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          }
        ],
        output: "Proc",
        colour: "208bfe"
      },
      {
        type: "proc_var_ref_name",
        tooltip: "Name variable reference: =*var",
        message0: "=* %1",
        args0: [
          {
            type: "field_input",
            name: "VAR",
            text: "x"
          }
        ],
        output: "Proc",
        colour: "208bfe"
      },
      // PSimpleType - simple type as process
      {
        type: "proc_simple_type",
        tooltip: "Simple type as process",
        message0: "%1",
        args0: [
          {
            type: "input_value",
            name: "TYPE",
            check: "SimpleType"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PEval - evaluate name to process
      {
        type: "proc_eval",
        tooltip: "Evaluate name: *name",
        message0: "* %1",
        args0: [
          {
            type: "input_value",
            name: "NAME",
            check: "Name"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PExprs - parenthesized expression
      {
        type: "proc_paren",
        tooltip: "Parenthesized expression",
        message0: "( %1 )",
        args0: [
          {
            type: "input_value",
            name: "EXPR",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // === Logical Operations ===
      // PNegation - process negation (~)
      {
        type: "proc_negation",
        tooltip: "Process negation: ~proc",
        message0: "~ %1",
        args0: [
          {
            type: "input_value",
            name: "PROC",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PConjunction - process conjunction (/\)
      {
        type: "proc_conjunction",
        tooltip: "Process conjunction: proc /\\ proc",
        message0: "%1 /\\ %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PDisjunction - process disjunction (\/)
      {
        type: "proc_disjunction",
        tooltip: "Process disjunction: proc \\/ proc",
        message0: "%1 \\/ %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PNot - logical not
      {
        type: "proc_not",
        tooltip: "Logical not: not proc",
        message0: "not %1",
        args0: [
          {
            type: "input_value",
            name: "PROC",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PAnd - logical and
      {
        type: "proc_and",
        tooltip: "Logical and: proc and proc",
        message0: "%1 and %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // POr - logical or
      {
        type: "proc_or",
        tooltip: "Logical or: proc or proc",
        message0: "%1 or %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // === Arithmetic Operations ===
      // PNeg - unary negation
      {
        type: "proc_neg",
        tooltip: "Unary negation: -proc",
        message0: "- %1",
        args0: [
          {
            type: "input_value",
            name: "PROC",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PMult - multiplication
      {
        type: "proc_mult",
        tooltip: "Multiplication: proc * proc",
        message0: "%1 * %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PDiv - division
      {
        type: "proc_div",
        tooltip: "Division: proc / proc",
        message0: "%1 / %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PMod - modulo
      {
        type: "proc_mod",
        tooltip: "Modulo: proc % proc",
        message0: "%1 %% %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PPercentPercent - percent percent operator
      {
        type: "proc_percent_percent",
        tooltip: "Percent percent: proc %% proc",
        message0: "%1 %%%% %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PAdd - addition
      {
        type: "proc_add",
        tooltip: "Addition: proc + proc",
        message0: "%1 + %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PMinus - subtraction
      {
        type: "proc_minus",
        tooltip: "Subtraction: proc - proc",
        message0: "%1 - %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PPlusPlus - list concatenation
      {
        type: "proc_plus_plus",
        tooltip: "List concatenation: proc ++ proc",
        message0: "%1 ++ %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PMinusMinus - set difference
      {
        type: "proc_minus_minus",
        tooltip: "Set difference: proc -- proc",
        message0: "%1 -- %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // === Comparison Operations ===
      // PLt - less than
      {
        type: "proc_lt",
        tooltip: "Less than: proc < proc",
        message0: "%1 < %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PLte - less than or equal
      {
        type: "proc_lte",
        tooltip: "Less than or equal: proc <= proc",
        message0: "%1 <= %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PGt - greater than
      {
        type: "proc_gt",
        tooltip: "Greater than: proc > proc",
        message0: "%1 > %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PGte - greater than or equal
      {
        type: "proc_gte",
        tooltip: "Greater than or equal: proc >= proc",
        message0: "%1 >= %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PEq - equality
      {
        type: "proc_eq",
        tooltip: "Equality: proc == proc",
        message0: "%1 == %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PNeq - not equal
      {
        type: "proc_neq",
        tooltip: "Not equal: proc != proc",
        message0: "%1 != %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PMatches - pattern match
      {
        type: "proc_matches",
        tooltip: "Pattern matches: proc matches proc",
        message0: "%1 matches %2",
        args0: [
          {
            type: "input_value",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_value",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // === Method and Path Operations ===
      // PMethod - method call
      {
        type: "proc_method",
        tooltip: "Method call: proc.method(args)",
        message0: "%1 . %2 ( %3 )",
        args0: [
          {
            type: "input_value",
            name: "OBJECT",
            check: "Proc"
          },
          {
            type: "field_input",
            name: "METHOD",
            text: "method"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: ["Proc", "ProcList"]
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // PPathMap - path map operator
      {
        type: "proc_path_map",
        tooltip: "Path map: %proc",
        message0: "%% %1",
        args0: [
          {
            type: "input_value",
            name: "PROC",
            check: "Proc"
          }
        ],
        inputsInline: true,
        output: "Proc",
        colour: "208bfe"
      },
      // === Send Operations ===
      // PSend - single send
      {
        type: "proc_send",
        tooltip: "Send: channel!(args)",
        message0: "%1 ! ( %2 )",
        args0: [
          {
            type: "input_value",
            name: "CHANNEL",
            check: "Name"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: ["Proc", "ProcList"]
          }
        ],
        inputsInline: true,
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PSend - multiple send
      {
        type: "proc_send_multiple",
        tooltip: "Persistent send: channel!!(args)",
        message0: "%1 !! ( %2 )",
        args0: [
          {
            type: "input_value",
            name: "CHANNEL",
            check: "Name"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: ["Proc", "ProcList"]
          }
        ],
        inputsInline: true,
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PSend - symmetric send
      {
        type: "proc_send_symm",
        tooltip: "Symmetric send: channel!$(args)",
        message0: "%1 !$ ( %2 )",
        args0: [
          {
            type: "input_value",
            name: "CHANNEL",
            check: "Name"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: ["Proc", "ProcList"]
          }
        ],
        inputsInline: true,
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PSendSynch - synchronous send
      {
        type: "proc_send_synch",
        tooltip: "Synchronous send: channel!?(args)",
        message0: "%1 !? ( %2 ) %3",
        args0: [
          {
            type: "input_value",
            name: "CHANNEL",
            check: "Name"
          },
          {
            type: "input_value",
            name: "ARGS",
            check: ["Proc", "ProcList"]
          },
          {
            type: "input_value",
            name: "CONT",
            check: "SynchSendCont"
          }
        ],
        inputsInline: true,
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // SynchSendCont - empty continuation
      {
        type: "synch_send_cont_empty",
        tooltip: "Empty synchronous send continuation",
        message0: ".",
        output: "SynchSendCont",
        colour: "208bfe"
      },
      // SynchSendCont - non-empty continuation
      {
        type: "synch_send_cont",
        tooltip: "Synchronous send continuation: ; proc",
        message0: "; %1",
        args0: [
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        output: "SynchSendCont",
        colour: "208bfe"
      },
      // === Input Operations ===
      // PInput - for loop
      {
        type: "proc_for",
        tooltip: "For: for (receipts) { body }",
        message0: "for ( %1 ) { %2 }",
        args0: [
          {
            type: "input_value",
            name: "RECEIPTS",
            check: "Receipt"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // PSynchIO - foreach loop
      {
        type: "proc_foreach",
        tooltip: "Foreach: foreach (receipts) { body }",
        message0: "foreach ( %1 ) { %2 }",
        args0: [
          {
            type: "input_value",
            name: "RECEIPTS",
            check: "Receipt"
          },
          {
            type: "input_statement",
            name: "BODY",
            check: "Proc"
          }
        ],
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      },
      // === Parallel Composition ===
      // PPar - parallel composition
      {
        type: "proc_par",
        tooltip: "Parallel composition: proc | proc",
        message0: "%1 | %2",
        args0: [
          {
            type: "input_statement",
            name: "LEFT",
            check: "Proc"
          },
          {
            type: "input_statement",
            name: "RIGHT",
            check: "Proc"
          }
        ],
        inputsInline: true,
        previousStatement: "Proc",
        nextStatement: "Proc",
        colour: "208bfe"
      }
    ];
    var processes_default = common.createBlockDefinitionsFromJsonArray(definitions7);
    function registerAllBlocks() {
      common.defineBlocks(ground_default);
      common.defineBlocks(names_default);
      common.defineBlocks(collections_default);
      common.defineBlocks(receipts_default);
      common.defineBlocks(control_default);
      common.defineBlocks(declarations_default);
      common.defineBlocks(processes_default);
    }
    var toolboxConfig = {
      kind: "categoryToolbox",
      contents: [
        {
          kind: "category",
          name: "Ground Types",
          contents: [
            { kind: "block", type: "ground_bool_true" },
            { kind: "block", type: "ground_bool_false" },
            { kind: "block", type: "ground_int" },
            { kind: "block", type: "ground_string" },
            { kind: "block", type: "ground_uri" },
            { kind: "block", type: "simple_type_bool" },
            { kind: "block", type: "simple_type_int" },
            { kind: "block", type: "simple_type_string" },
            { kind: "block", type: "simple_type_uri" },
            { kind: "block", type: "simple_type_byte_array" }
          ]
        },
        {
          kind: "category",
          name: "Names",
          contents: [
            { kind: "block", type: "name_wildcard" },
            { kind: "block", type: "name_var" },
            { kind: "block", type: "name_quote" },
            { kind: "block", type: "name_decl_simple" },
            { kind: "block", type: "name_decl_urn" },
            { kind: "block", type: "name_remainder" }
          ]
        },
        {
          kind: "category",
          name: "Collections",
          contents: [
            { kind: "block", type: "collect_list" },
            { kind: "block", type: "collect_list_remainder" },
            { kind: "block", type: "tuple_single" },
            { kind: "block", type: "tuple_multiple" },
            { kind: "block", type: "collect_set" },
            { kind: "block", type: "collect_map" },
            { kind: "block", type: "key_value_pair" },
            { kind: "block", type: "proc_list" },
            { kind: "block", type: "proc_remainder" },
            { kind: "block", type: "name_list" }
          ]
        },
        {
          kind: "category",
          name: "Receipts & Binds",
          contents: [
            { kind: "block", type: "linear_bind" },
            { kind: "block", type: "linear_bind_receive_send" },
            { kind: "block", type: "linear_bind_send_receive" },
            { kind: "block", type: "repeated_bind" },
            { kind: "block", type: "peek_bind" },
            { kind: "block", type: "receipt_linear" },
            { kind: "block", type: "receipt_repeated" },
            { kind: "block", type: "receipt_peek" },
            { kind: "block", type: "concurrent_binds" },
            { kind: "block", type: "sequential_receipts" },
            { kind: "block", type: "linear_bind_symm" },
            { kind: "block", type: "repeated_bind_symm" },
            { kind: "block", type: "peek_bind_symm" }
          ]
        },
        {
          kind: "category",
          name: "Control Flow",
          contents: [
            { kind: "block", type: "proc_if" },
            { kind: "block", type: "proc_if_else" },
            { kind: "block", type: "proc_match" },
            { kind: "block", type: "case" },
            { kind: "block", type: "proc_select" },
            { kind: "block", type: "branch" }
          ]
        },
        {
          kind: "category",
          name: "Declarations",
          contents: [
            { kind: "block", type: "proc_new" },
            { kind: "block", type: "name_decl_list" },
            { kind: "block", type: "proc_let" },
            { kind: "block", type: "decl" },
            { kind: "block", type: "linear_decls" },
            { kind: "block", type: "conc_decls" },
            { kind: "block", type: "proc_contract" },
            { kind: "block", type: "proc_contract_remainder" },
            { kind: "block", type: "proc_bundle_write" },
            { kind: "block", type: "proc_bundle_read" },
            { kind: "block", type: "proc_bundle_equiv" },
            { kind: "block", type: "proc_bundle_rw" }
          ]
        },
        {
          kind: "category",
          name: "Basic Processes",
          contents: [
            { kind: "block", type: "proc_nil" },
            { kind: "block", type: "proc_ground" },
            { kind: "block", type: "proc_collect" },
            { kind: "block", type: "proc_var" },
            { kind: "block", type: "proc_var_wildcard" },
            { kind: "block", type: "proc_var_ref" },
            { kind: "block", type: "proc_var_ref_name" },
            { kind: "block", type: "proc_simple_type" },
            { kind: "block", type: "proc_eval" },
            { kind: "block", type: "proc_paren" }
          ]
        },
        {
          kind: "category",
          name: "Logical Operations",
          contents: [
            { kind: "block", type: "proc_negation" },
            { kind: "block", type: "proc_conjunction" },
            { kind: "block", type: "proc_disjunction" },
            { kind: "block", type: "proc_not" },
            { kind: "block", type: "proc_and" },
            { kind: "block", type: "proc_or" }
          ]
        },
        {
          kind: "category",
          name: "Arithmetic",
          contents: [
            { kind: "block", type: "proc_neg" },
            { kind: "block", type: "proc_mult" },
            { kind: "block", type: "proc_div" },
            { kind: "block", type: "proc_mod" },
            { kind: "block", type: "proc_percent_percent" },
            { kind: "block", type: "proc_add" },
            { kind: "block", type: "proc_minus" },
            { kind: "block", type: "proc_plus_plus" },
            { kind: "block", type: "proc_minus_minus" }
          ]
        },
        {
          kind: "category",
          name: "Comparison",
          contents: [
            { kind: "block", type: "proc_lt" },
            { kind: "block", type: "proc_lte" },
            { kind: "block", type: "proc_gt" },
            { kind: "block", type: "proc_gte" },
            { kind: "block", type: "proc_eq" },
            { kind: "block", type: "proc_neq" },
            { kind: "block", type: "proc_matches" }
          ]
        },
        {
          kind: "category",
          name: "Methods & Paths",
          contents: [
            { kind: "block", type: "proc_method" },
            { kind: "block", type: "proc_path_map" }
          ]
        },
        {
          kind: "category",
          name: "Send & Receive",
          contents: [
            { kind: "block", type: "proc_send" },
            { kind: "block", type: "proc_send_multiple" },
            { kind: "block", type: "proc_send_symm" },
            { kind: "block", type: "proc_send_synch" },
            { kind: "block", type: "synch_send_cont_empty" },
            { kind: "block", type: "synch_send_cont" },
            { kind: "block", type: "proc_for" },
            { kind: "block", type: "proc_foreach" }
          ]
        },
        {
          kind: "category",
          name: "Composition",
          contents: [
            { kind: "block", type: "proc_par" }
          ]
        }
      ]
    };
    function createRholangGenerator() {
      const generator = new CodeGenerator("Rholang");
      const ORDER = {
        ATOMIC: 0,
        // Literals, variables
        MEMBER: 1,
        // . (method call)
        UNARY: 2,
        // - ~ not * @ %
        MULTIPLICATIVE: 3,
        // * / %
        ADDITIVE: 4,
        // + - ++ --
        RELATIONAL: 5,
        // < <= > >=
        EQUALITY: 6,
        // == != matches
        CONJUNCTION: 7,
        // /\
        DISJUNCTION: 8,
        // \/
        AND: 9,
        // and
        OR: 10,
        // or
        PARALLEL: 11,
        // |
        NONE: 99
      };
      generator.forBlock["proc_root"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return body;
      };
      generator.forBlock["ground_bool_true"] = function() {
        return ["true", ORDER.ATOMIC];
      };
      generator.forBlock["ground_bool_false"] = function() {
        return ["false", ORDER.ATOMIC];
      };
      generator.forBlock["ground_int"] = function(block) {
        const value = block.getFieldValue("VALUE");
        return [String(value), ORDER.ATOMIC];
      };
      generator.forBlock["ground_string"] = function(block) {
        const value = block.getFieldValue("VALUE");
        return [`"${value}"`, ORDER.ATOMIC];
      };
      generator.forBlock["ground_uri"] = function(block) {
        const value = block.getFieldValue("VALUE");
        return [`\`${value}\``, ORDER.ATOMIC];
      };
      generator.forBlock["simple_type_bool"] = function() {
        return ["Bool", ORDER.ATOMIC];
      };
      generator.forBlock["simple_type_int"] = function() {
        return ["Int", ORDER.ATOMIC];
      };
      generator.forBlock["simple_type_string"] = function() {
        return ["String", ORDER.ATOMIC];
      };
      generator.forBlock["simple_type_uri"] = function() {
        return ["Uri", ORDER.ATOMIC];
      };
      generator.forBlock["simple_type_byte_array"] = function() {
        return ["ByteArray", ORDER.ATOMIC];
      };
      generator.forBlock["name_wildcard"] = function() {
        return ["_", ORDER.ATOMIC];
      };
      generator.forBlock["name_var"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [varName, ORDER.ATOMIC];
      };
      generator.forBlock["name_quote"] = function(block) {
        const proc = generator.valueToCode(block, "PROC", ORDER.UNARY);
        return [`@${proc}`, ORDER.UNARY];
      };
      generator.forBlock["name_decl_simple"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [varName, ORDER.ATOMIC];
      };
      generator.forBlock["name_decl_urn"] = function(block) {
        const varName = block.getFieldValue("VAR");
        const urn = block.getFieldValue("URN");
        return [`${varName}(\`${urn}\`)`, ORDER.ATOMIC];
      };
      generator.forBlock["name_remainder"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [`...@${varName}`, ORDER.ATOMIC];
      };
      generator.forBlock["collect_list"] = function(block) {
        const elements = generator.valueToCode(block, "ELEMENTS", ORDER.NONE);
        return [`[${elements}]`, ORDER.ATOMIC];
      };
      generator.forBlock["collect_list_remainder"] = function(block) {
        const elements = generator.valueToCode(block, "ELEMENTS", ORDER.NONE);
        const remainder = block.getFieldValue("REMAINDER");
        return [`[${elements}...${remainder}]`, ORDER.ATOMIC];
      };
      generator.forBlock["tuple_single"] = function(block) {
        const element = generator.valueToCode(block, "ELEMENT", ORDER.NONE);
        return [`(${element},)`, ORDER.ATOMIC];
      };
      generator.forBlock["tuple_multiple"] = function(block) {
        const first = generator.valueToCode(block, "FIRST", ORDER.NONE);
        const rest = generator.valueToCode(block, "REST", ORDER.NONE);
        return [`(${first}, ${rest})`, ORDER.ATOMIC];
      };
      generator.forBlock["collect_set"] = function(block) {
        const elements = generator.valueToCode(block, "ELEMENTS", ORDER.NONE);
        return [`Set(${elements})`, ORDER.ATOMIC];
      };
      generator.forBlock["collect_map"] = function(block) {
        const pairs = generator.valueToCode(block, "PAIRS", ORDER.NONE);
        return [`{${pairs}}`, ORDER.ATOMIC];
      };
      generator.forBlock["key_value_pair"] = function(block) {
        const key = generator.valueToCode(block, "KEY", ORDER.NONE);
        const value = generator.valueToCode(block, "VALUE", ORDER.NONE);
        return [`${key}: ${value}`, ORDER.ATOMIC];
      };
      generator.forBlock["proc_list"] = function(block) {
        const item = generator.valueToCode(block, "ITEM", ORDER.NONE);
        const next = generator.valueToCode(block, "NEXT", ORDER.NONE);
        return [`${item}, ${next}`, ORDER.NONE];
      };
      generator.forBlock["proc_remainder"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [`...${varName}`, ORDER.ATOMIC];
      };
      generator.forBlock["name_list"] = function(block) {
        const item = generator.valueToCode(block, "ITEM", ORDER.NONE);
        const next = generator.valueToCode(block, "NEXT", ORDER.NONE);
        return [`${item}, ${next}`, ORDER.NONE];
      };
      generator.forBlock["linear_bind"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <- ${source}`, ORDER.NONE];
      };
      generator.forBlock["linear_bind_receive_send"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <- ${source}?!`, ORDER.NONE];
      };
      generator.forBlock["linear_bind_send_receive"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        return [`${pattern} <- ${source}!?(${args})`, ORDER.NONE];
      };
      generator.forBlock["repeated_bind"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <= ${source}`, ORDER.NONE];
      };
      generator.forBlock["peek_bind"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <<- ${source}`, ORDER.NONE];
      };
      generator.forBlock["receipt_linear"] = function(block) {
        const binds = generator.valueToCode(block, "BINDS", ORDER.NONE);
        return [binds, ORDER.NONE];
      };
      generator.forBlock["receipt_repeated"] = function(block) {
        const binds = generator.valueToCode(block, "BINDS", ORDER.NONE);
        return [binds, ORDER.NONE];
      };
      generator.forBlock["receipt_peek"] = function(block) {
        const binds = generator.valueToCode(block, "BINDS", ORDER.NONE);
        return [binds, ORDER.NONE];
      };
      generator.forBlock["concurrent_binds"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.NONE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.NONE);
        return [`${left} & ${right}`, ORDER.NONE];
      };
      generator.forBlock["sequential_receipts"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.NONE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.NONE);
        return [`${left}; ${right}`, ORDER.NONE];
      };
      generator.forBlock["linear_bind_symm"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <-> ${source}`, ORDER.NONE];
      };
      generator.forBlock["repeated_bind_symm"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <=> ${source}`, ORDER.NONE];
      };
      generator.forBlock["peek_bind_symm"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const source = generator.valueToCode(block, "SOURCE", ORDER.NONE);
        return [`${pattern} <<->> ${source}`, ORDER.NONE];
      };
      generator.forBlock["proc_if"] = function(block) {
        const condition = generator.valueToCode(block, "CONDITION", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `if (${condition}) {
${body}}
`;
      };
      generator.forBlock["proc_if_else"] = function(block) {
        const condition = generator.valueToCode(block, "CONDITION", ORDER.NONE);
        const thenBody = generator.statementToCode(block, "THEN_BODY");
        const elseBody = generator.statementToCode(block, "ELSE_BODY");
        return `if (${condition}) {
${thenBody}} else {
${elseBody}}
`;
      };
      generator.forBlock["proc_match"] = function(block) {
        const expr = generator.valueToCode(block, "EXPR", ORDER.NONE);
        const cases = generator.statementToCode(block, "CASES");
        return `match ${expr} {
${cases}}
`;
      };
      generator.forBlock["case"] = function(block) {
        const pattern = generator.valueToCode(block, "PATTERN", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `${pattern} => {
${body}}
`;
      };
      generator.forBlock["proc_select"] = function(block) {
        const branches = generator.statementToCode(block, "BRANCHES");
        return `select {
${branches}}
`;
      };
      generator.forBlock["branch"] = function(block) {
        const receipt = generator.valueToCode(block, "RECEIPT", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `${receipt} => {
${body}}
`;
      };
      generator.forBlock["proc_new"] = function(block) {
        const names = generator.valueToCode(block, "NAMES", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `new ${names} in {
${body}}
`;
      };
      generator.forBlock["name_decl_list"] = function(block) {
        const item = generator.valueToCode(block, "ITEM", ORDER.NONE);
        const next = generator.valueToCode(block, "NEXT", ORDER.NONE);
        return [`${item}, ${next}`, ORDER.NONE];
      };
      generator.forBlock["proc_let"] = function(block) {
        const decls = generator.valueToCode(block, "DECLS", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `let ${decls} in {
${body}}
`;
      };
      generator.forBlock["decl"] = function(block) {
        const names = generator.valueToCode(block, "NAMES", ORDER.NONE);
        const procs = generator.valueToCode(block, "PROCS", ORDER.NONE);
        return [`${names} <- ${procs}`, ORDER.NONE];
      };
      generator.forBlock["linear_decls"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.NONE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.NONE);
        return [`${left}; ${right}`, ORDER.NONE];
      };
      generator.forBlock["conc_decls"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.NONE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.NONE);
        return [`${left} & ${right}`, ORDER.NONE];
      };
      generator.forBlock["proc_contract"] = function(block) {
        const name = generator.valueToCode(block, "NAME", ORDER.NONE);
        const params = generator.valueToCode(block, "PARAMS", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `contract ${name}(${params}) = {
${body}}
`;
      };
      generator.forBlock["proc_contract_remainder"] = function(block) {
        const name = generator.valueToCode(block, "NAME", ORDER.NONE);
        const params = generator.valueToCode(block, "PARAMS", ORDER.NONE);
        const remainder = block.getFieldValue("REMAINDER");
        const body = generator.statementToCode(block, "BODY");
        return `contract ${name}(${params}...@${remainder}) = {
${body}}
`;
      };
      generator.forBlock["proc_bundle_write"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return `bundle+ {
${body}}
`;
      };
      generator.forBlock["proc_bundle_read"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return `bundle- {
${body}}
`;
      };
      generator.forBlock["proc_bundle_equiv"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return `bundle0 {
${body}}
`;
      };
      generator.forBlock["proc_bundle_rw"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return `bundle {
${body}}
`;
      };
      generator.forBlock["proc_nil"] = function() {
        return ["Nil", ORDER.ATOMIC];
      };
      generator.forBlock["proc_ground"] = function(block) {
        const value = generator.valueToCode(block, "VALUE", ORDER.NONE);
        return [value, ORDER.ATOMIC];
      };
      generator.forBlock["proc_collect"] = function(block) {
        const value = generator.valueToCode(block, "VALUE", ORDER.NONE);
        return [value, ORDER.ATOMIC];
      };
      generator.forBlock["proc_var"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [varName, ORDER.ATOMIC];
      };
      generator.forBlock["proc_var_wildcard"] = function() {
        return ["_", ORDER.ATOMIC];
      };
      generator.forBlock["proc_var_ref"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [`=${varName}`, ORDER.UNARY];
      };
      generator.forBlock["proc_var_ref_name"] = function(block) {
        const varName = block.getFieldValue("VAR");
        return [`=*${varName}`, ORDER.UNARY];
      };
      generator.forBlock["proc_simple_type"] = function(block) {
        const type = generator.valueToCode(block, "TYPE", ORDER.NONE);
        return [type, ORDER.ATOMIC];
      };
      generator.forBlock["proc_eval"] = function(block) {
        const name = generator.valueToCode(block, "NAME", ORDER.UNARY);
        return [`*${name}`, ORDER.UNARY];
      };
      generator.forBlock["proc_paren"] = function(block) {
        const expr = generator.valueToCode(block, "EXPR", ORDER.NONE);
        return [`(${expr})`, ORDER.ATOMIC];
      };
      generator.forBlock["proc_negation"] = function(block) {
        const proc = generator.valueToCode(block, "PROC", ORDER.UNARY);
        return [`~${proc}`, ORDER.UNARY];
      };
      generator.forBlock["proc_conjunction"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.CONJUNCTION);
        const right = generator.valueToCode(block, "RIGHT", ORDER.CONJUNCTION);
        return [`${left} /\\ ${right}`, ORDER.CONJUNCTION];
      };
      generator.forBlock["proc_disjunction"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.DISJUNCTION);
        const right = generator.valueToCode(block, "RIGHT", ORDER.DISJUNCTION);
        return [`${left} \\/ ${right}`, ORDER.DISJUNCTION];
      };
      generator.forBlock["proc_not"] = function(block) {
        const proc = generator.valueToCode(block, "PROC", ORDER.UNARY);
        return [`not ${proc}`, ORDER.UNARY];
      };
      generator.forBlock["proc_and"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.AND);
        const right = generator.valueToCode(block, "RIGHT", ORDER.AND);
        return [`${left} and ${right}`, ORDER.AND];
      };
      generator.forBlock["proc_or"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.OR);
        const right = generator.valueToCode(block, "RIGHT", ORDER.OR);
        return [`${left} or ${right}`, ORDER.OR];
      };
      generator.forBlock["proc_neg"] = function(block) {
        const proc = generator.valueToCode(block, "PROC", ORDER.UNARY);
        return [`-${proc}`, ORDER.UNARY];
      };
      generator.forBlock["proc_mult"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.MULTIPLICATIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.MULTIPLICATIVE);
        return [`${left} * ${right}`, ORDER.MULTIPLICATIVE];
      };
      generator.forBlock["proc_div"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.MULTIPLICATIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.MULTIPLICATIVE);
        return [`${left} / ${right}`, ORDER.MULTIPLICATIVE];
      };
      generator.forBlock["proc_mod"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.MULTIPLICATIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.MULTIPLICATIVE);
        return [`${left} % ${right}`, ORDER.MULTIPLICATIVE];
      };
      generator.forBlock["proc_percent_percent"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.MULTIPLICATIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.MULTIPLICATIVE);
        return [`${left} %% ${right}`, ORDER.MULTIPLICATIVE];
      };
      generator.forBlock["proc_add"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.ADDITIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.ADDITIVE);
        return [`${left} + ${right}`, ORDER.ADDITIVE];
      };
      generator.forBlock["proc_minus"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.ADDITIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.ADDITIVE);
        return [`${left} - ${right}`, ORDER.ADDITIVE];
      };
      generator.forBlock["proc_plus_plus"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.ADDITIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.ADDITIVE);
        return [`${left} ++ ${right}`, ORDER.ADDITIVE];
      };
      generator.forBlock["proc_minus_minus"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.ADDITIVE);
        const right = generator.valueToCode(block, "RIGHT", ORDER.ADDITIVE);
        return [`${left} -- ${right}`, ORDER.ADDITIVE];
      };
      generator.forBlock["proc_lt"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.RELATIONAL);
        const right = generator.valueToCode(block, "RIGHT", ORDER.RELATIONAL);
        return [`${left} < ${right}`, ORDER.RELATIONAL];
      };
      generator.forBlock["proc_lte"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.RELATIONAL);
        const right = generator.valueToCode(block, "RIGHT", ORDER.RELATIONAL);
        return [`${left} <= ${right}`, ORDER.RELATIONAL];
      };
      generator.forBlock["proc_gt"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.RELATIONAL);
        const right = generator.valueToCode(block, "RIGHT", ORDER.RELATIONAL);
        return [`${left} > ${right}`, ORDER.RELATIONAL];
      };
      generator.forBlock["proc_gte"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.RELATIONAL);
        const right = generator.valueToCode(block, "RIGHT", ORDER.RELATIONAL);
        return [`${left} >= ${right}`, ORDER.RELATIONAL];
      };
      generator.forBlock["proc_eq"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.EQUALITY);
        const right = generator.valueToCode(block, "RIGHT", ORDER.EQUALITY);
        return [`${left} == ${right}`, ORDER.EQUALITY];
      };
      generator.forBlock["proc_neq"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.EQUALITY);
        const right = generator.valueToCode(block, "RIGHT", ORDER.EQUALITY);
        return [`${left} != ${right}`, ORDER.EQUALITY];
      };
      generator.forBlock["proc_matches"] = function(block) {
        const left = generator.valueToCode(block, "LEFT", ORDER.EQUALITY);
        const right = generator.valueToCode(block, "RIGHT", ORDER.EQUALITY);
        return [`${left} matches ${right}`, ORDER.EQUALITY];
      };
      generator.forBlock["proc_method"] = function(block) {
        const obj = generator.valueToCode(block, "OBJECT", ORDER.MEMBER);
        const method = block.getFieldValue("METHOD");
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        return [`${obj}.${method}(${args})`, ORDER.MEMBER];
      };
      generator.forBlock["proc_path_map"] = function(block) {
        const proc = generator.valueToCode(block, "PROC", ORDER.UNARY);
        return [`%${proc}`, ORDER.UNARY];
      };
      generator.forBlock["proc_send"] = function(block) {
        const channel = generator.valueToCode(block, "CHANNEL", ORDER.NONE);
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        return `${channel}!(${args})
`;
      };
      generator.forBlock["proc_send_multiple"] = function(block) {
        const channel = generator.valueToCode(block, "CHANNEL", ORDER.NONE);
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        return `${channel}!!(${args})
`;
      };
      generator.forBlock["proc_send_symm"] = function(block) {
        const channel = generator.valueToCode(block, "CHANNEL", ORDER.NONE);
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        return `${channel}!$(${args})
`;
      };
      generator.forBlock["proc_send_synch"] = function(block) {
        const channel = generator.valueToCode(block, "CHANNEL", ORDER.NONE);
        const args = generator.valueToCode(block, "ARGS", ORDER.NONE);
        const cont = generator.valueToCode(block, "CONT", ORDER.NONE);
        return `${channel}!?(${args})${cont}
`;
      };
      generator.forBlock["synch_send_cont_empty"] = function() {
        return [".", ORDER.ATOMIC];
      };
      generator.forBlock["synch_send_cont"] = function(block) {
        const body = generator.statementToCode(block, "BODY");
        return [`; ${body}`, ORDER.NONE];
      };
      generator.forBlock["proc_for"] = function(block) {
        const receipts = generator.valueToCode(block, "RECEIPTS", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `for (${receipts}) {
${body}}
`;
      };
      generator.forBlock["proc_foreach"] = function(block) {
        const receipts = generator.valueToCode(block, "RECEIPTS", ORDER.NONE);
        const body = generator.statementToCode(block, "BODY");
        return `foreach (${receipts}) {
${body}}
`;
      };
      generator.forBlock["proc_par"] = function(block) {
        const left = generator.statementToCode(block, "LEFT");
        const right = generator.statementToCode(block, "RIGHT");
        return `${left} | ${right}
`;
      };
      return generator;
    }
    var generator_default = createRholangGenerator;
    registerAllBlocks();
    var Events2 = /* @__PURE__ */ ((Events3) => {
      Events3["TREE_REQUEST"] = "tree:request";
      Events3["TREE_RETURN"] = "tree:return";
      Events3["BLOCKLY_REQUEST"] = "blockly:request";
      Events3["BLOCKLY_RETURN"] = "blockly:return";
      Events3["BLOCKLY_LOAD"] = "blockly:load";
      return Events3;
    })(Events2 || {});
    function initEditor() {
      let workspace = inject("blockly", {
        trashcan: false,
        sounds: false,
        scrollbars: false,
        grid: { spacing: 20, length: 3, colour: "#ccc", snap: true },
        toolbox: toolboxConfig
      });
      const rootBlock = workspace.newBlock("proc_root");
      rootBlock.initSvg();
      rootBlock.render();
      rootBlock.moveBy(50, 50);
      workspace.addChangeListener(Events.disableOrphans);
      workspace.addChangeListener((event) => {
        if (event.type === Events.SELECTED) {
          const toolboxDiv = document.querySelector(".blocklyToolboxDiv");
          if (toolboxDiv) {
            toolboxDiv.style.display = "block";
          }
          const workspaceSvg2 = workspace;
          if (workspaceSvg2.getFlyout && workspaceSvg2.getFlyout()) {
            const flyout = workspaceSvg2.getFlyout();
            if (flyout) {
              flyout.setVisible(true);
            }
          }
        }
      });
      const workspaceSvg = workspace;
      const svgElement = workspaceSvg.getCanvas().ownerSVGElement;
      if (svgElement) {
        svgElement.addEventListener("click", (event) => {
          const target = event.target;
          if (target.classList.contains("blocklyMainBackground") || target.classList.contains("blocklyWorkspace") || target.tagName === "svg") {
            const flyout = workspaceSvg.getFlyout();
            if (flyout) {
              flyout.setVisible(false);
            }
          }
        });
      }
      return workspace;
    }
    var EditorElement = class extends HTMLElement {
      handlers = [];
      workspace;
      static observedAttributes = ["width", "height"];
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
        setLocale(en_exports);
      }
      connectedCallback() {
        this.render();
      }
      handleListeners() {
        this.handlers.forEach((callback) => callback());
        const listenTreeRequest = () => {
          const generator = generator_default();
          const code = generator.workspaceToCode(this.workspace);
          console.log(code);
          this.dispatchEvent(
            new CustomEvent("tree:return", {
              detail: code,
              bubbles: true,
              composed: true
            })
          );
        };
        this.addEventListener("tree:request", listenTreeRequest);
        this.handlers.push(() => {
          this.removeEventListener("tree:request", listenTreeRequest);
          console.log("Callback removed");
        });
        const listenBlocklyRequest = () => {
          const state = serialization.workspaces.save(this.workspace);
          console.log(state);
          this.dispatchEvent(
            new CustomEvent("blockly:return", {
              detail: state,
              bubbles: true,
              composed: true
            })
          );
        };
        this.addEventListener("blockly:request", listenBlocklyRequest);
        this.handlers.push(() => {
          this.removeEventListener("blockly:request", listenBlocklyRequest);
          console.log("Blockly callback removed");
        });
        const listenBlocklyLoad = (event) => {
          const state = event.detail;
          if (state) {
            serialization.workspaces.load(state, this.workspace);
            console.log("Blockly state loaded");
          }
        };
        this.addEventListener("blockly:load", listenBlocklyLoad);
        this.handlers.push(() => {
          this.removeEventListener("blockly:load", listenBlocklyLoad);
          console.log("Blockly load callback removed");
        });
      }
      render() {
        console.time("Rendering");
        this.handleListeners();
        this.workspace = initEditor();
        console.timeEnd("Rendering");
      }
      attributeChangedCallback(name, oldValue, newValue) {
        this[name] = newValue;
      }
    };
    window.customElements.define("oslf-editor", EditorElement);
  })();

  // index.tsx
  var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
  var root = (0, import_client.createRoot)(document.getElementById("app"));
  root.render(/* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(App, {}, void 0, false, {
    fileName: "index.tsx",
    lineNumber: 7,
    columnNumber: 13
  }));
  var STORAGE_KEY = "oslf-editor-blockly-state";
  function App() {
    const ref = (0, import_react.useRef)(null);
    const saveToStorageRef = (0, import_react.useRef)(false);
    const [generatedCode, setGeneratedCode] = (0, import_react.useState)("");
    const [blocklyState, setBlocklyState] = (0, import_react.useState)("");
    const [loadInput, setLoadInput] = (0, import_react.useState)("");
    const [codeCopied, setCodeCopied] = (0, import_react.useState)(false);
    const [stateCopied, setStateCopied] = (0, import_react.useState)(false);
    (0, import_react.useEffect)(() => {
      const editor = ref.current;
      if (!editor) return;
      const handleTreeReturn = (event) => {
        setGeneratedCode(event.detail);
      };
      const handleBlocklyReturn = (event) => {
        const stateJson = JSON.stringify(event.detail, null, 2);
        setBlocklyState(stateJson);
        if (saveToStorageRef.current) {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(event.detail));
          saveToStorageRef.current = false;
        }
      };
      editor.addEventListener("tree:return", handleTreeReturn);
      editor.addEventListener("blockly:return", handleBlocklyReturn);
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const state = JSON.parse(saved);
          editor.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
        } catch (e) {
          console.log("Failed to load from localStorage. Value:", saved);
          console.error("Parse error:", e);
          localStorage.removeItem(STORAGE_KEY);
        }
      }
      return () => {
        editor.removeEventListener("tree:return", handleTreeReturn);
        editor.removeEventListener("blockly:return", handleBlocklyReturn);
      };
    }, []);
    const handleGenerateCode = () => {
      if (ref.current) {
        ref.current.dispatchEvent(new CustomEvent("tree:request"));
      }
    };
    const handleExportBlockly = () => {
      if (ref.current) {
        ref.current.dispatchEvent(new CustomEvent("blockly:request"));
      }
    };
    const handleLoadBlockly = () => {
      if (ref.current && loadInput) {
        try {
          const state = JSON.parse(loadInput);
          ref.current.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
        } catch (e) {
          console.error("Invalid JSON", e);
        }
      }
    };
    const handleSaveToStorage = () => {
      if (ref.current) {
        saveToStorageRef.current = true;
        ref.current.dispatchEvent(new CustomEvent("blockly:request"));
      }
    };
    const handleLoadFromStorage = () => {
      if (ref.current) {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const state = JSON.parse(saved);
            ref.current.dispatchEvent(new CustomEvent("blockly:load", { detail: state }));
          } catch (e) {
            console.error("Invalid saved state", e);
          }
        }
      }
    };
    const handleCopyCode = async () => {
      try {
        await navigator.clipboard.writeText(generatedCode);
        setCodeCopied(true);
        setTimeout(() => setCodeCopied(false), 2e3);
      } catch (e) {
        console.error("Failed to copy code", e);
      }
    };
    const handleCopyState = async () => {
      try {
        await navigator.clipboard.writeText(blocklyState);
        setStateCopied(true);
        setTimeout(() => setStateCopied(false), 2e3);
      } catch (e) {
        console.error("Failed to copy state", e);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginBottom: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleGenerateCode, children: "Generate Code" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 133,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleExportBlockly, style: { marginLeft: "10px" }, children: "Export Blockly" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 134,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleLoadBlockly, style: { marginLeft: "10px" }, children: "Load Blockly" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 135,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleSaveToStorage, style: { marginLeft: "10px" }, children: "Save" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 136,
          columnNumber: 5
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleLoadFromStorage, style: { marginLeft: "10px" }, children: "Load" }, void 0, false, {
          fileName: "index.tsx",
          lineNumber: 137,
          columnNumber: 5
        }, this)
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 132,
        columnNumber: 4
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginBottom: "10px" }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
        "textarea",
        {
          value: loadInput,
          onChange: (e) => setLoadInput(e.target.value),
          placeholder: "Paste Blockly JSON here to load...",
          style: {
            width: "100%",
            height: "100px",
            fontFamily: "monospace",
            fontSize: "12px"
          }
        },
        void 0,
        false,
        {
          fileName: "index.tsx",
          lineNumber: 140,
          columnNumber: 5
        },
        this
      ) }, void 0, false, {
        fileName: "index.tsx",
        lineNumber: 139,
        columnNumber: 4
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("oslf-editor", { ref }, void 0, false, {
        fileName: "index.tsx",
        lineNumber: 152,
        columnNumber: 4
      }, this),
      generatedCode && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginTop: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h3", { style: { margin: 0 }, children: "Generated Code:" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 156,
            columnNumber: 7
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleCopyCode, children: codeCopied ? "Copied!" : "Copy" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 157,
            columnNumber: 7
          }, this)
        ] }, void 0, true, {
          fileName: "index.tsx",
          lineNumber: 155,
          columnNumber: 6
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
          "pre",
          {
            style: {
              backgroundColor: "#f4f4f4",
              padding: "10px",
              borderRadius: "4px",
              overflow: "auto",
              marginTop: "10px"
            },
            children: generatedCode
          },
          void 0,
          false,
          {
            fileName: "index.tsx",
            lineNumber: 161,
            columnNumber: 6
          },
          this
        )
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 154,
        columnNumber: 5
      }, this),
      blocklyState && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { marginTop: "10px" }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h3", { style: { margin: 0 }, children: "Blockly State:" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 177,
            columnNumber: 7
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", { onClick: handleCopyState, children: stateCopied ? "Copied!" : "Copy" }, void 0, false, {
            fileName: "index.tsx",
            lineNumber: 178,
            columnNumber: 7
          }, this)
        ] }, void 0, true, {
          fileName: "index.tsx",
          lineNumber: 176,
          columnNumber: 6
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
          "pre",
          {
            style: {
              backgroundColor: "#e8f4e8",
              padding: "10px",
              borderRadius: "4px",
              overflow: "auto",
              maxHeight: "300px",
              marginTop: "10px"
            },
            children: blocklyState
          },
          void 0,
          false,
          {
            fileName: "index.tsx",
            lineNumber: 182,
            columnNumber: 6
          },
          this
        )
      ] }, void 0, true, {
        fileName: "index.tsx",
        lineNumber: 175,
        columnNumber: 5
      }, this)
    ] }, void 0, true, {
      fileName: "index.tsx",
      lineNumber: 131,
      columnNumber: 3
    }, this);
  }
})();
/*! Bundled license information:

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-dev-runtime.development.js:
  (**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
